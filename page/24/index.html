<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/24/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/24/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script src="https://use.typekit.net/tqr0ojg.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/17/leetcode-124-binary-tree-maximum-path-sum/">LeetCode 124. Binary Tree Maximum Path Sum</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 17, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.</p>
<p>For example:<br>
Given the below binary tree,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Return <code>6</code>.</p>
</blockquote>
<p>这道题我一开始是先用DFS来搜索出所有节点到根节点的路径, 然后再用双重循环来计算出每对节点的路径和. 如果有n个节点的话, 这个方法的时间复杂度是O(n<sup>2</sup>), 所以超时了.</p>
<p>后来发现了递归的方法. 对于一个二叉树的根节点来说, 这棵树中的最长路径和要么经过它, 要么经过它的后代, 所以我们就可以算出经过根节点的最长路径和是多少, 然后对每一个节点都计算一遍就可以找出最长的路径和.</p>
<p>在递归过程中, 除了维护一个最终的最长路径和以外, 我们还要知道每个节点的左右子树到该节点的最长路径和(注意, 这里的路径必须有一端是该节点)才能找出经过该节点的最长路径和.</p>
<p>同时还要注意路径和与0的大小关系, 如果到某节点的路径和小于0, 那么就不应该把这部分路径包含进去.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxPath = INT_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        DFS(root);</span><br><span class="line">        <span class="keyword">return</span> maxPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPath = DFS(root-&gt;left), rightPath = DFS(root-&gt;right);</span><br><span class="line">        <span class="comment">// 经过root节点的路径的四种情况, 选择最大的.</span></span><br><span class="line">        maxPath = max(maxPath, (leftPath + rightPath + root-&gt;val));</span><br><span class="line">        maxPath = max(maxPath, root-&gt;val);</span><br><span class="line">        maxPath = max(maxPath, root-&gt;val + leftPath);</span><br><span class="line">        maxPath = max(maxPath, root-&gt;val + rightPath);</span><br><span class="line">        <span class="comment">// 如果左右子树都小于0, 那么应该只返回root节点的值</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + max(<span class="number">0</span>, max(leftPath, rightPath));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/15/leetcode-123-best-time-to-buy-and-sell-stock-iii/">LeetCode 123. Best Time to Buy and Sell Stock III</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 15, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
<p><strong>Note:</strong><br>
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<p>这道题可以用一种我也不知道算不算动态规划的方法来解. 首先我们可以进行零次, 一次或者两次买入卖出操作, 零次或一次是之前的题目, 比较容易解决. 问题在于两次交易, 由于不能同时持有多个stock, 所以两次交易必须是前后发生的, 那么就可以用两个数组来分别记录[0,i]中获得能获得的最大收益和[i+1, n]中能获得的最大收益, 通过遍历i就可以得到前后两次交易的最大收益.</p>
<p>第一个数组通过遍历一次prices得到, 而第二个数组通过反向遍历一次prices得到.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; profit1(n, 0), profit2(n, 0);</span><br><span class="line">        <span class="keyword">int</span> lowest = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            lowest = min(lowest, prices[i]);</span><br><span class="line">            profit1[i] = max(profit1[i - <span class="number">1</span>], prices[i] - lowest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> highest = prices.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            highest = max(highest, prices[i]);</span><br><span class="line">            profit2[i] = max(profit2[i + <span class="number">1</span>], highest - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxProfit = profit1.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxProfit = max(maxProfit, profit1[i] + profit2[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而最后两个循环可以合并为一个.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; profit1(n, 0), profit2(n, 0);</span><br><span class="line">        <span class="keyword">int</span> lowest = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            lowest = min(lowest, prices[i]);</span><br><span class="line">            profit1[i] = max(profit1[i - <span class="number">1</span>], prices[i] - lowest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> highest = prices.back(), maxProfit = profit1.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            highest = max(highest, prices[i]);</span><br><span class="line">            profit2[i] = max(profit2[i + <span class="number">1</span>], highest - prices[i]);</span><br><span class="line">            maxProfit = max(maxProfit, profit1[i] + profit2[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/14/leetcode-399-evaluate-division/">LeetCode 399. Evaluate Division</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 14, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.</p>
<p><strong>Example:</strong><br>
Given <code>a / b = 2.0, b / c = 3.0.</code> <br>
queries are: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .</code> <br>
return <code>[6.0, 0.5, -1.0, 1.0, -1.0 ].</code></p>
<p>The input is:</p>
<figure class="highlight plain"><figcaption><span>string>> equations, vector<double>& values, vector<pair<string, string>> queries ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">, where &#96;equations.size() &#x3D;&#x3D; values.size()&#96;, and the values are positive. This represents the equations. Return &#96;vector&#96;.</span><br><span class="line"></span><br><span class="line">According to the example above:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>equations = [ [“a”, “b”], [“b”, “c”] ],<br>
values = [2.0, 3.0],<br>
queries = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</span><br><span class="line"></span><br><span class="line">这道题一看起来没啥思路, 但是看到tags里的Graph就一下子豁然开朗了. 其实每一个除法就是定义了有向图的一条边(实际上是来回两条)以及这条边的权值. 这样一来每一个查询就是判断给定的两个节点是否连通, 并且计算出路径上每条边的权值的乘积.</span><br><span class="line"></span><br><span class="line">首先构建邻接矩阵或邻接表, 然后对每个查询使用DFS或者BFS来搜索是否有两点之间的通路, 并且计算乘积.</span><br><span class="line"></span><br><span class="line">在计算过程中, 如果两个点是间接相连的, 实际上我们就可以直接在两点之间增加一条边, 权值为连接通路的权值乘积. 这样的话在剩下的查询中BFS中就可能更快地抵达目标节点.</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line">   &#x2F;&#x2F; 由于对于string的比较等操作很费时, 所以用一个map把string与int对应起来.</span><br><span class="line">   unordered_map&lt;string, int&gt; nodes; </span><br><span class="line">public:</span><br><span class="line">   vector&lt;double&gt; calcEquation(vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries) &#123;</span><br><span class="line">       for(int i &#x3D; 0; i &lt; equations.size(); i++)&#123;</span><br><span class="line">           &#x2F;&#x2F; 给每一个string分配一个下标</span><br><span class="line">           &#x2F;&#x2F; 注意这里有个隐藏bug, 假如map&#x2F;unordered_map对象m中不包含a, </span><br><span class="line">           &#x2F;&#x2F; 那么在使用m[a]时实际上是已经创建一个a的key和对应的value, 导致size加1</span><br><span class="line">           &#x2F;&#x2F; 所以如果我们想让第n个加入的元素的value为n-1的话, </span><br><span class="line">           &#x2F;&#x2F; 需要赋值m.size() - 1而不是m.size()</span><br><span class="line">           if(!nodes.count(equations[i].first))&#123;</span><br><span class="line">               nodes[equations[i].first] &#x3D; nodes.size() - 1;</span><br><span class="line">           &#125;</span><br><span class="line">           if(!nodes.count(equations[i].second))&#123;</span><br><span class="line">               nodes[equations[i].second] &#x3D; nodes.size() - 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       vector&lt;vector&lt;double&gt;&gt; g(nodes.size(), vector&lt;double&gt;(nodes.size(), -1.0));</span><br><span class="line">       for(int i &#x3D; 0; i &lt; equations.size(); i++)&#123;</span><br><span class="line">           &#x2F;&#x2F; 构建邻接矩阵</span><br><span class="line">           g[getNode(equations[i].first)][getNode(equations[i].second)] &#x3D; values[i];</span><br><span class="line">           g[getNode(equations[i].second)][getNode(equations[i].first)] &#x3D; 1 &#x2F; values[i];</span><br><span class="line">       &#125;</span><br><span class="line">       vector&lt;double&gt; ret(queries.size());</span><br><span class="line">       for(int i &#x3D; 0; i &lt; queries.size(); i++)&#123;</span><br><span class="line">           string a &#x3D; queries[i].first, b &#x3D; queries[i].second;</span><br><span class="line">           if(!nodes.count(a) || !nodes.count(b))&#123;</span><br><span class="line">               &#x2F;&#x2F; 如果出现了不存在的节点</span><br><span class="line">               ret[i] &#x3D; -1.0;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               &#x2F;&#x2F; 使用BFS来搜索路径</span><br><span class="line">               ret[i] &#x3D; BFS(g, getNode(a), getNode(b));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   int getNode(string s)&#123;</span><br><span class="line">       return nodes[s];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   double BFS(vector&lt;vector&lt;double&gt;&gt; &amp;g, int a, int b)&#123;</span><br><span class="line">       &#x2F;&#x2F; 如果是同一个节点就直接返回</span><br><span class="line">       if(a &#x3D;&#x3D; b) return 1.0;</span><br><span class="line">       int n &#x3D; g.size();</span><br><span class="line">       vector&lt;int&gt; visited(n, 0); &#x2F;&#x2F; 用于保存是否访问过节点</span><br><span class="line">       queue&lt;int&gt; q; &#x2F;&#x2F; BFS队列, 保存节点下标</span><br><span class="line">       queue&lt;double&gt; v; &#x2F;&#x2F; 用于保存从a到BFS队列中相应的节点的路径乘积</span><br><span class="line">       q.push(a);</span><br><span class="line">       visited[a] &#x3D; 1;</span><br><span class="line">       v.push(1.0);</span><br><span class="line">       while(!q.empty())&#123;</span><br><span class="line">           int node &#x3D; q.front();</span><br><span class="line">           double value &#x3D; v.front();</span><br><span class="line">           for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">               if(visited[i] || g[node][i] &#x3D;&#x3D; -1.0) continue; &#x2F;&#x2F; 节点i已经访问过或者没有边到达i</span><br><span class="line">               visited[i] &#x3D; 1;</span><br><span class="line">               q.push(i);</span><br><span class="line">               double len &#x3D; value * g[node][i]; &#x2F;&#x2F; 从a到i的路径权值乘积</span><br><span class="line">               &#x2F;&#x2F; 添加新的边</span><br><span class="line">               g[a][i] &#x3D; len;</span><br><span class="line">               g[i][a] &#x3D; 1 &#x2F; len;</span><br><span class="line">               if(i &#x3D;&#x3D; b)&#123; &#x2F;&#x2F; 抵达b点</span><br><span class="line">                   return len;</span><br><span class="line">               &#125;</span><br><span class="line">               v.push(len);</span><br><span class="line">           &#125;</span><br><span class="line">           q.pop();</span><br><span class="line">           v.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       return -1.0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
</blockquote>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/14/leetcode-398-random-pick-index/">LeetCode 398. Random Pick Index</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 14, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.</p>
<p><strong>Note:</strong><br>
The array size can be very large. Solution that uses too much extra space will not pass the judge.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int[] nums &#x3D; new int[] &#123;1,2,3,3,3&#125;;</span><br><span class="line">Solution solution &#x3D; new Solution(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br><span class="line">solution.pick(3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pick(1) should return 0. Since in the array only nums[0] is equal to 1.</span><br><span class="line">solution.pick(1);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这道题的内存要求相当严, 对我来说比较容易想到的方法都超内存了. 最后还是看tag才知道要用一种叫作<em>reservoir sampling 水塘抽样</em>(<a href="https://en.wikipedia.org/wiki/Reservoir_sampling" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reservoir_sampling</a>)的算法来做.</p>
<p>这个算法可以用于从n个数据(n很大且未知)中随机抽取k个样本, 具体思路如下(下标从0开始):</p>
<ol>
<li>首先取取数组a前k个元素放入结果r中</li>
<li>对于第i个元素(n&gt;i&gt;=k), 取一个随机数j(0&lt;=j&lt;i), 如果j&lt;k, 那么就把r[j]换成a[i].</li>
</ol>
<p>至于等概率的具体证明可以看wiki. 具体到这道题, 就是k=1的情况, 我们只需要在r中保存一个元素, 并且同时记录已经遍历到第几个target即可…</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        n = nums;</span><br><span class="line">        srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> retIndex, totalTarget = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n[i] != target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(totalTarget == <span class="number">1</span>)&#123;</span><br><span class="line">                retIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(rand() % totalTarget == <span class="number">0</span>)&#123;</span><br><span class="line">                    retIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            totalTarget++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pick(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/12/leetcode-397-integer-replacement/">LeetCode 397. Integer Replacement</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 12, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a positive integer <em>n</em> and you can do operations as follow:</p>
<ol>
<li>If <em>n</em> is even, replace <em>n</em> with <code>n/2</code>.</li>
<li>If <em>n</em> is odd, you can replace <em>n</em> with either <code>n + 1</code> or <code>n - 1</code>.</li>
</ol>
<p>What is the minimum number of replacements needed for <em>n</em> to become 1?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">8 -&gt; 4 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</span><br><span class="line">or</span><br><span class="line">7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我一开始想用动态规划, 但是这个题的测试数据有INT_MAX这么大, 根本开不了这么大的数组, 所以不行. 说明这道题有一些小窍门. 仔细想想, n为偶数是直接除以2没有什么问题, 问题在于奇数时有两种情况, <code>(n+1)/2</code>与<code>(n-1)/2</code>恰好是相邻的两个数, 一个奇数一个偶数, 对于其中的偶数还是直接除以2, 但是奇数就要多一步加1或减1, 所以在选择加1还是减1时应该选择的是除以2后还是偶数的那一个.</p>
<p>这道题因为数据是指数下降的, 所以最多迭代几十次, 递归与循环的性能差距不大, 用递归更好理解一点.</p>
<p>当n等于INT_MAX时, 再加1会导致溢出, 所以下次递归选择次数相同的INT_MAX-1.</p>
<p>还有一个问题在于n等于3时的情况, <code>(n+1)</code>与<code>(n-1)/2</code>分别是4和2, 按照先前的规则应该选择4, 但实际上应该选择2, 我对于这种情况单独处理.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">4</span> || n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> integerReplacement(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span>(n == INT_MAX) <span class="keyword">return</span> integerReplacement(n - <span class="number">1</span>);</span><br><span class="line">	    <span class="keyword">else</span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> integerReplacement(((n - <span class="number">1</span>) / <span class="number">2</span>) % <span class="number">2</span> ? (n + <span class="number">1</span>) : (n - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/12/leetcode-396-rotate-function/">LeetCode 396. Rotate Function</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 12, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>问题描述:</p>
<blockquote>
<p>Given an array of integers <code>A</code> and let <em>n</em> to be its length.</p>
<p>Assume <code>Bk</code> to be an array obtained by rotating the array <code>A</code> <em>k</em> positions clock-wise, we define a “rotation function” <code>F</code> on <code>A</code> as follow:</p>
<p><code>F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]</code>.</p>
<p>Calculate the maximum value of <code>F(0), F(1), ..., F(n-1)</code>.</p>
<p><strong>Note:</strong><br>
<em>n</em> is guaranteed to be less than 105.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [4, 3, 2, 6]</span><br><span class="line"></span><br><span class="line">F(0) &#x3D; (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) &#x3D; 0 + 3 + 4 + 18 &#x3D; 25</span><br><span class="line">F(1) &#x3D; (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) &#x3D; 0 + 4 + 6 + 6 &#x3D; 16</span><br><span class="line">F(2) &#x3D; (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) &#x3D; 0 + 6 + 8 + 9 &#x3D; 23</span><br><span class="line">F(3) &#x3D; (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) &#x3D; 0 + 2 + 12 + 12 &#x3D; 26</span><br><span class="line"></span><br><span class="line">So the maximum value of F(0), F(1), F(2), F(3) is F(3) &#x3D; 26.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>按照题目要求的步骤来计算一个数组的每个元素与下标乘积的和, 然后每次循环右移一位, 找出所有的和中的最大值. 不需要在每次右移后都计算一次数组的和, 只要把上一次得到的结果减去最后一项<code>(n-1) * Bk[n-1]</code>再加上所有元素的和(不乘下标)再减去<code>Bk[n-1]</code>即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, stepSum = <span class="number">0</span>, maxSum = INT_MIN, n = A.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            stepSum += (i * A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxSum = stepSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            stepSum = stepSum - A[n - i] * (n - <span class="number">1</span>) + sum - A[n - i];</span><br><span class="line">            maxSum = max(maxSum, stepSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/11/leetcode-122-best-time-to-buy-and-sell-stock-ii/">LeetCode 122. Best Time to Buy and Sell Stock II</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 11, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<p>这道题与<a href="http://xiadong.info/2016/09/leetcode-121-best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">上一题</a>相比不同点在于可以多次买入卖出股票但是不能同时持有多份股票, 所以整个的操作流程必须是&quot;买入-卖出-买入-卖出…-买入-卖出&quot;. 考虑一个简单的情况:</p>
<p><code>1,4,2,10</code></p>
<p>显然有两种策略, 分别的利润为<code>(4-1)+(10-2)=11</code>和<code>10-1=9</code>, 应选择第一种. 而另一种情况:</p>
<p><code>1,2,4,10</code></p>
<p>两种策略的利润为<code>(2-1)+(10-4)=8</code>和<code>10-1=9</code>, 此时应该选择第二种. 对于一般情况来说:</p>
<p><code>a1,a2,a3...,ap,...,aq,...,an</code></p>
<p>如果在a1买入ap卖出然后再aq买入an卖出的话, 利润为<code>(an-aq)+(ap-a1)</code>, 如果在a1买入an卖出的话, 利润为<code>an-a1</code>, 两者之差为<code>(an-a1)-[(an-aq)+(ap-a1)]=aq-ap</code>, 所以如果<code>ap&gt;aq</code>, 那么应该选择前者, 反之选择后者. 从编程策略上来说就应该是搜索一个从低价位开始的递增序列, 在不能再保持递增的时候就是应该卖出的时候.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; low) low = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(prices[i] &gt; prices[i + <span class="number">1</span>])&#123;</span><br><span class="line">                profit += (prices[i] - low);</span><br><span class="line">                low = prices[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prices.back() &gt; low) profit += (prices.back() - low);</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/11/leetcode-121-best-time-to-buy-and-sell-stock/">LeetCode 121. Best Time to Buy and Sell Stock</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 11, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 1, 5, 3, 6, 4]</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">max. difference &#x3D; 6-1 &#x3D; 5 (not 7-1 &#x3D; 6, as selling price needs to be larger than buying price)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 6, 4, 3, 1]</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这道题我一开始看错了题意. 它的意思是只允许一次买入卖出操作或者没有操作, 所以只要找到相差最大的两个价格并且低价在高价之前就可以了. 从前往后遍历一次数组, 记录到目前为止的最低价格, 然后再记录一个差额的最大值就可以了. 时间复杂度O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lowest = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lowest &gt; prices[i])&#123;</span><br><span class="line">                lowest = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                profit = max(profit, prices[i] - lowest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/11/leetcode-120-triangle/">LeetCode 120. Triangle</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 11, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述：</p>
<blockquote>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [2],</span><br><span class="line">   [3,4],</span><br><span class="line">  [6,5,7],</span><br><span class="line"> [4,1,8,3]</span><br><span class="line">&gt;]</span><br></pre></td></tr></table></figure>
<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
</blockquote>
<p>比较简单的动态规划题, 每次需要的数据就是上一行到达每个位置的最小路径和. 只要比较左上方与右上方的两个和然后选择较小的一个就可以了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lastRow, rowSum;</span><br><span class="line">        lastRow = triangle[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangle.size(); i++)&#123;</span><br><span class="line">            rowSum.resize(triangle[i].size());</span><br><span class="line">            rowSum[<span class="number">0</span>] = lastRow[<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; triangle[i].size() - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                rowSum[j] = min(lastRow[j - <span class="number">1</span>], lastRow[j]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            rowSum.back() = lastRow.back() + triangle[i].back();</span><br><span class="line">            lastRow = rowSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastRow.size(); i++)&#123;</span><br><span class="line">            ret = min(lastRow[i], ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/09/09/leetcode-119-pascals-triangle-ii/">LeetCode 119. Pascal's Triangle II</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Sep 9, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given an index <em>k</em>, return the <em>k</em>th row of the Pascal’s triangle.</p>
<p>For example, given <em>k</em> = 3,<br>
Return <code>[1,3,3,1]</code>.</p>
<p><strong>Note:</strong><br>
Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>
</blockquote>
<p>与<a href="http://xiadong.info/2016/09/leetcode-118-pascals-triangle/" target="_blank" rel="noopener">上一题</a>类似, 只不过现在是要求某一行的结果. 每计算一行只需要上一行的数据, 所以只需要保存一行.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; last = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">            ret.clear();</span><br><span class="line">            ret.push_back(last[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">auto</span> j = last.begin() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j != last.end(); j++)&#123;</span><br><span class="line">                ret.push_back(*j + *(j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(*(j - <span class="number">1</span>));</span><br><span class="line">            last = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/23/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/25/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
