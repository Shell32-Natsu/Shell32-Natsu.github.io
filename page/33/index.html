<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/33/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/33/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script>
  (function(d) {
    var config = {
      kitId: 'tqr0ojg',
      scriptTimeout: 3000,
      async: true
    },
    h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
  })(document);
</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/09/leetcode-70-climbing-stairs/">LeetCode 70. Climbing Stairs</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 9, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<p>斐波那契数列, 到达第n层的路径数量等于到达第n - 1层的路径数量加到达第n - 2层的路径数量.</p>
<pre><code>class Solution {
public:
    int climbStairs(int n) {
        if(n == 1)return 1;
        if(n == 2)return 2;
        int a = 1, b = 2, t;
        for(int i = 2; i &lt; n; i++){
            t = b;
            b = a + b;
            a = t;
        }
        return b;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/08/leetcode-69-sqrtx/">LeetCode 69. Sqrt(x)</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 8, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of x.</p>
</blockquote>
<p>实现整数的开平方运算, 使用二分搜索, 也就是方程求根的二分法来计算. 因为计算结果为整数, 所以最后如果没有平方根的准确值, 要把最后的结果减1.</p>
<pre><code>class Solution {
public:
    int mySqrt(int x) {
        if(x == 1) return 1;
        long long left = 1, right = x, mid = (left + right) / 2;
        while(left &lt; right){
            long long m = mid * mid;
            if(m &gt; x) 
                right = mid;
            else if(m &lt; x)
                left = mid + 1;
            else 
                return mid;
            mid = (left + right) / 2;
        }
        return left - 1;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/08/leetcode-68-text-justification/">LeetCode 68. Text Justification</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 8, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ’ ’ when necessary so that each line has exactly L characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>For example,</p>
<p>words: <code>[&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</code></p>
<p>L: <code>16</code>.</p>
<p>Return the formatted lines as:</p>
<pre><code>[
   &quot;This    is    an&quot;,
   &quot;example  of text&quot;,
   &quot;justification.  &quot;
]
</code></pre>
<p>Note: Each word is guaranteed not to exceed L in length.</p>
</blockquote>
<p>细节比较多, 难度倒也不是很大, 但是这种题在面试的时候我觉得更难, 因为考虑许多情况, 人肉调试还是比较困难的.</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) {
        vector&lt;string&gt; ret;
        if(maxWidth == 0) { // 因为每个单词长度都不会超过maxWidth, 所以可以直接返回
            ret.push_back(string(&quot;&quot;));
            return ret;
        }
        // start保存每行单词的起始下标, end表示结束下标, 单词的下标范围为[start, end)
        // lenInLine保存每一行的长度
        int start = 0, end = 0, lenInLine = 0;
        while (start &lt; words.size()) {
            // 计算这一行能放多少个单词, 把第一个单词放进去, +1是因为后面还有一个空格
            lenInLine = words[start].length() + 1; 
            end = start + 1; 
            while (end &lt; words.size() &amp;&amp; lenInLine &lt; maxWidth) {
                lenInLine += words[end++].length();
                lenInLine += 1; // 计算空格
            }
            if(lenInLine - 1 &gt; maxWidth){ // 去掉尾部空格后如果还是大于maxWidth, 那么应该少放一个单词
                end--;
            }
            if (end == words.size()) { // 根据题目, 最后一行要单独处理, 使用左对齐而不是两端对齐
                string line = words[start];
                for (int i = start + 1; i &lt; end; i++) {
                    line += &quot; &quot;;
                    line += words[i];
                }
                line.insert(line.end(), maxWidth - line.length(), ' ');
                ret.push_back(line);
            }
            else {
                createLine(words, start, end, ret, maxWidth); // 创建行
            }
            start = end;
        }
        return ret;
    }

    void createLine(vector&lt;string&gt; &amp;words, int start, int end, vector&lt;string&gt; &amp;ret, int maxWidth) {
        string line;
        int wordCnt = end - start, spacePerInterval = 0, spaceCnt = maxWidth;
        if (wordCnt == 0) return; // end == start, 没有单词
        for (int i = start; i &lt; end; i++) { // 计算总空格数
            spaceCnt -= words[i].length();
        }
        // 如果spaceCnt不能平均分配, 那么左边的一个或多个间隔就要增加一个空格
        // moreSpaceLen保存左边的多少个间隔需要多的空格
        int moreSpaceLen = spaceCnt % (wordCnt - 1 ? wordCnt - 1 : 1);
        spacePerInterval = spaceCnt / (wordCnt - 1 ? wordCnt - 1 : 1);
        line += words[start];
        if(wordCnt == 1){
            // 因为下面的循环从start + 1开始, 所以如果行内只有一个单词,
            // 就要在其之后填充空格直到长度达到maxWidth
            line.insert(line.end(), maxWidth - line.length(), ' ');
        }
        else{
            for (int i = start + 1; i &lt; end; i++) {
                if (i &lt;= start + moreSpaceLen) {
                    line.insert(line.end(), spacePerInterval + 1, ' ');
                }
                else {
                    line.insert(line.end(), spacePerInterval, ' ');
                }
                line += words[i];
            }
        }
        ret.push_back(line);
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/08/leetcode-67-add-binary/">LeetCode 67. Add Binary</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 8, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given two binary strings, return their sum (also a binary string).</p>
<p>For example,</p>
<p>a = <code>&quot;11&quot;</code></p>
<p>b = <code>&quot;1&quot;</code></p>
<p>Return <code>&quot;100&quot;</code>.</p>
</blockquote>
<p>模拟加法计算, 只不过是使用二进制格式.</p>
<pre><code>class Solution {
public:
    string addBinary(string a, string b) {
        if(a.length() &lt; b.length()) swap(a, b);
        int pa = a.length() - 1, pb = b.length() - 1, jw = 0;
        while(pb &gt;= 0){
            a[pa] = a[pa] - '0' + b[pb] - '0' + jw + '0';
            if(a[pa] &gt;= '2'){
                a[pa] = a[pa] % '2' + '0';
                jw = 1;
            }
            else{
                jw = 0;
            }
            pa--, pb--;
        }
        while(pa &gt;= 0){
            a[pa] = a[pa] + jw;
            if(a[pa] &gt;= '2'){
                a[pa] = a[pa] % '2' + '0';
                jw = 1;
            }
            else{
                jw = 0;
            }
            pa--;
        }
        if(jw){
            a.insert(a.begin(), '1');
        }
        return a;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/07/leetcode-66-plus-one/">LeetCode 66. Plus One</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 7, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
</blockquote>
<p>数组模拟计算, 由于只加1, 所以比较简单.</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) {
        vector&lt;int&gt; ret = digits;
        int jw = 1;
        for(int i = ret.size() - 1; i &gt;= 0 &amp;&amp; jw; i--){
            ret[i]++;
            if(ret[i] == 10){
                jw = 1;
                ret[i] = 0;
            }
            else{
                jw = 0;
            }
        }
        if(jw){
            ret.insert(ret.begin(), 1);
        }
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/06/leetcode-65-valid-number/">LeetCode 65. Valid Number</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 6, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Validate if a given string is numeric.</p>
<p>Some examples:</p>
<p><code>&quot;0&quot;</code> =&gt; <code>true</code></p>
<p><code>&quot; 0.1 &quot;</code> =&gt; <code>true</code></p>
<p><code>&quot;abc&quot;</code> =&gt; <code>false</code></p>
<p><code>&quot;1 a&quot;</code> =&gt; <code>false</code></p>
<p><code>&quot;2e10&quot;</code> =&gt; <code>true</code></p>
<p>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p>
</blockquote>
<p>判断一个输入字符串是否是数字, 这道题的要求并不是很明确, 一下子很难想的全面, 并且也不容易跟出题人想到一块去. 实际上主要有以下几点:</p>
<ul>
<li>字符串前后可以有空格, 但是数字中间不能出现空格</li>
<li>允许出现的字符有<code>+</code>, <code>-</code>, <code>.</code>, <code>e</code>和阿拉伯数字</li>
<li>数字可以以<code>.</code>开头或结尾</li>
<li>e后面的指数部分只能是整数</li>
</ul>
<pre><code>class Solution {
public:
    bool isNumber(string s) {
        delSpace(s);
        for(int i = 0; i &lt; s.length(); i++){ // 检查除e, ., 和数字以外的字符
            if((s[i] &lt; '0' || s[i] &gt; '9')  &amp;&amp; s[i] != 'e' &amp;&amp; s[i] != '.' &amp;&amp; s[i] != '-' &amp;&amp; s[i] != '+') return false;
        }
        int eCnt = 0;
        for(int i = 0; i &lt; s.length(); i++){ // 计算e的个数
            if(s[i] == 'e') eCnt++;
        }
        //printf(&quot;%d\n&quot;, eCnt);
        if(eCnt &gt; 1) return false; // e多于1个则返回false
        if(eCnt == 1){
            // 如果有e出现, 前后都有不含e的数字
            int i;
            for(i = 0; s[i] != 'e'; i++);
            // e的前面可以是小数, 但是后面不可以
            if(!isNumberWithoutE(s.substr(0, i)) || !isNumberWithoutEAndDot(s.substr(i + 1, s.length() - i - 1))){
                return false;
            }
            else return true;
        }
        else{
            // 如果没有e
            return isNumberWithoutE(s);
        }
    }
    
    bool isNumberWithoutE(string s){ // 判断是不是不包含e的数字
        if(s.empty()) return false;
        if(s.length() == 1 &amp;&amp; (s[0] == '.' || s[0] == '-' || s[0] == '+')) return false; // 只有符号或小数点
        int dashPos = -1, dotCnt = 0, plusSignPos = -1;
        for(int i = 0; i &lt; s.length(); i++){ // 查找是否有不位于开头的正负号
            if(s[i] == '-') dashPos = i;
            else if(s[i] == '+') plusSignPos = i;
        }
        if(dashPos &gt; 0 || plusSignPos &gt; 0) return false;
        if(s[0] == '+' || s[0] == '-'){ // 清除开头的正负号
            s.erase(s.begin(), s.begin() + 1);
        }
        if(s.length() == 1 &amp;&amp; s[0] == '.') return false; // 如果去掉符号后只有小数点了, 那么不是数字
        for(int i = 0; i &lt; s.length(); i++){ // 计算小数点的数量
            if(s[i] == '.') dotCnt++;
        }
        if(dotCnt &gt; 1) return false;
        else return true;
    }
    
    bool isNumberWithoutEAndDot(string s){ //判断是不是不包含e的整数
        if(s.empty()) return false;
        if(s.length() == 1 &amp;&amp; (s[0] == '.' || s[0] == '-' || s[0] == '+')) return false;
        int dashPos = -1, plusSignPos = -1;
        for(int i = 0; i &lt; s.length(); i++){ // 查找是否有不位于开头的正负号
            if(s[i] == '-') dashPos = i;
            else if(s[i] == '+') plusSignPos = i;
            else if(s[i] == '.') return false; // 如果有小数点则返回false
        }
        if(dashPos &gt; 0 || plusSignPos &gt; 0) return false;
        else return true;
    }
    
    void delSpace(string &amp;s){ //删除前后空格
        int i;
        for(i = 0; i &lt; s.size() &amp;&amp; s[i] == ' '; i++);
        s.erase(s.begin(), s.begin() + i);
        for(i = 0; i &lt; s.size() &amp;&amp; s[s.size() - i - 1] == ' '; i++);
        s.erase(s.end() - i, s.end());
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/06/leetcode-64-minimum-path-sum/">LeetCode 64. Minimum Path Sum</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 6, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
</blockquote>
<p>动态规划问题, 到达每个格子的最小的路径和等于到达左边左边格子的路径和与到达上面的格子的路径和中的较小值加上当前格子的值.</p>
<pre><code>class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) {
        int height = grid.size(), width = grid[0].size();
        
        for(int i = 1; i &lt; height; i++)
            grid[i][0] += grid[i - 1][0];
        for(int i = 1; i &lt; width; i++)
            grid[0][i] += grid[0][i - 1];
            
        for(int i = 1; i &lt; height; i++){
            for(int j = 1; j &lt; width; j++){
                grid[i][j] += (grid[i - 1][j] &lt; grid[i][j - 1] ? grid[i - 1][j] : grid[i][j - 1]);
            }
        }
        
        return grid[height - 1][width - 1];
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/05/leetcode-63-unique-paths-ii/">LeetCode 63. Unique Paths II</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 5, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述</p>
<blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<pre><code>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
</code></pre>
<p>The total number of unique paths is 2.</p>
<p>Note: m and n will be at most 100.</p>
</blockquote>
<p>紧跟着上一题<a href="http://xiadong.info/2016/08/leetcode-62-unique-paths/" target="_blank" rel="noopener">Unique Paths</a>, 这一题增加了条件, 在地图上会出现障碍物(用1表示), 障碍物不能出现在路线上. 仍然采用上一题的动态规划法, 只不过多了一条:</p>
<ul>
<li>所有障碍物的位置到达的路线数量都为0</li>
</ul>
<pre><code>class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0)
            return 0;
        int n = obstacleGrid[0].size();
        vector&lt;vector&lt;int&gt;&gt; arr(m, vector&lt;int&gt;(n, 0));
        int i, j;
        for(i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] != 1; i++)
            arr[i][0] = 1;
        for(i = 0; i &lt; n &amp;&amp; obstacleGrid[0][i] != 1; i++)
            arr[0][i] = 1;
        for(i = 1; i &lt; m; i++){
            for(j = 1; j &lt; n; j++){
                if(obstacleGrid[i][j])
                    continue;
                    
                arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
            }
        }
        
        return arr[m - 1][n - 1];
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/05/leetcode-62-unique-paths/">LeetCode 62. Unique Paths</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 5, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png" alt=""></p>
<p>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p>Note: m and n will be at most 100.</p>
</blockquote>
<p>经典的动态规划题目, 由于每一个格子只能从上面的格子和左面的格子到达, 所以到达每个格子的路线数量等于到达上面格子的路线数量+到达左面格子的路线数量.</p>
<pre><code>class Solution {
public:
    int uniquePaths(int m, int n) {
        int arr[m][n];
        int i, j;
        for(i = 0; i &lt; m; i++)
            arr[i][0] = 1;
        for(i = 0; i &lt; n; i++)
            arr[0][i] = 1;
        for(i = 1; i &lt; m; i++){
            for(j = 1; j &lt; n; j++){
                arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
            }
        }
        
        return arr[m - 1][n - 1];
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/05/leetcode-61-rotate-list/">LeetCode 61. Rotate List</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 5, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:</p>
<p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</p>
<p>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
</blockquote>
<p>最简单的方法是把所有节点指针保存在一个数组中, 设总长度为<code>len</code>, 然后找到第<code>len - k</code>个节点为新链表的头结点, 它之前的节点是新链表的尾节点. 把原链表的尾节点指向头结点即可. 要注意<code>k</code>可能会大于<code>len</code>, 所以可以先把<code>k</code>对<code>len</code>取余.</p>
<pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return head;
        vector&lt;ListNode*&gt; l;
        ListNode* p = head, *reHead;
        while(p){
            l.push_back(p);
            p = p-&gt;next;
        }
        
        k = k % l.size();
        if(k == 0)
            return head;
        auto iter = l.end() - k;
        (*(iter - 1))-&gt;next = NULL;
        (*(l.end() - 1))-&gt;next = *(l.begin());
        return *iter;
    }
};
</code></pre>
<p>不使用额外空间的方法需要多遍历几次链表:</p>
<pre><code>class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return head;
        int len = 0;
        ListNode *p = head, *newHead = nullptr, *tail = nullptr, *newTail = nullptr;
        while(p){
            len++;
            if(!p-&gt;next)
                tail = p;
            p = p-&gt;next;
        }
        k = k % len;
        if(!k) return head;
        newHead = head;
        for(int i = 0; i &lt; len - k; i++){
            newTail = newHead;
            newHead = newHead-&gt;next;
        }
        newTail-&gt;next = nullptr;
        tail-&gt;next = head;
        return newHead;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/32/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/34/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Shell32-Natsu" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2025

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
