<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/36/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/36/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script src="https://use.typekit.net/tqr0ojg.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-forward-list/">STL容器学习笔记三 - Forward_list</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h1 id="forward-list-前向链表-c-11"><a href="http://www.cplusplus.com/reference/forward_list/forward_list/" target="_blank" rel="noopener">Forward list</a> 前向链表[C++11]</h1>
<p>前向链表是提供常数复杂度的插入删除操作的容器, 它被实现为一个单链接链表.</p>
<p><code>forward_list</code>与<code>list</code>的区别在于前者保存指向每个节点的后一个节点的指针, 而后者保存前后两个节点的指针. <code>forward_list</code>比<code>list</code>稍微高效, 但是缺点在于只能向前遍历.</p>
<p>与其他顺序容器相比主要优点在于在容器任意位置插入, 提取和移动的表现更好. 不足在于不能根据元素在容器中的位置来访问元素.</p>
<p><code>forward_list</code>被设计得非常高效, 它与一个简单的C语言手写单向链表的效率相当. 实际上, <strong>它是唯一一个出于性能考虑而不提供<code>size</code>成员函数的标准容器</strong>.</p>
<h1 id="部分函数">部分函数</h1>
<p>只列举一些我不太熟悉的函数.</p>
<h2 id="构造函数">构造函数</h2>
<h3 id="默认构造函数">默认构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个空容器.<br>
​</p>
<h3 id="填充构造函数">填充构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个大小为n的容器, 如果提供了val, 则n个值都初始化为val.<br>
​</p>
<h3 id="范围构造函数">范围构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">forward_list</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br></pre></td></tr></table></figure>
<p>用<code>[first, last)</code>中的数据初始化.</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst);</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br></pre></td></tr></table></figure>
<h3 id="移动构造函数">移动构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (forward_list&amp;&amp; fwdlst);</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br></pre></td></tr></table></figure>
<p>除非alloc的类型与fwdlst不一致, 否则不会构造任何一个元素, 它们的所有权被直接转移.</p>
<h3 id="初始化列表">初始化列表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span><br><span class="line"><span class="keyword">const</span> allocator_type&amp; alloc = allocator_type());</span><br></pre></td></tr></table></figure>
<h2 id="forward-list-before-begin">forward_list::before___begin</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回指向容器中首个元素之前的元素的迭代器. 该迭代器不能解引用, 主要作为成员函数<code>emplace_after</code>, <code>insert_after</code>, <code>erase_after</code>和<code>splice_after</code>的参数.</p>
<h2 id="forward-list-emplace-after">forward_list::emplace_after</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">emplace_after</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>在position的位置之后插入元素, args为插入的新元素的初始化参数.</p>
<h2 id="forward-list-emplace-front">forward_list::emplace_front</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">emplace_front</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>在容器头部插入新元素, args为插入的新元素的初始化参数.</p>
<h2 id="forward-list-erase-after">forward_list::erase_after</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase_after</span> <span class="params">(const_iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase_after</span> <span class="params">(const_iterator <span class="built_in">position</span>, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>删除容器中position之后的一个元素或者(position, last)范围内的元素.</p>
<h2 id="forward-list-merge">forward_list::merge</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(forward_list&amp; fwdlst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(forward_list&amp;&amp; fwdlst)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">forward_list</span>&amp; <span class="title">fwdlst</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">forward_list</span>&amp;&amp; <span class="title">fwdlst</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure>
<p>根据指定顺序将fwdlst与当前容器合并.</p>
<h2 id="forward-list-remove-if">forward_list::remove_if</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">remove_if</span> (<span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure>
<p>对容器中的每个元素, 执行pred(以<code>pred(*i)</code>的形式), 如果为true则删除该元素.</p>
<p>pred可以为函数指针或者函数对象.</p>
<h2 id="forward-list-sort">forward_list::sort</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span> (<span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure>
<p>排序函数, 该函数是稳定排序. 整个操作不包括任何的元素构造, 析构和复制. 元素只是在容器内移动.</p>
<p><strong>时间复杂度</strong>: NlogN.</p>
<h2 id="forward-list-unique">forward_list::unique</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">unique</span> (<span class="title">BinaryPredicate</span> <span class="title">binary_pred</span>);</span></span><br></pre></td></tr></table></figure>
<p>删除重复元素. <strong>这个操作只会删除与前一个元素相同的元素, 也就是说只能用于已经排序的容器.</strong></p>
<p>第二种形式中的参数binary_pred以<code>binary_pred(*i, *(i - 1))</code>的形式调用, 此函数返回true则认为两个元素相等.</p>
<p>binary_pred可以为函数指针或者函数对象.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/leetcode-26-remove-duplicates-from-sorted-array-2/">LeetCode 27. Remove Element</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>问题描述:</p>
<blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>
Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p>对一个有序数组去重, 并且要求不使用额外的存储空间.</p>
<p>首先解决的是去重的问题, 如果没有额外空间的限制, 首先想到的是创建一个新的数组, 然后遍历nums, 大于新数组末尾的数则把当前的数加入新数组. 这里数组末尾的数其实就是已经遍历过的最大值, 因此可以用一个变量来保存.</p>
<p>接下来是存储空间的问题, 由于nums中每个数在遍历时的作用只是与当前遍历过的最大值比较, 而已经遍历过的数是没有什么作用的, 所以可以使用已经遍历过的nums数所占的空间.</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
        }
        return num;
    }
};
</code></pre>
<p>这段代码的Runtime是36毫秒, 但是许多AC代码的Runtime都在32ms, 说明这个程序还有一定的优化空间.</p>
<p>首先循环体内部的操作已经非常简洁, 应该很难有所作为, 所以优化的目标应该在循环次数上. 先将nums中最大的数保存下来, 当遍历到与该值相等的时候, 把这个数处理完后就可以退出循环了. 所以最终代码:</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        int maxItem = nums.empty() ? 0 : nums.back();
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
            if(nums[i] == maxItem){
                break;
            }
        }
        return num;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/leetcode-26-remove-duplicates-from-sorted-array/">LeetCode 26. Remove Duplicates from Sorted Array</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>问题描述:</p>
<blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>
Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p>对一个有序数组去重, 并且要求不使用额外的存储空间.</p>
<p>首先解决的是去重的问题, 如果没有额外空间的限制, 首先想到的是创建一个新的数组, 然后遍历nums, 大于新数组末尾的数则把当前的数加入新数组. 这里数组末尾的数其实就是已经遍历过的最大值, 因此可以用一个变量来保存.</p>
<p>接下来是存储空间的问题, 由于nums中每个数在遍历时的作用只是与当前遍历过的最大值比较, 而已经遍历过的数是没有什么作用的, 所以可以使用已经遍历过的nums数所占的空间.</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
        }
        return num;
    }
};
</code></pre>
<p>这段代码的Runtime是36毫秒, 但是许多AC代码的Runtime都在32ms, 说明这个程序还有一定的优化空间.</p>
<p>首先循环体内部的操作已经非常简洁, 应该很难有所作为, 所以优化的目标应该在循环次数上. 先将nums中最大的数保存下来, 当遍历到与该值相等的时候, 把这个数处理完后就可以退出循环了. 所以最终代码:</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        int maxItem = nums.empty() ? 0 : nums.back();
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
            if(nums[i] == maxItem){
                break;
            }
        }
        return num;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/leetcode-25-reverse-nodes-in-k-group/">LeetCode 25. Reverse Nodes in k-Group</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,<br>
Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
</blockquote>
<p>以k个节点为一组进行顺序颠倒. 首先实现一个从某个节点开始, 把包括它的接下来的k个节点的顺序颠倒的函数, 再不断迭代这个函数直到链表末尾. 由于如果链表长度不是k的整数倍的话, 最后的<code>m(m&lt;k)</code>个元素不进行处理, 所以先计算出链表的总长度<code>len</code>, 在每次迭代时计算已经处理过的节点数<code>reversedLen</code>, 当<code>reversedLen + k &gt; len</code>时结束循环.</p>
<pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* reverse(ListNode* prev, int k){
        if(!prev-&gt;next) return nullptr;
        ListNode *tail = prev-&gt;next, *pPrev = tail, *pCur = pPrev-&gt;next;
        for(int i = 1; pCur &amp;&amp; i &lt; k; i++){
            ListNode *pNext = pCur-&gt;next;
            pCur-&gt;next = pPrev;
            pPrev = pCur;
            pCur = pNext;
        }
        prev-&gt;next = pPrev;
        tail-&gt;next = pCur;
        return tail;
    }
    
    int countListLength(ListNode *list){
        int len = 0;
        ListNode *p = list;
        while(p){
            len++;
            p = p-&gt;next;
        }
        return len;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr || k &lt;= 1)
            return head;
        ListNode *trueHead = new ListNode(0), *p = trueHead;
        trueHead-&gt;next = head;
        int listLen = countListLength(head);
        int reversedLen = 0;
        
        while(true){
            if(reversedLen + k &gt; listLen) break;
            p = reverse(p, k);
            reversedLen += k;
        }
        return trueHead-&gt;next;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/18/leetcode-24-swap-nodes-in-pairs/">LeetCode 24. Swap Nodes in Pairs</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 18, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>
Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<p>交换链表相邻节点。</p>
<p>C++:</p>
<pre><code>class Solution {
public:
    ListNode *swapPairs(ListNode *head) {
        if(head == NULL || head-&gt;next == NULL) return head;
        ListNode *first = head, *second = head-&gt;next, *prev = NULL;
        first-&gt;next = second-&gt;next;
        second-&gt;next = first;
        head = second;
        prev = first;
        first = first-&gt;next;
        while(first){
            second = first-&gt;next;
            if(second == NULL)break;
            first-&gt;next = second-&gt;next;
            second-&gt;next = first;
            prev-&gt;next = second;
            prev = first;
            first = first-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>时间4ms。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/18/leetcode-23-merge-k-sorted-lists/">LeetCode 23. Merge k Sorted Lists</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 18, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</blockquote>
<p>合并k个有序链表. 首先创建一个小顶堆(比较的是每个链表节点的值), 其中的元素是k个链表的头结点, 每次取出堆顶的节点, 加入到合并后的链表中, 然后将这个节点的后一个节点放入堆中, 如果是链表尾则不放入. 重复这个步骤直到堆为空.</p>
<p>由于建n个元素的堆的时间复杂度为O(n)(证明见: <a href="http://blog.csdn.net/anonymalias/article/details/8807895" target="_blank" rel="noopener">http://blog.csdn.net/anonymalias/article/details/8807895</a>). 假设共有n个节点, 总的时间复杂度约为<code>O(k)+O(nlogk)</code>(我并不太会算复杂度, 这个也只是估计的…).</p>
<pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        auto comp = [=](ListNode *a, ListNode *b){
            return a-&gt;val &lt;= b-&gt;val;
        };
        ListNode *head = new ListNode(0), *p = head;
        if(lists.empty()) return head-&gt;next;
        set&lt;ListNode*, decltype(comp)&gt; s(comp);
        for(int i = 0; i &lt; lists.size(); i++){
            if(lists[i] != nullptr){
                s.insert(lists[i]);
            }
        }
        while(!s.empty()){
            ListNode *node = *(s.begin());
            s.erase(s.begin());
            if(node-&gt;next != nullptr) s.insert(node-&gt;next);
            p-&gt;next = node;
            p = p-&gt;next;
        }
        return head-&gt;next;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/18/leetcode-22-generate-parentheses/">LeetCode 22. Generate Parentheses</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 18, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<pre><code>[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
</code></pre>
</blockquote>
<p>题目要求输出n个括号的所有组合. 每个合法的字符串的长度都是<code>2*n</code>, 其中每个位置的字符有两种可能: 左括号和右括号. 因此循环<code>2*n</code>次, 每次对于结果集ret中的每个字符串末尾添加括号, 判断两种情况哪一种合法.或者两种都合法.</p>
<p><strong>左括号合法的情况</strong></p>
<p>字符串中出现的左括号总数没有超过<code>n</code>, 则在尾部添加左括号总是合法的.</p>
<p><strong>右括号合法的情况</strong></p>
<p>字符串中含有未配对的左括号. 注意: 如果左括号总数没有超过<code>n</code>, 那么该字符串添加左右括号都是合法的, 因此要在结果集末尾增加一条; 如果已经有了<code>n</code>个左括号, 那么只能添加右括号.</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; ret = {&quot;(&quot;};
        vector&lt;int&gt; leftNum = {1};   //ret中每个字符串中左括号的数量
        vector&lt;int&gt; singleLeftNum = {1};  //ret中每个字符串中未配对的左括号数量
        int strLen = n * 2;
        for(int i = 1; i &lt; strLen; i++){
            int len = ret.size();
            for(int j = 0; j &lt; len; j++){
                if(singleLeftNum[j] &gt; 0){
                    if(leftNum[j] == n){
                        ret[j].push_back(')');
                        singleLeftNum[j]--;
                    }
                    else{
                        ret.push_back(ret[j] + &quot;)&quot;);
                        leftNum.push_back(leftNum[j]);
                        singleLeftNum.push_back(singleLeftNum[j] - 1);
                    }
                }
                if(leftNum[j] &lt; n){
                    ret[j].push_back('(');
                    leftNum[j]++;
                    singleLeftNum[j]++;
                }
            }
        }
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/17/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-deque/">STL容器学习笔记二 - Deque</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 17, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h1 id="deque简介"><a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank" rel="noopener">Deque</a>简介</h1>
<p>deque(读作<em>deck</em>)是双向队列的缩写(<strong>d</strong>ouble-<strong>e</strong>nded <strong>que</strong>ue), 它是可以在两端动态变更大小的顺序容器.</p>
<p>不同的库可能会以不同的方法来实现deque, 但不管怎样, 它们都允许通过随机访问迭代器访问特定元素, 并且根据需要自动管理存储空间.</p>
<p>deque提供与vector相似的功能, 但是允许首尾两端高效的插入删除元素而不是像vector一样只能在尾部. <strong>但是</strong>, deque不像vector一样保证使用顺序存储空间来保存元素, 因此如果通过指针和偏移量访问deque中的另一个元素会引发<strong>未定义行为</strong>.</p>
<p>Vector与deque提供相似的接口并且可以用于相似的用途, 但它们的内部实现确完全不同. Vector使用一个在元素数量增长时偶尔需要重新分配空间的数组, 而deque中的元素可以分散存储在内存中的不同位置, deque容器内部通过保存必要的信息来提供在常数时间内访问任意元素的功能, 并且通过迭代器提供一个统一的顺序访问接口. 因此, deque的内部实现比vector要复杂, 但是这使得它在特定情况下可以更高效的增长, 比如在序列非常长时, 重新分配空间会非常耗时.</p>
<p>对于需要在首尾以外的位置频繁插入删除的操作来说, deque比list和forward list表现要差.</p>
<h1 id="容器属性">容器属性</h1>
<h2 id="顺序">顺序</h2>
<p>顺序容器中的元素都遵循严格的线性序列, 每个元素都可以通过他们在序列中的位置来访问.</p>
<h2 id="动态数组">动态数组</h2>
<p>通常实现类似于动态数组, 提供随机访问序列中任意元素的能力并且提供在序列首尾高效插入/删除的操作.</p>
<h2 id="allocator-aware">Allocator-aware[?]</h2>
<p>容器使用一个allocator对象来动态管理存储空间.</p>
<h1 id="部分常用函数">部分常用函数</h1>
<p>一些常用的函数比如<code>size</code>, <code>back</code>, <code>push_back</code>, <code>pop_back</code>, <code>push_front</code>, <code>pop_front</code>等我就不再赘述了</p>
<h2 id="构造函数">构造函数</h2>
<h3 id="默认构造函数-default-constructor">默认构造函数 <em>Default constructor</em></h3>
<pre><code>explicit deque (const allocator_type&amp; alloc = allocator_type());
</code></pre>
<p>创建一个空容器.</p>
<h3 id="填充构造函数-fill-constructor">填充构造函数 <em>Fill constructor</em></h3>
<pre><code>explicit deque (size_type n);
         deque (size_type n, const value_type&amp; val,
                const allocator_type&amp; alloc = allocator_type());
</code></pre>
<p>创建一个有n个元素的容器, 如果提供了val, 则n个元素的值都为val.</p>
<h3 id="范围构造函数-range-constructor">范围构造函数 <em>Range constructor</em></h3>
<pre><code>template &lt;class InputIterator&gt;
  deque (InputIterator first, InputIterator last,
         const allocator_type&amp; alloc = allocator_type());
</code></pre>
<p>构建一个数量与[first, last)相同的容器, 以与之相同的顺序初始化每个元素.</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<pre><code>deque (const deque&amp; x);
deque (const deque&amp; x, const allocator_type&amp; alloc);
</code></pre>
<p>创建一个以x中的元素的拷贝组成的容器.</p>
<h3 id="移动构造函数-move-constructor">移动构造函数 <em>Move constructor</em></h3>
<pre><code>deque (deque&amp;&amp; x);
deque (deque&amp;&amp; x, const allocator_type&amp; alloc);
</code></pre>
<p>创建一个由从x中取得的元素组成的容器, 下面这句话我没有太看懂:</p>
<blockquote>
<p>If alloc is specified and is different from x’s allocator, the elements are moved. Otherwise, no elements are constructed (their ownership is directly transferred).</p>
</blockquote>
<p>x会保持一个未定义但合法的状态.</p>
<h3 id="初始化列表构造函数">初始化列表构造函数</h3>
<pre><code>deque (initializer_list&lt;value_type&gt; il,
       const allocator_type&amp; alloc = allocator_type());
</code></pre>
<p>以il中元素的顺序用每个元素的拷贝创建一个容器.</p>
<h3 id="例子">例子</h3>
<pre><code>// code url: http://www.cplusplus.com/reference/deque/deque/deque/
// constructing deques
#include &lt;iostream&gt;
#include &lt;deque&gt;

int main ()
{
    unsigned int i;

    // constructors used in the same order as described above:
    std::deque&lt;int&gt; first;                                // empty deque of ints
    std::deque&lt;int&gt; second (4,100);                       // four ints with value 100
    std::deque&lt;int&gt; third (second.begin(),second.end());  // iterating through second
    std::deque&lt;int&gt; fourth (third);                       // a copy of third

    // the iterator constructor can be used to copy arrays:
    int myints[] = {16,2,77,29};
    std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) );

    std::cout &lt;&lt; &quot;The contents of fifth are:&quot;;
    for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it)
        std::cout &lt;&lt; ' ' &lt;&lt; *it;

    std::cout &lt;&lt; '\n';

    return 0;
}
</code></pre>
<p>输出</p>
<pre><code>The contents of fifth are: 16 2 77 29
</code></pre>
<h2 id="deque-assign">deque::assign</h2>
<p><strong>range (1)</strong></p>
<pre><code>template &lt;class InputIterator&gt;
void assign (InputIterator first, InputIterator last);
</code></pre>
<p><strong>fill (2)</strong></p>
<pre><code>void assign (size_type n, const value_type&amp; val);
</code></pre>
<p><strong>initializer list (3)</strong></p>
<pre><code>void assign (initializer_list&lt;value_type&gt; il);
</code></pre>
<p>重新配置deque中的内容, 并相应地调整大小. 使用方法类似于相应的构造函数.</p>
<h2 id="deque-clear">deque::clear</h2>
<pre><code>void clear() noexcept;
</code></pre>
<p>清空容器中的所有元素.</p>
<p><strong>时间复杂度:</strong> 与size有关的线性(因为要执行元素的析构函数).</p>
<h2 id="deque-max-size">deque::max_size</h2>
<pre><code>size_type max_size() const noexcept;
</code></pre>
<p>返回deque容器所能保存的最大元素数量. 但是deque不保证一定能达到这个数量.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/17/leetcode-21-merge-two-sorted-lists/">LeetCode 21. Merge Two Sorted Lists</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 17, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>问题描述:</p>
<blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<p>简单的链表操作。</p>
<pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1 == NULL &amp;&amp; l2 == NULL)return NULL;
        if(l1 == NULL)return l2;
        if(l2 == NULL)return l1;
        ListNode *head = new ListNode(0), *l1Node = l1, *l2Node = l2, *p = head;
        while(l1Node || l2Node){
            if(!l1Node){
                p-&gt;next = l2Node;
                break;
            }
            else if(!l2Node){
                p-&gt;next = l1Node;
                break;
            }
            else{
                if(l1Node-&gt;val &lt; l2Node-&gt;val){
                    p-&gt;next = l1Node;
                    l1Node = l1Node-&gt;next;
                }
                else{
                    p-&gt;next = l2Node;
                    l2Node = l2Node-&gt;next;
                }
            }
            p = p-&gt;next;
        }
        return head-&gt;next;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/17/leetcode-20-valid-parentheses/">LeetCode 20. Valid Parentheses</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 17, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a string containing just the characters ‘(’, ‘)’, ‘{’, ‘}’, ‘[’ and ‘]’, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
</blockquote>
<p>要求判断输入字符串中的括号是否正确匹配, 因为括号要正确闭合, 因此使用计数器来记录左右括号数量是不行的. 我用栈来保存所有的左括号, 每遇到一个右括号就与栈顶端的左括号匹配, 不匹配则返回false, 匹配则将栈顶括号出栈. 循环过程中如果出现栈为空, 或者循环结束后栈不为空则返回false. 其他情况返回true.</p>
<pre><code>class Solution {
public:
    bool isValid(string s) {
        vector&lt;char&gt; bracket;
        for(auto i : s){
            if(i == '(' || i == '[' | i == '{')
                bracket.push_back(i);
            else{
                if(bracket.empty())
                    return false;
                else if( (i == ')' &amp;&amp; bracket.back() == '(') || (i == ']' &amp;&amp; bracket.back() == '[') || (i == '}' &amp;&amp; bracket.back() == '{'))
                    bracket.pop_back();
                else
                    return false;
            }
        }
        
        return bracket.empty() ? true : false;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/35/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/37/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
