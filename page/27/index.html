<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/27/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/27/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script src="https://use.typekit.net/tqr0ojg.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/31/leetcode-103-binary-tree-zigzag-level-order-traversal/">LeetCode 103. Binary Tree Zigzag Level Order Traversal</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 31, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>
Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这道题与上一题<a href="http://xiadong.info/2016/08/leetcode-102-binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>非常相似, 只需要在BFS之后汇总的时候以正反方向间隔的形式放入level中即可. 我是全部正向放入之后再对偶数行颠倒来完成的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals, level;</span><br><span class="line">        generateMap(root, vals, level);</span><br><span class="line">        <span class="keyword">int</span> maxLevel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level.size(); i++) <span class="keyword">if</span>(maxLevel &lt; level[i]) maxLevel = level[i];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">re</span><span class="params">(maxLevel + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.size(); i++)&#123;</span><br><span class="line">            re[level[i]].push_back(vals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxLevel; i += <span class="number">2</span>)&#123;</span><br><span class="line">            reverse(re[i].begin(), re[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateMap</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;level)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; levels;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        levels.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            TreeNode* p = nodes.front();</span><br><span class="line">            <span class="keyword">int</span> l = levels.front();</span><br><span class="line">            vals.push_back(p-&gt;val);</span><br><span class="line">            level.push_back(l);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">                nodes.push(p-&gt;left);</span><br><span class="line">                levels.push(l + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">                nodes.push(p-&gt;right);</span><br><span class="line">                levels.push(l + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            nodes.pop();</span><br><span class="line">            levels.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/31/leetcode-102-binary-tree-level-order-traversal/">LeetCode 102. Binary Tree Level Order Traversal</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 31, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>
Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我的方法是使用广度优先搜索遍历每一个节点并计算出每一个节点的level值, 然后再遍历一次节点把节点放到相应的level中去. 时间和空间复杂度都是O(n).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于BFS的队列, qLevel用于保存BFS中相应节点的level</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; BFS;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qLevel;</span><br><span class="line">        <span class="comment">// 把遍历到的每一个节点都放到vector中保存, 用于最后汇总</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        </span><br><span class="line">        BFS.push(root);</span><br><span class="line">        qLevel.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLevel = <span class="number">0</span>;</span><br><span class="line">        nodes.push_back(root);</span><br><span class="line">        level.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!BFS.empty())&#123;</span><br><span class="line">            TreeNode* node = BFS.front();</span><br><span class="line">            <span class="keyword">int</span> currentLevel = qLevel.front();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                BFS.push(node-&gt;left);</span><br><span class="line">                qLevel.push(currentLevel + <span class="number">1</span>);</span><br><span class="line">                nodes.push_back(node-&gt;left);</span><br><span class="line">                level.push_back(currentLevel + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                BFS.push(node-&gt;right);</span><br><span class="line">                qLevel.push(currentLevel + <span class="number">1</span>);</span><br><span class="line">                nodes.push_back(node-&gt;right);</span><br><span class="line">                level.push_back(currentLevel + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currentLevel + <span class="number">1</span> &gt; maxLevel) maxLevel = currentLevel + <span class="number">1</span>;</span><br><span class="line">            BFS.pop();</span><br><span class="line">            qLevel.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次遍历节点并放到相应的level中去</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">re</span><span class="params">(maxLevel)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++)&#123;</span><br><span class="line">            re[level[i]].push_back(nodes[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/30/leetcode-101-symmetric-tree/">LeetCode 101. Symmetric Tree</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 30, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>
Bonus points if you could solve it both recursively and iteratively.</p>
</blockquote>
<p>最直观的方法就是先把二叉树翻转, 然后再判断两棵二叉树是否相同.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copyTree</span><span class="params">(TreeNode* root, TreeNode *copy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            copy-&gt;left = <span class="keyword">new</span> TreeNode(root-&gt;left-&gt;val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            copy-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        copyTree(root-&gt;left, copy-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            copy-&gt;right = <span class="keyword">new</span> TreeNode(root-&gt;right-&gt;val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            copy-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        copyTree(root-&gt;right, copy-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseTree</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode *tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        reverseTree(root-&gt;left);</span><br><span class="line">        reverseTree(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sameTree</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> sameTree(root1-&gt;left, root2-&gt;left) &amp;&amp; sameTree(root1-&gt;right, root2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        TreeNode *mirrorRoot = <span class="keyword">new</span> TreeNode(root-&gt;val);</span><br><span class="line">        copyTree(root, mirrorRoot);</span><br><span class="line">        reverseTree(mirrorRoot);</span><br><span class="line">        <span class="keyword">return</span> sameTree(root, mirrorRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>非递归的方法就是使用迭代而不是递归来分别从<strong>不同的方向</strong>遍历左右子树, <strong>注意</strong>, 不能用先序遍历或者后序遍历, 比如这组数据<code>[1,2,2,null,3,null,3]</code>使用先序遍历它的左右子树是互为镜像的.</p>
<p>另外说一句, 直到这里我才去看非递归遍历二叉树的标准方法, 我以前都是用另一个栈来保存节点状态…很有力地证明了我的数据结构课听得很水= =.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* left, TreeNode *right)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; leftPath, rightPath;</span><br><span class="line">        <span class="keyword">while</span>((!leftPath.empty() || left != <span class="literal">nullptr</span>) &amp;&amp; (!rightPath.empty() || right != <span class="literal">nullptr</span>))&#123;</span><br><span class="line">            TreeNode *curLeftNode = <span class="literal">nullptr</span>, *curRightNode = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                leftPath.push(left);</span><br><span class="line">                left = left-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = leftPath.top();</span><br><span class="line">                curLeftNode = left;</span><br><span class="line">                leftPath.pop();</span><br><span class="line">                left = left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                rightPath.push(right);</span><br><span class="line">                right = right-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = rightPath.top();</span><br><span class="line">                curRightNode = right;</span><br><span class="line">                rightPath.pop();</span><br><span class="line">                right = right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((curLeftNode &amp;&amp; curRightNode &amp;&amp; curLeftNode-&gt;val != curRightNode-&gt;val) || (!(curLeftNode &amp;&amp; curRightNode) &amp;&amp; !(curLeftNode == <span class="literal">nullptr</span> &amp;&amp; curRightNode == <span class="literal">nullptr</span>))) &#123;</span><br><span class="line">                <span class="comment">// 这个布尔表达式的意思是当前的左右节点都不为null并且值不等, 或者其中有且只有</span></span><br><span class="line">                <span class="comment">// 一个null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftPath.empty() &amp;&amp; left == <span class="literal">nullptr</span> &amp;&amp; rightPath.empty() &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>附上标准的非递归遍历方法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderIter</span><span class="params">(struct node *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;struct node *&gt; s;  </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">" "</span>; <span class="comment">//访问结点并入栈  </span></span><br><span class="line">            s.push(root);                </span><br><span class="line">            root = root-&gt;left;         <span class="comment">//访问左子树  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            root = s.top();            <span class="comment">//回溯至父亲结点  </span></span><br><span class="line">            s.pop();  </span><br><span class="line">            root = root-&gt;right;        <span class="comment">//访问右子树  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderIter</span><span class="params">(struct node *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;struct node *&gt; s;  </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            s.push(root);  </span><br><span class="line">            root = root-&gt;left;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            root = s.top();  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">" "</span>;  <span class="comment">//访问完左子树后才访问根结点  </span></span><br><span class="line">            s.pop();  </span><br><span class="line">            root = root-&gt;right;        <span class="comment">//访问右子树  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderIter</span><span class="params">(struct node *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;struct node*&gt; s, output;  </span><br><span class="line">    s.push(root);  </span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">curr</span> = <span class="title">s</span>.<span class="title">top</span>();</span>  </span><br><span class="line">        output.push(curr);  </span><br><span class="line">        s.pop();  </span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;left)  </span><br><span class="line">            s.push(curr-&gt;left);  </span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;right)  </span><br><span class="line">            s.push(curr-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (!output.empty()) &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; output.top()-&gt;data &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">        output.pop();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/30/leetcode-391-perfect-rectangle/">LeetCode 391. Perfect Rectangle</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 30, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given N axis-aligned rectangles where N &gt; 0, determine if they all together form an exact cover of a rectangular region.</p>
<p>Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).</p>
<p><img src="https://leetcode.com/static/images/problemset/rectangle_perfect.gif" alt="img"></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rectangles &#x3D; [</span><br><span class="line">  [1,1,3,3],</span><br><span class="line">  [3,1,4,2],</span><br><span class="line">  [3,2,4,4],</span><br><span class="line">  [1,3,2,4],</span><br><span class="line">  [2,3,3,4]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return true. All 5 rectangles together form an exact cover of a rectangular region.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://leetcode.com/static/images/problemset/rectangle_separated.gif" alt="img"></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rectangles &#x3D; [</span><br><span class="line">  [1,1,2,3],</span><br><span class="line">  [1,3,2,4],</span><br><span class="line">  [3,1,4,2],</span><br><span class="line">  [3,2,4,4]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return false. Because there is a gap between the two rectangular regions.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://leetcode.com/static/images/problemset/rectangle_hole.gif" alt="img"></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rectangles &#x3D; [</span><br><span class="line">  [1,1,3,3],</span><br><span class="line">  [3,1,4,2],</span><br><span class="line">  [1,3,2,4],</span><br><span class="line">  [3,2,4,4]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return false. Because there is a gap in the top center.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://leetcode.com/static/images/problemset/rectangle_intersect.gif" alt="img"></p>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rectangles &#x3D; [</span><br><span class="line">  [1,1,3,3],</span><br><span class="line">  [3,1,4,2],</span><br><span class="line">  [1,3,2,4],</span><br><span class="line">  [2,2,4,4]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return false. Because two of the rectangles overlap with each other.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一开始我对于这道题的思路是这样的:</p>
<ul>
<li>第一步, 遍历所有小的矩形计算它们的面积之和并且计算出最终应该拼成的大矩形的端点位置(左下角和右上角), 如果面积之和与大矩形的面积不相等, 那么就肯定不可能拼成.</li>
<li>第二步, 判断小矩形之间是不是有重叠.</li>
</ul>
<p>问题在于第二步, 判断矩形是否有重叠比较容易, 但是两两比较要求O(n<sup>2</sup>)的时间复杂度, 超时了.</p>
<p>如果不对小矩形两两判断是否有重叠而使用累积的办法看某个小矩形与之前所有小矩形拼成的多边形是否有重合的话, 实现起来相当复杂, 所以应该有更好的方法.</p>
<p>在Discuss中看到了一个相当妙的办法<a href="https://discuss.leetcode.com/topic/56081/easy-understanding-o-n-python-solution" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/56081/easy-understanding-o-n-python-solution</a>, 基本思想就是如果最终能拼成大矩形, 那么除了大矩形的四个顶点只出现一次外, 其他的每个小矩形的顶点只能出现两次或者四次. 所以就可以用一个map来记录小矩形的每个顶点出现的次数, 然后再遍历这个map判断其中的顶点是不是都满足条件. 时间复杂度(O(nlogn + n)).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleCover</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rectangles.size(), areaSum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">finalRect</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; corners;</span><br><span class="line">        finalRect[<span class="number">0</span>] = finalRect[<span class="number">1</span>] = INT_MAX, finalRect[<span class="number">2</span>] = finalRect[<span class="number">3</span>] = INT_MIN;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">areas</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            areas[i] = (rectangles[i][<span class="number">2</span>] - rectangles[i][<span class="number">0</span>]) * (rectangles[i][<span class="number">3</span>] - rectangles[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; corner = &#123;&#123;rectangles[i][<span class="number">0</span>], rectangles[i][<span class="number">1</span>]&#125;, &#123;rectangles[i][<span class="number">2</span>], rectangles[i][<span class="number">3</span>]&#125;, &#123;rectangles[i][<span class="number">0</span>], rectangles[i][<span class="number">3</span>]&#125;, &#123;rectangles[i][<span class="number">2</span>], rectangles[i][<span class="number">1</span>]&#125;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(corners.count(corner[j]))&#123;</span><br><span class="line">                    corners[corner[j]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    corners[corner[j]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            finalRect[<span class="number">0</span>] = min(finalRect[<span class="number">0</span>], rectangles[i][<span class="number">0</span>]);</span><br><span class="line">            finalRect[<span class="number">1</span>] = min(finalRect[<span class="number">1</span>], rectangles[i][<span class="number">1</span>]);</span><br><span class="line">            finalRect[<span class="number">2</span>] = max(finalRect[<span class="number">2</span>], rectangles[i][<span class="number">2</span>]);</span><br><span class="line">            finalRect[<span class="number">3</span>] = max(finalRect[<span class="number">3</span>], rectangles[i][<span class="number">3</span>]);</span><br><span class="line">            areaSum += areas[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> finalArea = (finalRect[<span class="number">2</span>] - finalRect[<span class="number">0</span>]) * (finalRect[<span class="number">3</span>] - finalRect[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(areaSum != finalArea) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = corners.begin(); i != corners.end(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((i-&gt;first.first == finalRect[<span class="number">0</span>] &amp;&amp; i-&gt;first.second == finalRect[<span class="number">1</span>]) || (i-&gt;first.first == finalRect[<span class="number">2</span>] &amp;&amp; i-&gt;first.second == finalRect[<span class="number">3</span>]) || (i-&gt;first.first == finalRect[<span class="number">0</span>] &amp;&amp; i-&gt;first.second == finalRect[<span class="number">3</span>]) || (i-&gt;first.first == finalRect[<span class="number">2</span>] &amp;&amp; i-&gt;first.second == finalRect[<span class="number">1</span>])))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-&gt;second != <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-&gt;second == <span class="number">2</span> || i-&gt;second == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/29/leetcode-389-find-the-difference/">LeetCode 389. Find the Difference</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 29, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given two strings <strong>s</strong> and <strong>t</strong> which consist of only lowercase letters.</p>
<p>String <strong>t</strong> is generated by random shuffling string <strong>s</strong> and then add one more letter at a random position.</p>
<p>Find the letter that was added in <strong>t</strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;abcd&quot;</span><br><span class="line">t &#x3D; &quot;abcde&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; is the letter that was added.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用哈希表来记录每个字母出现的次数, 多出现的字符就是增加的字符.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            nums[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--nums[t[i] - <span class="string">'a'</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还可以使用异或. 由于s与t除了一个元素以外其他都相同, 所以使用0分别于s与t的每个元素异或, 得到的就是多余的那一个字符.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ch ^= s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            ch ^= t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/28/leetcode-100-same-tree/">LeetCode 100. Same Tree</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 28, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>
<p>很简单, 使用递归来判断每个节点是否相等.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) || (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/28/leetcode-99-recover-binary-search-tree/">LeetCode 99. Recover Binary Search Tree</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 28, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:<br>
A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
</blockquote>
<p>使用O(n)辅助空间的方法就是使用中序遍历从BST中获得一个有序递增的序列, 但是其中有两个元素的位置交换了. 被交换的元素的特征就是前一个元素大于后一个元素, 找到这样两个元素再把它们交换回来即可, 如果只找到了一个这样的元素, 说明是相邻的两个元素交换了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; seq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mistakeNodes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i]-&gt;val &gt; seq[i + <span class="number">1</span>]-&gt;val)&#123;</span><br><span class="line">                mistakeNodes.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mistakeNodes.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            swap(seq[mistakeNodes[<span class="number">0</span>]]-&gt;val, seq[mistakeNodes[<span class="number">0</span>] + <span class="number">1</span>]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            swap(seq[mistakeNodes[<span class="number">0</span>]]-&gt;val, seq[mistakeNodes[<span class="number">1</span>] + <span class="number">1</span>]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        seq.push_back(root);</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而把这一思路推广到不使用辅助空间, 很容易就可以发现我们并不需要一个完整的序列, 只需要相邻两个值的大小关系, 所以我们只要在遍历过程中维持两个节点值即可. 另外由于我们没有完整的序列, 所以在mistakeNodes中要同时保存前一个元素比后一个元素大的这两个元素, 因为对于被交换的较小值来说, 它在后一个元素的位置, 而对于较大值来说, 它位于前一个元素的位置. 当然也可以通过判断mistakeNodes中是否已经有元素来避免同时保存.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; mistakeNodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; tmpNodes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        tmpNodes.resize(<span class="number">2</span>);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">if</span>(mistakeNodes.size() == <span class="number">2</span>)&#123;</span><br><span class="line">            swap(mistakeNodes[<span class="number">0</span>]-&gt;val, mistakeNodes[<span class="number">1</span>]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            swap(mistakeNodes[<span class="number">0</span>]-&gt;val, mistakeNodes[<span class="number">3</span>]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || mistakeNodes.size() == <span class="number">4</span>) <span class="keyword">return</span> ;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        tmpNodes[<span class="number">0</span>] = tmpNodes[<span class="number">1</span>];</span><br><span class="line">        tmpNodes[<span class="number">1</span>] = root;</span><br><span class="line">        <span class="keyword">if</span>(tmpNodes[<span class="number">0</span>] &amp;&amp; tmpNodes[<span class="number">0</span>]-&gt;val &gt; tmpNodes[<span class="number">1</span>]-&gt;val)&#123;</span><br><span class="line">            mistakeNodes.push_back(tmpNodes[<span class="number">0</span>]);</span><br><span class="line">            mistakeNodes.push_back(tmpNodes[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/28/leetcode-98-validate-binary-search-tree/">LeetCode 98. Validate Binary Search Tree</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 28, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,1,3]</span><br></pre></td></tr></table></figure>
<p>, return true.</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure>
<p>, return false.</p>
</blockquote>
<p>验证一个二叉搜索树是否合法, 使用递归的方法来依次遍历左右子树.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; BSTMax(root-&gt;left) &gt;= root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; BSTMin(root-&gt;right) &lt;= root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BSTMax</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BSTMax(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BSTMin</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BSTMin(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/24/leetcode-97-interleaving-string/">LeetCode 97. Interleaving String</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 24, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p>
<p>For example,<br>
Given:<br>
<em>s1</em> = <code>&quot;aabcc&quot;</code>,<br>
<em>s2</em> = <code>&quot;dbbca&quot;</code>,</p>
<p>When <em>s3</em> = <code>&quot;aadbbcbcac&quot;</code>, return true.<br>
When <em>s3</em> = <code>&quot;aadbbbaccc&quot;</code>, return false.</p>
</blockquote>
<p>使用动态规划, <code>dp[i][j]</code>代表s1的前i个字符与s2的前j个字符是否能组成s3的前i+j个字符.</p>
<p>显然<code>dp[0][0]</code>能组成空字符串, 所以<code>dp[0][0]</code>为真. 而对于<code>i=0</code>和<code>j=0</code>的情况来说, 直接比较s1的前i个字符或s2的前j个字符与s3是否相同就可以了.</p>
<p>接下来的<code>dp[i][j]</code>分为两种情况:</p>
<ol>
<li><code>s3[i+j-1]</code>的字符与<code>s1[i-1]</code>相同, 代表<code>s3[i+j-1]</code>的字符可以从s1中取得. 此时<code>dp[i][j]</code>为真则要求<code>dp[i-1][j]</code>为真.</li>
<li><code>s3[i+j-1]</code>的字符与<code>s2[j-1]</code>相同, 代表<code>s3[i+j-1]</code>的字符可以从s2中取得. 此时<code>dp[i][j]</code>为真则要求<code>dp[i][j-1]</code>为真.</li>
</ol>
<p>递推方程为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; (dp[i - 1][j] &amp;&amp; s3[i + j - 1] &#x3D;&#x3D; s1[i - 1]) || (dp[i][j - 1] &amp;&amp; s3[i + j - 1] &#x3D;&#x3D; s2[j - 1])</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() + s2.length() != s3.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s2.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i - <span class="number">1</span>][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s2.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[<span class="number">0</span>][i - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s2[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((dp[i - <span class="number">1</span>][j] &amp;&amp; s3[i + j - <span class="number">1</span>] == s1[i - <span class="number">1</span>]) || (dp[i][j - <span class="number">1</span>] &amp;&amp; s3[i + j - <span class="number">1</span>] == s2[j - <span class="number">1</span>])) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.size()][s2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/24/leetcode-96-unique-binary-search-trees/">LeetCode 96. Unique Binary Search Trees</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 24, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>?</p>
<p>For example,<br>
Given <em>n</em> = 3, there are a total of 5 unique BST’s.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> &#x2F;     &#x2F;       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p>采用递归+动态规划来解决.</p>
<p>首先一颗n个节点的BST, 假设它的根节点值为r(1&lt;=r&lt;=n), 那么它的不同形态数量等于所有左子树的形态数量(r-1个节点)×所有右子树的形态数量(n-r个节点), 而因为一颗BST的形态数量只与节点数量有关而与节点的具体值无关, 所以可以用一个数组来记录已经计算过数量的n来减少计算.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> numsTrees(n, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numsTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num += ((nums[i - <span class="number">1</span>] == <span class="number">-1</span> ? numsTrees(i - <span class="number">1</span>, nums) : nums[i - <span class="number">1</span>]) * (nums[n - i] == <span class="number">-1</span> ? numsTrees(n - i, nums) : nums[n - i]));</span><br><span class="line">        &#125;</span><br><span class="line">        nums[n] = num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/26/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/28/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
