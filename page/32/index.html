<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/32/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/32/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script src="https://use.typekit.net/tqr0ojg.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/05/leetcode-61-rotate-list/">LeetCode 61. Rotate List</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 5, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:</p>
<p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</p>
<p>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
</blockquote>
<p>最简单的方法是把所有节点指针保存在一个数组中, 设总长度为<code>len</code>, 然后找到第<code>len - k</code>个节点为新链表的头结点, 它之前的节点是新链表的尾节点. 把原链表的尾节点指向头结点即可. 要注意<code>k</code>可能会大于<code>len</code>, 所以可以先把<code>k</code>对<code>len</code>取余.</p>
<pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return head;
        vector&lt;ListNode*&gt; l;
        ListNode* p = head, *reHead;
        while(p){
            l.push_back(p);
            p = p-&gt;next;
        }
        
        k = k % l.size();
        if(k == 0)
            return head;
        auto iter = l.end() - k;
        (*(iter - 1))-&gt;next = NULL;
        (*(l.end() - 1))-&gt;next = *(l.begin());
        return *iter;
    }
};
</code></pre>
<p>不使用额外空间的方法需要多遍历几次链表:</p>
<pre><code>class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return head;
        int len = 0;
        ListNode *p = head, *newHead = nullptr, *tail = nullptr, *newTail = nullptr;
        while(p){
            len++;
            if(!p-&gt;next)
                tail = p;
            p = p-&gt;next;
        }
        k = k % len;
        if(!k) return head;
        newHead = head;
        for(int i = 0; i &lt; len - k; i++){
            newTail = newHead;
            newHead = newHead-&gt;next;
        }
        newTail-&gt;next = nullptr;
        tail-&gt;next = head;
        return newHead;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/04/leetcode-60-permutation-sequence/">LeetCode 60. Permutation Sequence</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 4, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>
We get the following sequence (ie, for n = 3):</p>
<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
<p>Given n and k, return the kth permutation sequence.</p>
<p>Note: Given n will be between 1 and 9 inclusive.</p>
</blockquote>
<p>返回[1,n]n个数字的全排列按照字典序排序后的第k个排列, n在[1,9]的范围内.</p>
<p>通过观察题目给出的<code>n = 3</code>的全排列可以看出, 以1, 2, 3开头的排列各有两个. n的全排列有<code>n!</code>种, 而以[1,n]中某个数字开头的排列种数有<code>(n - 1)!</code>种, 所以第k个排列的第一个数为<code>(k - 1) / (n - 1)! + 1</code>. 将k更新为<code>k % (n - 1)!</code>, 把第一个已经确定的数从数字集合中去掉(该集合应有序), 就可以以类似递归的方法确定整个序列.</p>
<p>实际上每一次确定数字在集合数组中的下标比直接确定数字要更加有效. 而且由于n在1到9之间, 因此可以先把<code>n!</code>计算出来放到数组中.</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; arr = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
    string getPermutation(int n, int k) {
        int kk = k - 1;
        vector&lt;int&gt; nums;
        for(int i = 1; i &lt;= n; i++){
            nums.push_back(i); //nums[i]的值实际是i + 1
        }
        string ret;
        for(int i = 0; i &lt; n; i++){
            if(i == n - 1){
                ret.push_back(nums[0] + '0'); //i = n - 1时下方会出现除零错误
                break;
            }
            int t = kk / arr[n - 1 - i];
            ret.push_back(nums[t] + '0'); //因为nums[i] = i + 1, 所以不需要再加1
            nums.erase(nums.begin() + t); //把已经确定的元素删除
            kk = kk % arr[n - i - 1];
        }
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/04/leetcode-59-spiral-matrix-ii/">LeetCode 59. Spiral Matrix II</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 4, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>For example,<br>
Given n = 3,</p>
<p>You should return the following matrix:</p>
<pre><code>[
  [ 1, 2, 3 ],
  [ 8, 9, 4 ],
  [ 7, 6, 5 ]
]
</code></pre>
</blockquote>
<p>螺旋输出序列. 首先用一个循环, 在循环体内填充一圈数字, 直到所有位置填满.</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) {
        vector&lt;vector&lt;int&gt; &gt; ret(n, vector&lt;int&gt;(n, 0));
        if(n == 0)return ret;
        int a = 1;
        for(int i = n; i &gt; 0; i-=2){ // 圈数应为n/2
            if(i == 1 &amp;&amp; n % 2 == 1){ // 当n为奇数时, 最内圈只有一个元素
                ret[(n - i) / 2][(n - i) / 2] = a++;
                break;
            }
            for(int j = (n - i) / 2; j &lt; n - (n - i) / 2 - 1; j++) // 填充上边的行
                ret[(n - i) / 2][j] = a++;
            for(int j = (n - i) / 2; j &lt; n - (n - i) / 2 - 1; j++) // 填充右边的列
                ret[j][n - (n - i) / 2 - 1] = a++;
            for(int j = n - (n - i) / 2 - 1; j &gt; (n - i) / 2; j--) // 填充下边的行
                ret[n - (n - i) / 2 - 1][j] = a++;
            for(int j = n - (n - i) / 2 - 1; j &gt; (n - i) / 2; j--) // 填充左边的列
                ret[j][(n - i) / 2] = a++;
        }
        
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/04/leetcode-58-length-of-last-word/">LeetCode 58. Length of Last Word</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 4, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a string s consists of upper/lower-case alphabets and empty space characters ’ ', return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>
Given s = “Hello World”,<br>
return 5.</p>
</blockquote>
<p>找出一个字符串中最后一个单词的长度, 没有什么好说的, 从后往前搜索.</p>
<pre><code>class Solution {
public:
    int lengthOfLastWord(string s) {
        int end = s.size();
        if(end == 0)
            return 0;
        for(; end &gt;= 1 &amp;&amp; s[end - 1] == ' '; end--); // 跳过结尾的空格
        int i;
        for(i = end - 1; i &gt;= 0 &amp;&amp; s[i] != ' '; i--);
        return end - i - 1;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/03/leetcode-57-insert-interval/">LeetCode 57. Insert Interval</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 3, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p>Example 1:</p>
<p>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p>
<p>Example 2:</p>
<p>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p>
<p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p>
</blockquote>
<p>向一个已经按照start排好序的区间数组中插入新区间, 问题分为两个部分:</p>
<ol>
<li>找到插入位置</li>
<li>确定区间是否需要合并, 如何合并</li>
</ol>
<p>用语言来说还是不太好说清楚, 还是看注释吧.</p>
<pre><code>/**
* Definition for an interval.
* struct Interval {
*     int start;
*     int end;
*     Interval() : start(0), end(0) {}
*     Interval(int s, int e) : start(s), end(e) {}
* };
*/
class Solution {
public:
    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) {
        vector&lt;Interval&gt; ret;
        if(intervals.empty()){ // 如果intervals为空就返回只包含newInterval的数组
            ret.push_back(newInterval);
            return ret;
        }
        int i;
        // 以下循环用于跳过所有end小于newInterval.start, 也就是所有小于newInterval并且
        // 与newInterval没有交集的区间
        for(i = 0; i &lt; intervals.size() &amp;&amp; intervals[i].end &lt; newInterval.start; i++);
        // 如果i == intervals.size(), 说明所有元素都小于newInterval, 把它插入到最后即可
        if(i == intervals.size()){
            intervals.push_back(newInterval);
            return intervals;
        }
        int j = i;
        // 将要插入的新区间
        Interval t;
        // 此时j = i, intervals[j]是end &gt;= newInterval.start的第一个元素,但它们的start
        // 关系还不确定, 因此要插入的start值是intervals[j].start和newInterval.start中较
        // 小的一个
        t.start = min(intervals[j].start, newInterval.start);
        // 寻找start &gt; newInterval.end的元素, 该元素之前的元素是要与newInterval合并的区间
        for(; j &lt; intervals.size() &amp;&amp; intervals[j].start &lt;= newInterval.end; j++);
        // 如果j == intervals.size()说明i之后的所有区间都要与newInterval合并,
        // 所以t.end是newInterval.end和intervals.back().end中较大的值.
        // 然后删除intervals中i之后的元素(包括i, 因为i也与newInterval有交集),
        // 最后插入t
        if(j == intervals.size()){
            t.end = max(newInterval.end, intervals.back().end);
            intervals.erase(intervals.begin() + i, intervals.end());
            intervals.push_back(t);
            return intervals;
        }
        // 否则intervals[j - 1]是start &lt;= newInterval.end的最后一个元素, 也就是与newInterval
        // 有交集的最后一个元素, t.end的值是newInterval.end和intervals[j - 1].end中较大的.
        // 从intervals中移除下标在[i, j-1]范围内的元素, 在i位置插入新区间t.
        else{
            t.end = max(newInterval.end, intervals[j - 1].end);
            intervals.erase(intervals.begin() + i, intervals.begin() + j);
            intervals.insert(intervals.begin() + i, t);
        }
        return intervals;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/03/leetcode-56-merge-intervals/">LeetCode 56. Merge Intervals</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 3, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,</p>
<p>Given <code>[1,3],[2,6],[8,10],[15,18]</code>,</p>
<p>return <code>[1,6],[8,10],[15,18]</code>.</p>
</blockquote>
<p>合并(闭)区间, 区间以对象的形式给出. 首先将输入的区间数组按照<code>start</code>从小到大排序, 然后先取第一个元素放入结果集中, 从第二个元素开始遍历. 取当前区间为<code>cur</code>, 结果集中的最后一个元素为<code>pre</code>. 如果<code>cur.start &gt; pre.end</code>, 说明<code>cur</code>与<code>pre</code>并无交集, 由于有序, 所以<code>cur</code>以后的区间与<code>pre</code>也都没有交集, 所以可以将<code>cur</code>放入结果集中. 如果<code>cur.start &lt;= pre.end</code>, 说明有交集, 由于必然存在<code>cur.start &gt;= pre.start</code>, 所以新区间的<code>start</code>等于<code>pre.start</code>, 只要考虑<code>cur.end</code>与<code>pre.end</code>的大小关系, 如果<code>cur.end &lt;= pre.end</code>, 那么新区间与<code>pre</code>相同; 如果<code>cur.end &gt; pre.end</code>那么要把<code>pre</code>也就是结果集的最后一个区间的<code>end</code>修改为<code>cur.end</code>.</p>
<pre><code>/**
* Definition for an interval.
* struct Interval {
*     int start;
*     int end;
*     Interval() : start(0), end(0) {}
*     Interval(int s, int e) : start(s), end(e) {}
* };
*/
class Solution {
public:
    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) {
        vector&lt;Interval&gt; ret;
        if(intervals.empty()) return ret;
        sort(intervals.begin(), intervals.end(), [=](Interval &amp;a, Interval &amp;b){
            return a.start &lt; b.start;
        });
        ret.push_back(intervals[0]);
        for(int i = 1; i &lt; intervals.size(); i++){
            Interval cur = intervals[i], pre = ret.back();
            if(cur.start &gt; pre.end){
                ret.push_back(cur);
            }
            else{
                if(cur.end &gt; pre.end){
                    ret.back().end = cur.end;
                }
            }
        }
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/03/leetcode-55-jump-game/">LeetCode 55. Jump Game</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 3, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:</p>
<p>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
</blockquote>
<p>数组中的每个元素表示从当前下标可以向前跳的距离, 返回能不能到达最后一个下标. 从第一个元素开始记录从当前元素能到达的最远的下标值, 对之后的每个元素更新这个值, 如果该值小于当前下标则说明该下标无法到达.</p>
<pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        int farthest = nums[0], i;
        for(i = 1; i &lt; nums.size() &amp;&amp; farthest &gt;= i; i++){
            farthest = max(farthest, nums[i] + i);
        }
        if(farthest &gt;= nums.size() - 1)
            return true;
        else
            return false;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/02/leetcode-54-spiral-matrix/">LeetCode 54. Spiral Matrix</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 2, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>
Given the following matrix:</p>
<pre><code>[
  [ 1, 2, 3 ],
  [ 4, 5, 6 ],
  [ 7, 8, 9 ]
]
</code></pre>
<p>You should return <code>[1,2,3,6,9,8,7,4,5]</code>.</p>
</blockquote>
<p>螺旋形输出一个矩阵, 我的方法就是螺旋形地遍历这个矩阵. 用一个变量来表示方向, 到达矩阵边缘的时候就更改方向.</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt; re;
        if (matrix.size() == 0 || matrix[0].size() == 0)
            return re;
        int m = matrix.size(), n = matrix[0].size(), num = m * n;
        vector&lt;int&gt; row(n, 0);
        vector&lt;vector&lt;int&gt;&gt; visited(m, row);
        int direction = 0;// 0 =&gt; right, 1 =&gt; down, 2 =&gt; left, 3 =&gt; up
        int posRow = 0, posCol = 0, cnt = 0;
        while (cnt &lt; num) {
            int nextPosRow, nextPosCol;
            if(!visited[posRow][posCol]){
                re.push_back(matrix[posRow][posCol]);
                visited[posRow][posCol] = 1;
                cnt++;
            }
            bool nextPosValid = true;
            switch (direction) {
            case 0:
                nextPosRow = posRow;
                nextPosCol = posCol + 1;
                if (nextPosCol &gt;= n || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 1:
                nextPosRow = posRow + 1;
                nextPosCol = posCol;
                if (nextPosRow &gt;= m || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 2:
                nextPosRow = posRow;
                nextPosCol = posCol - 1;
                if (nextPosCol &lt; 0 || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 3:
                nextPosRow = posRow - 1;
                nextPosCol = posCol;
                if (nextPosRow &lt; 0 || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            }
            if(nextPosValid){
                posRow = nextPosRow;
                posCol = nextPosCol;
            }
            else{
                direction = (direction + 1) % 4;
            }
        }
        return re;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/02/leetcode-53-maximum-subarray/">LeetCode 53. Maximum Subarray</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 2, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>
the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
</blockquote>
<p>题目要求找出最大的连续子序列的和, 首先采用一种分治法. 对于一个数组, 把它中中间分成两半, 和最大的连续子序列可能出现在左半边, 可能出现在右半边, 也有可能出现跨越左右的情况. 对于在左半边或右半边的情况, 可以使用递归缩小问题, 对于跨越左右的情况, 可以使用线性算法来获得结果. 最后返回三个值中的最大值.</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        return maxSub(nums, 0, nums.size());
    }

    int maxSub(vector&lt;int&gt;&amp; nums, int left, int right) {
        if (right - left == 1) {
            return nums[left];
        }
        int leftSum, rightSum, mid = (left + right) / 2;
        leftSum = maxSub(nums, left, mid);
        rightSum = maxSub(nums, mid, right);

        int midLeftSum = 0, midLeftMaxSum = INT_MIN, midRightSum = 0, midRightMaxSum = INT_MIN;
        for (int i = mid - 1; i &gt;= left; i--) {
            midLeftSum += nums[i];
            if (midLeftSum &gt; midLeftMaxSum) midLeftMaxSum = midLeftSum;
        }
        for (int i = mid; i &lt; right; i++) {
            midRightSum += nums[i];
            if (midRightSum &gt; midRightMaxSum) midRightMaxSum = midRightSum;
        }
        int midSum = midRightMaxSum + midLeftMaxSum;

        return max(midSum, max(leftSum, rightSum));
    }
};
</code></pre>
<p>还可以使用动态规划法. 使用<code>dp[i]</code>来表示包含<code>nums[i]</code>的和最大的连续子串的和. 如果<code>dp[i-1]</code>是大于0的, 那么就可以加上<code>dp[i-1]</code>, 因为<code>nums[i]</code>是必须有的. 用另一种方式来说, 这个题目的主要问题在于和最大的连续子串中可能出现负数, 要考虑的是负数及负数之前的子串要不要加到当前子串中来, 而这个判断就是看以该负数结尾的连续子串的和是否大于0, 如果小于0则不能加进来, 大于0则可以.</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; dp(nums.size(), 0);
        int ret = nums[0];
        dp[0] = nums[0];
        for(int i = 1; i &lt; nums.size(); i++){
            dp[i] = dp[i - 1] &gt; 0 ? dp[i - 1] + nums[i] : nums[i];
            if(ret &lt; dp[i])
                ret = dp[i];
        }
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/01/leetcode-52-n-queens-ii/">LeetCode 52. N-Queens II</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 1, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total number of distinct solutions.</p>
</blockquote>
<p>与上一题<a href="http://xiadong.info/2016/08/leetcode-51-n-queens/" target="_blank" rel="noopener">51. N-Queens</a>基本类似, 但是要求返回共有多少个解, 对上一个程序稍加改动即可. <s>当然, 最投机取巧的做法是算出n=1到9的结果然后直接返回</s>.</p>
<pre><code>class Solution {
public:
    int totalNQueens(int n) {
        vector&lt;vector&lt;int&gt;&gt; board(n, vector&lt;int&gt;(n, 0));
        int re = 0;
        NQueensRow(n, board, 0, re);
        return re;
    }
    void NQueensRow(int n, vector&lt;vector&lt;int&gt;&gt; &amp;board, int row, int &amp;re) {
        if (row == n) {
            re++;
            return;
        }
        for (int i = 0; i &lt; n; i++) {
            if (validPos(board, row, i)) {
                board[row][i] = 1;
                NQueensRow(n, board, row + 1, re);
                board[row][i] = 0;
            }
        }
    }

    bool validPos(vector&lt;vector&lt;int&gt;&gt; &amp;board, int x, int y) {
        int n = board.size();
        for (int i = 0; i &lt; n; i++) {
            if (board[x][i] &amp;&amp; i != y)
                return false;
            else if (board[i][y] &amp;&amp; i != x)
                return false;
        }

        int xt, yt;
        for (xt = x - 1, yt = y - 1; xt &gt;= 0 &amp;&amp; yt &gt;= 0; xt--, yt--){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y + 1; xt &lt; n &amp;&amp; yt &lt; n; xt++, yt++) {
            if (board[xt][yt])
                return false;
        }
        for (xt = x - 1, yt = y + 1; xt &gt;= 0 &amp;&amp; yt &lt; n; xt--, yt++){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y - 1; xt &lt; n &amp;&amp; yt &gt;= 0; xt++, yt--) {
            if (board[xt][yt])
                return false;
        }

        return true;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/31/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/33/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
