<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/37/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/37/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script>
  (function(d) {
    var config = {
      kitId: 'tqr0ojg',
      scriptTimeout: 3000,
      async: true
    },
    h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
  })(document);
</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/24/%E5%86%8D%E4%B8%80%E6%AC%A1%E8%A2%ABonenote%E5%87%BB%E9%80%80%E4%BA%86/">再一次被OneNote击退了</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 24, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>印象笔记前段时间调整了收费策略, 免费账户只能同时登录两个设备, 这个就有点不爽了. 而且我也不是重度用户, 觉得并不值得为高级账户付钱, 所以想起了被传的神乎其神的OneNote.</p>
<p>我在装Office的时候一起装了OneNote, 所以直接打开试试, 不得不说功能可以的, 但是同步实在太过于艰难了, 在移动设备上同步更改要等很久很久, 这还是在Wi-Fi下, 在网络不好的时候岂不是完全不能用了? 而且我从印象笔记使用微软官方提供的工具导入笔记, 但是同步的时候却告诉我格式错误. Exo me? 这不是你自己导入的吗? 因为OneNote是基于OndDrive来同步的, 所以OneNote的同步问题就是OneDrive的同步问题, 我在Win10中彻底禁用OneDrive就是因为这个同步功能过于坑爹.</p>
<p>难道我跟微软的东西都是相性不合? 微软做的东西我就没几个是用的舒心的(少数的几个有VS, OutLook邮箱不是客户端, Windows和VS Online的Git服务), 尤其是跟网络沾边的东西, 不过这大概也不全是巨硬的锅, 毕竟我现在还生活在一个不正常国家. 另外, 相比于OneNote的类Word的编辑体验, 我更喜欢纯文本的编辑(比如Markdown), 大概是因为这给了我更大的自主性吧, 而且一些其他的高级功能我也用不上. 我现在还是用Markdown+Git来写东西和同步(BTW, 我的私人Git服务是用的微软的, 不过这该算是Git好用还是难得我用巨硬的东西用的舒服呢), 我喜欢这种每一个环节都可以彻底掌控的感觉, 只不过手机和平板上就没办法了.</p>
<p>最后, 折腾了几个小时OneNote最后还是<strong>浪费时间</strong>. 暂时还是用着印象笔记吧.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/24/leetcode-33-search-in-rotated-sorted-array/">LeetCode 33. Search in Rotated Sorted Array</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 24, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>首先找到有序序列平移了多少位, 然后根据target在哪个范围内使用二分搜索.</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty()) return -1;
        int start = 0, end = nums.size();
        for(int i = 0; i &lt; nums.size() - 1; i++){
            if(nums[i] &gt; nums[i + 1]){
                start = i + 1;
                break;
            }
        }
        if(target &lt; nums[0]){
            return binSearch(nums, start, nums.size(), target);
        }
        else{
            return binSearch(nums, 0, start ? start : nums.size(), target);
        }
    }
    
    int binSearch(vector&lt;int&gt; &amp;nums, int left, int right, int target){
        int low = left, high = right, mid = (low + high) / 2;
        while(low &lt; high){
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] &gt; target)
                high = mid;
            else
                low = mid + 1;
            
            mid = (low + high) / 2;
        }
        return -1;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/24/leetcode-32-longest-valid-parentheses/">LeetCode 32. Longest Valid Parentheses</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 24, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
</blockquote>
<p>求最长的合法括号的长度, 采用先求匹配, 再求长度的方法.</p>
<pre><code>class Solution {
public:
    int longestValidParentheses(string s) {
        if(s.empty()) return 0;
        vector&lt;int&gt; pStack;
        vector&lt;bool&gt; pMatch(s.length(), false);
        int len = s.length();
        for(int i = 0; i &lt; len; i++){
            if(s[i] == '('){
                pStack.push_back(i);
            }
            else if(pStack.empty() || s[pStack.back()] == ')'){
                pStack.push_back(i);
            }
            else{
                pMatch[i] = pMatch[pStack.back()] = true;
                pStack.pop_back();
            }
        }
        int maxLen = 0, curLen = 0;
        for(int i = 0; i &lt; len; i++){
            if(pMatch[i]){
                curLen++;
                if(curLen &gt; maxLen) maxLen = curLen;
            }
            else{
                curLen = 0;
            }
        }
        return maxLen;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/24/leetcode-31-next-permutation/">LeetCode 31. Next Permutation</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 24, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p><code>1,2,3 → 1,3,2</code></p>
<p><code>3,2,1 → 1,2,3</code></p>
<p><code>1,1,5 → 1,5,1</code></p>
</blockquote>
<p>提要求输入一个数组, 返回下一个字典序比它大的排列, 如果不存在比它大的就返回最小的排列. 首先解决判断一个排列是不是最大的问题, 这个问题比较简单: 只要是这个序列是从大到小排列的, 那么它就是最大的序列. 然后再思考比较两个序列大小的问题: 从前到后逐个比较数组中的数字, 出现第一个不相等的位置, 较大的那一个序列就是字典序较大的. 然后再考虑给定一个序列获得它的下一个序列的方法, 因为随着数组下标增加, 该下标位置的数对于整个序列大小的影响是越来越小的, 因此要获得下一个排列, 应该修改尽量靠后位置的元素, 同时这个元素应该变为一个较大的值, 但是这个较大的值要在该元素之后, 因为要是与该位置之前的较大元素交换位置这个排列是变小了; 而且这个变换的目标值应该尽量小, 也就是找到该位置之后比该位置元素大的最小值. 然后是该位置之后的序列要最小, 把它们从小到大排序就可以了.</p>
<p>因此算法如下:</p>
<ul>
<li>判断是不是最大值</li>
<li>从后向前查找第一个在它之后有比它大的值的元素</li>
<li>在这个元素之后找到比它大的最小值</li>
<li>交换之后对于该元素之后的序列从小到大排序</li>
</ul>
<pre><code>class Solution {
public:
    bool isBiggest(vector&lt;int&gt;&amp; nums){
        if(nums.size() &lt;= 1)
            return true;
        for(int i = 1; i &lt; nums.size(); i++){
            if(nums[i] &gt; nums[i - 1])
                return false;
        }
        return true;
    }
    int findCloestBiggerBehind(vector&lt;int&gt;&amp; nums, int pos){
        int index = pos, n = INT_MAX;
        for(int i = pos + 1; i &lt; nums.size(); i++){
            if(nums[i] &gt; nums[pos] &amp;&amp; nums[i] &lt; n){
                index = i;
                n = nums[i];
            }
        }
        return index;
    }
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        if(isBiggest(nums)){
            sort(nums.begin(), nums.end());
            return;
        }
        int maxNum = INT_MIN;
        for(int i = nums.size() - 1; i &gt;= 0; i--){
            if(nums[i] &lt; maxNum){
                int pos = findCloestBiggerBehind(nums, i);
                int t = nums[i];
                nums[i] = nums[pos];
                nums[pos] = t;
                sort(nums.begin() + i + 1, nums.end());
                break;
            }
            maxNum = nums[i];
        }
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/23/leetcode-30-substring-with-concatenation-of-all-words/">LeetCode 30. Substring with Concatenation of All Words</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 23, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p>
<p>For example, given:</p>
<p>s: “barfoothefoobarman”</p>
<p>words: [“foo”, “bar”]</p>
<p>You should return the indices: [0,9].</p>
<p>(order does not matter).</p>
</blockquote>
<p>首先使用暴力法, 将words中的词放入一个哈希表中, 这样可以在常数时间内找到它. 然后用一个双重循环来遍历字符串s.</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; ret;
        int wordsLen = words.size();
        if(wordsLen == 0)
            return ret;
        int wordLen = words[0].length(), sLen = s.length(), totalLen = wordsLen * wordLen;
        
        unordered_map&lt;string, int&gt; wordExistOrig;
        
        for(int i = 0; i &lt; wordsLen; i++){
            if(wordExistOrig.count(words[i])){
                wordExistOrig[words[i]]++;
            }
            else{
                wordExistOrig[words[i]] = 1;
            }
        }
        
        for(int i = 0; i &lt;= sLen - totalLen; i++){
            unordered_map&lt;string, int&gt; wordExist = wordExistOrig;
            bool valid = true;
            for(int j = i; j &lt; totalLen + i; j += wordLen){
                string str = s.substr(j, wordLen);
                if(wordExist.count(str) == 0) {
                    valid = false;
                    break;
                }
                else{
                    wordExist[str]--;
                    if(wordExist[str] &lt; 0){
                        valid = false;
                        break;
                    }
                }
            }
            if(valid) ret.push_back(i);
        }
        
        return ret;
    }
};
</code></pre>
<p>还可以使用一种&quot;滑动窗口&quot;方法, 或者是双指针方法, 思路参考这里: <a href="http://www.2cto.com/kf/201406/311648.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201406/311648.html</a>. 举例来说比如题目中的例子: <code>&quot;barfoothefoobarman&quot;</code>和数组<code>[&quot;foo&quot;, &quot;bar&quot;]</code>, 首先窗口长度为0, 起始位置为0, 窗口长度和起始位置都是以单词长度的整数倍变化的, 这里是3, 首先把第一个单词放进窗口(用<code>{}</code>来表示窗口): <code>{bar}foothefoobarman</code>, 由于<code>foo</code>和<code>bar</code>每个都只出现一次, 所以把<code>bar</code>的剩余次数(这个次数保存在hash表中)减1变为0, 接下来把下一个单词放入窗口: <code>{barfoo}thefoobarman</code>, 同样把<code>foo</code>的次数减1变为0, 这时窗口中已经有两个单词, 与words数组的大小相同, 就可以把当前的窗口起始位置放入结果集中. 接下来是单词<code>the</code>, 这个单词在words数组中没有, 所以窗口可以直接跳过它, 将窗口起始位置越过的<code>bar</code>和<code>foo</code>的允许出现次数加1, 此时窗口位置位于<code>barfoothe{}foobarman</code>, 然后重复这个步骤. 为了不忽略类似<code>abarfoo</code>这种字符串中的结果, 所以要将窗口起始位置从0到单词长度3遍历一次.</p>
<p>代码如下, 运行时间36ms:</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; ret;
        int wordsLen = words.size();
        if (wordsLen == 0)
            return ret;
        int wordLen = words[0].length(), sLen = s.length(), totalLen = wordsLen * wordLen;

        unordered_map&lt;string, int&gt; wordExist;

        for (int i = 0; i &lt; wordsLen; i++) {
            if (wordExist.count(words[i])) {
                wordExist[words[i]]++;
            }
            else {
                wordExist[words[i]] = 1;
            }
        }
        for (int i = 0; i &lt; wordLen; i++) {
            int slideLeft = i, j = i, wordFound = 0;

            while (slideLeft &lt;= sLen - totalLen &amp;&amp; j &lt; sLen) {
                string str = s.substr(j, wordLen);
                if (wordExist.count(str) == 0) {
                    //下一个单词不再words中时将窗口初始位置移到当前之后的位置
                    j += wordLen;
                    for (; slideLeft &lt; j; slideLeft += wordLen) {
                        string toDropStr = s.substr(slideLeft, wordLen);
                        if(wordExist.count(toDropStr))wordExist[toDropStr]++;
                    }
                    //slideLeft = j;
                    wordFound = 0;
                    continue;
                }
                if (wordFound == wordsLen) {
                    //当窗口满的时候丢弃最前端的字符串
                    string toDropStr = s.substr(slideLeft, wordLen);
                    wordExist[toDropStr]++;
                    slideLeft += wordLen;
                    wordFound--;
                }
                wordExist[str]--;
                if (wordExist[str] &lt; 0) {
                    //当前字符串出现次数已满, 要不停的丢弃窗口最前端的字符串直到出现次数为0为止
                    while (wordExist[str] &lt; 0) {
                        string toDropStr = s.substr(slideLeft, wordLen);
                        wordExist[toDropStr]++;
                        slideLeft += wordLen;
                        wordFound--;
                    }
                }
                wordFound++;
                if (wordFound == wordsLen) {//找到一个要求的位置
                    ret.push_back(slideLeft);
                }
                j += wordLen;
            }
            for (; slideLeft &lt; j; slideLeft += wordLen) {
                //恢复每个单词出现的次数
                string toDropStr = s.substr(slideLeft, wordLen);
                if (wordExist.count(toDropStr)) wordExist[toDropStr]++;
            }
        }

        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/23/leetcode-29-divide-two-integers/">LeetCode 29. Divide Two Integers</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 23, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
</blockquote>
<p>不使用乘除和取模运算实现整数除法. 我的实现方法是使用位运算来实现二进制除法, 首先确定结果的符号位后取得被除数与除数的绝对值, 这样就可以只考虑原码不用考虑补码除法. 需要注意的是对于<code>INT_MIN</code>这个值(也就是-2147483648)要特殊处理, 因为它的值是这样的: <code>0x80000000</code>, 也就是只有最高位是1, <code>abs</code>函数无法对这个值取绝对值, 而且可能造成溢出问题.</p>
<p>关于二进制除法可以参考这里: <a href="http://www.tyut.edu.cn/kecheng1/2008/site08/courseware/chapter1/1.2.htm" target="_blank" rel="noopener">http://www.tyut.edu.cn/kecheng1/2008/site08/courseware/chapter1/1.2.htm</a></p>
<blockquote>
<p>二进制数除法与十进制数除法很类似。可先从被除数的最高位开始，将被除数（或中间余数）与除数相比较，若被除数（或中间余数）大于除数，则用被除数（或中间余数）减去除数，商为1，并得相减之后的中间余数，否则商为0。再将被除数的下一位移下补充到中间余数的末位，重复以上过程，就可得到所要求的各位商数和最终的余数。</p>
</blockquote>
<p>代码:</p>
<pre><code>class Solution {
public:
    int divide(int dividend, int divisor) {
        if(divisor == 0) return INT_MAX;
        int sign = (dividend ^ divisor) &amp; 0x80000000 ? -1 : 1;
        int absDividend = abs(dividend), absDivisor = abs(divisor);
        if(dividend == INT_MIN){
            if(divisor == -1) return INT_MAX;
            else absDividend = INT_MIN;
        }
        else{
            if(absDividend &lt; absDivisor) return 0;
        }
        
        return sign * absDivid(absDividend, absDivisor);
    }
    
    int absDivid(unsigned int dividend, unsigned int divisor){
        int mDividend = getBit(dividend, 31), ret = 0;
        for(int i = 31; i &gt;= 0; i--){
            if(mDividend &gt;= divisor){
                ret |= (1 &lt;&lt; i);A
                mDividend = mDividend - divisor;
            }
            if(i != 0){
                mDividend = (mDividend &lt;&lt; 1) + getBit(dividend, i - 1);
            }
        }
        return ret;
    }
    
    int getBit(unsigned int n, int p){
        return n &amp; (1 &lt;&lt; p) ? 1 : 0;
    }
};
</code></pre>
<p>这段代码是默认<code>int</code>类型长度是4个字节.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/22/leetcode-28-implement-strstr/">LeetCode 28. Implement strStr()</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 22, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<p>实现查找子串函数. 使用双重循环.</p>
<pre><code>class Solution {
public:
    int strStr(string haystack, string needle) {
        int haylength = haystack.length(), needlelength = needle.length();
        if(haylength &lt; needlelength) return -1;
        for(int i = 0; i &lt;= haylength - needlelength; i++){
            int j;
            for(j = 0; j &lt; needlelength; j++){
                if(haystack[i + j] != needle[j]) break;
            }
            if(j == needlelength)
                return i;
        }
        
        return -1;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/21/leetcode-376-wiggle-subsequence/">LeetCode 376. Wiggle Subsequence</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 21, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p>
<p>For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p>
<p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>
<p>Examples:</p>
<pre><code>Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
</code></pre>
<p>Follow up:
Can you do it in O(n) time?</p>
</blockquote>
<p>使用动态规划, 只需要保存当前节点与之前一个节点的信息.</p>
<pre><code>class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len &lt;= 2) return len;
        int maxLen = 2, diff = nums[1] - nums[0];
        for(int i = 2; i &lt; len; i++){
            int d = nums[i] - nums[i - 1];
            if(d &amp;&amp; diff &amp;&amp; ((d ^ diff) &amp; 0x80000000)){
                maxLen++;
            }
            if(d != 0){
                diff = d;
            }
        }
        return maxLen;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/21/%E5%85%B3%E4%BA%8E%E7%BB%99%E7%88%B6%E6%AF%8D%E5%88%86%E4%BA%AB%E7%85%A7%E7%89%87/">关于给父母分享照片</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 21, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>关于照片存储备份的问题, 我现在用的Google相册, 虽然按照Google的尿性说不定哪天就给关了, 但是现在用起来还是挺方便的. 但是本来应该是主要功能的照片分享功能却由于那说是不存在但是却是确确实实无处不在的GFW的原因而变得几乎不可用. 尤其是对于我父母这样别说搭梯子, 百度云都不会用(我也不敢给他们用百度)的, 分享照片更是非常麻烦.</p>
<p>我先来总结一下给我父母这样的用户分享照片所需要的服务应该有什么样的特性:</p>
<ul>
<li>访问方便, 便于查找; 也就是说可生成分享链接或者与社交网络绑定</li>
<li>国内访问速度快; 这就没有了用Google相册或者Flickr之类服务的可能</li>
<li>稳定; 谁都不想过一段时间服务就关闭了</li>
<li>要有相册管理功能, 至少缩略图之类应该具备</li>
<li>免费</li>
<li>最好有权限访问控制, 因为与父母分享的照片不少是不想公开的</li>
<li>手机访问支持比较好</li>
</ul>
<p>出于以上的几点, 我首先排除了国内的所有网盘, 因为它们基本都没有相册管理功能; 然后把目标划定在国内大型的互联网企业上. 至于iCloud, 小米, 华为等公司推出的云相册服务因为与要与设备绑定所以也排除. 百度家的东西排除, 网易相册的iOS客户端快三年没有更新了也不知道还能挺多久, 而且初始容量只有1G, 超出后只有每月300M, 有点不太够用. 至于阿里似乎没有推出过这种服务.</p>
<p>剩下的考虑企鹅, 不得不说企鹅的占有率真是厉害, 我父母手机上使用频率最高的应用就是微信了. 所以我一直用朋友圈来给父母分享一些照片. 但是这问题仍然很大, 首先是一次只能选择9张, 我一次上传一千多张根本就是不可能; 其次是微信对于图片压缩地太厉害, 基本上属于放大就不能看; 然后是没有PC端, 电脑上的许多照片不可能都传到手机上. 所以我每次都是选几张照片传上去.</p>
<p>直到昨天, 我突然心血来潮打开了尘封已久的QQ空间, 突然发现QQ空间相册竟然支持原图上传(其实我忘记了它以前支不支持), 并且有了只允许部分好友查看的功能. 突然觉得这就是我想要的与父母分享照片的工具. 父母都有QQ号并且可以通过手机QQ客户端查看; 可以保存原图, 不压缩画质(<strong>实测分辨率不变但是体积减少100-200kB左右, 并且不提供批量下载功能, 加上下载后会丢失EXIF信息, 因此不太适合做照片备份</strong>); 有访问权限控制; 国内访问速度有保障; 可以在PC端上传图片; 服务免费, 我现在有30G容量, 虽然不大, 但也勉强够用(而且不知道它是怎么计算容量的, 我昨天上传了1000+张3M左右的照片原图, 但是现在只显示用了0.4G).</p>
<p>关于安全和隐私, 企鹅虽然不能说很安全, 但是也算是有底线. 而想要隐私的话, 东西还是根本不要放到网上为好.</p>
<p>对我来说, 目前用QQ空间的相册功能算是给父母分享照片的最佳方案了.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-forward-list/">STL容器学习笔记三 - Forward_list</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h1 id="forward-list-前向链表-c-11"><a href="http://www.cplusplus.com/reference/forward_list/forward_list/" target="_blank" rel="noopener">Forward list</a> 前向链表[C++11]</h1>
<p>前向链表是提供常数复杂度的插入删除操作的容器, 它被实现为一个单链接链表.</p>
<p><code>forward_list</code>与<code>list</code>的区别在于前者保存指向每个节点的后一个节点的指针, 而后者保存前后两个节点的指针. <code>forward_list</code>比<code>list</code>稍微高效, 但是缺点在于只能向前遍历.</p>
<p>与其他顺序容器相比主要优点在于在容器任意位置插入, 提取和移动的表现更好. 不足在于不能根据元素在容器中的位置来访问元素.</p>
<p><code>forward_list</code>被设计得非常高效, 它与一个简单的C语言手写单向链表的效率相当. 实际上, <strong>它是唯一一个出于性能考虑而不提供<code>size</code>成员函数的标准容器</strong>.</p>
<h1 id="部分函数">部分函数</h1>
<p>只列举一些我不太熟悉的函数.</p>
<h2 id="构造函数">构造函数</h2>
<h3 id="默认构造函数">默认构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个空容器.
​</p>
<h3 id="填充构造函数">填充构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个大小为n的容器, 如果提供了val, 则n个值都初始化为val.
​</p>
<h3 id="范围构造函数">范围构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">forward_list</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br></pre></td></tr></table></figure>
<p>用<code>[first, last)</code>中的数据初始化.</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst);</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br></pre></td></tr></table></figure>
<h3 id="移动构造函数">移动构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (forward_list&amp;&amp; fwdlst);</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br></pre></td></tr></table></figure>
<p>除非alloc的类型与fwdlst不一致, 否则不会构造任何一个元素, 它们的所有权被直接转移.</p>
<h3 id="初始化列表">初始化列表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span><br><span class="line"><span class="keyword">const</span> allocator_type&amp; alloc = allocator_type());</span><br></pre></td></tr></table></figure>
<h2 id="forward-list-before-begin">forward_list::before___begin</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回指向容器中首个元素之前的元素的迭代器. 该迭代器不能解引用, 主要作为成员函数<code>emplace_after</code>, <code>insert_after</code>, <code>erase_after</code>和<code>splice_after</code>的参数.</p>
<h2 id="forward-list-emplace-after">forward_list::emplace_after</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">emplace_after</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>在position的位置之后插入元素, args为插入的新元素的初始化参数.</p>
<h2 id="forward-list-emplace-front">forward_list::emplace_front</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">emplace_front</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>在容器头部插入新元素, args为插入的新元素的初始化参数.</p>
<h2 id="forward-list-erase-after">forward_list::erase_after</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase_after</span> <span class="params">(const_iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase_after</span> <span class="params">(const_iterator <span class="built_in">position</span>, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>删除容器中position之后的一个元素或者(position, last)范围内的元素.</p>
<h2 id="forward-list-merge">forward_list::merge</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(forward_list&amp; fwdlst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(forward_list&amp;&amp; fwdlst)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">forward_list</span>&amp; <span class="title">fwdlst</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">forward_list</span>&amp;&amp; <span class="title">fwdlst</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure>
<p>根据指定顺序将fwdlst与当前容器合并.</p>
<h2 id="forward-list-remove-if">forward_list::remove_if</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">remove_if</span> (<span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure>
<p>对容器中的每个元素, 执行pred(以<code>pred(*i)</code>的形式), 如果为true则删除该元素.</p>
<p>pred可以为函数指针或者函数对象.</p>
<h2 id="forward-list-sort">forward_list::sort</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span> (<span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure>
<p>排序函数, 该函数是稳定排序. 整个操作不包括任何的元素构造, 析构和复制. 元素只是在容器内移动.</p>
<p><strong>时间复杂度</strong>: NlogN.</p>
<h2 id="forward-list-unique">forward_list::unique</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">unique</span> (<span class="title">BinaryPredicate</span> <span class="title">binary_pred</span>);</span></span><br></pre></td></tr></table></figure>
<p>删除重复元素. <strong>这个操作只会删除与前一个元素相同的元素, 也就是说只能用于已经排序的容器.</strong></p>
<p>第二种形式中的参数binary_pred以<code>binary_pred(*i, *(i - 1))</code>的形式调用, 此函数返回true则认为两个元素相等.</p>
<p>binary_pred可以为函数指针或者函数对象.</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/36/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/38/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Shell32-Natsu" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2025

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
