<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解锁美版Pixel Felica支持</title>
      <link href="/2025/08/11/%E8%A7%A3%E9%94%81%E7%BE%8E%E7%89%88Pixel%20Felica%E6%94%AF%E6%8C%81/"/>
      <url>/2025/08/11/%E8%A7%A3%E9%94%81%E7%BE%8E%E7%89%88Pixel%20Felica%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>众所周知Pixel是搭载了Felica（用于支持日本交通IC卡）的硬件的，可是却通过软件锁区屏蔽了非日本地区销售的型号。我最近尝试了一下通过修改系统<code>devinfo</code>来实现改区，让系统错认为日版机器从而解锁Felica的使用。我使用的是美版Pixel 8a搭载Android 16。</p><p>已知问题：</p><ul><li>需要Root，但是修改完可以刷回原版系统并锁上fastboot</li><li>需要多次刷机，数据无法保留</li><li>相机会有无法关闭的拍照声，这是日版特有的</li></ul><a id="more"></a><h1 id="解锁bootloader">解锁bootloader</h1><ol><li><strong>备份备份备份</strong></li><li>打开开发者模式</li><li>打开USB调试然后连接adb</li><li><code>adb reboot bootloader</code></li><li><code>fastboot flashing unlock</code>。这一步就会清除数据了。</li></ol><h1 id="刷入magisk">刷入Magisk</h1><ol><li>从<a href="https://developers.google.com/android/images" target="_blank" rel="noopener">Google</a>下载对应机型的刷机包，这个不要删了，后面有用。</li><li>解压，找到<code>image-</code>开头的zip再解压一次</li><li>复制其中的<code>boot.img</code>到手机</li><li>安装Magisk App</li><li>在Magisk里面选择Install-&gt;Select and Patch a file</li><li>把patch后的<code>boot.img</code>复制回电脑</li><li>刷入patch后的image</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash init_boot_a magisk_patched.img</span><br><span class="line">fastboot flash init_boot_b magisk_patched.img</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><p><strong>Pixel 8a需要刷入两次</strong>，重启后就完成了root了。</p><h1 id="提取devinfo">提取devinfo</h1><ol><li><code>adb shell</code></li><li><code>su</code></li><li>在手机上授权root</li><li>Dump devinfo分区 <code>dd if=/dev/block/by-name/devinfo of=/sdcard/devinfo.img</code></li><li>Pull dump出来的devinfo分区 <code>adb pull /sdcard/devinfo.img</code></li></ol><h1 id="修改sku">修改SKU</h1><ol><li>使用hex editor打开<code>devinfo.img</code></li><li>找到其中的类似<code>sku GKV4X</code>字符串</li><li>在Google的<a href="https://support.google.com/pixelphone/answer/7158570?hl=en#zippy=%2Cpixel-a" target="_blank" rel="noopener">官方文档</a>中，找到对应的日本地区型号<code>G576D</code>。</li><li>替换sku字符串</li><li>写回修改后的devinfo分区</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">adb push devinfo_modified.img &#x2F;sdcard&#x2F;</span><br><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line"># Verify the partition path first</span><br><span class="line">ls -la &#x2F;dev&#x2F;block&#x2F;by-name&#x2F;devinfo</span><br><span class="line"></span><br><span class="line"># Flash the modified image</span><br><span class="line">dd if&#x3D;&#x2F;sdcard&#x2F;devinfo_modified.img of&#x3D;&#x2F;dev&#x2F;block&#x2F;by-name&#x2F;devinfo</span><br><span class="line"></span><br><span class="line"># Sync and reboot</span><br><span class="line">sync</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="刷回原版系统并lock-bootloader">刷回原版系统并lock bootloader</h1><ol><li>在之前下载解压的刷机包里面运行<code>./flash-all.sh</code>刷回出厂系统。</li><li>重启后确认Magisk已经卸载</li><li>锁上bootloader</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flashing lock</span><br></pre></td></tr></table></figure><h1 id="充值ic卡">充值IC卡</h1><p>重启设置完成后，在Google Wallet里申领一张Suica卡。不要用Pasmo，因为用美国的信用卡无法充值。然后下载Mobile Suica App，在App里绑卡充值，Google Wallet里是充不了的，我用AMex卡成功充值。</p>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 备忘 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/2024/12/05/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>/2024/12/05/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>四年前，我写了<a href="https://blog.xiadong.info/2020/11/07/%E8%81%8A%E8%81%8A%E5%85%A5%E8%81%8C%E8%BF%99%E5%8D%8A%E5%B9%B4/">聊聊入职这半年</a>，四年后，我从Google离职了。距离我加入Google已经过去了1687天，现在的全职员工里，已经有超过50%的人是在我之后入职的了。我在Google工作的时间覆盖了从2020年的疫情初起，到2021年的疯狂扩招，再到2023年的首次裁员。幸运的是，不论是疫情还是裁员，都没有怎么影响到我，我只是日复一日的做着自己的本职工作而已。时间还是不等人的，2024年12月2日，是我在Google的最后一天。四年多的工作时间里，有许多好的方面，也有许多不好的。</p><p>先来说说好的吧。我入职的时候正好赶上疫情开始爆发，股市暴跌，入职时的股票后来涨了许多，虽然不像Meta一样夸张，也还算是体面。Google的食堂在疫情WFH期间一直是关门的，后来开放了我才有机会尝试。说实话，湾区Office的食堂只能是差强人意的水平。相比与亚洲，比如东京、香港的办公室，实在是差距太大。免费的健身房是相当划算的，只要你不在高峰时间去。免费的通勤班车大大节省了我每天上下班的精力，尤其是WFH结束之后需要每周去Office三天。</p><p>Google的Infra也是应有尽有，做为一个写代码的，你基本只需要关心代码，其余的东西基本都有相应的工具。很好的Infra所带来的另一面就是对于整体的把握不足。许多人可能写了很多代码，但是却不知道他们是怎么部署到Borg上的，也不需要去了解Spanner和Colossus是怎么设计和工作的。虽然Google的绝大部分代码都是对所有员工开放的，但是能够达到这种主观能动性的人恐怕还是凤毛麟角。</p><p>代码和文档质量我想Google也还是在线的。只不过这就导致了很多时候动作不够快，Google在设计文档所花的时间可能比其他大厂都要高不少。但是实际实现的时候遇到的问题在设计阶段很难完全考虑到，所以即使有详尽的设计文档，在开发阶段所节省的时间也仍然有限。而开发阶段所做出的变动基本上很少会再反馈回设计文档了，很多时候设计文档和最终的代码是有一定脱节的，不过有总比没有好。</p><p>Google的更大问题是中上层领导们的眼光和能力不足，某种程度上是一种大公司病。一些想法听起来很好，但是没有考虑真正实施起来的难度，又因为想做的东西太多（也是为了抢scope）导致每个项目的人手都处于不足状态。即使现在员工数量相比与我入职的时候已经翻了一番，所有的组始终处于人手不足的状态。归根结底是中层想升职必须要展示自己领导的东西多，但是实际上又没有那么多有意义的项目，所以都在拍脑袋想一些听起来很不错但是做起来一地鸡毛的事情。Google其实不需要那么多Director和Manager，甚至不需要那么多VP，不过只要盈利继续强劲，这个状态也就还能继续下去。</p><p>Mid-level的IC我觉得现在不是加入Google的好时机，很难找到有意义又能出成绩的项目。如果有的话，早就被老人占了。对于Entry level和NG来说，Google依然是一个好地方，至少在你感觉出不对劲之前你都可以工作地很舒服，同时还能获得足够的成长。</p><p>不管怎么说，我花了十年时间圆了我少年时期的梦，别说一个懵懂的高中生，即使在我读本科的时候我也没有想到过我能真的成为一名Googler，不过完成了的梦想已经成为了过去，现在是时候走出下一步了。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 博客 </tag>
            
            <tag> Google </tag>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1358. Number of Substrings Containing All Three Characters</title>
      <link href="/2024/05/21/LeetCode%201358.%20Number%20of%20Substrings%20Containing%20All%20Three%20Characters/"/>
      <url>/2024/05/21/LeetCode%201358.%20Number%20of%20Substrings%20Containing%20All%20Three%20Characters/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given a string s consisting only of characters a, b and c.</p><p>Return the number of substrings containing at least one occurrence of all these characters a, b and c.</p><p>Example 1:</p><p>Input: s = &quot;abcabc&quot;Output: 10Explanation: The substrings containing at least one occurrence of the characters a, b and c are “abc”, “abca”, “abcab”, “abcabc”, “bca”, “bcab”, “bcabc”, “cab”, “cabc” and “abc” (again).Example 2:</p><p>Input: s = &quot;aaacb&quot;Output: 3Explanation: The substrings containing at least one occurrence of the characters a, b and c are “aaacb”, “aacb” and “acb”.Example 3:</p><p>Input: s = &quot;abc&quot;Output: 1</p><p>Constraints:</p><p>3 &lt;= s.length &lt;= 5 x 10^4s only consists of a, b or c characters.</p></blockquote><p>基本思路是对于每一个字符，如果想要找到以它为结尾的符合要求的子串，那么我们只要找到距离它最远的另外两个字符的出现位置。这样我们就找到了一个每个字符都至少包含一次的最短子串，以这个子串结尾的所有子串都符合要求。使用前缀表记录字符上一次出现的位置就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">prefix</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">        prefix[<span class="number">0</span>][s[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            prefix[i] = prefix[i - <span class="number">1</span>];</span><br><span class="line">            prefix[i][s[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">            <span class="keyword">int</span> minIdx = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == s[i] - <span class="string">'a'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                minIdx = min(prefix[i][j], minIdx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minIdx == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res += (minIdx + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一个野路子算法，不使用前缀表，而是使用二分搜索来找到每个字符都至少包含一次的最短子串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cnt[i] = cnt[i - <span class="number">1</span>];</span><br><span class="line">            cnt[i][s[i - <span class="number">1</span>] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i][<span class="number">0</span>] &amp;&amp; cnt[i][<span class="number">1</span>] &amp;&amp; cnt[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = bshelper(cnt, i);</span><br><span class="line">                res += (t + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bshelper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cnt, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = end, mid;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                tmp[i] = cnt[end][i] - cnt[mid][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp[<span class="number">0</span>] &amp;&amp; tmp[<span class="number">1</span>] &amp;&amp; tmp[<span class="number">2</span>]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见了，所有的EVA</title>
      <link href="/2021/08/15/%E5%86%8D%E8%A7%81%E4%BA%86%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84EVA/"/>
      <url>/2021/08/15/%E5%86%8D%E8%A7%81%E4%BA%86%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84EVA/</url>
      
        <content type="html"><![CDATA[<p><i>さらば、全てのエヴァンゲリオン</i></p><p><strong>「所有的故事都必将迎来终结。」</strong></p><a id="more"></a><p>说起来我还从来没有在博客里写过ACG相关的东西，可能除了一两篇跟舰C相关的吧。毕竟本来这个博客应该是一个技术博客的（笑）。但是前天晚上 Amazon Prime Video 上线了《EVA新剧场版：终》，我还是想写点什么。</p><p>我的记忆中我小的时候是在电视上看过EVA的，虽然我当时不知道它的译名是《天鹰战士》，也完全不记得我在哪个频道看到的，而且不知道是什么原因，刻在我记忆里的片段跟后来我仔细看了正片以后注意到的片段似乎有一点对不上。我记得特别清楚的一个是插入栓，我当时应该是把它跟EVA的外接电源插头弄混淆了，一直以为那是插头，但是我很肯定的是里面有人并且充满了液体（后来才知道是LCL），而且有一个片段是有人用手打开插入栓的舱门救人（碇司令：有人Q我？）。另一个就是初号机生吃了三号机的名场面了，这东西真的是我的童年阴影之一，给我幼小的心灵留下了深深的震撼……</p><p>后来上了大学重新看起动画，终于完整的看了一遍旧TV和旧剧场版（EOE），以及《序》《破》《Q》三部新剧场版。总结起来就是一句话：我看不懂，但我深受震撼🤣。再后来补了一些设定、看了一些解析、读了一遍漫画，终于还是多多少少理解了旧 TV + EOE 想要讲的故事。但是新剧场版当时只出到《Q》，《Q》还又一个个的都是谜语人，看了以后完全不知道剧情是什么，就想等着看终，没想到一等就是七年。</p><p>EVA 有许许多多值得说的地方，比如设定、制作、人物塑造、以及痞子的报复社会行为等等，但是新剧场版是什么地方让我百看不厌呢？我首先能想到的就是痞子对于机械结构的执着以及对机械设定的考究。《序》里面美里带着真嗣看着夕阳下第三新东京市缓缓升上地面的镜头，以及第五使徒来袭的时候城市再次进入地下，被防御武器（多炮塔神教www）所替代的镜头简直就是我中二幻想的具现，这种整齐、巨大，精巧并且复杂的机械结构真的是太令我着迷了，试问哪个男孩能抵挡住这种诱惑呢？《序》中接下来的屋岛作战也是经典中的经典，详尽的工程机械刻画、电缆铺设的细节、成排的变压器运输镜头还有工作人员一本正经的各种汇报台词真的是中二度拉满。</p><p>「中二」就是我想说的第二点了，毕竟第一次看EVA的人大概都会觉得这是个普通少年驾驶巨大机器人拯救世界的故事吧<del>（少年啊快去创造奇迹）</del>，虽然实际上不是，既不是普通少年，驾驶的也不是机器人，更没有拯救世界（好吧《终》里还是救了的），但是不妨碍EVA从头到尾的中二气息外漏。《破》中「把绫波……还回来！」的台词要是在现实中说出来真的是尬到原地爆炸，但是配合真嗣觉醒和初号机暴走锤爆第十使徒<del>小力</del>就是让我热血沸腾。在《Q》中抛出的太多谜团和剧情线大改导致观众和真嗣一样云里雾里一直吃瘪，导致这种中二感几乎没有了，我想这也是为什么《Q》没有前两部「好看」的原因之一吧。真嗣真的是从头到尾都是懵逼的状态（我也是），还眼看着<del>爱人</del>基友被字面意义上的爆头，一直自闭到《终》里也怪不得他。</p><p>EVA的暗线和设定从来都是藏着掖着的，这也是很多考据党的精神食粮。EVA是什么？Seele的计划是什么？碇司令的计划与之有什么区别？<del>碇司令到底有没有计划？</del>冲击的条件是什么，怎么突然就开始冲击了？Guf 之门又是什么鬼？很多问题我到现在都还没有搞明白。剧中人物说的话可能本来就是谎话，也可能是被谎话所欺骗，所以想要知道这些基本都要靠自己的眼睛和脑子了。看完了《终》，有的疑惑我以为被解开了，可是又多了更多的疑惑，本来我还想写写的，但是想来想去这已经有点像是在做语文阅读理解了，也许痞子自己对这些问题都没有很好的答案，而且结束就是结束了，感觉再去分析什么显得有点「空気が読めない」。</p><p>谈论EVA的时候人们总是提到上世纪90年代日本的社会背景以及EVA对当时迷茫的年轻人的内心刻画，独自反抗自己所不能理解的大人、社会、世界的无力感，没有希望，想要逃避的自闭感。我不在那个环境下成长，也几乎没有过「反抗世界」这种逆反的想法，也几乎不曾迷茫过，更没有过与世界「和解」，所以当人们说《终》没有「EVA那味儿」的时候，我是不怎么有切身的体会的。《Q》整体的压抑和故意的谜团渲染让我不喜，《终》里痞子大发慈悲先是花了几十分钟来描写一个末世中的世外桃源，想要传达生命、母性、包容、顽强得活下去等等的心情几乎溢出屏幕，我不得不承认也许EOE那种充满了绝望的故事更有艺术感甚至哲学感，但我还是更喜欢温柔的故事。</p><p>在最后各个角色依次「补完」，所有人都得到了救赎和拯救，碇司令跟话唠一样喋喋不休地说他有多需要唯的时候，我有一瞬间觉得痞子是真的老了累了，他不再是那个在作品中狠狠地讥讽报复观众的痞子了，也许他选择了与他的世界「和解」，他也不用再跟《EVA》这一部作品相爱相杀了。</p><p>是时候跟所有的EVA说再见了。</p><p><img src="https://user-images.githubusercontent.com/5417586/129487989-b6c867af-709d-48fe-93ce-83bcdc88a9c5.png" alt="image"></p><p align="center">《终》里我最爱的一幕</p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Anime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云函数+SSH Reverse Tunnel实现Socks代理</title>
      <link href="/2021/08/12/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%87%BD%E6%95%B0+SSH%20Reverse%20Tunnel%E5%AE%9E%E7%8E%B0Socks%E4%BB%A3%E7%90%86/"/>
      <url>/2021/08/12/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%87%BD%E6%95%B0+SSH%20Reverse%20Tunnel%E5%AE%9E%E7%8E%B0Socks%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这次试验受到油猴脚本“解除B站区域限制”所使用的在阿里云用<a href="https://github.com/ipcjs/bilibili-helper/blob/user.js/packages/unblock-area-limit/README.md#3-%E9%98%BF%E9%87%8C%E4%BA%91%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">云函数搭建B站反向代理</a>、以及<a href="https://github.com/dan-v/awslambdaproxy" target="_blank" rel="noopener">awslambdaproxy</a>项目启发，使用阿里云函数+Custom Container实现Socks代理。</p><p>本文默认读者已经有一定的公有云平台/阿里云以及Linux系统和Docker使用经验，并且已经拥有可以部署云函数的阿里云账号。本文不会详细解释阿里云的使用细节，关于如何部署/管理阿里云资源请参考阿里云文档。</p><p><strong>注意⚠️：笔者在此只简述工作原理及搭建简易POC，不保证任何可靠性及安全性。鉴于笔者的水平有限，文中不免出现错误，请不吝指出。</strong></p><p><strong>使用阿里云免费额度一定要注意，由于本文所述的云函数几乎是一直运行，因此极其容易被反薅羊毛。</strong></p><a id="more"></a><h1 id="how-does-it-work">How does it work?</h1><h2 id="直接搭建正向代理的局限性">直接搭建正向代理的局限性</h2><p>一般的代理工具的工作方式一般被称为“正向代理”（有别于“反向代理”），在不考虑某些特殊的隐蔽流量的需求的情况下，常用的正向代理方式有http/https/socks。使用云函数搭建http代理非常简单，基本是开箱即用，因为http代理作为一个中间人可以完全获得http请求的内容，然后根据header中host的值直接进行转发。https代理，或者是基于http的隧道，都需要代理服务器支持<code>connect</code>方法，而云函数运行在一个类似API网关的反向代理后面，该API网关与云函数之间不使用标准http请求通信，也同样不转发<code>connect</code>请求，因此难以实现此种代理。</p><p>由于云函数所在的网络结构，类似于一个位于防火墙或者NAT网关之后的主机：可以与外部建立TCP连接但是不能监听外部连接请求。因此在这种情况下常用的反向SSH隧道便可以派上用场。</p><h2 id="使用反向ssh隧道">使用反向SSH隧道</h2><p>SSH客户端和服务端提供了方便的端口转发（port forwarding）功能，利用其提供的反向隧道（reverse SSH tunnel）功能，我们可以在云函数所在的主机（下称主机A）向一台外部主机（下称主机B）发起SSH连接并使用<a href="https://man.openbsd.org/ssh#R~5" target="_blank" rel="noopener"><code>-R</code></a>选项来把远程主机的端口转发到本地主机端口，同时在本地使用SSH启动一个socks5代理，把端口转发的本地端口设置为socks代理的监听端口，这样就实现了<code>外部主机B &lt;--&gt; 外部主机B隧道监听端口 &lt;--&gt; 云函数主机A本地端口 &lt;--&gt; 云函数主机A socks 代理</code>的代理转发流程。</p><h1 id="how-to-do-it">How to do it?</h1><h2 id="准备工作">准备工作</h2><ul><li>阿里云账号</li><li>一台有公网IP的主机（主机B），笔者使用的是一台VPS</li></ul><h2 id="步骤">步骤</h2><h3 id="在主机a上启动ssh-server">在主机A上启动SSH Server</h3><p>出于安全和方便起见，笔者没有直接使用VPS上运行的SSH Server，而是选择启动一个Docker容器专门用于SSH Server，基于以下两点理由：</p><ol><li>VPS使用公钥认证，从主机A登录到主机B需要在主机A上存储私钥，作为云服务商，相信阿里云提供了相应的密钥管理服务，但是因为笔者使用的是阿里云免费额度所以想要尽量减少使用的资源。</li><li>Docker提供的相对隔离的环境对部署来说更加方便。</li></ol><p>笔者使用Docker镜像<code>linuxserver/openssh-server</code>启动SSH Server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line"> --name=openssh-server \</span><br><span class="line"> -e PUID=1000 \</span><br><span class="line"> -e PGID=1000 \</span><br><span class="line"> -p 10241:2222 \</span><br><span class="line"> -e PASSWORD_ACCESS=<span class="literal">true</span> \</span><br><span class="line"> -e USER_PASSWORD=<span class="variable">$&#123;PASSWORD&#125;</span> \</span><br><span class="line"> -e USER_NAME=proxy \</span><br><span class="line"> --restart unless-stopped \</span><br><span class="line"> -v $(<span class="built_in">pwd</span>)/88-enable_tunnels:/etc/cont-init.d/88-enable_tunnels \</span><br><span class="line"> linuxserver/openssh-server</span><br></pre></td></tr></table></figure><p><code>linuxserver/openssh-server</code>镜像默认监听<code>2222</code>端口，笔者选择了对外暴露<code>10241</code>端口。注意选项<code>-v $(pwd)/88-enable_tunnels:/etc/cont-init.d/88-enable_tunnels</code>，该init脚本是为了在openssh-server中启用隧道功能，该功能默认是禁用的。<code>88-enable_tunnels</code>文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/with-contenv bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Enabling Tunneling</span><br><span class="line">sed -i <span class="string">'s@#PermitTunnel no@PermitTunnel yes@'</span> /etc/ssh/sshd_config</span><br><span class="line">sed -i <span class="string">'s@AllowTcpForwarding no@AllowTcpForwarding yes@'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>注意笔者在本文中全部使用密码验证，如上所述这主要是为了方便起见，如果需要更高安全性可以换成密钥认证。</p><h3 id="构建云函数custom-container">构建云函数Custom Container</h3><p>阿里云函数支持自定义Docker Image，这给了我们极大的方便。</p><p>首先我们要基于<code>alpine</code>镜像，安装必要的程序：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add openssh sshpass</span></span><br></pre></td></tr></table></figure><p>其中<code>sshpass</code>是为了能够在脚本中传入SSH密码。</p><p>接下来修改镜像中的<code>sshd_config</code>文件，之所以要修改是因为我们除了要在容器中连接主机B以外，还要创建一个本地的socks连接，所以主机A也要能够接受SSH连接。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/#PasswordAuthentication/PasswordAuthentication/'</span> /etc/ssh/sshd_config</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/#PermitEmptyPasswords\ no/PermitEmptyPasswords\ yes/'</span> /etc/ssh/sshd_config</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/#PermitRootLogin\ prohibit-password/PermitRootLogin\ yes/'</span> /etc/ssh/sshd_config</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/AllowTcpForwarding\ no/AllowTcpForwarding\ yes/'</span> /etc/ssh/sshd_config</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ssh-keygen -A</span></span><br></pre></td></tr></table></figure><p>然后我们就可以开始建立SSH连接了，在镜像中加入一个脚本<code>start-tunnel.sh</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动sshd</span></span><br><span class="line">/usr/sbin/sshd</span><br><span class="line"></span><br><span class="line">PASSWORD=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">REMOTE_HOST=<span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line">REMOTE_PORT=<span class="string">"<span class="variable">$3</span>"</span></span><br><span class="line">SLEEP_SEC=<span class="string">"<span class="variable">$4</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建本地socks代理</span></span><br><span class="line">sshpass \</span><br><span class="line"> -p <span class="string">'haha'</span> \</span><br><span class="line"> sh -c <span class="string">'ssh -f -N -D 54321 -4 \</span></span><br><span class="line"><span class="string"> -o GlobalKnownHostsFile=/dev/null \</span></span><br><span class="line"><span class="string"> -o UserKnownHostsFile=/dev/null \</span></span><br><span class="line"><span class="string"> -o StrictHostKeyChecking=no \</span></span><br><span class="line"><span class="string"> 127.0.0.1 &amp;&amp; \</span></span><br><span class="line"><span class="string"> sleep .1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建反向隧道</span></span><br><span class="line">sshpass \</span><br><span class="line"> -p <span class="string">"<span class="variable">$PASSWORD</span>"</span> \</span><br><span class="line"> sh -c <span class="string">"ssh \</span></span><br><span class="line"><span class="string"> -o GlobalKnownHostsFile=/dev/null \</span></span><br><span class="line"><span class="string"> -o UserKnownHostsFile=/dev/null \</span></span><br><span class="line"><span class="string"> -o StrictHostKeyChecking=no \</span></span><br><span class="line"><span class="string"> <span class="variable">$REMOTE_HOST</span> \</span></span><br><span class="line"><span class="string"> -p <span class="variable">$REMOTE_PORT</span> \</span></span><br><span class="line"><span class="string"> -R 127.0.0.1:6666:127.0.0.1:54321 \</span></span><br><span class="line"><span class="string"> -f -N &amp;&amp; \</span></span><br><span class="line"><span class="string"> sleep .1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持运行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sleeping <span class="variable">$SLEEP_SEC</span>..."</span></span><br><span class="line">sleep <span class="variable">$SLEEP_SEC</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"exit"</span></span><br></pre></td></tr></table></figure><p>可以看到，主机B的<code>6666</code>端口被转发到了主机A的<code>54321</code>端口，而主机A的<code>54321</code>端口就是socks代理的监听端口。关于脚本中的ssh命令选项在此就不赘述了。不过有一点需要注意的是，使用<code>sshpass</code>搭配ssh端口转发会导致ssh client开启转发后立刻退出，因此使用<code>sh -c ... sleep .1</code>来避免这个问题。</p><p>把这个文件复制到镜像中：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> start-tunnel.sh .</span></span><br></pre></td></tr></table></figure><p>接下来是最后一个问题，阿里云函数在运行Custom Container的时候，默认通过<code>9000</code>端口传入参数，因为我们的镜像也必须有一个HTTP服务器监听<code>9000</code>端口。好在用Go语言写起来很容易：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"net/http"</span></span><br><span class="line"> <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 请求返回后这次函数调用就会视为结束，因此要block在这里以保持容器运行</span></span><br><span class="line"> time.Sleep(<span class="number">595</span>*time.Second)</span><br><span class="line"> fmt.Fprintf(w, <span class="string">"hello\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> http.HandleFunc(<span class="string">"/"</span>, hello)</span><br><span class="line"> http.ListenAndServe(<span class="string">":9000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Dockerfile中构建<code>server</code>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>-alpine AS build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> server.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> GO111MODULE=off go build -o /server</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build /server /server</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9000</span></span><br></pre></td></tr></table></figure><p>最后运行<code>docker build</code>和<code>docker push</code>把镜像push到阿里云的镜像仓库。</p><h3 id="创建云函数">创建云函数</h3><p>在阿里云的控制台创建一个云函数并选择使用我们push的Custom Container，选择128MB内存的弹性实例（实际上笔者实测容器只用了&lt;10MB的内存）。在<code>Command</code>中填上<code>[&quot;sh&quot;, &quot;start-tunnel.sh&quot;, &quot;PASSWORD&quot;, &quot;user@Host_A_IP&quot;, &quot;Host_A_Port&quot;, &quot;TIMEOUT&quot;]</code>。<code>TIMEOUT</code>要配合函数配置，以及之前脚本中的时间（笔者选择10min）。然后创建一个每10min运行一次的定时触发器。这样就可以让容器<strong>几乎</strong>一直运行。</p><h3 id="正向隧道">正向隧道</h3><p>完成了以上步骤，主机B已经可以使用主机A作为代理了。作为客户端，我们还要创建一个客户端主机（C）到主机B的正向隧道，以便在本地使用socks代理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> -L 0.0.0.0:8086:127.0.0.1:6666 -N</span><br></pre></td></tr></table></figure><p>这条命令把主机C的8086端口转发到了主机B的6666端口，这样我们就可以在本地使用主机C的8086端口作为socks代理了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -x <span class="string">'socks5://localhost:8086'</span> https://api.myip.com</span><br><span class="line">&#123;<span class="string">"ip"</span>:<span class="string">"47.102.125.165"</span>,<span class="string">"country"</span>:<span class="string">"China"</span>,<span class="string">"cc"</span>:<span class="string">"CN"</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> 工具 </tag>
            
            <tag> Docker </tag>
            
            <tag> Go </tag>
            
            <tag> 网络 </tag>
            
            <tag> serverless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近读的几本书</title>
      <link href="/2021/07/17/%E6%9C%80%E8%BF%91%E8%AF%BB%E7%9A%84%E5%87%A0%E6%9C%AC%E4%B9%A6/"/>
      <url>/2021/07/17/%E6%9C%80%E8%BF%91%E8%AF%BB%E7%9A%84%E5%87%A0%E6%9C%AC%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>Note：全是剧透</p><a id="more"></a><p>几个月前开始看奎因的书，看完了《罗马帽子之谜》。我本来是冲着“奎因讲逻辑”这条去看的，但是第一我记不住里面的人物名字，第二虽然讲逻辑但是读起来还是有点枯燥的。整本书围绕着一个我觉得并不刺激的毒杀案展开，也没有什么猎奇悬疑的元素，甚至也没有冒险元素，是一本味儿特别正的本格推理。看到第二本《法国粉末之谜》的时候，我实在是受不了又长又难记的人名（偏偏记不住人名破案逻辑就无从谈起）就搁置下了。</p><p>再之前我把高罗佩的《大唐狄公案》读完了，说实话推理味儿有点淡，但是至少还有点冒险元素，读起来也还算是不错。</p><p>还有乱步，我之前读了他的《怪盗二十面相》，是明智小五郎系列的一本，但不是第一本。不知道是不是翻译的原因，乱步给我的感觉就是相当忽视周围环境的描写，语言非常平铺直叙而且口语化，其中还夹杂着第三人称故事讲述者的自言自语，看起来像说书。然后看了他的《两分铜币》和《人间椅子》这两个著名短篇，《人间椅子》的构思还是挺有意思的，至少我现在读来还有新意，但是我怀疑它到底能不能被归类到推理小说的范畴。《两分铜币》就比较一般了，毕竟是处女作，而且也是100年前的小说了。上周我读了另一本明智小五郎系列的《魔术师》。整体的气氛渲染还是可以的，但是重点的密室杀人就草草带过了，门上有可以供小孩出入的气窗这种把戏已经被用烂了，身份交换这种戏码也很容易猜到。说是计划了40年的复仇，但是整个事件看起来并没有特别精心策划的感觉。我读完之后觉得最不合理的就是这个所谓的计划了40年的复仇，几乎全部依赖某个人在某时的偶然想法。比如被害家族的女儿，就算她本来是凶手的亲生女儿，但是她也是从小就在养父母家长大，被一个都不知道是真是假的“亲生父亲”忽悠两句就能痛下杀手？一个还没有结婚的年轻大小姐，竟然能收养一个比她小不了多少的养子，还能把他训练成莫得感情的杀手？还有她大哥，不知道为啥跑到钟楼上去，不知道为啥脑子抽了听见声音就要把头从钟楼表盘上的洞伸出去，还就是打死不缩回来。对了，利用钟楼的表盘和指针杀人我记得岛田庄司也玩过，不知道是不是从这来的灵感。我还是更喜欢横沟正史的风格，既有气氛，又有逻辑，有时间把金田一系列再看一遍。</p><p>这周看了京极夏彦的《姑获鸟之夏》。开篇第一章先看了半个小时京极堂关于灵魂，意识和大脑的哲学陈述，差点没坚持下去。不过我已经大概能猜到后面的故事肯定少不了幻觉，失忆和精神分裂，结果证明我猜的一点不错……除了冗长的哲学对话，京极堂在第一章关于“妖怪”这个可以说是全书、乃至全系列主题的阐述我觉得还是挺有意思的。我一向是对鬼怪妖这种怪力乱神嗤之以鼻，认为这些都是人类脆弱精神的牵强附会，抑或是对无法解释现象的自我安慰，是绝对不存在的。但是即使从自然科学的角度不存在，从民俗学或是社会心理的角度来看，人们一直以来都愿意相信怪谈却是实实在在的，这种大众心理的潜移默化的影响，是不是就让“妖怪”真的出现了呢？说起来《女神异闻录5》讲的好像也就是这样的故事，简直是梦幻联动！不过这也不奇怪，P系列的“Persona”这个词就是来自荣格，P5中印象空间也是来自荣格的集体潜意识。京极堂也是引用了荣格和佛洛依德的理论来讲述他关于灵魂和意识的看法（虽然我不敢苟同）。</p><p>过了第一章，事件正式开始的时候，我就觉得不大对了。谜面还是相当引人入胜的，丈夫从密室中消失了，妻子怀孕二十多个月还没有生产，妇产科医院有婴儿失踪，还牵扯到十几年前秘密的真相，可以说是吊足了我的胃口。但是坑爹的是，作为第一人称讲述者，并且跟事件有千丝万缕的联系的主角关口，竟然失！忆！了！！而且是心因性失忆，自己都不知道的那种！看起来的感觉是这样的：我好像有印象；我好像想起来了；不对，我没想起来；啊我又想起来了！但我就是不告诉你这个读书的。关口你把情书送错人了我拿jo指头都能想到，你对女主接下来干了啥导致你失忆我拿另一个jo指头也能想到，但你就是在那傻了吧唧的跟丢了魂似的脑子里只想着女主。还有你都结婚了，你在那追着女主屁股后面拼命献殷勤是想干啥？真是又蠢又渣！</p><p>接下来的故事就更加匪夷所思了，失踪的人根本没有失踪，就一直躺在屋子里，躺了快两年，那么为什么一直没有被发现呢？因为所有进过屋子的人，都看！不！见！尸！体！真是见了鬼了，幻觉好用也不是这么用的吧，虽然所有人都有精神创伤但是也不能这么巧都看不见吧？哪怕有一个正常人搂一眼就啥事儿没有了，结果尸体就被捅着刀躺在地上，还尸蜡化了。还有死者的妻子，假性怀孕还能真把肚子弄大了？更扯的是最后还能炸开，嗯？炸开？？我严重怀疑叙述者关口不仅失忆而且脑子有病。主要凶手女主不仅有遗传病，还在小时候被性侵，然后生了畸形孩子被当面杀死然后彻底崩溃变成三重精神分裂（说着都觉得太惨了）。总之所有的事情都归结到遗传病、封建迷信和精，神，分，裂；再加上不知所谓的香艳描写（日本小说感觉总是会有这些），国产恐怖惊悚片是不是就是从这找的灵感？</p><p>京极夏彦本来应该是是新本格派，但是看完《姑获鸟之夏》我真的觉得这不应该是变格吗？这个案子也实在是太扯了而且几乎没有什么推理元素……不过这个系列我还是会看下去的，至少文学性还是挺好的，下一本应该是《魍魉之匣》，还改编了动画呢。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 推理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日本游记（三）</title>
      <link href="/2020/12/14/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/12/14/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>终于来到最后一篇了，之前的两篇：</p><ul><li><a href="https://blog.xiadong.info/2020/11/19/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">日本游记（一）</a></li><li><a href="https://blog.xiadong.info/2020/11/23/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">日本游记（二）</a></li></ul><p>说来也很巧，我第三次无日本是在我敲下这些字的时候的整整一年前，不多也不少。这次去主要是带着父母去关西玩一趟，所以有很多地方都是我第一次去的时候就已经去过的，这一篇我打算只写一写我之前没去过的地方，最后再聊一聊我接下来想去的地方。</p><a id="more"></a><h1 id="姬路：姬路城">姬路：姬路城</h1><p>我想去姬路城的原因是姬路城是文明5的奇观之一，而且其在现实中的所在地也离大阪不远。从大阪坐电车往西约一小时就到姬路市了，从车站出来远远地就可以看到姬路城天守阁，步行大约十分钟就可以走到姬路城脚下。<img src="https://user-images.githubusercontent.com/5417586/104962172-bad8dc80-598c-11eb-9de5-67d863dc3787.jpg" alt="_DSF5124"></p><p>姬路城建于越700年前，其大天守是目前日本保存最完好的，而且也是可以进去参观的。大阪城的我没进去，但是姬路城还是有点兴趣的。从最底下走到顶层再走下来，全程大约花了30～40分钟。</p><p><img src="https://user-images.githubusercontent.com/5417586/104962604-9fba9c80-598d-11eb-8771-49259edc47e0.jpg" alt="_DSF5010"><img src="https://user-images.githubusercontent.com/5417586/104962612-a6491400-598d-11eb-8f61-ad1e188b5c88.jpg" alt="_DSF5019"></p><p align="center">天守阁的窗</p><p>除了大天守以外，还可以进入<a href="https://ja.wikipedia.org/wiki/%E5%A7%AB%E8%B7%AF%E5%9F%8E#%E8%A5%BF%E3%81%AE%E4%B8%B8" target="_blank" rel="noopener">西の丸</a>参观。</p><p>姬路城旁边有一个名叫“好古園”的日式庭院，我记得姬路城的门票是包含好古园的，而且里面的景色还是非常值得一看的。</p><p><img src="https://user-images.githubusercontent.com/5417586/104963230-eb217a80-598e-11eb-974f-0295233dab42.jpg" alt="_DSF5111"><img src="https://user-images.githubusercontent.com/5417586/104963236-ee1c6b00-598e-11eb-8757-5d0d3b434bd2.jpg" alt="_DSF5078"></p><p>姬路城附近的一栋楼的楼顶有一个<a href="https://goo.gl/maps/wKZw6Xsx9E3CoyEf7" target="_blank" rel="noopener">展望台</a>，这里可以看到姬路城的全景。</p><p><img src="https://user-images.githubusercontent.com/5417586/104963463-769b0b80-598f-11eb-9f56-c3bc29e07232.jpg" alt="IMG_2125"></p><p align="center">透过展望台上的望远镜拍的大天守</p><h1 id="京都：贵船神社">京都：贵船神社</h1><p>贵船神社在不少京都旅游的文章中被大力推荐，第二次来京都我就决定去看看。贵船神社在京都市北部的山里面，可以坐公交车也可以坐电车。我还是比较推荐坐电车，搭睿山电铁鞍马线到贵船口站下车，如果正值红叶季的话，这条线路还会穿过一条名叫“红叶隧道”著名赏枫景点。在贵船口站还要再坐一趟巴士继续向北一段距离，然后再走一小段路才能到。</p><p>贵船神社面积很小，跟伏见稻荷大社这种完全没法比，爬上两边布满红色灯笼的石梯进入神社，一共没有几间房子，走几步路就出来了。虽然神社很小，但是历史却非常的悠久，以至于创立时间不可考，传说是在公元五世纪建立的。</p><p>贵船神社的抽签占卜很有特色，是抽出签后放到水中才会显现出文字，有兴趣的一定要试一试。</p><p><img src="https://user-images.githubusercontent.com/5417586/104964885-4012c000-5992-11eb-9afa-20ab9c21cf7f.jpg" alt="_DSF5185"></p><h1 id="京都：京都动画">京都：京都动画</h1><p>我这次去日本是在京都动画2019年的事件过后半年，当时的现场还没有被拆除，仍在进行现场处理工作。我专程去了第一工作室的现场看了看，实在没有心情驻足观望所以又匆匆离去，直到现在我仍然对于那里发生的惨剧耿耿于怀。</p><h1 id="滋贺：丰乡小学校">滋贺：丰乡小学校</h1><p><a href="https://goo.gl/maps/RwFiQ7xcD4FujbSe8" target="_blank" rel="noopener">丰乡小学校</a>是滋贺县一个偏僻的乡下学校，从京都站要换乘一次，其中第二程电车的车站甚至不能用IC卡，总时间一个半小时。我之所以去这么一个偏远的乡下地方是因为丰乡小学校是《轻音少女》的取景地，那里现在还保留着轻音部房间的布置。</p><p><img src="https://user-images.githubusercontent.com/5417586/104965652-05118c00-5994-11eb-91b4-5a29425dc357.jpg" alt="IMG_2152"></p><p align="center">丰乡站站牌</p><p>从车站出来直接往右边走约10分钟，穿过“真·农村”就到了。</p><p><img src="https://user-images.githubusercontent.com/5417586/104965739-3d18cf00-5994-11eb-8ef4-1add2ddbe1e2.jpg" alt="IMG_2154"></p><p align="center">熟悉的校舍</p><p><img src="https://user-images.githubusercontent.com/5417586/104967176-93d3d800-5997-11eb-9629-2c60f068d5c3.jpg" alt="IMG_2157"></p><p align="center"><del>蓝白碗</del></p><p><img src="https://user-images.githubusercontent.com/5417586/104967311-e9a88000-5997-11eb-8f38-a9620e3db8bd.jpg" alt="IMG_2165"></p><p align="center">梦开始的地方</p><p><img src="https://user-images.githubusercontent.com/5417586/104967372-09d83f00-5998-11eb-9e19-44b852613f80.jpg" alt="IMG_2168"><img src="https://user-images.githubusercontent.com/5417586/104967446-3724ed00-5998-11eb-81e0-ddd09912eedf.jpg" alt="IMG_2181"></p><p align="center">我的眼泪差点没止住，仿佛她们真的在这里</p><p>喜欢京都动画/轻音的一定一定要抽时间来一次，绝对不虚此行。</p><h1 id="广岛：严岛神社-大和博物馆">广岛：严岛神社，大和博物馆</h1><p>这次我还去了广岛，但是最该去的原爆纪念馆我没有去，而是去了<a href="https://zh.wikipedia.org/wiki/%E4%B8%A5%E5%B2%9B%E7%A5%9E%E7%A4%BE" target="_blank" rel="noopener">严岛神社</a>。本来是想去拍那个著名的海上的大鸟居的，但是可惜去的时候鸟居在维修，被包的严严实实，只在神社里转了一圈便返回广岛然后去吴市的大和博物馆了。</p><p>吴市是海军重镇，二战前的“吴海军工厂”便是建在这里，而吴海军工厂就是建造大和号的地方，所以在吴市会有一个大和博物馆也就不足为奇了。</p><p><img src="https://user-images.githubusercontent.com/5417586/104968187-03e35d80-599a-11eb-89ea-de8c32663f35.jpg" alt="IMG_2207"><img src="https://user-images.githubusercontent.com/5417586/104968260-38571980-599a-11eb-8977-d587ee4f16fc.jpg" alt="IMG_2236"></p><p align="center">1/10的大和模型</p><h1 id="the-next-step：环游日本">The Next Step：环游日本</h1><p>基本上日本我最想去的地方都已经去过了，但是还有一些要么太小众，要么太偏僻的地方还在我的必去清单里，对于我的下一次日本旅行，现在的打算是呆的时间久一点，大概一个月左右，然后从东京出发顺时针来一趟环本州岛旅行，顺便去一下九州和北海道。但是现在的这个疫情情况也不知道要等到什么时候了。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日本游记（二）</title>
      <link href="/2020/11/23/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/11/23/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.xiadong.info/2020/11/19/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">上篇文章</a>写了我在16年春天第一次去日本自由行的经历，这一篇我打算写一写我19年春天第二次去的时候的事。时隔三年，仍然是樱花季，只不过这次是从旧金山出发，单程飞机就要10个多小时，远没有从中国飞去方便，而且机票价格也不便宜，樱花季往返机票价格接近2000美元。不过这次我已经开始拿工资了，可支配资金还是绰绰有余的。</p><a id="more"></a><h1 id="东京">东京</h1><h2 id="千鸟渊">千鸟渊</h2><p>从旧金山起飞的飞机，大多数还是飞东京的，这次我是3月31日下午抵达东京，等到宾馆的时候已经是夜幕降临了。因为时差的关系，我第二天早上五点钟就起床了。第一站是紧邻皇居西墙的千鸟渊。千鸟渊也是一个久负盛名的赏樱之地，其本身则是皇居护城河的一段。</p><p><img src="https://user-images.githubusercontent.com/5417586/100050859-3b38f200-2dcf-11eb-85e7-a9597db6b543.jpg" alt="18E524AB-0CBC-4E9E-A11C-A203398F5A52-4891-000002804FDA905D"></p><p align="center">清晨的樱花</p><p><img src="https://user-images.githubusercontent.com/5417586/100051008-9834a800-2dcf-11eb-9c1b-f0ed2381b93e.jpg" alt="89CA3517-DD0C-4C4F-8433-7915EBCBB790-4891-0000028084A772AA-2"></p><p align="center">从千鸟渊公园可以看到不远处的国会议事堂</p><p>千鸟渊沿着皇居的城墙一直往南走的话，会看到皇居的南门，樱田门。樱田门的对面就是东京警视厅的总部，也是名侦探柯南中经常出现的地标性建筑。我在岛田庄司的吉敷竹史系列的某一本小说中知道东京警视厅就坐落在皇居樱田门的对面，因此也有用樱田门来代指警视厅的说法。</p><p>还有值得一提的是，当天正好是新年号发表的日子，还是挺巧的。</p><p><img src="https://user-images.githubusercontent.com/5417586/100051536-fca43700-2dd0-11eb-8be1-711604fa099e.jpg" alt="DAA93AA8-3753-4727-9228-EBCF466D372C-4891-0000028131DBE9F2"></p><p align="center">皇居乾門外的首都高速公路出口</p><p>皇居的正北方，千鸟渊旁边有一个北の丸公园，<a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E6%AD%A6%E9%81%93%E9%A4%A8" target="_blank" rel="noopener">日本武道馆</a>便坐落其中。武道馆因为有很多世界顶尖乐队及歌手在此演出过而闻名于世，也是《轻音少女》轻音部众人的目标。</p><p><img src="https://user-images.githubusercontent.com/5417586/100052277-72f56900-2dd2-11eb-9876-81ac40d930c6.jpg" alt="C27C6DF7-B8AA-4D47-B79B-1FAE80F26D07-4891-00000281F139B63A"></p><p align="center">田安门</p><h2 id="上野公园">上野公园</h2><p>上野公园，全名上野恩赐公园，位于离皇居不远的台东区上野。上野公园是日本第一座公园，其中的上野动物园也是日本最古老的动物园，从中国来的大熊猫便是在这里。不过我去上野公园是为了赏樱的，所以没有去动物园。</p><p>当天是周一，也不是假日，但是上野公园内也是游人如织，路两边的樱花树下有很多野餐垫，不过我去的时候时间尚早，只有三三两两的占位子的人。</p><p><img src="https://user-images.githubusercontent.com/5417586/100054063-2dd33600-2dd6-11eb-9927-94900b74d66a.jpg" alt="8BCE7190-B783-4DC5-89C0-A09FF5BA329C-4891-00000282BFB2B3D3-2"></p><p align="center">上野公园的樱花</p><p>上野公园里有一个小湖名曰不忍池，其中有一条长堤，两边都是樱花垂柳，非常好看。</p><p><img src="https://user-images.githubusercontent.com/5417586/100054392-cb2e6a00-2dd6-11eb-82d2-3ed64b26812e.png" alt="image"></p><p align="center">不忍池</p><h2 id="巡礼">巡礼</h2><p>离开上野公园，我的下一站是《路人女主的养成方法》中出现的<a href="https://www.google.com/maps/place/Nozokizaka/@35.7180327,139.6720461,12.79z/data=!4m9!1m3!11m2!2s1U7rf1qF38OvHqnmFn5N5tyqD3Io!3e3!3m4!1s0x0:0xe876c38539a950e2!8m2!3d35.7176325!4d139.7139072" target="_blank" rel="noopener">のぞき坂</a></p><p><img src="https://user-images.githubusercontent.com/5417586/100054986-f6fe1f80-2dd7-11eb-87e7-ec9c29d34fa4.jpg" alt="IMG_0165"></p><p align="center">安艺伦也就是在这里遇到加藤惠</p><p>这个坡给我的感觉非常陡，伦也能骑车骑上这个坡是真的强。</p><p>下一个地方则是一个叫“<a href="https://www.google.com/maps/place/' target="_blank" rel="noopener"'Your+Name'+Stairwell+(Suga+Shrine+Otoko-zaka+Stairs)'/@35.6852376,139.7207547,17z/data=!4m5!3m4!1s0x60188c8d7293e86d:0x555933e43119edf8!8m2!3d35.6852376!4d139.7229434">須賀神社女坂</a>”的地方。名字没有听说过不要紧，我放张图你可能就知道了。</p><p><img src="https://user-images.githubusercontent.com/5417586/100055423-af2bc800-2dd8-11eb-8734-8896d93478b9.jpg" alt="DDF72CF0-85F2-4891-88C7-FF2933271E65-4891-00000283742C73D6"></p><p><img src="https://user-images.githubusercontent.com/5417586/100055471-c10d6b00-2dd8-11eb-9c94-ce04e2c153e6.png" alt="image"></p><p align="center"><del>完全一致</del></p><p>虽然右边的墙被改掉了，整体高度也有变化，但是还是能看出来的。Google Map上这个楼梯的名字已经是“你的名字楼梯”了……</p><h2 id="目黑川">目黑川</h2><p><a href="https://blog.xiadong.info/2020/11/19/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/#%E7%9B%AE%E9%BB%91%E5%B7%9D">上一次</a>已经来过一次目黑川，这一次来的时候樱花似乎比上一次还要更盛一点，不少河道上樱花铺满了天空。</p><div class='lr_embed' style='position: relative; padding-bottom: 50%; height: 0; overflow: hidden;'><iframe id='iframe' src='https://lightroom.adobe.com/embed/shares/91b3bc6b56b04915a510ea860e589d14/slideshow?background_color=%232D2D2D&color=%23999999' frameborder='0'style='width:100%; height:100%; position: absolute; top:0; left:0;' ></iframe></div><p>只不过人还是一样的多。</p><h2 id="东京塔">东京塔</h2><p>上次来东京的时候我去了东京塔脚下，但是离得太近了反而看不太清楚，这次在东京我去了位于六本木的六本木之丘（六本木ヒルズ）。这是一栋摩天大楼，但是可以登上露天楼顶，可以俯瞰东京夜景，同时也把东京塔尽收眼底。本来在下午就是阴沉沉的天空在夜幕降临的时候飘起了雨滴，但是不是很大所以顶楼天台还是开放的。要注意的是出于安全原因顶楼室外是不能使用三脚架的，所以要长快门拍夜景的就靠一双铁手吧。次一层的展望台可以隔着玻璃欣赏夜景，没有风吹雨打。</p><p><img src="https://user-images.githubusercontent.com/5417586/100480900-737a5200-30a7-11eb-8e7b-b7751acc1ad0.jpg" alt="B9024F08-A4D0-48DE-83E2-70F978745F17-5016-000002AFF582DAED-2"></p><p align="center">在下雨，有点雾蒙蒙的，姑且看看</p><p><img src="https://user-images.githubusercontent.com/5417586/100481157-277bdd00-30a8-11eb-8884-29ce16a8d2aa.jpg" alt="67C35014-8E02-4381-AD03-689DFD354646-5016-000002B048204F64-2"></p><p align="center">脚下灯火通明</p><p><img src="https://user-images.githubusercontent.com/5417586/100481222-4c705000-30a8-11eb-9244-c9c4bef99b6c.jpg" alt="AE6100D3-D7C5-49A8-AE4E-428413757B2B-5016-000002B076474BBB-2"></p><p align="center">新宿方向，远处的建筑已经在雨雾之中，中间的楼就是言叶之庭中经常出现的NTTドコモ代々木ビル</p><h2 id="横须贺">横须贺</h2><p>第二天我的第一个目的地是横须贺。横须贺位于神奈川县东南的三浦半岛，扼住东京湾进出要道。横须贺在日本海军的历史上是个非常重要的城市，横须贺海军工厂从明治初期开始便负责建造军舰，慢慢发展成为一个军港城市，19世纪末设立横须贺镇守府，简称横镇。你游第一个服务器便是横镇。曾经参加过日俄海战的联合舰队旗舰三笠号，也是当时东乡平八郎的座舰，现在作为纪念舰还完整保存在横须贺。横须贺现在也是海自和美国第七舰队的司令部所在地。</p><p>从东京站或者品川乘横须贺线可以直达横须贺。我先去了三笠参观了一番，作为100多年前的战列舰，三笠给我的视觉冲击力没有洛杉矶的衣阿华号战列舰大，主要是体型不够大，主炮口径也只有30.5cm。（大和：食我46大根啦</p><p><img src="https://user-images.githubusercontent.com/5417586/100483299-42048500-30ad-11eb-8fd8-5f34d85c6778.png" alt="image"></p><p align="center">东乡名言</p><p>中午吃了你游用来骗钱的海军咖喱😾。</p><p>吃完饭我就去了一个叫做“YOKOSUKA軍港めぐり”的乘船环游军港的项目，就是搭船在港口里绕一圈，还会对停泊在港口里的军舰有一些介绍（日语）。当时在港里的大船有海自的出云号直升机<del>航母</del>护卫舰，里根号核动力航母。对于舰C玩家这个旅游项目还是很值得一去的。</p><p>军港周边的公园里有一些原帝国海军有关的东西，比如长门和山城的纪念碑以及陆奥的四号炮塔（不是三号！）上的一个主炮炮管等等……</p><h2 id="镰仓">镰仓</h2><p>从横须贺返回东京的路上路过镰仓。镰仓对于ACG爱好者来说最先想到的是《灌篮高手》中出现的那个道口，以及近几年的《青春猪头少年不会梦见兔女郎学姐》中的圣地江之岛。镰仓本身也是一个历史名城，12到14世纪的时候，幕府便是坐落在镰仓，因此那个时代被称为镰仓幕府时代。</p><p>不过因为时间的关系（只有几个小时）我没有怎么去镰仓的古迹，也没有去江之岛（要走不少路）。只在《灌篮高手》的道口附近转了转，那里拍照的人非常多，几乎不可能拍出没有人的还原度比较高的照片。</p><h1 id="河口湖">河口湖</h1><p>河口湖是富士五湖之一（河口湖，本栖湖，山中湖，精进湖和西湖），不仅可以在比较合适的距离欣赏富士山，而且可以乘“富士回游”号特急列车从新宿直达。我当时没注意富士回游号是全车指定席，只买了自由席车票，结果当天满座，我只能在车厢一头的过道里席地而坐。</p><p><img src="https://user-images.githubusercontent.com/5417586/100484945-3025e080-30b3-11eb-8886-bd9cb2781cd5.jpg" alt="CBCAF82E-1C25-4911-BBFD-98A8BDC55C75-7742-000003A977514BF3-2"></p><p align="center">这个位置构图很独特</p><p><img src="https://user-images.githubusercontent.com/5417586/100484987-4e8bdc00-30b3-11eb-907d-30349b5f2da8.jpg" alt="B2C32D32-A900-4838-88A2-01F933A22C78-7742-000003A9C131E210-2"></p><p align="center">新倉山浅間公園</p><p>我住的地方就在河口湖站出来不远的地方，然后在附近找了一家自行车行租了一天的自行车。河口湖还是比较大的，靠步行不仅浪费时间还浪费体力，所以自行车是比较好的选择。</p><p><img src="https://user-images.githubusercontent.com/5417586/100485218-19cc5480-30b4-11eb-8caa-f295c21a5434.jpg" alt="8B2D79E5-41FD-4ED7-B413-3700B6183AE4-7742-000003AAA2E66511"><img src="https://user-images.githubusercontent.com/5417586/100485221-1b961800-30b4-11eb-8e8a-71bef0152de3.jpg" alt="B0471B17-A4C5-4D47-9794-911540D1F1C2-7742-000003AA6C4A516A"></p><p align="center">那天天气很好</p><p>河口湖边上有一个很有名的地方，名叫青木原树海（青木ヶ原樹海），也就是传说中的自杀圣地，据说每年都会在其中发现两位数以上，甚至三位数的自杀遗体。对于这种现象一种比较广为接受的解释是在这个风景优美，人迹罕至的地方自杀可以很长时间不被发现，也不容易给别人添麻烦。选择卧轨会导致列车延误，跳楼会给附近人造成影响，在家吃安眠药也会给房东/家人带来麻烦，所以在森林里悄悄结束生命才会在轻生群体中流行起来。可以，这很日本。</p><p>我在到河口湖的那天下午骑车绕湖大半周。第二天早上则骑车去了十公里外的西湖边（跟杭州的西湖没有关系）。</p><p>下午则还了车，上了去往岐阜县高山市的巴士。</p><h1 id="高山市">高山市</h1><p>我在上一篇中说过，高山市是我一直想要去看一看的城市，它在岐阜县的群山之中，是个货真价实的山中小城。高山市旁边是飞弹市，常与高山市合称“飞弹高山”。飞弹市原本就以“飞弹牛”（一个和牛种类）出名，在《你的名字》中，宫水三叶的老家糸守町便是在飞弹市（但是飞弹市没有湖，湖的原型是在长野县的诹访湖）。</p><p>高山市地处群山之中，从关东地区过去有几种选择：一是走东海道新干线到名古屋，再换高山本线到高山。二是走北陆新干线到富山市再转高山本线。三是乘巴士，新宿和河口湖都有巴士往返高山。如果选择铁路的话，必须搭新干线否则路上可能就要耗费一天多，考虑到从河口湖出发，要坐新干线必须返回东京，巴士便是最适合我的选择了。</p><p>飞弹高山并不是非常热门的旅游目的地，多数游客也会选择铁路交通，从河口湖过去的游客就更少了，所以我很幸运的成为了那一趟巴士的唯一一个乘客（也不知道这条线路怎么盈利）。大概五个小时车程只有我和司机相顾无言（互相听不懂，司机的英语非常蹩脚且日式）。这条巴士路线会路过我刚才提到的诹访湖，然后翻过日本中部的群山。在靠近山巅的地方，有一个温泉乡叫“平汤温泉”，那附近的积雪在四月份都还没有融化，我一直想体验一下在雪中泡露天温泉来着，可惜这次只是过客。山路本就蜿蜒再加上日本道路又窄，我不止一次惊叹于司机的精湛车技，有的地方的转弯半径都小于大巴车的长度，甚至没法一次转过去……</p><p>我是不喜欢坐大巴的，尤其是山路上的大巴。上次坐大巴从成都到九寨沟我坐了整整八个小时，在最后的山路上被晃吐了。但是这次的日本大巴体验还是不错的，至少我没有感到任何不适。</p><p>抵达高山的时候太阳已经下山了，巴士站就在火车站旁边还是挺方便的，我订的旅馆也在火车站对面。这还是我第一次到一个不是很热门，或者说对于外国游客不是很热门的地方，跟东京，京都这种城市比起来，高山站前的这家旅馆设施明显要老旧一些，外国游客也不多。</p><p>我还能记起在旅馆安顿下来之后我下楼去找吃的，信步走进了附近一家小店，里面的白炽灯的暖光很昏暗但是顾客却很多，是那种一看就是当地人去的店。我点了一份炒面，量大又便宜，是我在日本少有的感到经济实惠的一餐。</p><p>第二天一早我就开始了我的圣地巡礼，一大早去的就是“宫川朝市”。宫川朝市的地点在一条叫“宫川”的河川旁边而得名，其形式类似于赶集（如果你知道什么是赶集的话）或者ACG作品中的夏日祭典，道路两旁都是小摊和店铺，卖的东西主要是手工艺品和瓜果蔬菜。</p><p><img src="https://user-images.githubusercontent.com/5417586/100490951-d209f500-30d4-11eb-9cd2-94964b2534ca.jpg" alt="FB47D28D-25A0-4BF7-9386-ABAABFB1AE29-11020-000005444EEBCCF9"></p><p align="center">宫川朝市</p><p><img src="https://user-images.githubusercontent.com/5417586/100491138-32e5fd00-30d6-11eb-99d9-a1d842a63937.png" alt="image"></p><p align="center">一毛一样</p><p>接着沿着宫川一直往北走，就差不多可以走到“岐阜県立斐太高等学校“ 门口，这所高中就是《冰菓》中神山高等学校的原型。</p><p><img src="https://user-images.githubusercontent.com/5417586/100491026-81df6280-30d5-11eb-84e9-52e56fb29326.png" alt="image"></p><p align="center">非常还原</p><p>当天不是休息日，在学校门口转来转去感觉不太好，我只拍了几张照片就掉头往回走了。走回宫川朝市后继续沿着河往南走两个路口，左手边有一家叫做“バグ・パイプ”的咖啡店。这里就是吃蛋挞和折棒<del>约会</del>喝咖啡的地方。</p><p><img src="https://user-images.githubusercontent.com/5417586/100491203-97a15780-30d6-11eb-916d-932e564d0f6a.png" alt="image"></p><p align="center">店外</p><p><img src="https://user-images.githubusercontent.com/5417586/100491182-7fc9d380-30d6-11eb-82a9-fb15642b977e.jpg" alt="IMG_0907"></p><p align="center">店内，<del>差一位美少女圆满</del></p><p>在收银台旁边还能看到一些冰菓的宣传材料，不过动画的巡礼地图已经没有了，只有真人版的。我也没太好意思问老板还有没有。</p><p><img src="https://user-images.githubusercontent.com/5417586/100491271-15fdf980-30d7-11eb-9c2a-4498d69cf941.png" alt="image"></p><p align="center">冰菓OP画面</p><p>从咖啡店东边有一片古街，这些是从江户时代至今保存了数百年的建筑，值得一看。</p><p>再往东走一点则是冰菓中神山市图书馆的原型：高山市图书馆。</p><p><img src="https://user-images.githubusercontent.com/5417586/100491752-0bddfa00-30db-11eb-939c-db2c6f5674b9.png" alt="image"></p><p align="center">又名焕章馆</p><p>从高山市搭乘高山本线的列车向北便是飞弹市，而往南的下一站叫做飞弹一之宫（飛騨一ノ宮），这个车站所在的小镇便是冰菓最后一集中女儿节祭典（现实中的<a href="http://hidamiya.com/event/event01" target="_blank" rel="noopener">生雏祭，生きびな祭り</a>）的舞台。祭典是由<a href="https://www.google.com/maps/place/Minashi+Shrine/@36.0869165,137.2425257,16.19z/data=!4m5!3m4!1s0x6002bbd2eba3d99b:0x39a6477c8ca89745!8m2!3d36.0853323!4d137.2518539" target="_blank" rel="noopener">水无神社</a>在每年4月3日举行，我很不巧的错过了，下次有机会再说吧。动画中出现的那一大株樱花树名叫<a href="https://ja.wikipedia.org/wiki/%E8%87%A5%E9%BE%8D%E6%A1%9C" target="_blank" rel="noopener">卧龙樱（臥龍桜）</a>，据说已经有1100岁了。可惜的是卧龙樱在4月中旬才开花，所以动画里在四月三号罕见地遇到满开的樱花才会有人设计故意绕远路。</p><h2 id="白川乡">白川乡</h2><p>下午我搭车去参观了一下<a href="https://zh.wikipedia.org/wiki/%E7%99%BD%E5%B7%9D%E9%84%89" target="_blank" rel="noopener">白川乡</a>。白川乡因为独特的<a href="https://zh.wikipedia.org/wiki/%E5%90%88%E6%8E%8C%E9%80%A0" target="_blank" rel="noopener">合掌造</a>民居而被登录为世界遗产。合掌造就是茅草屋顶很高很尖的房子，因为房梁很高，所以人字形的屋顶坡度很陡，在下雪的时候不易积雪。</p><p><img src="https://user-images.githubusercontent.com/5417586/100493088-6a5da500-30e8-11eb-8fff-1064a3e6faf7.jpg" alt="3A522D60-1FC8-4879-95F4-B7FAB6BC7D44-11020-000005452F47217F"></p><p align="center">白川乡</p><p>我觉得白川乡最佳的拍照时间是冬天下雪的时候，我记得看到过不少积雪很厚的时候的白川乡照片，很有童话氛围。</p><p>不少人的心理阴影，《寒蝉鸣泣之时》的原作游戏和动画的背景都是取材自白川乡。日本的这种山中闭塞的小村落感觉确实很契合惊悚恐怖故事，无处可逃的压抑感很容易引起共鸣。现实中这种小村庄也确实发生过不少可怕的故事，比如<a href="https://zh.wikipedia.org/wiki/%E6%B4%A5%E5%B1%B1%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">津山事件</a>；再比如<a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E6%AF%9B%E5%88%A5%E6%A3%95%E7%86%8A%E8%A5%B2%E6%93%8A%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">三毛别棕熊袭击事件</a>，不过津山事件的发生地在冈山县，而棕熊袭击事件则是在北海道。</p><h1 id="尾声">尾声</h1><p>最后我从高山市搭高山本线到名古屋然后转乘东海道新干线返回东京。高山本线是我第一次见到在国内很少见的柴油动车，虽然是分散动力的动车组，但是每节动车都是柴油动力的。也许是山中的铁路电气化成本太高得不偿失吧。回到东京后就是逛了两天秋叶原，然后我的第二次日本之行就结束了。</p><p>最后我想引用一下千反田在冰菓最后一集最后的话：</p><p align="center"><q>这里是我的故乡<br>只有水和土地<br>人们也在渐渐老去，失去活力<br>我并不觉得这里是最美的地方<br>也不觉得这里充满了可能性<br>但是……<br>我想向折木同学介绍这里</q></p><p>可能正是因为这席话，我才会跨越千山万水来到这里吧。</p><p>缘，妙不可言。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日本游记（一）</title>
      <link href="/2020/11/19/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/11/19/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>我现在坐在湾区的家里，本来如果没有这次疫情的话，我此时此刻应该在准备飞往洛杉矶然后转机飞往东京开始我的两周红叶+北海道游，而不是坐在这里敲键盘。这应该是我第四次去日本旅游了，本来计划的好好的，前三次有两次是樱花季去的，一次是冬天，这次就挑红叶季去，哪知人算不如天算，疫情没完没了，再好的计划也都泡了汤。我也只能百无聊赖地呆在家里等着下周感恩节放假，顶多在湾区附近开车逛逛。既然如此，那我就趁着这个时间回忆一下前几次的旅行，权当望梅止渴吧。</p><p>写着写着发现要写完三次游记实在是太长，所以会分成几篇文章。</p><p>⚠️<strong>大量图片预警</strong></p><a id="more"></a><h1 id="缘起">缘起</h1><p>说到我为什么想要去日本旅游，那不用问当然是我看的日本动画和漫画的影响。</p><p>我好像还没有怎么跟人提起过我的入坑作，那就在这里顺便说一下吧。2014年的六月末，那是成都闷热的夏天，大二下学期的期末考试也接近尾声，但是因为还有小学期要在学校呆到七月中下旬，所以我就只能在宿舍里想办法打发时间。不知道是什么原因，我鬼使神差地开始用iPad看起一本叫《只有神知道的世界》（简称《神知》）的漫画，结果一下子就看得入迷了。在此之前日本漫画我只看过火影这种热血大长篇，校园恋爱后宫类只看过一些以前很流行的网络YY小说，漫画这种形式还真的没有看过，再加上若木民喜老贼的画风还挺对我的胃口，让我看完了漫画后仍然意犹未尽。于是一番搜索发现《神知》是有动画的，所以又看完了三季动画。看完后还是没有尽兴，于是慢慢打开了新世界的大门。我还记得《神知》之后我看的是《约会大作战》第一季，也是我在B站看的第一部番。万幸《约战》第一季还算是制作精良，让我有动力继续找其他的番来看，进而一发不可收拾彻底入坑。</p><p>而真正勾起我想去日本看看的强烈欲望的，是在一个多月后在我看《冰菓》的时候。《冰菓》当时是真的惊艳到了我，在那以前我从没有想到过动画可以做到如此精致细腻。它第一次让我强烈感受到了日本这个国家的美，让我迫切地想要亲自踏上那片土地，用我的双脚和双眼去感受孕育出那些动画和那些人的地方。《冰菓》也第一次让我知道“圣地巡礼”这种事物的存在，也让我记住了故事发生的地方：岐阜县高山市。</p><p><img src="https://user-images.githubusercontent.com/5417586/99625353-ed924300-29e4-11eb-9fb2-5748e125aa95.jpg" alt="DHR Hakugetsu Hyouka 01 BDrip 1080P AVC_Hi10P_FLAC_AAC mkv_20140812_173707 289"></p><p align="center">千反田俺の嫁</p><p>后来我看过的越来越多的动画和漫画，都一直在加强我的这一愿望。与此同时，我在2015年的时候赚到了一些外快，算一算正好够我去趟日本来一次自由行。于是我毫不犹豫地把旅行时间定在了2016年的三月底，去看一看享有盛誉的樱花季🌸。</p><h1 id="初访霓虹">初访霓虹</h1><p>护照，签证这些东西就不再赘述了。2016年3月24日的清晨，我登上了上海飞往大阪的飞机，这是我第一次出国旅行，也算是第一次自己一个人进行长途旅行，当时兴奋的心情从那以后我都再也没有感受到过，即使是后来第一次飞纽约的时候也没有。</p><h2 id="大阪">大阪</h2><p>第一站是飞机的目的地，大阪。其实大阪对我来说没有什么特别想去的地方，也就是大阪城需要打打卡。即使是大阪城，也不是丰臣秀吉所建的那一个了，而是昭和初年用钢筋水泥重建的。</p><p><img src="https://user-images.githubusercontent.com/5417586/99628105-54662b00-29ea-11eb-8209-a2e043aa6288.jpg" alt="IMG_1712-3"></p><p align="center">通天阁</p><p>刚到的那天晚上我就到住处附近的通天阁和道顿堀转了转，虽说有不少餐馆，但是一是我本来就不贪图口腹之欲，二来我实在是没有勇气一个人走进去看着日语菜单出糗。只在小摊买了两盒章鱼烧和一个鲷鱼烧果腹。即使是街边小吃，我也是第一次见到鲷鱼烧这种只在动画里见过的食物。</p><p><img src="https://user-images.githubusercontent.com/5417586/99628975-15d17000-29ec-11eb-8ba1-820984215e77.jpg" alt="IMG_1783-2"></p><p align="center">大阪城天守阁</p><p>说实话像我这样不买东西也不爱美食的人在大阪没有什么好去的地方。对我来说，大阪这个商业城市还是少了点“味道”吧。我想也是因为类似的原因，即使关西作为修学旅行的常见目的地，奈良和京都的存在感要比关西最大城市大阪要高得多了。</p><h2 id="奈良">奈良</h2><p>动画中的奈良总是随着它最有代表性的鹿出现。但是作为1000多年前做过日本首都的城市，它的历史和文化底蕴也足以让我把它列在必去清单中。</p><p>从大阪天王寺坐有直达电车，一小时左右就到了奈良。步行游览奈良公园，春日大社和东大寺的话大半天时间就够了。出了JR奈良站，去游客中心拿一张地图，然后沿着车站门前的大路笔直地往前走就会穿过奈良公园。奈良公园有大片大片的鹿群，我猜这里就是《妄想学生会》中的天草会长被鹿推倒（不是）的地方。</p><p><img src="https://user-images.githubusercontent.com/5417586/99702144-4ea03200-2a4a-11eb-882c-fc1b857742aa.jpg" alt="DSCF0506-2"></p><p align="center">奈良的鹿</p><p>穿过奈良公园就是<a href="https://zh.wikipedia.org/wiki/%E6%98%A5%E6%97%A5%E5%A4%A7%E7%A4%BE" target="_blank" rel="noopener">春日大社</a>。春日大社建于1300多年前，是奈良时代遗存至今的古迹。日本的神社、佛寺，即使是有着货真价实的千年历史，从表面上却也看不出非常明显的时间摧残的痕迹，我想这得益于不间断的修葺和维护，真正的忒修斯之船。</p><p>从春日大社出来沿着右手边的路向东大寺走，会路过<a href="https://zh.wikipedia.org/wiki/%E8%8B%A5%E8%8D%89%E5%B1%B1" target="_blank" rel="noopener">若草山</a>。这里是奈良少有的可以登高远眺的地方。</p><p><img src="https://user-images.githubusercontent.com/5417586/99702910-45fc2b80-2a4b-11eb-860c-c75ac5156ca0.png" alt="image"></p><p align="center">奈良市全景</p><p>下山后我接着往前走，便会到<a href="https://zh.wikipedia.org/wiki/%E4%B8%9C%E5%A4%A7%E5%AF%BA" target="_blank" rel="noopener">东大寺</a>。东大寺距今也有近1300年的历史，后来毁于动乱，现在的东大寺大佛殿是300年前重建的，其最负盛名的便是高15米的大佛。</p><p>我当时走了这一圈已经是下午四五点钟了，没有时间再去奈良附近的寺庙，于是便打道回大阪府。后来2019年时与父母再访奈良，基本上是走了一模一样的路线，但是最后还是剩了一些时间又再多去了一个<a href="https://zh.wikipedia.org/wiki/%E5%94%90%E6%8B%9B%E6%8F%90%E5%AF%BA" target="_blank" rel="noopener">唐招提寺</a>。</p><p>中国所保留下来的唐代建筑几近于零，在奈良却还能体会到一丝唐风。</p><p><img src="https://user-images.githubusercontent.com/5417586/99704462-4b5a7580-2a4d-11eb-9151-554f2e4a7dd0.png" alt="image"></p><p align="center">东大寺大佛殿</p><h2 id="京都">京都</h2><p>京都应该是日本最热门的旅游目的地之一了吧。在动画中，除了舞台就设在京都的动画（比如《四叠半神话大系》，《稻荷恋之歌》）以外，在有修学旅行剧情的动画中很多也都会到访京都（比如《轻音少女》，《我的青春恋爱物语果然有问题》，《摇曳百合》）。</p><p>京都市内的景点极多，我当时花了三天时间走完了一些必去的地方。京都市内电车并不发达，大概是古迹太多以至于没法大规模修建铁路和地铁，也有可能是出于维持城市原貌的目的，总之主要交通方式是坐公交车。</p><h3 id="伏见稻荷大社">伏见稻荷大社</h3><p>从大阪乘电车很快就可以到达京都站，但是我当时住的地方并不在京都站附近，而是在伏见稻荷大社附近，在京都站以南几站的地方，所以我在宾馆落脚以后就直奔伏见稻荷大社了。伏见稻荷大社的名片便是千本鸟居，千本鸟居在伏见稻荷大社走进去左手边不远的地方，鸟居排列非常密集但是大小上却都是属于小号，高度大约只有两米左右，其中到底有没有一千座鸟居我也没有数过。千本鸟居有来回两段，每一段大概只有数十米长，而且游客众多不管怎么拍都肯定会拍进去一大堆人头。好在穿过千本鸟居后可以选择爬上神社后面的小山，蜿蜒的山路两边也是一座一座紧挨着的朱红色鸟居。这山路上的鸟居体积就要大了一号，而且布满了上下山小路两边，我猜没有上万座应该也有几千座了。</p><p>小时候看的柯南剧场版《迷宫的十字路口》ED的画面中就有不少伏见稻荷大社鸟居的镜头。可是那时候我都看不出来什么，只是觉得很美。</p><p>稻荷神是主管谷物丰收的神，后来又被赋予了保佑商业繁荣的职责，伏见稻荷大社作为全日本所有稻荷神社的总部所在所以香火旺盛也是情理之中，这满山的鸟居每一个都是要花真金白银才能建造，可不是我这种只往赛钱箱里扔几枚五円硬币的穷鬼能比的。</p><p><img src="https://user-images.githubusercontent.com/5417586/99757231-d36b6a00-2aa3-11eb-9463-4c946fea676a.jpg" alt="IMG_1968-2"></p><p align="center">鸟居</p><p>走完神社后面的山路还是需要不少时间和体力的，另外，最好要在阳光充足的午后到傍晚的时候去，这样阳光暖色会让鸟居的红色更鲜艳。</p><p><img src="https://user-images.githubusercontent.com/5417586/99758191-e0895880-2aa5-11eb-8145-f00443dbcd18.JPG" alt="IMG_1980"></p><p align="center">特色狐狸绘马</p><p>傍晚的时候从伏见稻荷大社出来，我又去鸭川旁边转了转。</p><p><img src="https://user-images.githubusercontent.com/5417586/99758392-62798180-2aa6-11eb-9017-ebb42cf153c0.JPG" alt="IMG_1991"></p><p align="center">《轻音少女》OP中出现过类似的石桥</p><h3 id="清水寺">清水寺</h3><p>第二天一早我就去了另一个著名景点：清水寺。我先从京都站坐公交到清水寺站，然后沿着清水坂一直往上走便到了清水寺。清水寺作为动画常客最出名的是清水舞台，以及清水舞台后面据说祈求姻缘非常灵验的地主神社。</p><p><img src="https://user-images.githubusercontent.com/5417586/99758612-0400d300-2aa7-11eb-8990-9deb3deef015.JPG" alt="IMG_2141"></p><p align="center">清水舞台，那时樱花还没有满开，我下次再来的时候就已经在维修了</p><p>从清水寺出来往北走，穿过古香古色的二年坂和三年坂。再一直往前就到了八坂神社。我记得我在走到八坂神社的时候天降骤雨，幸而神社里有一个棚子可以躲雨。</p><p><img src="https://user-images.githubusercontent.com/5417586/99760697-30b5ea00-2aa9-11eb-9ae4-122b05852407.jpg" alt="IMG_2033-2"></p><p align="center">二年坂</p><h3 id="银阁寺">银阁寺</h3><p>银阁寺本身可看的并不多，有名的枯山水我也不太欣赏的过来，但是银阁寺门前的哲学之道（哲学の道）是很好的赏樱地点，可惜我去的时候还没有满开，真正看到满开的樱花是在后来在东京的时候了。</p><p><img src="https://user-images.githubusercontent.com/5417586/99761195-58598200-2aaa-11eb-8f44-1655419952f0.JPG" alt="IMG_2084"></p><p align="center">🌸</p><h3 id="岚山">岚山</h3><p>在京都的第三天我起了个大早去岚山搭嵯峨野小火车。本来也是很适合赏樱的，但是还是太早，岚山的气温比京都市还要低一些，开放的樱花更少。</p><p>小火车从龟冈站出发，到达嵯峨岚山后出站走几分钟就到了著名的岚山竹林（大老师自爆现场）。</p><p><img src="https://user-images.githubusercontent.com/5417586/99761762-c8b4d300-2aab-11eb-9156-4511488db510.jpg" alt="IMG_2194-2"></p><p align="center">岚山竹林</p><p>同样，竹林也是需要有充足的阳光才更美。接着沿着竹林小径往前走，顺路转了转天龙寺，路过宝严院再往左拐就到了渡月桥了。对于渡月桥我最初的记忆依然还是在轻音的修学旅行篇里。现实中的渡月桥离岚电岚山站和JR嵯峨岚山站很近，人很多，旁边还有很多纪念品商店和小餐馆。</p><p>仓木麻衣有一首歌叫做《渡月橋 ~君 想ふ~》，是柯南剧场版《唐红的恋歌》的ED。这部剧场版虽然不咋样，但是歌还是好听的。</p><iframe allow="autoplay *; encrypted-media *; fullscreen *" frameborder="0" height="150" style="width:100%;max-width:660px;overflow:hidden;background:transparent;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/jp/album/%E6%B8%A1%E6%9C%88%E6%A9%8B-%E5%90%9B-%E6%83%B3%E3%81%B5/1226258280?i=1226258283"></iframe><h3 id="京都动画">京都动画</h3><p>金阁寺，京都御所我就跳过了因为没有什么好说的，就放一张金阁寺的照片吧。</p><p><img src="https://user-images.githubusercontent.com/5417586/99762361-2dbcf880-2aad-11eb-95ec-3ef94efcacc2.JPG" alt="IMG_2223"></p><p align="center">金阁寺</p><p>我在京都的最后一站就是位于京都市南边的宇治市的京都动画了，京都动画作为我最爱的，也是制作《冰菓》，《Clannad》等我心中神作的公司，是不能不去看看的。从京都站搭奈良线电车到木幡下车（如果我记得没错的话，这个站小到只有各停列车才会停），出了车站就是京都动画本社那不起眼的三层小楼了。</p><p><img src="https://user-images.githubusercontent.com/5417586/99762627-cd7a8680-2aad-11eb-9ca2-60fc1201d269.JPG" alt="IMG_2289"></p><p align="center">京都动画本社</p><p>那个时候外面的海报还是京吹剧场版总集篇和无彩限BD呢。公司大门是进不去了，所以我就继续往前走了一段路去了京都动画商店。</p><p><img src="https://user-images.githubusercontent.com/5417586/99762975-8c36a680-2aae-11eb-93f7-af11ce419ef7.JPG" alt="IMG_2293"></p><p align="center">京都动画商店后来搬了新地方</p><p>现在翻出这张照片我才发现，除了京吹，无彩限和Free以外，竟然还有京紫的海报，当时完全没有注意到啊。</p><p>看着这为数不多的几张照片，我又想起了去年夏天京都动画第一工作室发生的惨剧……真是上天不公，好人没有好报。</p><h2 id="箱根">箱根</h2><p>离开京都，我的下一站是箱根。为什么选择了箱根呢？首先是箱根的温泉很有名，其次是据说在芦之湖可以眺望到富士山，最后是箱根是EVA中第三新东京市的位置。</p><p><img src="https://user-images.githubusercontent.com/5417586/99763718-57c3ea00-2ab0-11eb-9aef-b2f710b01978.JPG" alt="IMG_2359"></p><p align="center">东海道新干线希望号N700系</p><p>我搭新干线到小田园，然后转箱根登山电车到箱根汤本。可惜的是大涌谷的缆车因为有喷发迹象而暂停了，所以实际玩的只有芦之湖上的游览船，但即使当天天气晴朗我也没有看到富士山的影子。</p><p>在箱根我专门找了一间温泉旅馆，可是我在温泉里泡上一会就觉得头晕脑胀不得不停下来，看来还是不太适应泡澡啊。我选的也是一间和室，也就是铺着榻榻米的房间，而且还有被炉。箱根海拔比较高，当天夜里气温接近零下，我第一次体会到被炉在这种天气有多爽，真是钻进去就再不想出来。</p><p>对了，箱根汤本车站前有一个EVA官方商店，喜欢的话绝对不能错过哦。</p><h2 id="东京">东京</h2><p>接下来就是我这次旅行的最后一站，东京了。我到东京的那天晚上正好是Lovelive缪斯的最后一场演唱会，虽然我不是拉拉人，也没有买票，但也还是去东京巨蛋外面凑了凑热闹，还买了我人生中第一盒实体CD。接着去了东京地标东京塔，但是这种大型建筑，离得太近了反而看不清楚，我下次再访东京的时候就学会了，从六本木的高楼上看东京塔更符合我想象中的样子，留到下一篇再说吧。</p><h3 id="秋叶原">秋叶原</h3><p>宅男胜地，二次元宇宙中心（笑）。秋叶原是我怎么逛都不觉得无聊的地方，好玩好看好买的东西太多了，但是彼时我并没有多少可以支配的资金能够在这里挥霍，所以大多数时候只能对着各种周边流口水（擦）。</p><p>秋叶原也是一个圣地巡礼的宝地，我印象中最出名的就是《命运石之门》和《LoveLive》了。这两部动画中的很多事件都是发生在秋叶原，要是把圣地巡礼的照片都贴出来的话也没什么太大意义，网上已经有很多圣地巡礼攻略了。我想提一嘴的是神田明神神社，它在LoveLive动画中有登场过，主角们练习体力的那个台阶顶上就是神田明神神社了。我在那里偶遇了一场由神官主持，新娘穿白无垢的日本传统婚礼，运气还是很不错的。</p><p><img src="https://user-images.githubusercontent.com/5417586/99765866-cf941380-2ab4-11eb-81a1-8b21b93fb0e0.JPG" alt="IMG_2431"></p><p align="center">果皇痛车（给俺也整一个）</p><h3 id="新宿御苑">新宿御苑</h3><p>新宿御苑是新海诚的剧场版动画《言叶之庭》的主要取景地，我去的时候正好是东京的樱花满开的时候，总之就是一个字，美！我在东京的那一天基本就是一直在看樱花，这辈子如果没有看过樱花满开的盛景那真的是一大遗憾。</p><p><img src="https://user-images.githubusercontent.com/5417586/99867536-4ee61d80-2b6f-11eb-8eca-bed39b9f6cdd.jpg" alt="IMG_2457-2"></p><p><img src="https://user-images.githubusercontent.com/5417586/99867540-54dbfe80-2b6f-11eb-9d50-cfb67e3805f9.jpg" alt="IMG_2447-2"></p><h3 id="秒五巡礼">秒五巡礼</h3><p>从新宿御苑出来往西南走一会就到了明治神宫。如果要是看樱花的话，我印象中明治神宫并没有多少樱花树，反而是参天的古木非常多。穿过明治神宫，有一个叫参宫桥的小田急线车站，这个车站往南走到第二个道口，也就是“小田急线参宫桥第二踏切”这个地方，就是著名的新海诚动画《秒速五厘米》中最后出现的那个道口。我作为秒五的死忠粉，这个地方是肯定不会错过的。</p><p><img src="https://user-images.githubusercontent.com/5417586/99867844-27dd1b00-2b72-11eb-8750-d46022cbbab2.jpg" alt="Kamigami Byousoku 5 Centimeter BD x264 1920x1080 AC3(5 1ch,jp,en,rus,ita,ger) Sub(BIG5,GB,en,jp,ara,ger,kor,por,tha,spa,ita,ind) mkv_005919 805"></p><p>道口附近逛一逛还能找到不少熟悉的场景，渋谷区立参宮橋公園则是动画一开始的时候场景。</p><p><img src="https://user-images.githubusercontent.com/5417586/99867904-9fab4580-2b72-11eb-93f4-cea7020228b2.jpg" alt="Kamigami Byousoku 5 Centimeter BD x264 1920x1080 AC3(5 1ch,jp,en,rus,ita,ger) Sub(BIG5,GB,en,jp,ara,ger,kor,por,tha,spa,ita,ind) mkv_000022 940"></p><p>再往南走一走的话代代木八幡宫也是秒五的圣地之一。</p><h3 id="目黑川">目黑川</h3><p>接下来我路过涉谷车站，摸一摸已经被磨得锃亮的八公像的前腿。《忠犬八公》还是高中时音乐课老师给放的（没错，音乐课……），当时把我给感动的稀里哗啦的。</p><p>然后从涉谷前往目黑川。目黑川如果以河的角度来看的话是一条很小的河，而且还是穿过东京闹市，但是它的那一段河岸两边种植了大量的樱花树，所以也是赏樱圣地之一。</p><p><img src="https://user-images.githubusercontent.com/5417586/99868035-b8682b00-2b73-11eb-9338-3e1da73644c6.JPG" alt="IMG_2531"></p><p align="center">目黑川的樱花</p><p>樱花季的时候目黑川的人非常非常多，河两边的路也非常的窄，是字面意义上的摩肩接踵。我后来2019年再来的时候人也还是那么多。</p><h3 id="台场">台场</h3><p>台场，或者叫御台场，在东京的东南边深入东京湾。台场是一个人造陆地，是近几十年才开发起来的，台场与东京都港区连接的桥梁名叫“彩虹大桥”，在很多日剧里作为背景板出现过。</p><p>我为什么要去御台场呢？因为御台场可能是我脑中记住的第一个日本地名，比东京还要早。它是《数码宝贝》第一部中大多数主角生活的地方，在我还没怎么有日本这个国家的概念的时候，御台场这个地名就深深印在了我的脑海里。后来我知道御台场是现实中存在的地方时候就想去看看了。</p><p>BTW，御台场还有一个宅圈有名的建筑，那就是每年Comic Market举办的地点：<a href="https://zh.wikipedia.org/zh/%E6%9D%B1%E4%BA%AC%E5%9C%8B%E9%9A%9B%E5%B1%95%E7%A4%BA%E5%A0%B4" target="_blank" rel="noopener">东京国际展示场</a>。</p><h1 id="尾声">尾声</h1><p>即使是已经快五年前的事情了，但是我现在的脑海里第一次日本旅行那两周的记忆还是那么鲜活。我还能记起很多细节，比如我在京都的时候坐公交下错站被一个老奶奶搭话时的手足无措，还有在参观伏见稻荷大社之前，我在正门对面的便利店买了两个面包，然后就坐在店外的长椅上一边看着神社入口的大鸟居一边吃。</p><p>在东京的最后一天我全部花在了逛秋叶原和买东西上，当然因为没有钱最后也没有买多少。当时买的手办后来随着我漂洋过海来到北美，现在就摆在我身后的架子上，想来还有一点不太真实的感觉呢。</p><p>好了，第一次的日本之旅就写到这里了。下一次我会到访富士山，然后真正的前往我心心念念的《冰菓》舞台岐阜县高山市。下一篇再见啦。</p><p>最后贴一张从浅草寺拍摄的云中的天空树</p><p><img src="https://user-images.githubusercontent.com/5417586/99868728-e2245080-2b79-11eb-8195-683e476d325c.jpg" alt="DSCF1239-2"></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊入职这半年</title>
      <link href="/2020/11/07/%E8%81%8A%E8%81%8A%E5%85%A5%E8%81%8C%E8%BF%99%E5%8D%8A%E5%B9%B4/"/>
      <url>/2020/11/07/%E8%81%8A%E8%81%8A%E5%85%A5%E8%81%8C%E8%BF%99%E5%8D%8A%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p>不知不觉入职Google也已经半年多了，在家工作也有半年多了。工作上的事情渐渐熟悉，想写写这半年多来的一些感受。</p><a id="more"></a><p>Google内部对于Google员工称为Googler，而新入职的New Googler则被称为Noogler。在入职办手续的时候，在入职Orientation的时候总是能听到这个词。一开始的时候我要参加一个为期数周的培训，说是培训，其实是一些老员工来给新人介绍介绍内部工作流程和内部工具。</p><p>Google内部有一大堆的内部工具，似乎大公司内部都很喜欢自己造轮子？一方面是大公司的需求可能是地球上独一份的，比如Google的代码管理显然不能用基于Git的，又比如海量数据存储分析倒逼Google开发大数据框架（其开源实现就是Hadoop）。而这种前沿需求又意味着抢先开发完善该领域就极有可能在未来成为事实标准，最近的例子就是Kubernetes，K8s其实不是Google为了内部开发的，内部有名为Borg的类似容器编排系统（Container Orchestration System）的工具，K8s借鉴了一些Borg的设计重新在开源许可证下实现了一套容器编排系统，并成功成为了现在行业的事实标准和云原生（Cloud Native）应用的基石。另一方面就是大公司有足够的人力资源和技术储备来开发和维护内部系统。现在传统行业，或者说非互联网行业向云计算迁移，一个主要动力就是自己维护IT基础设施需要持续、大量的投入才能达到勉强可用的水平，这部分的成本其实本身并不是必须的，云计算提供了一个把这部分工作“外包”出去的可能。但这对于大型科技公司来说不是问题，毕竟这是它们的老本行。并且由于上一个原因，开发这些东西在未来是很有可能带来收入的，所以大公司更倾向于开发和使用自己的内部工具。</p><p>说到造轮子，我所能想到的最典型的就是自己造编程语言了。Apple为了自家平台搞了Swift还挺顺理成章的，Google的工程师用C++用着不爽怎么办？造个新的你不会吗？于是一个静态链接，二进制分发，性能比肩C/C++，语法简洁类似C，还不用头疼指针的Go语言诞生了（当然，语法简洁必然带来的是表达能力的下降，比如我很不喜欢的<code>if err == nil</code>和没有构造函数只能用工厂方法）。另一边Facebook的工程师也不爽PHP，于是他们也另起炉灶搞了一个Hack语言，虽然我没有学过Hack，但是光看例子就有一股宇宙第一语言的味儿扑面而来。该说各个公司造的语言还都挺有各个公司的特色的吗？</p><p>扯远了，培训就是主要讲内部用的代码编辑器，提交review，跑test，提bug一类的东西。由于我的日常工作是在GitHub上的开源项目，所以培训之后我也再也没用过这些东西。</p><p>对了，所有这些工具全部都是跑在浏览器里的，这一点是最让我大开眼界。也不知道是这些内部工具催生了高性能浏览器的需求，还是Chrome强悍的性能让完全WEB化成为可能。浏览器里面跑一个全功能IDE，并且要在Google这种代码量下达到可用，比后来的VS Code要强多了。另外我也是第一次知道Chrome有扩展可以实现完整的SSH客户端，以及黑魔法一样的远程桌面（同样是跑在浏览器里，非内网环境却几乎感觉不到延迟，我怀疑跟Google Stadia的技术有共通的地方）。还有GSuite那一大堆办公套件全都是纯WEB的，感觉Google里是万物基于Chrome（怪不得会有Chrome OS这种东西呢）。</p><p>经过了一开始的一两个月之后，我就开始在慢慢上手我现在主要工作的项目了，项目本身是用Go语言写的，属于Kubernetes的相关工具吧。上手倒是没什么太大的难度，代码都在那里摆着，看就是了。从一开始的修修bug，再到后来慢慢写写小功能，做一些同组其他项目的工作，也还算是轻松愉快吧。唯一有点头疼的写设计文档，也许是我一直都是move fast的所以经常在写文档的时候不知道该写什么，一个我已经理解的东西再把它解释一遍让我很烦躁，可是不解释的话又觉得整个文档都没什么好说的，毕竟我得先理解了才能写。</p><p>我还有一个很深的感触，那就是大公司真的太大了，当然也许是WFH给我造成的心理错觉，我每天能有联系的也就是同组的几个人，所以开会和邮件里大片大片的陌生名字。还有就是大组100多号人都只是在做Google Cloud下的一个service，Cloud也只是Google的几个大部门之一，更别说Google是AlphaBet旗下的一个公司了。真正的是成为螺丝钉了，ま。いいんじゃない？我是觉得不太care的。</p><p>说到WFH，来大公司我最看重的免费三餐一次都没吃到，天坑啊，导致我天天都要纠结点什么外卖或者要做什么。还有免费咖啡，啊啊啊，好气啊。现在说要WFH到明年七月，也就是说还有大半年，说着说着快要过了一半了，似乎也没有那么遥远了。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 吐槽 </tag>
            
            <tag> Google </tag>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GitHub Actions来自动发布Issues到博客</title>
      <link href="/2020/11/04/%E4%BD%BF%E7%94%A8GitHub%20Actions%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83Issues%E5%88%B0%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/11/04/%E4%BD%BF%E7%94%A8GitHub%20Actions%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83Issues%E5%88%B0%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>GitHub Actions真的是非常好用的东西，基于它的事件驱动的工作流可以自动化很多以前我都得手动做的东西。以前当然也可以通过别的CI平台来做，但是GitHub Actions跟GitHub深度集成还是让它成为我的第一选择。<s>最重要的还免费。</s></p><p>这次我是通过GitHub Actions来实现在Issues发布的内容，自动转换为Hexo文章，然后push到repo，再自动生成、部署。</p><p><a href="https://blog.xiadong.info/2020/11/04/This%20is%20a%20test%20blog%20post/">https://blog.xiadong.info/2020/11/04/This is a test blog post/</a>这篇文章就是这样写的，本文也是。</p><a id="more"></a><p>主要的workflow文件：</p><ul><li><a href="https://github.com/Shell32-Natsu/Shell32-Natsu.github.io/blob/src/.github/workflows/issues.yml" target="_blank" rel="noopener">https://github.com/Shell32-Natsu/Shell32-Natsu.github.io/blob/src/.github/workflows/issues.yml</a></li></ul><p>自己写的Action：</p><ul><li><a href="https://github.com/Shell32-Natsu/blog-article-from-issue-action" target="_blank" rel="noopener">https://github.com/Shell32-Natsu/blog-article-from-issue-action</a></li></ul><p>Workflow和Action之间都是用base64编码过的字符串，以防止特殊字符的影响。</p><h1 id="workflow">Workflow</h1><p>整个流程挺直观的，主要步骤是：</p><ul><li>Issue的创建，更改会触发action</li><li>Checkout<ul><li>这里注意checkout使用的是Personal Access Token来clone仓库，这是为了在push的时候可以触发部署的Action，否则push后是不会触发别的action的。</li></ul></li><li>从<code>github.event.issue</code>获取Issue信息</li><li>base64编码</li><li>运行自定义的action生成文章</li><li>保存到文件</li><li>Add &amp; Push</li></ul><h1 id="自定义action">自定义Action</h1><p>自定义的Action其实是一个Docker image，只不过是由GitHub Actions在运行时构建的，我写了一个简单的Python脚本来处理输入的JSON字符串，然后生成一个Hexo的文章。</p><h1 id="功能">功能</h1><p>其实不需要啥功能，只有如下几个：</p><ol><li>根据<code>tags/...</code>，<code>categories/...</code>的issue tag自动添加文章tag和category。</li><li>可以设置只处理特定用户的issue</li><li>只处理有<code>BlogPost</code>tag的issue，这样可以灵活控制是否发布。</li><li>编辑文章也会触发部署</li></ol><p>问题：</p><ol><li>目前还不支持删除文章，想要删除只能手动操作。感觉可以通过tag增减和删除issue的事件来做。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>This is a test blog post</title>
      <link href="/2020/11/04/This%20is%20a%20test%20blog%20post/"/>
      <url>/2020/11/04/This%20is%20a%20test%20blog%20post/</url>
      
        <content type="html"><![CDATA[<p>test message.</p><h1 id="title">Title</h1><p><strong>bold</strong></p><p><em>italic</em></p><ol><li>list1</li><li>list2</li></ol>]]></content>
      
      
      <categories>
          
          <category> 沙箱 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lightroom嵌入分享相册</title>
      <link href="/2020/11/01/lightroom%E5%B5%8C%E5%85%A5%E5%88%86%E4%BA%AB%E7%9B%B8%E5%86%8C/"/>
      <url>/2020/11/01/lightroom%E5%B5%8C%E5%85%A5%E5%88%86%E4%BA%AB%E7%9B%B8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>似乎只能从网页端获得嵌入代码，lightroom客户端没有这个选项。而且也只能显示slideshow。</p><div class='lr_embed' style='position: relative; padding-bottom: 50%; height: 0; overflow: hidden;'><iframe id='iframe' src='https://lightroom.adobe.com/embed/shares/a43009754c57463cafe7410488a8891f/slideshow?background_color=%232D2D2D&color=%23999999' frameborder='0'style='width:100%; height:100%; position: absolute; top:0; left:0;' ></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Poi浏览器在macOS上PAC代理失效</title>
      <link href="/2020/10/31/poi%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A8macos%E4%B8%8Apac%E4%BB%A3%E7%90%86%E5%A4%B1%E6%95%88/"/>
      <url>/2020/10/31/poi%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A8macos%E4%B8%8Apac%E4%BB%A3%E7%90%86%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<p>我之前一直是用的Poi浏览器的PAC代理功能来上舰，见<a href="https://blog.xiadong.info/2017/09/07/%E5%85%B3%E4%BA%8E%E8%88%B0C%E7%9B%B4%E8%BF%9E/">这篇文章</a>。但是从今年年初开始，PAC代理功能就不work了，本来我以为是<a href="https://github.com/poooi/poi/issues/2266" target="_blank" rel="noopener">这个问题</a>，但是在后来的10.6.0版本中http-proxy-agent和pac-proxy-agent都更新了，PAC代理功能在我的系统上却还是不work，具体的表现为http请求总是返回200的空response，而https请求却没有问题，很不幸，舰C的游戏URL至今还是http的。今天我终于花了半天时间找了找原因，现记录在此。</p><p>首先考虑的就是POI的代码中还是有BUG，于是我从源码直接跑POI，PAC代理竟然神奇地work了，我以为是10.6.0之后修了什么bug，于是重新build，安装，又不行了……于是我花了好久看代码，但是看不出什么所以然，毕竟直接run是没有问题的，build之后问题才会出现。POI使用electron-builder来进行打包，我也不是很清楚怎么debug打包后的application，于是我尝试在<a href="https://github.com/poooi/poi/blob/master/lib/proxy.es" target="_blank" rel="noopener">proxy.es</a>文件中用<code>console.log</code>来打log。</p><p>由于这些log是打在electron的main process中的，所以它们不会出现在开发者工具的console里，而是会输出到stdout，所以我尝试着从terminal里运行打包后的application，命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -W /Application/poi.app</span><br></pre></td></tr></table></figure><p>但是这样是不会在terminal中打出log的，怀疑与macOS的application加载机制有关。于是我就直接运行了POI的binary而不是整个application</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Application/poi.app/Contents/MacOS/poi</span><br></pre></td></tr></table></figure><p>这样就可以看到<code>console.log</code>的输出了。神奇的事情发生了，通过这种方式打开POI，PAC代理的问题消失了，功能完全正常，当时我就一脸黑人问号.jpg。这是什么神奇的bug？搞了半天是macOS的application加载机制作祟。我猜测是electron+electron-builder+pac-proxy-agent+macOS产生了什么不为人知的神奇化学反应导致了这个现象。</p><p>知道了问题，那么只要直接跑<code>/Application/poi.app/Contents/MacOS/poi</code>就可以了。我用macOS自带的Automator建了一个一行shell语句的application</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /Applications/poi.app/Contents/MacOS/poi &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>然后就可以通过运行这个application来启动PAC正常工作的POI了。</p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> ACG </tag>
            
            <tag> 舰C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么不热衷于升级软件了</title>
      <link href="/2020/05/24/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%83%AD%E8%A1%B7%E4%BA%8E%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E4%BA%86/"/>
      <url>/2020/05/24/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%83%AD%E8%A1%B7%E4%BA%8E%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>在我正式开始学习计算机知识，也就是大学之前的几年里，我想大概是从我家刚有电脑的初中开始吧，我都是一个热衷于把电脑里的软件更新到最新版的人。然而从那以后的八年里，我越来越懒于更新软件了，手机也好，电脑也好，平板也好，软件商店上常常五六十个App更新我都能做到视而不见了。</p><a id="more"></a><p>家里刚刚添置电脑的时候，对什么都很好奇，总是迫不及待的想要体验最新的功能，用最酷炫的界面。我家的电脑一开始预装的是XP，后来很快的微软发布了Vista，作为跟Windows 8一样现在风评不佳的版本在刚出来的时候着实让我眼前一亮，尤其是一直沿用到Windows 7的Aero UI风格深得我心，可惜的是毛玻璃特效从8开始就消失了变成了扁平的我个人觉得很难看的Metro UI。我记得我当时在什么是ISO文件，什么是MSDN，甚至装系统到底是怎么一回事都不知道的时候就用4M小水管下了2.5G（也有可能是3.5G）的安装文件用虚拟光驱（现在的小朋友大概有很多已经不知道什么是光驱了吧）装了Vista尝鲜。</p><p>说到装系统，其实我第一次动手装系统完全是因为一场事故。我已经不记得是哪一年的事情了，但是应该是初中的某一天，我偶然发现了Windows有个“显示隐藏文件”的选项，然后就仿佛发现了新大陆一样，在C盘的根目录里面发现了不少隐藏文件，比如bootmgr，比如Boot.ini，比如NTLDR之类的，无知给我勇气，把它们统统删了个精光，然后毫无意外的重启起不来了。</p><p>对一个领域不了解的人总是无所畏惧，拥有不知从何而来的勇气，而了解的越多，就越发的谨慎。我想这也是我后来不再折腾软件的原因之一吧。这件事最后被从同学那里借来的一张OEM XP安装盘解决。其实我不知道有多少人见过XP的正式安装界面，因为那时的组装机应该还是Ghost安装盗版占据主导地位，而品牌机都是预装的OEM系统。当时买电脑附送的说明书中还说了怎么使用安装光盘装系统，但是不知道为什么我从来都没有见过附送的安装盘。而那本说明书其实也是我闲暇时候的读物之一，薄薄的一本跟当时我的电脑课教材一样被我翻了很多遍，现在想想还真是很无聊的。</p><p>2010年前后流行过很久的一段时间“电脑/软件管家”类的工具，比如360和腾讯软件管家，我相信它们一直到现在都还活的很好，毕竟在中国不懂如何管理软件的人比比皆是。但是还是小白的我毫不意外地成为了某软件管家的用户（到底是哪一个我不记得了），经常没事打开检查一下更新，不管有用没用都统统更新，不知道可能还以为我有强迫症。其实所谓的软件管家就是现在手机上的应用市场，只不过Windows的开放性让它们变得可有可无。</p><p>我自己有另一个挺好的例子，那就是Office套件了。可能很多人用过Office 2000，2003，2007 etc，但是2000和2003之间还有一个版本就叫Office XP，我家的电脑上一开始就是装的这个Office版本，但是在买了它之后不久，Office 2007就release了，于是我就又手痒地装上了2007（毫无意外的是盗版）。之后也第一时间升级2010，丝毫不管其实我几乎从来没有用过Office套件。一个苦逼中学生除了偶尔打印一些东西，谁会用到PPT和Excel呢？但是但是这些事情都不在我的考虑范围之内，一味地追求“新”。</p><p>转变应该是发生在大学之后，上大学以后我有了自己的笔记本电脑，天天都要用它，渐渐地失去了对于软件新功能的好奇心。另一方面，开始正式学习计算机之后我的兴趣慢慢转到了软件内部实现和计算机底层机制上去了，那些针对用户使用的更新已经不能再引起我的兴趣了。其实这也是我之前说过的，对于不是非常了解的事物，人们总是会去追求外在的东西，深入了解之后才能体会到真正核心的东西是什么。比如不了解汽车的人就会看重外观和牌子，而忽略掉最重要的发动机，变速箱等核心部件。曾经有显卡厂商通过片面宣传大显存而把低端GPU卖出高价，也是利用了这一点。</p><p>另一个问题我想就是现在的软件更新说明都相当的模糊了，现在我手机上的App更新说明，十个有八个是“bug fix &amp; improvements”，尤其以大厂应用为甚。这种废话一样的更新说明简直就是在说：不要管我更新了什么，更新就对了。可是作为一个码农，“bug fix”可能还不错，“improvement”这种话真的让我摸不着头脑，我非常确信这些improvement一定会引入新的bug，说不定这次fix的bug就是前几次improvement引入的呢？而即使是真的improvement，也不一定是我用得上的东西，比如微信这个蠢玩意儿，我实际上只用聊天和朋友圈两个功能，你更新小程序关我什么事呢？但是开源软件是个例外，原因很简单，开源软件所做的更改我都是可以看得见的，虽然我不一定会去看，但是这种透明感就很让我信任。</p><p>最后一的一点原因就是我的软件使用习惯变了，十几岁的时候软件对我来说是一种玩具一样的存在，本来我就不怎么“使用”它们，而是从中找乐子，比如探寻各种不同的选项，比如在Word里敲些东西装作很专业的样子。而现在不一样了，我安装的每一个软件都是要解决特定需求的，比如我的Mac上装的BetterTouchTool就是为了自定义鼠标侧键，解决了这个问题就OK，我不需要你提供什么新的功能，除非有影响我使用的严重bug不然我也不需要bug fix，自然我也不想让你更新。再比如手机上的Twitter，能刷推就行，不需要什么别的更新了。</p><p>也许可以说我失去了探寻新软件的热情了，也许是软件的世界变了，从售卖license到售卖服务到售卖广告再到中国最先进的售卖客户自己，我对于大部分闭源开发商的信任都降低了很多，毕竟他们是要我身上赚钱的，所有的更新都要朝着这个最高目标优化嘛。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 吐槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题的况味</title>
      <link href="/2020/05/22/%E5%88%B7%E9%A2%98%E7%9A%84%E5%86%B5%E5%91%B3/"/>
      <url>/2020/05/22/%E5%88%B7%E9%A2%98%E7%9A%84%E5%86%B5%E5%91%B3/</url>
      
        <content type="html"><![CDATA[<p>写下这个标题的时候我才发现我竟然一直都不是很确定“况味”这个词到底是个什么意思，忘记了中学时候在什么地方看到过这个词，估计是在哪一堂语文课或者哪一次语文阅读的时候遇到的吧。去查了一下才知道跟“滋味”是差不多的，这么说来放在标题也还是挺贴切的。</p><a id="more"></a><p>我的博客里目前有343篇属于LeetCode类别的文章，而我实际在LeetCode上solve了834题，翻了提交记录发现我的第一次提交是在5年两个月前，也就是2015年的3月份。现在我已经忘记了当时为什么要开始做题，那个时候我还没有能出国、能来硅谷的奢望，估计大概是为了准备那一年的蓝桥杯和暑假里的保研夏令营吧。</p><p>我一开始的做题过程完全没有章法，纯粹是随机挑一题开始做，第一次提交竟然是#191，不知道当时是怎么找到这一题的。我本科的时候曾经还参与过学校的ACM比赛，水平实在是过于垃圾所以我用“参与”而不是“参加”，那个时候我看过刘汝佳的白书（算法竞赛入门经典），虽然几乎什么都没有记住，但是也算是对于LeetCode这种形式不是一张白纸吧。</p><p>我真正开始正视刷题这件事应该是在16年下半年的时候，毕竟有在北美找工作的压力，但是也还是没有什么计划性，我记得那时候应该是按照题号从小往大来刷的，笔记啊，整理啊更是统统没有（其实我现在也是没有🤷‍♂️）。我应该是从那个时候开始做周赛的，从那之后一直做了好几年。17年的时候应该一直在刷题，但是同时CMU的课业也是相当繁重，所以我也不清楚做了多少题。</p><p>绝大多数的题我都已经没有印象了，但是我还清晰的记得某些难题做不出来的时候，那种感受跟高中时的数学或者物理试卷上碰到难题的感觉差不多，似乎能抓住一点尾巴但是脑袋里面总是像是堵满了浆糊。</p><p>从18年，或者19的时候开始，大概做了400到500题左右，我能感觉到我的做题水平进入了一个新的阶段。很难精确地去描述这种感觉，我能感觉到我已经能在脑中快速过一遍LeetCode题目用到的所有的数据结构和算法，在看到一道题的时候，读完题我大概就知道需要用什么数据结构和算法来做。还有一个表现就是抽象能力的提高，稍微复杂一点的题目的文字描述总是会找一个情景套进去，从这个情景的描述中快速抽象出实际上应该使用的数据结构和算法是很重要的。</p><p>很多人总是会说做题无用，数据结构和算法在实际工作中基本上用不到。v2ex上这种自称CRUD boy的人尤其的多。不错，我工作快两年来一次都没有用到过DP和图论之类的东西，但是我认为更重要的不是你能记住几种算法，而是面对实际问题快速把它抽象为计算机语言的能力。</p><p>其实我是不喜欢“刷题”这个说法的，它给我的感觉总是有点功利化，有点漫不经心。做题本身应该是一种解决问题的娱乐方式，就像做数独，读侦探小说一样享受解谜的快感。而不是机械得去“刷”。</p><p>有一个很好的例子，在我写POI浏览器的<a href="https://github.com/Shell32-Natsu/poi-plugin-collection-progress" target="_blank" rel="noopener">舰娘收集进度插件</a>的时候，遇到过这种情况：舰C服务器返回的数据中，舰娘类别数据和拥有的舰娘本身的数据是分开的。可以把类别数据当作是一个类，而实际拥有的舰娘是类的实例，比如你可以有两艘吹雪，她们都是同一个“类别”，每个舰娘的属性有一个ID会指向她的舰种。我现在的第一舰队旗舰是Fletcher改，她的舰船ID（api_id）是24326，舰种ID（api_ship_id）是692。而收集进度插件在处理的时候应该考虑类别而非实际舰娘，也就是即使你有两艘吹雪也只应该代表着“吹雪”这艘船已经收集了。但当考虑到改造的时候，问题就变得复杂了，在舰C服务器的数据中，每个舰娘类别中都有一个api_aftershipid属性，它指的是改造后的舰娘类别ID；与此同时吹雪、吹雪改和吹雪改二在收集进度中应该考虑为同一艘船，那么在有吹雪多号机以及不同改造形态的情况下，如何判断一艘吹雪改和一艘吹雪改二都是“吹雪”？稍微了解一些数据结构就能很容易地想到这个结构是一个典型的单链表：吹雪=&gt;吹雪改=&gt;吹雪改二，那么问题就抽象为，给定两个单链表节点，它们可能在也可能不在一个链表中，你要实现一个函数，返回它们是否在一个链表中。bruteforce的方法就是从一个节点开始遍历看能否到达另一个节点，因为两个节点的先后顺序不确定，所以前后调换再遍历一次。</p><p>让这个问题变得更有趣的是，舰娘改造现在是可以“反复横跳”的。Fletcher改 Mod.2的api_aftershipid指向Fletcher Mk.II，而Fletcher Mk.II的api_aftershipid又指向Fletcher改 Mod.2，在游戏中的表现就是形态切换了。而这个机制的存在就让上述的链表算法可能陷入死循环中。问题现在加了一个条件，这个单链表可能有环。要在链表的基础上解决这个问题就有点麻烦了，你也许会说：Fletcher这种情况，只要判断aftershipid是不是前一个节点不就行了？对于Fletcher这个特例，或者说大多数双形态切换来说都可行，但刷过题你应该就知道，用特例来通过边界条件是大忌，因为你不知道还有没有其他的边界条件。夕张就是这么个边界条件，她是三形态切换，具体的表现就是夕张改二、夕张改二特和夕张改二丁首尾相连都在环中。你需要一个更具有普适性的算法。</p><p>想到链表其实是一个有向图，而在我们的问题中，方向并不是很重要，所以可以抽象为一个无向有环图，实际上要解决的问题是非连通无向有环图中判断两个节点是否连通，或者说这两个节点是否在一个集合中。说到这里是不是觉得很熟悉了，刷了题你就应该知道无向图中两个节点是否连通是个非常常见的问题，你可以用DFS，BFS或者并查集来解决。而并查集简直就是为了解决这个问题而存在的。到此为止，这个问题终于有了一个简洁优雅的算法。</p><p>算法题没有做到熟练，对于数据结构不够熟悉，你可能要在这个问题上耗费不少的时间写出bug一堆的代码。谁也不知道在实际工作中会不会哪一天就碰到这种问题，如果没有过这种经历的话，恐怕真的到了那个时候才能体味一下刷题的况味吧。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>似乎读不下去书了</title>
      <link href="/2020/05/21/%E4%BC%BC%E4%B9%8E%E8%AF%BB%E4%B8%8D%E4%B8%8B%E5%8E%BB%E4%B9%A6%E4%BA%86/"/>
      <url>/2020/05/21/%E4%BC%BC%E4%B9%8E%E8%AF%BB%E4%B8%8D%E4%B8%8B%E5%8E%BB%E4%B9%A6%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>我最近发现自己的读书能力下降的非常厉害，不仅是读书的效率还是读书的意愿都不像以前那么好了。</p><a id="more"></a><p>这几周因为工作的原因，要学习k8s的知识，同事推荐了一本<em>Kubernetes in Action</em>，这本书要出新版了（似乎是七八月份，但是现在的情况也不知道还能不能按时出版），所以我就预订了新版的实体书，同时赠送旧版的电子书。因为这个原因我其实在看的是电子版，主要是在iPad上看EPUB。</p><p>电子书的体验还是不错的，但是我发现我总是看大概十几二十分钟就走神。也不仅是这本书，之前我看<em>Understanding ECMAScript 6</em>，甚至《重构》<em>Refactoring</em>、<em>The Art of Unix Programming</em>这种经典中的经典也有这种感觉。仔细想想我应该不是单纯的“读不下去书”，而是针对“技术书籍”有点读不下去。</p><p>去年回国的时候，家里面有300块的书店代金券，我父母是不怎么读书的人，他们的打算是拿去书店旁边的面包店花掉算了。但是对于体验过美国的书有多贵的我来说，去逛一逛许久未去过的书店是个更好的选择。当天我就去了书店把这些代金券花得差不多了，买了大概有六七本书，然后跨过重洋把它们带回了家。在那之后我花了大概有三个月的时间慢慢读完了其中一本叫做《简明日本古代史》的书，这是本天津社科院的人写的书，说实话挺一般的，因为成书较早所以经常有一些时代特征过于明显的话出现。之后我在这周看完了《日本最漫长的一天》这本书，实际花了大概两天时间读完，这种有点小说性质的，或者说纪实文学的书本身就有情节的跌宕起伏，作者和译者的文笔也都不错，这些因素加起来才让我有了一口气把它读完的冲动。《日本最漫长的一天》我还是挺喜欢的，可能会单独写一篇文章吧。</p><p>说句题外话，在我买的那些书里，有一本书叫做《京都》的，我本来以为它是一部简单讲述历史的书，但是我错了，实际上它的内容对于对日本历史，尤其是京都历史不是非常熟悉，也没有在京都常住过的人来说相当晦涩。这本书能在国内出版我有点好奇它的受众群体是谁。</p><p>说起来去年我读的最多的大概还是网络小说了吧（笑</p><p>为什么技术书我最近有点读不下去了呢？我想第一个原因是技术书籍没有一条情节的主线串联起来，当然对技术书要求情节实在是有点强人所难，但是章与章之间的割裂感很多时候是真实存在的。像<em>Kubernetes in Action</em>，<em>Understanding ECMAScript 6</em>这种书，说实话让我想起来教科书，一个一个的专题，先讲概念，再讲应用、举例子，然后说注意事项。虽然是非常正统的“学习”的感觉，但是我现在已经不是可以在书桌前一坐几个小时的年纪了。</p><p>第二个原因我想就是现在让我分心的东西太多了。遥想中学的时候，在家里就是呆在书房里看书写作业。高中在学校就是趴在桌子上做题，没有什么真正的堪称娱乐的东西。但是现在就不一样了，面前就对着电脑，手机就放在旁边，想起来什么事情马上就可以去做，想买个东西就打开亚马逊，想刷推特就拿起手机，时间就这么一点点的消磨掉了。毕竟看技术书哪里有不带脑子看《月曜夜未央》轻松呢，没错我最近沉迷日综《月曜夜未央》。</p><p>还有一个原因是对于技术书籍来说，我的知识水平可能也跟以前不一样了。大学的时候图书馆里计算机科学的书随便拿一本我都得一字一句仔细钻研才能勉强弄懂，但是现在拿<em>Kubernetes in Action</em>来说，我只想看有关概念的部分，碰到命令行实例的时候我基本都想跳过，需要的时候再去查文档就好了。这种心态的变化也让我没有以前那么专心了吧。</p><p>去年我一共读完了几本书？我想充其量十本左右吧，文档倒是看了很多，毕竟是工作需要。但是果然还是想要更多的通过看书来充实自己啊。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的WFH配置</title>
      <link href="/2020/05/21/%E6%88%91%E7%9A%84wfh%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/05/21/%E6%88%91%E7%9A%84wfh%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>不知不觉在家工作已经快要两个月了，其间经历了一次跳槽来Google，在新公司<s>家里</s>也呆了一个月了。因为两周前Pichai说可能要一直WFH的年底，于是不得不为长期作战做准备了，添置了一些新的硬件。现在我对于WFH的环境还是比较满意的了。</p><a id="more"></a><h1 id="硬件">硬件</h1><ul><li>电动升降的桌子。非常重要，一把好的椅子价格也不菲，不如买一个升降桌子不时站起来工作。</li><li>双4K显示器。都是27寸的4K，是我以前就有的显示器直接拿来用了，像写代码这种文字工作，高分辨率的屏幕可以极大的提升体验。</li><li>工作用电脑是公司给的16寸MBP，两个TB口接显示器，另一边的接dock+充电。平时用我自己的MBP 15。</li><li>键盘是跟了我好多年的HHKB Pro2，新买了一个木质掌托。</li><li>鼠标是杂牌无线鼠标，在Mac上配合<a href="https://mos.caldis.me/" target="_blank" rel="noopener">Mos</a>来解决滑动卡顿的问题。</li><li>杂牌笔记本支架，毕竟16寸MBP散热感人。</li><li>耳机是AKG N5005，前端用乐之邦Monitor 09。不烧耳机觉得还可以吧。</li><li>AirPods Pro+一个旧的有线耳机开会用。</li><li>赛睿寒冰3玩游戏用。</li><li>台式机把显卡从1060换成了2060，为了玩COD吃鸡。</li><li>本来台式机的显示器被我拿来接笔记本了，再加上要玩游戏，就买了一个144Hz 2K的显示器。</li><li>台式机键盘从108键的青轴换成了海盗船的87键红轴。感觉我可能更喜欢红轴的打字手感，比HHKB的压力克数要小。</li></ul><h1 id="软件">软件</h1><ul><li>iTerm2，不用说了。</li><li>Chrome，Google内部的几乎任何东西都是可以通过Chrome访问的，包括SSH和代码编辑器。</li><li>VS Code，用Remote development获得完美的远程开发体验。</li><li>BetterTouchTool，我主要用来自定义鼠标的侧键，同时还有简单的桌面窗口布局功能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在网页中使用Service Worker发送通知</title>
      <link href="/2020/05/08/%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8service%20worker%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5/"/>
      <url>/2020/05/08/%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8service%20worker%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>最近写了一个上班时摸鱼用的<a href="https://blog.xiadong.info/kancolle_mission_timer/">舰C远征计时工具</a>。React的部分很快就搞定了，但是因为远征结束的时候要发送一个浏览器通知，我以前没有写过这种东西，所以走了很多弯路花了不少时间，最终还是把功能实现了。</p><p>这是我第一次使用Service Worker，也没有花很多时间去研究，所以肯定会有很多疏漏。</p><a id="more"></a><h1 id="最简单的通知">最简单的通知</h1><p>单纯发送通知其实是很简单的，只要new一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/notification" target="_blank" rel="noopener"><code>Notification</code></a>就可以了。注意要先用<code>Notification.requestPermission()</code>申请通知权限。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Notification(<span class="string">"Hi there!"</span>);</span><br></pre></td></tr></table></figure><h1 id="与通知交互">与通知交互</h1><p>事情到这里进行得还算比较顺利，问题出现在我想要在通知中加入一个重启计时器的按钮，这样我就不用点开计时器的标签了。类似这样的</p><p><img src="https://i.loli.net/2020/05/10/m9rcIC4XV6KNFLz.png" alt="image.png"></p><p>这种按钮在Notification中称为<em>Action</em>。在<code>Notification</code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification" target="_blank" rel="noopener">构造函数</a>中有一个<code>Actions</code>数组，其成员是<a href="https://developer.mozilla.org/en-US/docs/Web/API/NotificationAction" target="_blank" rel="noopener"><code>NotificationAction</code></a>，这里面就可以添加你想要的Action了。既然可以添加Action，那么按照JavaScript的惯例，肯定有个地方要添加相应的callback了。对于Notification的Action来说，callback是定义在<a href="https://developers.google.com/web/fundamentals/primers/service-workers" target="_blank" rel="noopener">Service Worker</a>中的。</p><p>Notification中的Action不能直接定义在前面那样的构造函数中，而必须通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification" target="_blank" rel="noopener">ServiceWorkerRegistration.showNotification()</a>来定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用了React的props变量</span></span><br><span class="line"><span class="keyword">this</span>.props.serviceWorkerRegistration.showNotification(</span><br><span class="line">  <span class="string">`远征「<span class="subst">$&#123;<span class="keyword">this</span>.props.missionInfo[<span class="keyword">this</span>.state.missionId].name&#125;</span>」结束`</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    body: <span class="keyword">this</span>.getFleetName(<span class="keyword">this</span>.props.fleetId),</span><br><span class="line">    renotify: <span class="literal">true</span>,</span><br><span class="line">    requireInteraction: <span class="literal">true</span>,</span><br><span class="line">    tag: <span class="keyword">this</span>.fleetId,</span><br><span class="line">    actions: [</span><br><span class="line">      &#123;</span><br><span class="line">        action: <span class="string">"restart-timer"</span>,</span><br><span class="line">        title: <span class="string">"Restart"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="service-worker-sw">Service Worker (SW)</h1><blockquote><p>A service worker is a script that your browser runs in the background, separate from a web page, opening the door to features that don’t need a web page or user interaction.</p></blockquote><p>我的理解是Service Worker是浏览器替网站执行的本地后台进程，前台网页可以把一些background任务交给service worker让它在后台运行，更重要的是，service worker还具有离线运行的能力。</p><p>关于service worker的life cycle之类的可以去看前面的Google的文档。</p><h2 id="registration">Registration</h2><p>Service worker是一个单独的js文件，需要前台网页来register。我用了register-service-worker这个库来简化这个流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; register &#125; <span class="keyword">from</span> <span class="string">"register-service-worker"</span>;</span><br><span class="line"><span class="keyword">const</span> registration = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  register(<span class="string">"./service_worker.js"</span>, &#123;</span><br><span class="line">    registrationOptions: &#123; <span class="attr">scope</span>: <span class="string">"./"</span> &#125;, <span class="comment">// 这里的scope要注意，一定要包含你要控制的页面路径</span></span><br><span class="line">    ready(registration: ServiceWorkerRegistration) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Service worker is active."</span>);</span><br><span class="line">      resolve(registration);</span><br><span class="line">    &#125;,</span><br><span class="line">    error(error) &#123;</span><br><span class="line">      reject(<span class="string">"Error during service worker registration:"</span> + error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="与service-worker通信">与Service Worker通信</h1><p>我一开始看到的例子是使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel" target="_blank" rel="noopener">MessageChannel</a>来进行通信，注册SW之后直接通知SW使用全局变量保存channel的信息。问题出在SW<strong>在一段时间后（几分钟or几十秒）会被浏览器stop</strong>，在有事件的时候会再次唤醒。全局变量会被清除，SW也不能用local storage。</p><p>所以要么你在每次show notification之后都重新通知一次SW channel信息，要么使用广播模式。我选择了广播模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">"notificationclick"</span>, (event: any) =&gt; &#123;</span><br><span class="line">  event.notification.close();</span><br><span class="line">  <span class="comment">// 这里的action与之前注册时的action对应</span></span><br><span class="line">  <span class="keyword">if</span> (event.action === <span class="string">"restart-timer"</span>) &#123;</span><br><span class="line">    <span class="comment">// Restart the timer</span></span><br><span class="line">    <span class="keyword">const</span> fleetId = event.notification.tag;</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">new</span> BroadcastChannel(<span class="string">"kancolle_mission_timer"</span>);</span><br><span class="line">    channel.postMessage(&#123;</span><br><span class="line">      restart: <span class="literal">true</span>,</span><br><span class="line">      fleetId</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给博客加了GitHub Action自动部署</title>
      <link href="/2020/04/30/%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%BA%86GitHub%20Action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/04/30/%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%BA%86GitHub%20Action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>虽然很久没有写博客了，但是题还是在做的，最近也跳了槽来了Google。前几天有人给我的BGM report仓库开PR，由于不想手动try，所以就加了个简单的GitHub Action来自动测。今天给博客也加上了Action，以后就不用手动run Hexo命令来生成然后再push了。</p><p>Action Workflow：<a href="https://github.com/Shell32-Natsu/Shell32-Natsu.github.io/blob/src/.github/workflows/deploy.yml" target="_blank" rel="noopener">https://github.com/Shell32-Natsu/Shell32-Natsu.github.io/blob/src/.github/workflows/deploy.yml</a></p><p>今天还写了个远征计时的小玩意儿，用React的小App，也用了Action自动部署到GitHub Pages。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1156. Swap For Longest Repeated Character Substring</title>
      <link href="/2019/08/11/LeetCode-1156-Swap-For-Longest-Repeated-Character-Substring/"/>
      <url>/2019/08/11/LeetCode-1156-Swap-For-Longest-Repeated-Character-Substring/</url>
      
        <content type="html"><![CDATA[<p>Given a string <code>text</code>, we are allowed to swap two of the characters in the string. Find the length of the longest substring with repeated characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text &#x3D; &quot;ababa&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can swap the first &#39;b&#39; with the last &#39;a&#39;, or the last &#39;b&#39; with the first &#39;a&#39;. Then, the longest repeated character substring is &quot;aaa&quot;, which its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text &#x3D; &quot;aaabaaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Swap &#39;b&#39; with the last &#39;a&#39; (or the first &#39;a&#39;), and we get longest repeated character substring &quot;aaaaaa&quot;, which its length is 6.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text &#x3D; &quot;aaabbaaa&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text &#x3D; &quot;aaaaa&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: No need to swap, longest repeated character substring is &quot;aaaaa&quot;, length is 5.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text &#x3D; &quot;abcdef&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= text.length &lt;= 20000</code></li><li><code>text</code> consist of lowercase English characters only</li></ul><a id="more"></a><p>在可以swap一对字符位置的情况下查找最长的相同字符子串。用双指针来搜索这种子串，搜索过程中要注意可以跳过一个字符，记录下跳过的字符的位置，在遇到第二个需要跳过的字符或者字符串结尾的时候判断跳过的字符能不能被swap（也就是找到不在这个子串范围内的可以跟跳过字符swap构成同字符字符串的字符）。</p><p>先把每个字符的出现index记录下来，它自然是一个有序的序列，然后在每次查找时使用二分搜索搜索不在找到的子串的范围内的index，如果有那么就是可以swap的。</p><p>要注意的有三点：</p><ul><li>一个子串处理完毕后下一次查找应该从被跳过的字符开始而不是子串结尾，所以最坏情况下每个字符会被访问两次。</li><li>一个字符都没有跳过的情况，这种情况肯定是到达原字符串结尾了。</li><li>在遇到第二个要跳过的字符的时候，其实<code>p2-p1-1</code>已经必然是一个可行解了，在这种情况下，<code>[p1, p2)</code>之间是<code>p2-p1-1</code>个相同字符+<code>1</code>个不同字符，必然可以swap成一个<code>p2-p1-1</code>长度的同字符序列。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRepOpt1</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">            pos[text[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; text.length()) &#123;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            <span class="keyword">int</span> skip = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> skip_pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; text.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text[p2] != text[p1]) &#123;</span><br><span class="line">                    skip++;</span><br><span class="line">                    <span class="keyword">if</span> (skip &lt;= <span class="number">1</span>)</span><br><span class="line">                        skip_pos = p2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (skip &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, p2 - p1 - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (findPossible(p1, p2, pos[text[p1]])) &#123;</span><br><span class="line">                ans = max(ans, p2 - p1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skip == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = max(ans, p2 - p1);</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = skip_pos == <span class="number">-1</span> ? p2 : skip_pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findPossible</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> _right = upper_bound(pos.begin(), pos.end(), right) - pos.begin();</span><br><span class="line">        <span class="keyword">int</span> _left = lower_bound(pos.begin(), pos.end(), left) - pos.begin();</span><br><span class="line">        <span class="keyword">return</span> _left &gt; <span class="number">0</span> || _right &lt; pos.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1155. Number of Dice Rolls With Target Sum</title>
      <link href="/2019/08/11/LeetCode-1155-Number-of-Dice-Rolls-With-Target-Sum/"/>
      <url>/2019/08/11/LeetCode-1155-Number-of-Dice-Rolls-With-Target-Sum/</url>
      
        <content type="html"><![CDATA[<p>You have <code>d</code> dice, and each die has <code>f</code> faces numbered <code>1, 2, ..., f</code>.</p><p>Return the number of possible ways (out of <code>fd</code> total ways) <strong>modulo 10^9 + 7</strong> to roll the dice so the sum of the face up numbers equals <code>target</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: d &#x3D; 1, f &#x3D; 6, target &#x3D; 3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">You throw one die with 6 faces.  There is only one way to get a sum of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: d &#x3D; 2, f &#x3D; 6, target &#x3D; 7</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:</span><br><span class="line">1+6, 2+5, 3+4, 4+3, 5+2, 6+1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: d &#x3D; 2, f &#x3D; 5, target &#x3D; 10</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: d &#x3D; 1, f &#x3D; 2, target &#x3D; 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">You throw one die with 2 faces.  There is no way to get a sum of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: d &#x3D; 30, f &#x3D; 30, target &#x3D; 500</span><br><span class="line">Output: 222616187</span><br><span class="line">Explanation: </span><br><span class="line">The answer must be returned modulo 10^9 + 7.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= d, f &lt;= 30</code></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><a id="more"></a><p>基本思路是使用动态规划，有<code>n</code>个骰子投出<code>m</code>点的可能数量为<code>sum(n-1个骰子投出m-1的数量, n-1个骰子投出m-2的数量,..., n-1个骰子投出m-f的数量)</code>。对于每一个<code>d</code>都要遍历一遍<code>f</code>个点，每一次遍历中要再遍历一次<code>d-1</code>时的<code>f</code>个点所以最佳时间复杂度应为<code>O(df^2)</code>，在我的实现中因为不知道<code>d-1</code>时的可能点数的起始位置所以实际遍历了所有<code>d*f</code>个可能，实际复杂度为<code>O(d^2f^2)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; d * f)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; dp1(d * f + 1, 0), dp2(d * f + 1, 0);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++) &#123;</span><br><span class="line">            dp1[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= d; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp1.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp1[j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f; k++) &#123;</span><br><span class="line">                    dp2[k + j] += dp1[j] % MOD;</span><br><span class="line">                    dp2[k + j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(dp1, dp2);</span><br><span class="line">            dp2.assign(d * f + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp1[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Invoke Jenkins Jobs from BitBucket Server by Webhook</title>
      <link href="/2019/05/19/Invoke-Jenkins-Jobs-from-BitBucket-by-Webhook/"/>
      <url>/2019/05/19/Invoke-Jenkins-Jobs-from-BitBucket-by-Webhook/</url>
      
        <content type="html"><![CDATA[<p>I just added unit tests and am planning to add functional test scripts to one of my project. What comes to your mind when you work on a project every day, already have had test scripts and there is a Jenkins server available? Right, automate it!</p><p>My compay uses BitBucket server. However, although there are several BitBucket server plugins <a href="https://marketplace.atlassian.com/search?product=bitbucket&amp;query=jenkins" target="_blank" rel="noopener">available</a>, all of them are not free (and they are even not cheap!). So far, I just want to invoke a Jenkins job when some events happen. Should we pay thousands of dollars for such a easy (relatively) use case? So I decide to find some free alternatives.</p><a id="more"></a><h1 id="webhook">Webhook</h1><p><a href="https://en.wikipedia.org/wiki/Webhook" target="_blank" rel="noopener">Webhook</a> is a very convenient feature. It’s very simple. Just send a HTTP request to a URL when an event occurs. Fortunately, BitBucket server support Webhook <a href="https://confluence.atlassian.com/bitbucket/manage-webhooks-735643732.html" target="_blank" rel="noopener">natively</a>, which means you don’t need to install a plugin.</p><p><img src="https://i.imgur.com/1aSNdLN.png" alt="Imgur"></p><p>It’s very easy to configure a Webhook. Just follow the documentations.</p><h1 id="jenkins">Jenkins</h1><p>You need two plug-ins on Jenkins:</p><h2 id="generic-webhook-trigger-plugin">Generic Webhook Trigger Plugin</h2><p>You need this plug-in to parse the payload in the POST body sent by BitBucket.</p><p>BitBucket will send a POST request to the URL you set. The information is a JSON object in the body. Jenkins cannot parse the JSON object in the body so we need this plug-in.</p><p><img src="https://i.imgur.com/SuT3V5I.png" alt=""></p><p>After intalling <em>Generic Webhook Trigger Plugin</em>, You should set the Webhook URL to <code>{JENKINS SERVER}/generic-webhook-trigger/invoke</code>.</p><p>For more information, see <a href="https://wiki.jenkins.io/display/JENKINS/Generic+Webhook+Trigger+Plugin" target="_blank" rel="noopener">here</a>.</p><h2 id="bitbucket-stash-notifier-plugin">Bitbucket (Stash) Notifier Plugin</h2><p>After a Jenkins job finishes, you definitely want to get a notification. Sure, you can choose to send an email to the author or the code reviewer of the pull request. But there is a better way. BitBucket can accept the build status by a REST API (well, another Webhook). This plug-in is used to send this request.</p><p><img src="https://i.imgur.com/uRbOz7b.png" alt=""></p><p>Note that this plug-in only supports username/password credentials but you can use <a href="https://confluence.atlassian.com/bitbucketserver/personal-access-tokens-939515499.html" target="_blank" rel="noopener">personal access token</a> to secure your password.</p><p>When a job finishes, a build status icon will show beside the commit message and pull request if there is one.</p><p><img src="https://i.imgur.com/TWXsFzV.png" alt=""></p><p><img src="https://i.imgur.com/adNJCz0.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
            <tag> BitBucket </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1035. Uncrossed Lines</title>
      <link href="/2019/04/27/LeetCode-1035-Uncrossed-Lines/"/>
      <url>/2019/04/27/LeetCode-1035-Uncrossed-Lines/</url>
      
        <content type="html"><![CDATA[<p>We write the integers of <code>A</code> and <code>B</code> (in the order they are given) on two separate horizontal lines.</p><p>Now, we may draw a straight line connecting two numbers <code>A[i]</code> and <code>B[j]</code> as long as <code>A[i] == B[j]</code>, and the line we draw does not intersect any other connecting (non-horizontal) line.</p><p>Return the maximum number of connecting lines we can draw in this way.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,4,2], B &#x3D; [1,2,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can draw 2 uncrossed lines as in the diagram.</span><br><span class="line">We cannot draw 3 uncrossed lines, because the line from A[1]&#x3D;4 to B[2]&#x3D;4 will intersect the line from A[2]&#x3D;2 to B[1]&#x3D;2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [2,5,1,2,5], B &#x3D; [10,5,2,1,5,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,3,7,1,7,5], B &#x3D; [1,9,2,5,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= A.length &lt;= 500</code></li><li><code>1 &lt;= B.length &lt;= 500</code></li><li><code>1 &lt;= A[i], B[i] &lt;= 2000</code></li></ol><a id="more"></a><p>虽然题目看起来有点复杂，其实就是求最长公共子串的长度。连线互不交叉其实就是公共子串换了一种说法而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = A.size(), col = B.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(row + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1034. Coloring A Border</title>
      <link href="/2019/04/27/LeetCode-1034-Coloring-A-Border/"/>
      <url>/2019/04/27/LeetCode-1034-Coloring-A-Border/</url>
      
        <content type="html"><![CDATA[<p>Given a 2-dimensional <code>grid</code> of integers, each value in the grid represents the color of the grid square at that location.</p><p>Two squares belong to the same <em>connected component</em> if and only if they have the same color and are next to each other in any of the 4 directions.</p><p>The <em>border</em> of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).</p><p>Given a square at location <code>(r0, c0)</code> in the grid and a <code>color</code>, color the border of the connected component of that square with the given <code>color</code>, and return the final <code>grid</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1],[1,2]], r0 &#x3D; 0, c0 &#x3D; 0, color &#x3D; 3</span><br><span class="line">Output: [[3, 3], [3, 2]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,2,2],[2,3,2]], r0 &#x3D; 0, c0 &#x3D; 1, color &#x3D; 3</span><br><span class="line">Output: [[1, 3, 3], [2, 3, 3]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,1],[1,1,1],[1,1,1]], r0 &#x3D; 1, c0 &#x3D; 1, color &#x3D; 2</span><br><span class="line">Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= grid.length &lt;= 50</code></li><li><code>1 &lt;= grid[0].length &lt;= 50</code></li><li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li><li><code>0 &lt;= r0 &lt; grid.length</code></li><li><code>0 &lt;= c0 &lt; grid[0].length</code></li><li><code>1 &lt;= color &lt;= 1000</code></li></ol><a id="more"></a><p>BFS搞就完事了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nextStep = &#123;</span><br><span class="line">            &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">colorBorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        row = grid.size(), col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">visited</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>))</span></span>;</span><br><span class="line">        q.push(&#123;r0, c0&#125;);</span><br><span class="line">        visited[r0][c0] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; border;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> r = p.first, c = p.second;</span><br><span class="line">            <span class="keyword">if</span> (isBorder(grid, r, c))</span><br><span class="line">                border.emplace_back(r, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> next: nextStep) &#123;</span><br><span class="line">                <span class="keyword">int</span> tr = r + next[<span class="number">0</span>], tc = c + next[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (!isValid(grid, tr, tc) || grid[r][c] != grid[tr][tc] || </span><br><span class="line">                    visited[tr][tc])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.push(&#123;tr, tc&#125;);</span><br><span class="line">                visited[tr][tc] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : border) &#123;</span><br><span class="line">            grid[p.first][p.second] = color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span> || c == <span class="number">0</span> || r == row - <span class="number">1</span> || c == col - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next: nextStep) &#123;</span><br><span class="line">            <span class="keyword">int</span> tr = r + next[<span class="number">0</span>], tc = c + next[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!isValid(grid, tr, tc))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[tr][tc] != grid[r][c])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; row &amp;&amp; c &lt; col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1033. Moving Stones Until Consecutive</title>
      <link href="/2019/04/27/LeetCode-1033-Moving-Stones-Until-Consecutive/"/>
      <url>/2019/04/27/LeetCode-1033-Moving-Stones-Until-Consecutive/</url>
      
        <content type="html"><![CDATA[<p>Three stones are on a number line at positions <code>a</code>, <code>b</code>, and <code>c</code>.</p><p>Each turn, let’s say the stones are currently at positions <code>x, y, z</code> with <code>x &lt; y &lt; z</code>.  You pick up the stone at either position <code>x</code> or position <code>z</code>, and move that stone to an integer position <code>k</code>, with <code>x &lt; k &lt; z</code> and <code>k != y</code>.</p><p>The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.</p><p>When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: <code>answer = [minimum_moves, maximum_moves]</code></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 1, b &#x3D; 2, c &#x3D; 5</span><br><span class="line">Output: [1, 2]</span><br><span class="line">Explanation: Move stone from 5 to 4 then to 3, or we can move it directly to 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 4, b &#x3D; 3, c &#x3D; 2</span><br><span class="line">Output: [0, 0]</span><br><span class="line">Explanation: We cannot make any moves.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= a &lt;= 100</code></li><li><code>1 &lt;= b &lt;= 100</code></li><li><code>1 &lt;= c &lt;= 100</code></li><li><code>a != b, b != c, c != a</code></li></ol><a id="more"></a><p>对于最大值，就是两端的石头以每次一格的速度往中间靠拢。每次一格，每个格子走一次。所以就是两端的石头之间的格子数（<code>stones[2] - stones[0] - 1</code>）再减掉中间的石头。</p><p>最小值有三种情况：</p><ol><li>已经相邻，最小步数为0.</li><li>任意两个石头之间只有一个格子，把另一个石头移过来就可以了，步数为1.</li><li>其他情况。先移动一个石头使其与另一个的石头差一格或相邻，再移动另一个石头。共2步。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numMovesStones</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stones = &#123;a, b, c&#125;;</span><br><span class="line">        sort(stones.begin(), stones.end());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">1</span>] = stones[<span class="number">2</span>] - stones[<span class="number">0</span>] - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (stones[<span class="number">1</span>] - stones[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; stones[<span class="number">2</span>] - stones[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stones[<span class="number">1</span>] - stones[<span class="number">0</span>] == <span class="number">1</span> || stones[<span class="number">2</span>] - stones[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stones[<span class="number">1</span>] - stones[<span class="number">0</span>] == <span class="number">2</span> ||</span><br><span class="line">                stones[<span class="number">2</span>] - stones[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微博图片外链临时解决</title>
      <link href="/2019/04/27/%E5%BE%AE%E5%8D%9A%E5%9B%BE%E7%89%87%E5%A4%96%E9%93%BE%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/04/27/%E5%BE%AE%E5%8D%9A%E5%9B%BE%E7%89%87%E5%A4%96%E9%93%BE%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>最近微博给用户上传的图片增加了反盗链。鼓捣了一个小时终于把这个问题给搞定了。</p><a id="more"></a><h1 id="原因">原因</h1><p>微博的反盗链机制目前很简单，就是查<code>referer</code>这个<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer" target="_blank" rel="noopener">header</a>。但是如果请求中没有这个header，那么也是可以的。正好HTML的图片tag <code>img</code>有一个属性<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" target="_blank" rel="noopener">referrerpolicy</a>，可以让浏览器不发送referer header。那么只要在博客图片里面加上这个属性就可以了。</p><p><strong>这个属性还属于experimental的阶段。</strong> iOS的Safari还不支持。不过FF和Chrome的较新版本都支持了。</p><p>盲猜一下为什么微博没有把没有referer的也给封杀了：也许有一些非WEB端也会请求图片吧。</p><h1 id="解决">解决</h1><h2 id="hexo-tag">Hexo <a href="https://hexo.io/api/tag" target="_blank" rel="noopener">Tag</a></h2><p>Hexo Tag 类似于一个自定义的可以在Markdown文件中调用的函数。它会在generate的时候运行把调用位置替换成函数的返回结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo.extend.tag.register(<span class="string">'sinaimage'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> image_url = args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;img src="<span class="subst">$&#123;image_url&#125;</span>" alt="" referrerpolicy="no-referrer"&gt;&lt;/img&gt;`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个函数很简单，没什么好说的。把它保存成一个<code>.js</code>文件然后放到hexo project目录下面的scripts目录里，没有就创建一个。</p><p>在Markdown中这样调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sinaimage https:&#x2F;&#x2F;wx4.sinaimg.cn&#x2F;large&#x2F;xxxxx.jpg %&#125;</span><br></pre></td></tr></table></figure><h2 id="替换以前文章中的图片">替换以前文章中的图片</h2><p>使用<code>sed</code>就可以批量替换掉以前文章中插入的图片了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -E &#39;s&#x2F;.*\!\[.*\]\((https?\:\&#x2F;\&#x2F;.*\.sinaimg\.cn.*)\)&#x2F;\&#123;% sinaimage \1 %\&#125;&#x2F;g&#39; &#39;FILE_PATH&#39;</span><br></pre></td></tr></table></figure><p>以上的正则请自行修改。<strong>注意做好备份。</strong></p><p>暂时就解决了。</p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 839. Similar String Groups</title>
      <link href="/2018/05/21/LeetCode-839-Similar-String-Groups/"/>
      <url>/2018/05/21/LeetCode-839-Similar-String-Groups/</url>
      
        <content type="html"><![CDATA[<p>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of <code>X</code>, so that it equals <code>Y</code>.</p><p>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p><p>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code>are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p><p>We are given a list <code>A</code> of unique strings.  Every string in <code>A</code> is an anagram of every other string in <code>A</code>.  How many groups are there?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>A.length &lt;= 2000</code></li><li><code>A[i].length &lt;= 1000</code></li><li><code>A.length * A[i].length &lt;= 20000</code></li><li>All words in <code>A</code> consist of lowercase letters only.</li><li>All words in <code>A</code> have the same length and are anagrams of each other.</li><li>The judging time limit has been increased for this question.</li></ol> <a id="more"></a><p>一个分类问题，一下就想到用并查集来做，因为放宽了时间要求所以并不是很难。判断两个字符串是否相似比较简单，看能不能通过一次swap得到就行了。一开始每个字符串自己一个集合，然后对于每一个字符串，遍历所有已经分类过的字符串，如果有相似的，就把它们所在的集合合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uf;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.size();</span><br><span class="line">        uf = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            uf[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uf[i] == uf[j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (similar(A[i], A[j])) &#123;</span><br><span class="line">                    merge(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf[i] == i)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h1 = head(n1), h2 = head(n2);</span><br><span class="line">        <span class="keyword">if</span> (h1 == h2)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        uf[h2] = h1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">head</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = n;</span><br><span class="line">        <span class="keyword">while</span> (uf[p] != p) &#123;</span><br><span class="line">            p = uf[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">similar</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pos.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = pos[<span class="number">0</span>], p2 = pos[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s1[p1] == s2[p2] &amp;&amp; s1[p2] == s2[p1])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 838. Push Dominoes</title>
      <link href="/2018/05/21/LeetCode-838-Push-Dominoes/"/>
      <url>/2018/05/21/LeetCode-838-Push-Dominoes/</url>
      
        <content type="html"><![CDATA[<p>There are <code>N</code> dominoes in a line, and we place each domino vertically upright.</p><p>In the beginning, we simultaneously push some of the dominoes either to the left or to the right.</p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png" alt="img"></p><p>After each second, each domino that is falling to the left pushes the adjacent domino on the left.</p><p>Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</p><p>When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.</p><p>For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.</p><p>Given a string “S” representing the initial state. <code>S[i] = 'L'</code>, if the i-th domino has been pushed to the left; <code>S[i] = 'R'</code>, if the i-th domino has been pushed to the right; <code>S[i] = '.'</code>, if the <code>i</code>-th domino has not been pushed.</p><p>Return a string representing the final state.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;.L.R...LR..L..&quot;</span><br><span class="line">Output: &quot;LL.RR.LLRRLL..&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;RR.L&quot;</span><br><span class="line">Output: &quot;RR.L&quot;</span><br><span class="line">Explanation: The first domino expends no additional force on the second domino.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>0 &lt;= N &lt;= 10^5</code></li><li>String <code>dominoes</code> contains only <code>'L</code>', <code>'R'</code> and <code>'.'</code></li></ol><a id="more"></a><p>这道题我使用双指针</p><ul><li>如果遇到<code>L</code>，那么就把之前的<code>.</code>设置成<code>L</code>。</li><li>如果遇到<code>R</code>，那么就往后搜索<code>L</code><ul><li>如果没有<code>L</code>了，那么就把后面的全部设置成<code>R</code></li><li>如果遇到了<code>R</code>，那么这两个<code>R</code>之间的<code>.</code>就全部设置成<code>R</code>，把新的<code>R</code>当成新的起点</li><li>如果遇到了<code>L</code>，那么就从两边的<code>R</code>和<code>L</code>向中间合拢，直到相遇</li></ul></li></ul><p>时间复杂度<code>O(n)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; dominoes.length()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; dominoes.length() &amp;&amp; dominoes[p1] == <span class="string">'.'</span>)</span><br><span class="line">                p1++;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[p1] == <span class="string">'L'</span>) &#123;</span><br><span class="line">                p2 = p1;</span><br><span class="line">                <span class="keyword">int</span> i = p1 - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; dominoes[i] == <span class="string">'.'</span>)</span><br><span class="line">                    dominoes[i--] = <span class="string">'L'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p2 = p1;</span><br><span class="line">                <span class="keyword">while</span> (p2 &lt; dominoes.length() &amp;&amp; dominoes[p2] != <span class="string">'L'</span>) &#123;</span><br><span class="line">                    p2++;</span><br><span class="line">                    <span class="keyword">if</span> (dominoes[p2] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = p1; i &lt; p2; i++)</span><br><span class="line">                            dominoes[i] = <span class="string">'R'</span>;</span><br><span class="line">                        p1 = p2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2 == dominoes.length()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (p2 = p1; p2 &lt; dominoes.length(); p2++)</span><br><span class="line">                        dominoes[p2] = <span class="string">'R'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (p2 - p1 + <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                        dominoes[p1 + i] = <span class="string">'R'</span>;</span><br><span class="line">                        dominoes[p2 - i] = <span class="string">'L'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dominoes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 837. New 21 Game</title>
      <link href="/2018/05/21/LeetCode-837-New-21-Game/"/>
      <url>/2018/05/21/LeetCode-837-New-21-Game/</url>
      
        <content type="html"><![CDATA[<p>Alice plays the following game, loosely based on the card game “21”.</p><p>Alice starts with <code>0</code> points, and draws numbers while she has less than <code>K</code> points.  During each draw, she gains an integer number of points randomly from the range <code>[1, W]</code>, where <code>W</code> is an integer.  Each draw is independent and the outcomes have equal probabilities.</p><p>Alice stops drawing numbers when she gets <code>K</code> or more points.  What is the probability that she has <code>N</code> or less points?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">Output: 1.00000</span><br><span class="line">Explanation:  Alice gets a single card, then stops.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">Output: 0.60000</span><br><span class="line">Explanation:  Alice gets a single card, then stops.</span><br><span class="line">In 6 out of W &#x3D; 10 possibilities, she is at or below N &#x3D; 6 points.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">Output: 0.73278</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li><li><code>1 &lt;= W &lt;= 10000</code></li><li>Answers will be accepted as correct if they are within <code>10^-5</code> of the correct answer.</li><li>The judging time limit has been reduced for this question.</li></ol><a id="more"></a><p>这道题可以用DP+滑动窗口来解决。</p><p>最终获得N点的概率是<code>[N-W, N-1]</code>中每个点数出现的概率×<code>1/W</code>。所以<code>P(N)=P(N-1)-P(N-W-1)*1/W+P(N-1)*1/W</code>，这个步骤类似于把长度为W的窗口往前滑动一格。</p><p>要注意<code>&gt;=K</code>的点数要排除掉。最后要把<code>[K, N]</code>的所有概率加起来。</p><p>时间复杂度<code>O(n)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> f = (<span class="number">1</span> / (<span class="keyword">double</span>)W);</span><br><span class="line">        dp[<span class="number">1</span>] = f;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">double</span> t = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= W) &#123;</span><br><span class="line">                t -= f;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t -= (dp[j - W] * f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; K)</span><br><span class="line">                t += dp[j] * f;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= W) &#123;</span><br><span class="line">                t += f;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = t;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N; i++) &#123;</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 836. Rectangle Overlap</title>
      <link href="/2018/05/21/LeetCode-836-Rectangle-Overlap/"/>
      <url>/2018/05/21/LeetCode-836-Rectangle-Overlap/</url>
      
        <content type="html"><![CDATA[<p>A rectangle is represented as a list <code>[x1, y1, x2, y2]</code>, where <code>(x1, y1)</code> are the coordinates of its bottom-left corner, and <code>(x2, y2)</code> are the coordinates of its top-right corner.</p><p>Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.</p><p>Given two rectangles, return whether they overlap.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 &#x3D; [0,0,1,1], rec2 &#x3D; [1,0,2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ol><li>Both rectangles <code>rec1</code> and <code>rec2</code> are lists of 4 integers.</li><li>All coordinates in rectangles will be between <code>-10^9</code>and<code>10^9</code>.</li></ol> <a id="more"></a><p>判断两个矩形是否有相交，反过来思考什么条件下两个矩形不相交比较简单。如果</p><ul><li>一个矩形的下边比另一个上边大，那么它们不相交</li><li>一个矩形的左边比另一个右边大，那么它们不相交</li></ul><p>反之它们相交。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] || rec2[<span class="number">1</span>] &gt;= rec1[<span class="number">3</span>]) || (rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] || rec2[<span class="number">0</span>] &gt;= rec1[<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在CMU Solo OS是一种怎样的体验？</title>
      <link href="/2018/05/17/%E5%9C%A8CMU-solo-OS%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/05/17/%E5%9C%A8CMU-solo-OS%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>我想很多CMU的同学在选课的时候都搜到过关于<a href="https://www.cs.cmu.edu/~410/" target="_blank" rel="noopener">15410/15605 Operating System Design and Implementation</a>这门课的传说，比如<a href="https://www.zhihu.com/question/28249230/answer/131257766" target="_blank" rel="noopener">这篇</a>，比如<a href="http://www.1point3acres.com/bbs/thread-198949-1-1.html" target="_blank" rel="noopener">这篇</a>。BTW，我是从前面那篇介绍知道的这门课。以前学长们的介绍都挺详细了，我在这里就是记录一下我这个学期上这门课的体会吧，有很多地方与前人的介绍会有重复，毕竟这门课应该好久没有改过了😑。</p><a id="more"></a><h1 id="为什么我要选这门课">为什么我要选这门课</h1><p>在我一年多前看了这门课的介绍之后，我就决定一定要选上这门课。最吸引我的地方就是它的P3，也就是实现kernel的那个project。作为一个程序员，大家都是听着K&amp;R写Unix，Linus写Linux的传说长大的（误），谁不想亲手写一个OS内核？毕竟是程序员三大浪漫之一。</p><p>另外一个原因是虽然我在国内读本科的时候也上过OS课，但是远远没有达到能手写Kernel的水平，我想绝大多数国内的本科教学都没有达到这个高度。自学的话也很困难，一方面是写Kernel难度确实大，另一方面是没有相应的toolchain来debug，毕业以后再想尝试的话就只有找Kernel相关的工作了，所以这门课是一个挺宝贵的机会。</p><p>再加上看到前人对这门课的难度评价这么高，就激起了我的好胜心，偏要来试试。所以我也把这门课当作一个试炼，来检验我近六年的编程学习能不能hold住手写Kernel。</p><h1 id="课程介绍">课程介绍</h1><p>接下来是无聊的课程介绍，只想看我的主观看法的可以往下翻到下一节去了。</p><h2 id="选课">选课</h2><p>OS这门课不是有位置就能选的，它的waitlist不是一个FIFO结构，老师会手动的register，因此想选这门课的同学最好先上完三门system课（包括15213/15513/18600）。</p><h2 id="老师">老师</h2><p>我是在刚刚过去的18 Spring上的这门课，老师是<a href="http://www.cs.cmu.edu/~davide/" target="_blank" rel="noopener">Dave Eckhardt</a>和<a href="http://www.cs.cmu.edu/~bpr" target="_blank" rel="noopener">Brian Railing</a>。Dave教这门课教了挺久了，Brian也在教15213，所以老师们的水平是很高的。</p><p><img src="https://www.cs.cmu.edu/~davide/2009-09-01.4_sub_square_100.png" alt=""></p><p>上面这个大胡子就是Dave……</p><p>这门课应该在Fall和Spring都有开，但是Fall应该会有两个section，总人数都在40多人左右。</p><h2 id="lectures">Lectures</h2><p>每周上三次课，每次50分钟。Lecture的内容其实跟国内的差不多，进程线程，中断，虚拟内存，同步，死锁，自举，IPC，任务调度等等。后半部分会有一些比较现代一点的东西（其实也不算现代了……）比如虚拟化和内核安全。因为在大约midterm的时候就要开始写kernel project，所以一些比较重要的东西的进度会很快（虚拟内存，同步，调度等等），如果是初次接触这些概念的话可能会要花费大量的时间在上课以外，这个要注意。</p><h2 id="projects">Projects</h2><p>OS总共有5个Project，其中第三个和第四个是比较重要的，尤其以第四个Kernel project最重要。从第三个project开始是要两人的team来写。</p><h3 id="p0">P0</h3><p>第一个Project很简单，写一个stack backtrace的函数，被invoke的时候把调用栈打印出来。主要考察的就是对x86 C程序的call convention的了解程度。</p><h3 id="p1">P1</h3><p>第二个project是写一个跑在kernel space的小游戏，具体是什么游戏每年都在换，并不重要。主要是要编写键盘，时钟和console这三个驱动，实际操练一下怎么处理硬件中断。</p><h3 id="p2">P2</h3><p>第三个project的难度就有点提高了，也是开始要团队合作了（然而我不一样……看下文）。这个project要在user space实现一个multi-thread library以及相应的同步原语（synchronous primitive），就是一个类似于简易pthread的东西。提供一个写好的kernel（这个kernel的绝大多数功能都是在p3要实现的），在这个kernel上面写library。你需要处理thread的创建，销毁和同步，还要实现mutex，condition variable，semaphore和read/write lock等同步机制。这个project的难点在debug上，并发的同步问题debug起来非常恶心，但这个恰恰是OS这门课要搞明白的核心问题，并发问题从p2开始就会一直阴魂不散直到你考完Final为止。</p><h3 id="p3">P3</h3><p>大约在midterm之前的那一周，P3就会开始了，这个project的难度也体现在它的时间跨度上，单单这一个project就需要约50天，P2也只给了两周时间而已。</p><p>在这个project里，你要实现一个功能基本完整的抢占式分时多任务内核，主要包括：</p><ul><li>虚拟内存（使用二级页表）</li><li>内存管理</li><li>硬件驱动</li><li>多进程，多线程支持</li><li>时钟驱动的线程调度器</li><li>约二十多个系统调用</li><li>内核抢占</li><li>处理faults/exceptions</li></ul><p>我在写这个project的过程中，最困难的点就是实现一个优雅的上下文切换和内核同步了。Kernel在从一个thread切换到另一个thread的时候会进行上下文切换（context switch），这一部分需要保存thread的上下文（context），用汇编+thread的内核栈（kernel stack）可以非常优雅地实现它。而内核地同步机制需要在P2的同步原语的基础上做一些修改，因为P2依赖的是kernel的调度器，到P3调度器本身都会依赖这些原语，很容易就变成一个先有鸡还是先有蛋的问题。所以在P2的时候一定要尽量写得robust一点，不然一旦启用了时钟中断可能就炸的彻底。</p><p>这个Project的debug更恶心了，因为现在连一个可信的kernel都没有了，调试工具也不怎么好用，我面对各种死锁问题只能一点一点打log。另外，对于用汇编写的内存操作要极其小心地来安排，有时候会觉得是在捧着一大摞摇摇欲坠的玻璃杯，稍有不慎你辛辛苦苦写的kernel就死给你看。</p><p>我在这个Project上大约总共花了70-80小时的时间，代码量约在5000+左右，从三月初考完midterm一直到春假结束基本写完，<s>然后浪了一个多月</s>，所以50天还是非常充足的。</p><h3 id="p4">P4</h3><p>P4只有一周多的时间，要在P3的基础上实现一个更高级一点的功能，每个学期要实现的东西都不同，这学期要写一个user space的go风格协程库（实际上是要在P2的基础上来修改，只不过要跑在P3你写的Kernel上）+一个类似于signal的软时钟中断。没有什么普适性，就不多说了。</p><h2 id="成绩">成绩</h2><p>OS有期中和期末两次考试，最后成绩主要就是两次考试+Projects，两次考试都固定有一题是要手写一个新的sync数据结构和函数。其他题基本是简答题和找deadlock之类的问题。我觉得我的考试考的并不是很好，所以最后并没有拿到A……(T_T)，想拿A的话重点关注Projects和考试。</p><h1 id="体会">体会</h1><h2 id="难度">难度</h2><p>我想很多同学都是非常关心难度的问题，老实说，这是一个小马过河的问题，到底难不难你只有上过才知道。这门课我上下来觉得并没有传说中那么难，远远没有难到无法下手的程度，对我来说，可能没有一些Advanced XXX的读论文的课来的难<s>能用代码解决的问题都不是问题</s>，毕竟它只是一门本科生课程。</p><p>如果你本科的时候上过OS，或者对于自己的C语言功底有自信，那么我觉得选这门课还是很不错的。但是有一点要注意，这门课有15学分，不同于大多数课的12学分，而ECE的master有每学期48学分的选课限制，因此如果你一学期需要三门课来保持合法身份，那么选了这门课，你就没法再选一门课当作备份，也就是说不采取一些其他措施的话不能中途drop掉它。</p><h2 id="team">Team</h2><p>之前说了这门课从P2开始是组队写，然而我因为种种原因，错过了组队那节课，导致只能孤家寡人的solo所有project。我发现找不到partner之后有几天非常恐慌，觉得这门课很有可能要fail了，但是实际写下来，发现team和solo各自有利有弊。Team的好处是各种问题都有人可以讨论，不容易走入死胡同出不来，而缺点是两个人合作互相之间的沟通成本很高（仍然是一个同步问题），以及代码的质量问题会被放大。而Solo就不存在沟通的问题。</p><h2 id="其他学到的东西">其他学到的东西</h2><p>除了OS的知识以外，我想我还从这门课中学到了一些其他的东西。我觉得最重要的一条就是<em>There is no magic</em>，内核再复杂，也是像我这种普通人能力可及的范围，它不是魔法，这让我在以后面对复杂项目的时候不至于一下子被吓倒，我觉得这种信心是很重要的。</p><p>另一点就是一个好的设计可以成倍地节约debug时间，P4的时候我就没有仔细的重新设计结构，导致debug的时候到处都是问题并且重构成本极高。</p><h1 id="这学期的其他课">这学期的其他课</h1><p>为了OS，我这学期特意选了两门看上去不是很难的课，虽然最后实际上不需要这么小心翼翼ㄟ( ▔, ▔ )ㄏ。</p><h2 id="17437-web-application-development">17437 Web Application Development</h2><p>就是从最基础的HTML开始学WEB开发，讲的东西都很基础，后端是用Django。说实话我并不是很推荐，因为这个课讲的东西实在是太基础了，完全是可以自学的。前端部分最难也就是到AJAX+jQuery，在现在的前端圈子看来大概是属于上古技术了。后端也就是写写models，forms，templates等一些很烦的东西。只有期末考试，选择题+简答题+手写Django应用题←没错也是手写。</p><h2 id="14735-secure-code">14735 Secure Code</h2><p>主要讲如何写安全的C/C++，少量的其他类型程序的安全性。这门课可以做ECE master的核心课。这门课有约一半的时间是在看汇编找漏洞并且构造攻击输入来达到运行特定函数的目的<s>硬核黑客</s>，虽然基本都是各种字符串溢出问题，但这一部分还是挺有意思的，剩下的时间会讲一些fuzzing，formal method之类的内容。没有考试。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三门问题（蒙提霍尔问题）</title>
      <link href="/2018/04/07/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%88%E8%92%99%E6%8F%90%E9%9C%8D%E5%B0%94%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2018/04/07/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%88%E8%92%99%E6%8F%90%E9%9C%8D%E5%B0%94%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>三门问题，又称<a href="https://zh.wikipedia.org/zh-hans/%E8%92%99%E6%8F%90%E9%9C%8D%E7%88%BE%E5%95%8F%E9%A1%8C" target="_blank" rel="noopener">蒙提霍尔问题</a>我很久以前就在网上看到过，但是一直对于网上流传的各种复杂的概率解释没什么兴趣，也一直没有想明白。昨天跟朋友突然说起这个问题，起因是虎扑的这个<a href="https://bbs.hupu.com/21882854.html" target="_blank" rel="noopener">帖子</a>试图用蒙特卡罗模拟来实验一下（可惜的是，这个程序写的有点小错误，不知道你发现没有），也激发了我想来用程序模拟一下的想法，没想到思考了一会之后发现从逻辑的角度来说可以非常简单的解释和理解，不需要任何概率统计的知识（或者说，小学水平？）。</p><a id="more"></a><h1 id="问题">问题</h1><blockquote><p>参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车或者是奖品，选中后面有车的那扇门就可以赢得该汽车或奖品，而另外两扇门后面则各藏有一只山羊或者是后面没有任何东西。当参赛者选定了一扇门，但未去开启它的时候，知道门后情形的节目主持人会开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机会率？</p></blockquote><p>以上问题描述摘自维基百科。</p><p>首先有一点可以明确：如果参赛者不更换的话，那么他选中汽车的概率是1/3,这与主持人做了什么完全无关。所以我们现在要考虑的是参赛者会更换选择的情况，也就是说，我们假定参赛者在主持人开门后一定会更换选择。</p><h1 id="穷举？">穷举？</h1><p>我昨天在一开始思考的时候，因为只有三扇门，所以很自然地想到了穷举这个万金油解法：</p><ol><li>假设两者羊是不同的（羊A，羊B），这样是为了思考起来更清晰</li><li>那么初始的排列情况便是3的全排列，3×2×1=6种</li><li>一开始选手从三扇门里面随机选择一扇，于是有3×6=18种情况，其中12种选中了羊，6种选中了车</li><li>如果选手运气比较差一开始选中了羊，那么主持人只能打开另一扇有羊的门，所以依然是12种情况，更换后选中车</li><li>如果选手一开始选中了车，那么主持人就有两种开门选择（羊A/羊B），所以有6×2=12种情况，更换后选中羊</li><li>所以更换选择后选中车的概率是12/24=1/2。嗯？</li></ol><p>如果你看过这个问题的答案的话，就会知道1/2这个答案是错误的，然而错在那里了呢？我在昨天洗澡的时候想通了这个问题（我发现洗澡的时候经常能想通一些问题）。本文的读者如果不明白的话可以先思考一下，我后面再解释错在哪里。</p><h1 id="coding">Coding</h1><blockquote><p>Talk is cheap. Show me the code.</p></blockquote><p>后来我尝试写程序来模拟一下结果，在构思程序的时候发现一个关键问题：<strong>什么情况下会在变换选择后会选到汽车？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from random import choice</span><br><span class="line"></span><br><span class="line"># Number of cycles that the player changes to the car</span><br><span class="line">change_to_right &#x3D; 0</span><br><span class="line">cycles &#x3D; 10000</span><br><span class="line"></span><br><span class="line">for i in range(0, cycles):</span><br><span class="line">  doors &#x3D; [0, 0, 0]</span><br><span class="line">  index &#x3D; [0, 1, 2]</span><br><span class="line">  car &#x3D; choice(index)</span><br><span class="line">  </span><br><span class="line">  choose &#x3D; choice(index)</span><br><span class="line">  # PROBLEM</span><br><span class="line">  if ？:</span><br><span class="line">    change_to_right +&#x3D; 1</span><br><span class="line"></span><br><span class="line">print(float(change_to_right) &#x2F; float(cycles))</span><br></pre></td></tr></table></figure><p>参赛者在第一次选择之后，有两种情况，选中车（1/3），选中羊（2/3），再来分情况讨论一下：</p><ol><li>如果第一次选中了车，那么主持人打开一扇门之后，剩下的一扇门里面也是羊，此时如果更换选择（我们已经假设一定会），则<strong>肯定会选到羊</strong></li><li>如果第一次选中了羊，那么主持人只能打开另一扇有羊的门，此时更换选择，则<strong>肯定会选到车</strong></li></ol><p>到这里就很清楚了，如果第一次没选中，则更换后就会选中（2/3），如果第一次选中，则更换后就不会选中（1/3）。因此更换选择选中车的概率是2/3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from random import choice</span><br><span class="line"></span><br><span class="line"># Number of cycles that the player changes to the car</span><br><span class="line">change_to_right &#x3D; 0</span><br><span class="line">cycles &#x3D; 10000</span><br><span class="line"></span><br><span class="line">for i in range(0, cycles):</span><br><span class="line">  doors &#x3D; [0, 0, 0]</span><br><span class="line">  index &#x3D; [0, 1, 2]</span><br><span class="line">  car &#x3D; choice(index)</span><br><span class="line">  </span><br><span class="line">  choose &#x3D; choice(index)</span><br><span class="line">  if choose !&#x3D; car:</span><br><span class="line">    change_to_right +&#x3D; 1</span><br><span class="line"></span><br><span class="line">print(float(change_to_right) &#x2F; float(cycles))</span><br></pre></td></tr></table></figure><h1 id="那么穷举错在哪里？">那么穷举错在哪里？</h1><p>聪明的读者应该已经发现前文的穷举法错在哪里，问题就在于最后计算概率的时候</p><blockquote><ol><li>所以更换选择后选中车的概率是12/24=1/2。</li></ol></blockquote><p>这里24是12+12得来的。然而这么计算是有前提的，就是这24种情况是<strong>等概率的</strong>（概率都忘光了，应该是这么说吧），结果错误的原因就是这24种情况不等概率。</p><blockquote><ol><li>如果选手运气比较差一开始选中了羊，那么主持人只能打开另一扇有羊的门，所以依然是12种情况，更换后选中车</li><li>如果选手一开始选中了车，那么主持人就有两种开门选择（羊A/羊B），所以有6×2=12种情况，更换后选中羊</li></ol></blockquote><p>在第四步中，主持人其实也有两种选择（所以如果不考虑门后是车还是羊的话，应该有18×2=36种最终情况），但是其中一种打开是车，主持人会<strong>回避掉</strong>这种情况，这就使第四步中那12种情况的出现概率翻倍了（原本的概率+主持人打开有车的门的概率），因此选中车的概率仍然是(12×2)/(12×2+12)=2/3。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 因垂丝汀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 803. Bricks Falling When Hit</title>
      <link href="/2018/03/18/LeetCode-803-Bricks-Falling-When-Hit/"/>
      <url>/2018/03/18/LeetCode-803-Bricks-Falling-When-Hit/</url>
      
        <content type="html"><![CDATA[<p>We have a grid of 1s and 0s; the 1s in a cell represent bricks. A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.</p><p>We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.</p><p>Return an array representing the number of bricks that will drop after each erasure in sequence.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: </span><br><span class="line">grid &#x3D; [[1,0,0,0],[1,1,1,0]]</span><br><span class="line">hits &#x3D; [[1,0]]</span><br><span class="line">Output: [2]</span><br><span class="line">Explanation: </span><br><span class="line">If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: </span><br><span class="line">grid &#x3D; [[1,0,0,0],[1,1,0,0]]</span><br><span class="line">hits &#x3D; [[1,1],[1,0]]</span><br><span class="line">Output: [0,0]</span><br><span class="line">Explanation: </span><br><span class="line">When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>The number of rows and columns in the grid will be in the range [1, 200].</li><li>The number of erasures will not exceed the area of the grid.</li><li>It is guaranteed that each erasure will be located inside the grid.</li><li>An erasure may refer to a location with no brick - if it does, no bricks drop.</li></ul><a id="more"></a><p>这道题比赛的时候没有想出来，看了下AC的代码，发现可以用反向的并查集来做。这个反向的思维就是关键了。</p><p>先把<code>hits</code>正向走一遍，删除要删除的节点。最后得到一个剩余的bricks的图，把这些剩余的bricks用并查集分类，为了后面的方便，可以在头节点记录集合中有多少个bricks，在merge的时候把数量也merge了。merge的时候对于top的bricks特殊考虑，优先把它们作为head。</p><p>接着逆向地把<code>hits</code>删掉的bricks一个一个加回去，每次都与四个方向merge。merge之后看该brick的head是否在top，如果不在，说明这次remove没有导致任何bricks fall。如果在，说明有掉落，那么merge的时候head不在top的bricks集合就是本次删除会fall的bricks。</p><p>代码写的不是很好看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; afterGrid;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; uf;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; setNum;</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hitBricks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; hits)</span> </span>&#123;</span><br><span class="line">        row = grid.size();</span><br><span class="line">        col = grid[<span class="number">0</span>].size();</span><br><span class="line">        init (grid, hits);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = hits[i][<span class="number">0</span>], y = hits[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!grid[x][y]) &#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            afterGrid[x][y] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">auto</span> p1 = make_pair(x, y);</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            uf[x][y] = make_pair(x, y);</span><br><span class="line">            setNum[x][y] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;k : directions) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p2 = make_pair(x + k.first, y + k.second);</span><br><span class="line">                <span class="keyword">if</span> (!valid(p2) || afterGrid[p2.first][p2.second] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> h2 = head(p2);</span><br><span class="line">                <span class="keyword">auto</span> h1 = head(p1);</span><br><span class="line">                <span class="keyword">if</span> (h1 == h2) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (h2.first != <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt += setNum[h2.first][h2.second];</span><br><span class="line">                &#125;</span><br><span class="line">                merge(p1, p2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> h = head(p1);</span><br><span class="line">            <span class="keyword">if</span> (h.first != <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; hits)</span> </span>&#123;</span><br><span class="line">        afterGrid = grid;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;hit : hits) &#123;</span><br><span class="line">            afterGrid[hit[<span class="number">0</span>]][hit[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uf = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt;(row, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;(col, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">        setNum.assign(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!afterGrid[i][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                uf[i][j] = make_pair(i, j);</span><br><span class="line">                setNum[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!afterGrid[i][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> p1 = make_pair(i, j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;k : directions) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> p2 = make_pair(i + k.first, j + k.second);</span><br><span class="line">                    <span class="keyword">if</span> (!valid(p2) || afterGrid[p2.first][p2.second] == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    merge(p1, p2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.first &gt;= <span class="number">0</span> &amp;&amp; p.first &lt; row &amp;&amp; p.second &gt;= <span class="number">0</span> &amp;&amp; p.second &lt; col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;int, int&gt; head(pair&lt;int, int&gt; p) &#123;</span><br><span class="line">        <span class="keyword">while</span> (uf[p.first][p.second] != p) &#123;</span><br><span class="line">            p = uf[p.first][p.second];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> h1 = head(a), h2 = head(b);</span><br><span class="line">        <span class="keyword">if</span> (h1 == h2)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (h1.first == <span class="number">0</span>) &#123;</span><br><span class="line">            uf[h2.first][h2.second] = h1;</span><br><span class="line">            setNum[h1.first][h1.second] += setNum[h2.first][h2.second];</span><br><span class="line">            setNum[h2.first][h2.second] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            uf[h1.first][h1.second] = h2;</span><br><span class="line">            setNum[h2.first][h2.second] += setNum[h1.first][h1.second];</span><br><span class="line">            setNum[h1.first][h1.second] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 802. Find Eventual Safe States</title>
      <link href="/2018/03/18/LeetCode-802-Find-Eventual-Safe-States/"/>
      <url>/2018/03/18/LeetCode-802-Find-Eventual-Safe-States/</url>
      
        <content type="html"><![CDATA[<p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p><p>Now, say our starting node is *eventually safe *if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number <code>K</code> so that for any choice of where to walk, we must have stopped at a terminal node in less than <code>K</code> steps.</p><p>Which nodes are eventually safe? Return them as an array in sorted order.</p><p>The directed graph has <code>N</code> nodes with labels <code>0, 1, ..., N-1</code>, where <code>N</code> is the length of <code>graph</code>. The graph is given in the following form: <code>graph[i]</code> is a list of labels <code>j</code> such that <code>(i, j)</code> is a directed edge of the graph.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: graph &#x3D; [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Here is a diagram of the above graph.</span><br></pre></td></tr></table></figure><p><a href="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" target="_blank" rel="noopener"><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" alt="Illustration of graph"></a></p><p><strong>Note:</strong></p><ul><li><code>graph</code> will have length at most <code>10000</code>.</li><li>The number of edges in the graph will not exceed <code>32000</code>.</li><li>Each <code>graph[i]</code> will be a sorted list of different integers, chosen within the range <code>[0, graph.length - 1]</code>.</li></ul><a id="more"></a><p>这道题可以用找环来解决，所有在环中的node和后继node有在环中的node都不是safe的。使用DFS来搜索环，遇到已经判断过的就不需要再继续搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; circle;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        circle.assign(graph.size(), <span class="number">0</span>);</span><br><span class="line">        visited.assign(graph.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); i++) &#123;</span><br><span class="line">            dfs(graph, path, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; circle.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!circle[i])</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (circle[node] || path.count(node)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> i : path) &#123;</span><br><span class="line">                    circle[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[node] = <span class="number">1</span>;</span><br><span class="line">        path.insert(node);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : graph[node]) &#123;</span><br><span class="line">            dfs(graph, path, i);</span><br><span class="line">        &#125;</span><br><span class="line">        path.erase(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 801. Minimum Swaps To Make Sequences Increasing</title>
      <link href="/2018/03/18/LeetCode-801-Minimum-Swaps-To-Make-Sequences-Increasing/"/>
      <url>/2018/03/18/LeetCode-801-Minimum-Swaps-To-Make-Sequences-Increasing/</url>
      
        <content type="html"><![CDATA[<p>We have two integer sequences <code>A</code> and <code>B</code> of the same non-zero length.</p><p>We are allowed to swap elements <code>A[i]</code> and <code>B[i]</code>. Note that both elements are in the same index position in their respective sequences.</p><p>At the end of some number of swaps, <code>A</code> and <code>B</code> are both strictly increasing. (A sequence is <em>strictly increasing</em> if and only if <code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>.)</p><p>Given A and B, return the minimum number of swaps to make both sequences strictly increasing. It is guaranteed that the given input always makes it possible.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: A &#x3D; [1,3,5,4], B &#x3D; [1,2,3,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Swap A[3] and B[3].  Then the sequences are:</span><br><span class="line">A &#x3D; [1, 3, 5, 7] and B &#x3D; [1, 2, 3, 4]</span><br><span class="line">which are both strictly increasing.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><code>A, B</code> are arrays with the same length, and that length will be in the range <code>[1, 1000]</code>.</li><li><code>A[i], B[i]</code> are integer values in the range <code>[0, 2000]</code>.</li></ul><a id="more"></a><p>使用DP，如果array长度为n，那么使用2行n列的二维DP。<code>dp[0][i]</code>保存<code>i</code>位置没有交换的步数，<code>dp[1][i]</code>保存<code>i</code>位置交换了的最小步数。与<code>i-1</code>位置的情况组合之后有四种情况。但是实际上只有两种：</p><ol><li>在<code>i-1</code>位置没有交换的情况下<code>i</code>位置不需要交换；<code>i-1</code>和<code>i</code>位置都进行了交换。这两种情况都是<code>A</code>和<code>B</code>的<code>i</code>元素分别大于<code>i-1</code>元素。</li><li>如果<code>A</code>或<code>B</code>中有一个不满足递增，那么就要交换，分为<code>i-1</code>交换和<code>i</code>交换两种。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, INT_MAX))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>] &amp;&amp; B[i] &gt; B[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = min(dp[<span class="number">0</span>][i], dp[<span class="number">0</span>][i - <span class="number">1</span>]);</span><br><span class="line">                dp[<span class="number">1</span>][i] = min(dp[<span class="number">1</span>][i], dp[<span class="number">1</span>][i - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; B[i - <span class="number">1</span>] &amp;&amp; B[i] &gt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = min(dp[<span class="number">0</span>][i], dp[<span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">                dp[<span class="number">1</span>][i] = min(dp[<span class="number">1</span>][i], dp[<span class="number">0</span>][i - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">0</span>][len - <span class="number">1</span>], dp[<span class="number">1</span>][len - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 800. Similar RGB Color</title>
      <link href="/2018/03/18/LeetCode-800-Similar-RGB-Color/"/>
      <url>/2018/03/18/LeetCode-800-Similar-RGB-Color/</url>
      
        <content type="html"><![CDATA[<p>In the following, every capital letter represents some hexadecimal digit from <code>0</code> to <code>f</code>.</p><p>The red-green-blue color <code>&quot;#AABBCC&quot;</code> can be written as <code>&quot;#ABC&quot;</code> in shorthand. For example, <code>&quot;#15c&quot;</code> is shorthand for the color <code>&quot;#1155cc&quot;</code>.</p><p>Now, say the similarity between two colors <code>&quot;#ABCDEF&quot;</code> and <code>&quot;#UVWXYZ&quot;</code> is <code>-(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2</code>.</p><p>Given the color <code>&quot;#ABCDEF&quot;</code>, return a 7 character color that is most similar to <code>#ABCDEF</code>, and has a shorthand (that is, it can be represented as some <code>&quot;#XYZ&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: color &#x3D; &quot;#09f166&quot;</span><br><span class="line">Output: &quot;#11ee66&quot;</span><br><span class="line">Explanation:  </span><br><span class="line">The similarity is -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 &#x3D; -64 -9 -0 &#x3D; -73.</span><br><span class="line">This is the highest among any shorthand color.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><code>color</code> is a string of length <code>7</code>.</li><li><code>color</code> is a valid RGB color: for <code>i &gt; 0</code>, <code>color[i]</code> is a hexadecimal digit from <code>0</code> to <code>f</code></li><li>Any answer which has the same (highest) similarity as the best answer will be accepted.</li><li>All inputs and outputs should use lowercase letters, and the output is 7 characters.</li></ul><a id="more"></a><p>暴力穷举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> shex = <span class="string">"0123456789abcdef"</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">similarRGB</span><span class="params">(<span class="built_in">string</span> color)</span> </span>&#123;</span><br><span class="line">        color = color.substr(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">"000"</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> minVal = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shex.length(); i++) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = shex[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; shex.length(); j++) &#123;</span><br><span class="line">                ans[<span class="number">1</span>] = shex[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; shex.length(); k++) &#123;</span><br><span class="line">                    ans[<span class="number">2</span>] = shex[k];</span><br><span class="line">                    <span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : ans) &#123;</span><br><span class="line">                        tmp.push_back(ch); tmp.push_back(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> val = calc(color, tmp);</span><br><span class="line">                    <span class="keyword">if</span> (minVal &lt; val) &#123;</span><br><span class="line">                        minVal = val;</span><br><span class="line">                        ret = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span> <span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp1 = a.substr(i, <span class="number">2</span>), tmp2 = b.substr(i, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> v1 = stoi(tmp1, <span class="literal">nullptr</span>, <span class="number">16</span>), v2 = stoi(tmp2, <span class="literal">nullptr</span>, <span class="number">16</span>);</span><br><span class="line">            ans -= (v1 - v2) * (v1 - v2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 765. Couples Holding Hands</title>
      <link href="/2018/01/14/LeetCode-765-Couples-Holding-Hands/"/>
      <url>/2018/01/14/LeetCode-765-Couples-Holding-Hands/</url>
      
        <content type="html"><![CDATA[<p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A <em>swap</em> consists of choosing <strong>any</strong> two people, then they stand up and switch seats.</p><p>The people and seats are represented by an integer from <code>0</code> to <code>2N-1</code>, the couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2N-2, 2N-1)</code>.</p><p>The couples’ initial seating is given by <code>row[i]</code> being the value of the person who is initially sitting in the i-th seat.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: row &#x3D; [0, 2, 1, 3]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: row &#x3D; [3, 2, 0, 1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: All couples are already seated side by side.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>len(row)</code> is even and in the range of <code>[4, 60]</code>.</li><li><code>row</code> is guaranteed to be a permutation of <code>0...len(row)-1</code>.</li></ol><a id="more"></a><p>说是Hard，其实并不Hard。从前到后依次把应该配对的人配好对就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">seats</span><span class="params">(row.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.size(); i++) &#123;</span><br><span class="line">            seats[row[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> couple;</span><br><span class="line">            <span class="keyword">if</span> (row[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                couple = row[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                couple = row[i] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (row[i + <span class="number">1</span>] != couple) &#123;</span><br><span class="line">                <span class="keyword">int</span> coupleSeat = seats[couple];</span><br><span class="line">                swap(seats[row[i + <span class="number">1</span>]], seats[couple]);</span><br><span class="line">                swap(row[i + <span class="number">1</span>], row[coupleSeat]);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 764. Largest Plus Sign</title>
      <link href="/2018/01/14/LeetCode-764-Largest-Plus-Sign/"/>
      <url>/2018/01/14/LeetCode-764-Largest-Plus-Sign/</url>
      
        <content type="html"><![CDATA[<p>In a 2D <code>grid</code> from (0, 0) to (N-1, N-1), every cell contains a <code>1</code>, except those cells in the given list <code>mines</code> which are <code>0</code>. What is the largest axis-aligned plus sign of <code>1</code>s contained in the grid? Return the order of the plus sign. If there is none, return 0.</p><p>An “<em>axis-aligned plus sign of 1s</em> of order <strong>k</strong>” has some center <code>grid[x][y] = 1</code> along with 4 arms of length <code>k-1</code> going up, down, left, and right, and made of <code>1</code>s. This is demonstrated in the diagrams below. Note that there could be <code>0</code>s or <code>1</code>s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.</p><p><strong>Examples of Axis-Aligned Plus Signs of Order k:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Order 1:</span><br><span class="line">000</span><br><span class="line">010</span><br><span class="line">000</span><br><span class="line"></span><br><span class="line">Order 2:</span><br><span class="line">00000</span><br><span class="line">00100</span><br><span class="line">01110</span><br><span class="line">00100</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Order 3:</span><br><span class="line">0000000</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0111110</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0000000</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 5, mines &#x3D; [[4, 2]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11011</span><br><span class="line">In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 2, mines &#x3D; []</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">There is no plus sign of order 2, but there is of order 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 1, mines &#x3D; [[0, 0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">There is no plus sign, so return 0.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>N</code> will be an integer in the range <code>[1, 500]</code>.</li><li><code>mines</code> will have length at most <code>5000</code>.</li><li><code>mines[i]</code> will be length 2 and consist of integers in the range <code>[0, N-1]</code>.</li><li><em>(Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)</em></li></ol><a id="more"></a><p>这道题对我来说挺坑的，我一开始不想用二位数组来保存mines的位置，而是使用<code>set</code>\<code>unordered_set</code>来保存，导致超时……后来又想了很久找到了另一种解法。</p><h2 id="brute-force">Brute force</h2><p>对每一个点，都依次向外搜索最大的+，最坏时间复杂度为O(n<sup>3</sup>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int64_t</span> &gt; mines;</span><br><span class="line">    <span class="keyword">int</span> _N;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; _mines)</span> </span>&#123;</span><br><span class="line">        _N = N;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zeros</span><span class="params">(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v: _mines) &#123;</span><br><span class="line">            zeros[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans != <span class="number">0</span> &amp;&amp; (!valid(i - ans + <span class="number">1</span>, j) || !valid(i + ans - <span class="number">1</span>, j) || !valid(i, j - ans + <span class="number">1</span>) || !valid(i, j + ans - <span class="number">1</span>)))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; ; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> l = k - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!valid(i - l, j) || zeros[i - l][j]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!valid(i + l, j) || zeros[i + l][j]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!valid(i, j - l) || zeros[i][j - l]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!valid(i, j + l) || zeros[i][j + l]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ans = max(ans, k);</span><br><span class="line">                    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; ans * <span class="number">2</span> == N) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; ans * <span class="number">2</span> - <span class="number">1</span> == N) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; _N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; _N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="dp">DP</h2><p>用四次二维DP，分别找到每个点的上下左右四个方向的最长的连续1的个数，然后对每一个点从这四个长度中选择最小值，就是该点的最大+大小。时间复杂度O(n<sup>2</sup>)。</p><p>要注意这个方法很容易超内存，所以我不得已把三维数组改成了二位数组循环利用四次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int32_t</span> &gt; mines;</span><br><span class="line">    <span class="keyword">int</span> _N;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; _mines)</span> </span>&#123;</span><br><span class="line">        _N = N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : _mines) &#123;</span><br><span class="line">            mines.insert((<span class="keyword">int32_t</span>)v[<span class="number">0</span>] &lt;&lt; <span class="number">16</span> | (<span class="keyword">int32_t</span>)v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">len</span><span class="params">(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, INT_MAX))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isMine(i, <span class="number">0</span>)) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                len[i][<span class="number">0</span>] = min(len[i][<span class="number">0</span>], dp[i][<span class="number">0</span>]);</span><br><span class="line">                ans = max(ans, len[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isMine(i, j))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                len[i][j] = min(len[i][j], dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp.assign(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isMine(<span class="number">0</span>, i)) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                len[<span class="number">0</span>][i] = min(len[<span class="number">0</span>][i], dp[<span class="number">0</span>][i]);</span><br><span class="line">                ans = max(ans, len[<span class="number">0</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isMine(i, j))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                len[i][j] = min(len[i][j], dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp.assign(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isMine(N - <span class="number">1</span>, i)) &#123;</span><br><span class="line">                dp[N - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">                len[N - <span class="number">1</span>][i] = min(len[N - <span class="number">1</span>][i], dp[N - <span class="number">1</span>][i]);</span><br><span class="line">                ans = max(ans, len[N - <span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isMine(i, j))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                len[i][j] = min(len[i][j], dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp.assign(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isMine(i, N - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                len[i][N - <span class="number">1</span>] = min(len[i][N - <span class="number">1</span>], dp[i][N - <span class="number">1</span>]);</span><br><span class="line">                ans = max(ans, len[i][N - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isMine(i, j))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = dp[i][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                len[i][j] = min(len[i][j], dp[i][j]);</span><br><span class="line">                ans = max(ans, len[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMine</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">bool</span>)mines.count((<span class="keyword">int32_t</span>)x &lt;&lt; <span class="number">16</span> | (<span class="keyword">int32_t</span>)y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; _N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; _N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 763. Partition Labels</title>
      <link href="/2018/01/14/LeetCode-763-Partition-Labels/"/>
      <url>/2018/01/14/LeetCode-763-Partition-Labels/</url>
      
        <content type="html"><![CDATA[<p>A string <code>S</code> of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>S</code> will have length in range <code>[1, 500]</code>.</li><li><code>S</code> will consist of lowercase letters (<code>'a'</code> to <code>'z'</code>) only.</li></ol><a id="more"></a><p>从前往后和从后往前遍历一遍数组，对于每一个元素，记录它之前（含自己）和之后（含自己）每个字符出现的个数。然后再遍历一次，每一个字符都没有在某下标之前和之后都出现，那么这个下标就可以用来分割。注意结尾的corner case。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; front, back;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = S[i];</span><br><span class="line">            v[ch - <span class="string">'a'</span>]++;</span><br><span class="line">            front.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v.assign(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = S[i];</span><br><span class="line">            v[ch - <span class="string">'a'</span>]++;</span><br><span class="line">            back.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(back.begin(), back.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(front[i][j] == <span class="number">0</span> || back[i + <span class="number">1</span>][j] == <span class="number">0</span>)) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans.push_back(i + <span class="number">1</span> - prev);</span><br><span class="line">                prev = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev != S.length()) &#123;</span><br><span class="line">            ans.push_back(S.length() - prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 762. Prime Number of Set Bits in Binary Representation</title>
      <link href="/2018/01/14/LeetCode-762-Prime-Number-of-Set-Bits-in-Binary-Representation/"/>
      <url>/2018/01/14/LeetCode-762-Prime-Number-of-Set-Bits-in-Binary-Representation/</url>
      
        <content type="html"><![CDATA[<p>Given two integers <code>L</code> and <code>R</code>, find the count of numbers in the range <code>[L, R]</code> (inclusive) having a prime number of set bits in their binary representation.</p><p>(Recall that the number of set bits an integer has is the number of <code>1</code>s present when written in binary. For example, <code>21</code> written in binary is <code>10101</code> which has 3 set bits. Also, 1 is not a prime.)</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: L &#x3D; 6, R &#x3D; 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">6 -&gt; 110 (2 set bits, 2 is prime)</span><br><span class="line">7 -&gt; 111 (3 set bits, 3 is prime)</span><br><span class="line">9 -&gt; 1001 (2 set bits , 2 is prime)</span><br><span class="line">10-&gt;1010 (2 set bits , 2 is prime)</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: L &#x3D; 10, R &#x3D; 15</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">10 -&gt; 1010 (2 set bits, 2 is prime)</span><br><span class="line">11 -&gt; 1011 (3 set bits, 3 is prime)</span><br><span class="line">12 -&gt; 1100 (2 set bits, 2 is prime)</span><br><span class="line">13 -&gt; 1101 (3 set bits, 3 is prime)</span><br><span class="line">14 -&gt; 1110 (3 set bits, 3 is prime)</span><br><span class="line">15 -&gt; 1111 (4 set bits, 4 is not prime)</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>L, R</code> will be integers <code>L &lt;= R</code> in the range <code>[1, 10^6]</code>.</li><li><code>R - L</code> will be at most 10000.</li></ol><a id="more"></a><p>没什么好说的，数有几个1就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimeSetBits</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; primes = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                cnt += (tmp &amp; <span class="number">0x1</span>);</span><br><span class="line">                tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (primes.count(cnt)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换了博客字体</title>
      <link href="/2018/01/12/%E6%9B%B4%E6%8D%A2%E4%BA%86%E5%8D%9A%E5%AE%A2%E5%AD%97%E4%BD%93/"/>
      <url>/2018/01/12/%E6%9B%B4%E6%8D%A2%E4%BA%86%E5%8D%9A%E5%AE%A2%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>博客换字体了，中文字体使用<a href="https://github.com/adobe-fonts/source-han-serif" target="_blank" rel="noopener">思源宋体</a>，英文使用Droid Serif。</p><p>在网页上使用web font中文字体还真是一个很坑的东西，英文字体因为字母和符号数量少，所以体积很小，而CJK文字因为汉字数量太多，导致字体文件一个个体积巨大，难以像英文一样应用在网页上，所以一般都是使用操作系统中预置的字体 ，比如微软雅黑，黑体，宋体等等。</p><p>思源宋体本身也很大，但是Adobe提供了<a href="http://typekit.com/fonts" target="_blank" rel="noopener">Typekit</a>这个工具，可以让网页动态加载它提供的中文字体，也就是使用JS实时地分析网页使用的字体，只下载使用到的字体。这个方法的缺点就是从打开页面到字体下载完毕之间有一个时间差，强迫症可能会觉得难受。</p><p>更好的办法其实是用<a href="http://font-spider.org/" target="_blank" rel="noopener">字蛛</a>这个工具预先提取好字体，但是我还没有搞清楚怎么跟Hexo配合起来，以后有机会再弄吧。</p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 460. LFU Cache</title>
      <link href="/2018/01/11/LeetCode-460-LFU-Cache/"/>
      <url>/2018/01/11/LeetCode-460-LFU-Cache/</url>
      
        <content type="html"><![CDATA[<p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank" rel="noopener">Least Frequently Used (LFU)</a> cache. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least <strong>recently</strong> used key would be evicted.</p><p><strong>Follow up:</strong>Could you do both operations in <strong>O(1)</strong> time complexity?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LFUCache cache &#x3D; new LFUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3.</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1.</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure><a id="more"></a><p>这道题的主要难点在于插入和查询都是O(1)的复杂度，单纯查询O(1)用哈希表就可以做到，但是LFU要更新访问次数，这个步骤难以做到O(1)。最容易想到的方法，使用Heap来维护访问次数的话，evict操作可以是O(1)，更新访问次数的操作只能是O(logn)。</p><p>在这道题中使用链表+哈希表是一个很聪明的方法。其中链表是双重的，第一层链表的每一个节点指向一个包含特定访问次数的key-value对的链表，这个第二层链表很像是没有路径压缩的并查集，因为要按照时间顺序排列，所以不能采用路径压缩。针对一个key，从哈希表中找到对应的二级链表节点以及该二级链表节点所在的一级链表节点，从原二级链表中删除，如果原一级链表节点的下一个节点对应的访问次数是原访问次数+1，那么它就是应插入的位置；否则在一级链表中插入一个新的节点对应该访问次数。为了节省空间，对应二级链表为空的一级链表节点要删除。</p><p>evict的时候，删除最后一个二级链表节点的第一个元素就可以了。这样<code>get</code>和<code>put</code>操作就都可以在O(1)的时间复杂度内完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> NodeListNode = pair&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; _m;</span><br><span class="line">    <span class="built_in">list</span>&lt;NodeListNode&gt; _q;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;NodeListNode&gt;::iterator&gt; refCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        _c = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!_m.count(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        increaseCount(key);</span><br><span class="line">        <span class="keyword">auto</span> iter = _m[key];</span><br><span class="line">        <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_c &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (_m.count(key)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = _m[key];</span><br><span class="line">            iter-&gt;second = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_m.size() &gt;= _c) &#123;</span><br><span class="line">                evict();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator nextKeyIter;</span><br><span class="line">            <span class="keyword">if</span> (_q.empty() || _q.front().first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _q.emplace_front(<span class="number">1</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">                nextKeyIter = _q.front().second.insert(_q.front().second.end(), make_pair(key, value));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nextKeyIter = _q.front().second.insert(_q.front().second.end(), make_pair(key, value));</span><br><span class="line">            &#125;</span><br><span class="line">            _m[key] = nextKeyIter;</span><br><span class="line">        &#125;</span><br><span class="line">        increaseCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increaseCount</span> <span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!refCount.count(key)) &#123;</span><br><span class="line">            refCount[key] = _q.begin();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> iter = refCount[key];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> currCnt = iter-&gt;first;</span><br><span class="line">        <span class="keyword">int</span> nextCnt = currCnt + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> nextIter = iter;</span><br><span class="line">        nextIter++;</span><br><span class="line">        <span class="keyword">if</span> (nextIter == _q.end() || (nextIter)-&gt;first != nextCnt) &#123;</span><br><span class="line">            nextIter = _q.insert(nextIter, NodeListNode(nextCnt, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> value = _m[key]-&gt;second;</span><br><span class="line">        <span class="keyword">auto</span> nextKeyIter = nextIter-&gt;second.insert(nextIter-&gt;second.end(), make_pair(key, value));</span><br><span class="line">        iter-&gt;second.erase(_m[key]);</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;second.empty()) &#123;</span><br><span class="line">            _q.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _m[key] = nextKeyIter;</span><br><span class="line">        refCount[key] = nextIter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_q.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> key = _q.front().second.front().first;</span><br><span class="line">        _q.front().second.pop_front();</span><br><span class="line">        _m.erase(key);</span><br><span class="line">        refCount.erase(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[边做边学]用Node.js+React+Express来写个聊天室(完)</title>
      <link href="/2018/01/08/%E8%BE%B9%E5%81%9A%E8%BE%B9%E5%AD%A6-%E7%94%A8Node-js-React-Express%E6%9D%A5%E5%86%99%E4%B8%AA%E8%81%8A%E5%A4%A9%E5%AE%A4-%E5%AE%8C/"/>
      <url>/2018/01/08/%E8%BE%B9%E5%81%9A%E8%BE%B9%E5%AD%A6-%E7%94%A8Node-js-React-Express%E6%9D%A5%E5%86%99%E4%B8%AA%E8%81%8A%E5%A4%A9%E5%AE%A4-%E5%AE%8C/</url>
      
        <content type="html"><![CDATA[<p>大半年前，我开始着手用Node.js+Express+React来写一个聊天室：</p><ul><li><a href="https://www.xiadong.info/2017/04/28/%E8%BE%B9%E5%81%9A%E8%BE%B9%E5%AD%A6-%E7%94%A8Node-js-React-Express%E6%9D%A5%E5%86%99%E4%B8%AA%E8%81%8A%E5%A4%A9%E5%AE%A4(1)/" target="_blank" rel="noopener">[边做边学]用Node.js+React+Express来写个聊天室(1)</a></li><li><a href="https://www.xiadong.info/2017/05/13/%E8%BE%B9%E5%81%9A%E8%BE%B9%E5%AD%A6-%E7%94%A8Node-js-React-Express%E6%9D%A5%E5%86%99%E4%B8%AA%E8%81%8A%E5%A4%A9%E5%AE%A4-2/" target="_blank" rel="noopener">[边做边学]用Node.js+React+Express来写个聊天室(2)</a></li></ul><p>后来因为实习，考试等等原因坑掉了。结果在上周，我收到了一封邮件，来自我下学期要选的一门课的instructor。这门课使用Node.js来开发，要求在上课之前用Node.js+Express写一个聊天室。<s>咦，我还是真是有先见之明啊</s>。不过这也是一个填坑的好机会。我用了两天时间把剩下的东西写完了，但是因为要作为作业来上交，所以就不能放到公开的repo里面了，代码也不能全贴出来。写这篇文章只是个总结吧。</p><a id="more"></a><hr><p>我没有系统地学过Node.js，连JavaScript都没有。以前随便写点网页效果也还算差强人意，但是这次用来写后端以及在前端使用从来没接触过的React也还是感觉语言地基本功还是不够。<a href="https://www.xiadong.info/2017/07/16/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E7%BC%96%E7%A8%8B%EF%BC%9F/#%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">我之前说过</a>，JS这种语言我基本是处于拿来就用的状态，对于一些更深入的东西，比如闭包，依赖，各种方言之间的区别，异常等等方面并不清楚。这次地经历也让我明报如果要写好的前端的话，JS的基本功还是要扎实。</p><hr><p>然而这又让我重新思考了要不要真的深入地去学习前端，坦白地说，这两天的代码经历并不让我开心（虽然最终的成果还是挺有意思的）。JS纷繁复杂的框架，库甚至语法让我觉得这不是一个确定可预期的东西。前端圈子似乎永远不缺乏热点，然而热得快，凉得也快，恐怕唯一不怎么变的只有造轮子吧。JS的语法也很容易就写出来问题多多的代码，除非是expert，否则只能是不断地试错。</p><hr><p>最后说下这个小项目的成果吧。前端结构上是React，样式还是用的Bootstrap<s>懒人福音</s>，主要通信用websocket。最终的结果就是差不多这个样子：<img src="https://i.imgur.com/TLYYkUo.png" alt=""><img src="https://i.imgur.com/SZnW1uW.png" alt=""></p><p>虽然很丑，但是用起来还是蛮有意思的。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
            <tag> React </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 761. Special Binary String</title>
      <link href="/2018/01/07/LeetCode-761-Special-Binary-String/"/>
      <url>/2018/01/07/LeetCode-761-Special-Binary-String/</url>
      
        <content type="html"><![CDATA[<p><em>Special</em> binary strings are binary strings with the following two properties:</p><p>The number of 0’s is equal to the number of 1’s.</p><p>Every prefix of the binary string has at least as many 1’s as 0’s.</p><p>Given a special string <code>S</code>, a <em>move</em> consists of choosing two consecutive, non-empty, special substrings of <code>S</code>, and swapping them. <em>(Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)</em></p><p>At the end of any number of moves, what is the lexicographically largest resulting string possible?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;11011000&quot;</span><br><span class="line">Output: &quot;11100100&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The strings &quot;10&quot; [occuring at S[1]] and &quot;1100&quot; [at S[3]] are swapped.</span><br><span class="line">This is the lexicographically largest string possible after some number of swaps.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>S</code> has length at most <code>50</code>.</li><li><code>S</code> is guaranteed to be a <em>special</em> binary string as defined above.</li></ol><a id="more"></a><p>这道题用暴力就可以过，我在比赛时还尝试了DP，分治……每次迭代都遍历一次字符串，找到所有能交换的<em>Special string</em>，交换它们，从所有交换得到的结果中选择字典序最大的，进入下一个迭代。终止条件是找不到更大的交换后字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeLargestSpecial</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = S.length();</span><br><span class="line">        <span class="built_in">string</span> ans = S;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            S = ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + i &lt;= len; j++) &#123;</span><br><span class="line">                    <span class="built_in">string</span> tmp = S.substr(i, j);</span><br><span class="line">                    <span class="keyword">if</span> (!isSpecial(tmp))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">string</span> maxStr = tmp;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; tmp.length(); k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (tmp[k] == <span class="string">'0'</span>)</span><br><span class="line">                            cnt--;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            cnt++;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (k != tmp.length() - <span class="number">1</span> &amp;&amp; cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">string</span> a = tmp.substr(<span class="number">0</span>, k + <span class="number">1</span>), b = tmp.substr(k + <span class="number">1</span>);</span><br><span class="line">                            maxStr = max(maxStr, max(a + b, b + a));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ans = max(ans, S.substr(<span class="number">0</span>, i).append(maxStr).append(S.substr(i + j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ans != S);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSpecial</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'0'</span>)</span><br><span class="line">                cnt--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 759. Employee Free Time</title>
      <link href="/2018/01/07/LeetCode-759-Employee-Free-Time/"/>
      <url>/2018/01/07/LeetCode-759-Employee-Free-Time/</url>
      
        <content type="html"><![CDATA[<p>We are given a list <code>schedule</code> of employees, which represents the working time for each employee.</p><p>Each employee has a list of non-overlapping <code>Intervals</code>, and these intervals are in sorted order.</p><p>Return the list of finite intervals representing <strong>common, positive-length free time</strong> for <em>all</em> employees, also in sorted order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: schedule &#x3D; [[[1,2],[5,6]],[[1,3]],[[4,10]]]</span><br><span class="line">Output: [[3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There are a total of three employees, and all common</span><br><span class="line">free time intervals would be [-inf, 1], [3, 4], [10, inf].</span><br><span class="line">We discard any intervals that contain inf as they aren&#39;t finite.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: schedule &#x3D; [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]</span><br><span class="line">Output: [[5,6],[7,9]]</span><br></pre></td></tr></table></figure><p>(Even though we are representing <code>Intervals</code> in the form <code>[x, y]</code>, the objects inside are <code>Intervals</code>, not lists or arrays. For example, <code>schedule[0][0].start = 1, schedule[0][0].end = 2</code>, and <code>schedule[0][0][0]</code> is not defined.)</p><p>Also, we wouldn’t include intervals like [5, 5] in our answer, as they have zero length.</p><p><strong>Note:</strong></p><ol><li><code>schedule</code> and <code>schedule[i]</code> are lists with lengths in range <code>[1, 50]</code>.</li><li><code>0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8</code>.</li></ol><a id="more"></a><p>对于每一个区间，遍历现有的区间，找到有重叠的，合并并删除之，最后再插入进现有区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Interval&amp; lhs, <span class="keyword">const</span> Interval&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> lhs.start &lt; rhs.start;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">employeeFreeTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Interval&gt;&gt;&amp; avails)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;Interval, comp&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; employee: avails) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;avail : employee) &#123;</span><br><span class="line">                Interval toInsert = avail;</span><br><span class="line">                <span class="built_in">vector</span>&lt;Interval&gt; toDelete;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Int : s) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (overlap(Int, toInsert)) &#123;</span><br><span class="line">                        toInsert.start = min(toInsert.start, Int.start);</span><br><span class="line">                        toInsert.end = max(toInsert.end, Int.end);</span><br><span class="line">                        toDelete.push_back(Int);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Int : toDelete) &#123;</span><br><span class="line">                    s.erase(Int);</span><br><span class="line">                &#125;</span><br><span class="line">                s.insert(toInsert);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; ans;</span><br><span class="line">        <span class="keyword">auto</span> iter = s.begin();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        Interval prev = *iter;</span><br><span class="line">        iter++;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; s.size()) &#123;</span><br><span class="line">            ans.emplace_back(prev.end, iter-&gt;start);</span><br><span class="line">            prev = *iter;</span><br><span class="line">            cnt++;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">overlap</span> <span class="params">(<span class="keyword">const</span> Interval&amp; a, <span class="keyword">const</span> Interval&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(a.end &lt; b.start || a.start &gt; b.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 758. Bold Words in String</title>
      <link href="/2018/01/07/LeetCode-758-Bold-Words-in-String/"/>
      <url>/2018/01/07/LeetCode-758-Bold-Words-in-String/</url>
      
        <content type="html"><![CDATA[<p>Given a set of keywords <code>words</code> and a string <code>S</code>, make all appearances of all keywords in <code>S</code> bold. Any letters between <code>&lt;b&gt;</code> and <code>&lt;/b&gt;</code> tags become bold.</p><p>The returned string should use the least number of tags possible, and of course the tags should form a valid combination.</p><p>For example, given that <code>words = [&quot;ab&quot;, &quot;bc&quot;]</code> and <code>S = &quot;aabcd&quot;</code>, we should return <code>&quot;a&lt;b&gt;abc&lt;/b&gt;d&quot;</code>. Note that returning <code>&quot;a&lt;b&gt;a&lt;b&gt;b&lt;/b&gt;c&lt;/b&gt;d&quot;</code> would use more tags, so it is incorrect.</p><p><strong>Note:</strong></p><ol><li><code>words</code> has length in range <code>[0, 50]</code>.</li><li><code>words[i]</code> has length in range <code>[1, 10]</code>.</li><li><code>S</code> has length in range <code>[0, 500]</code>.</li><li>All characters in <code>words[i]</code> and <code>S</code> are lowercase letters.</li></ol><a id="more"></a><p>先用双重循环找到有所得子串，对于每一个子串，判断是否要加粗，如果是，那么就把这个子串的所有位置设置为<code>1</code>（要加粗）。最后再把所有标记为要加粗的字符两边加上<code>&lt;b&gt;&lt;/b&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">boldWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; _words, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">words</span><span class="params">(_words.begin(), _words.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(S.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="built_in">string</span> tmp = S.substr(j, i - j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (words.count(tmp)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= i; k++) &#123;</span><br><span class="line">                        flag[k] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (flag.front()) &#123;</span><br><span class="line">            ans += <span class="string">"&lt;b&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans.push_back(S[i]);</span><br><span class="line">            <span class="keyword">if</span> (flag[i] == <span class="number">0</span> &amp;&amp; flag[i + <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="string">"&lt;b&gt;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (flag[i] == <span class="number">1</span> &amp;&amp; flag[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += <span class="string">"&lt;/b&gt;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(S.back());</span><br><span class="line">        <span class="keyword">if</span> (flag.back()) &#123;</span><br><span class="line">            ans += <span class="string">"&lt;/b&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 760. Find Anagram Mappings</title>
      <link href="/2018/01/07/LeetCode-760-Find-Anagram-Mappings/"/>
      <url>/2018/01/07/LeetCode-760-Find-Anagram-Mappings/</url>
      
        <content type="html"><![CDATA[<p>Given two lists <code>A</code>and <code>B</code>, and <code>B</code> is an anagram of <code>A</code>. <code>B</code> is an anagram of <code>A</code> means <code>B</code> is made by randomizing the order of the elements in <code>A</code>.</p><p>We want to find an <em>index mapping</em> <code>P</code>, from <code>A</code> to <code>B</code>. A mapping <code>P[i] = j</code> means the <code>i</code>th element in <code>A</code> appears in <code>B</code> at index <code>j</code>.</p><p>These lists <code>A</code> and <code>B</code> may contain duplicates. If there are multiple answers, output any of them.</p><p>For example, given</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [12, 28, 46, 32, 50]</span><br><span class="line">B &#x3D; [50, 12, 32, 46, 28]</span><br></pre></td></tr></table></figure><p>We should return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 3, 2, 0]</span><br></pre></td></tr></table></figure><p>as <code>P[0] = 1</code> because the <code>0</code>th element of <code>A</code> appears at <code>B[1]</code>, and <code>P[1] = 4</code> because the <code>1</code>st element of <code>A</code> appears at <code>B[4]</code>, and so on.</p><p><strong>Note:</strong></p><ol><li><code>A, B</code> have equal lengths in range <code>[1, 100]</code>.</li><li><code>A[i], B[i]</code> are integers in range <code>[0, 10^5]</code>.</li></ol><a id="more"></a><p>遍历一次数组B，记录每个值出现的下标，再遍历A，依次对应起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">anagramMappings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.size(); i++) &#123;</span><br><span class="line">            m[B[i]].push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            ans.push_back(m[A[i]].front());</span><br><span class="line">            m[A[i]].pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bangumi年鉴生成小工具</title>
      <link href="/2018/01/04/Bangumi%E5%B9%B4%E9%89%B4%E7%94%9F%E6%88%90%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/01/04/Bangumi%E5%B9%B4%E9%89%B4%E7%94%9F%E6%88%90%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>前天晚上受这个<a href="http://bgm.tv/group/topic/344635" target="_blank" rel="noopener">帖子</a>的启发，想写一个爬取Bangumi时光机数据生成海报年鉴的工具。昨天开始付诸实施，一开始的想法是拼成一张大图，然后发现我傻了，生成一个HTML就OK。于是用requests下载数据，jinja2生成网页，成功搞定。</p><p><a href="https://github.com/xiadong1994/bangumi_yearly_report" target="_blank" rel="noopener">GitHub</a></p><p><a href="https://www.xiadong.info/html/bangumi-2017-report.html" target="_blank" rel="noopener">Demo1</a> <a href="https://www.xiadong.info/html/bangumi-all-report.html" target="_blank" rel="noopener">Demo2</a></p><p><img src="https://i.imgur.com/cLYQie2.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 工具 </tag>
            
            <tag> ACG </tag>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 729. My Calendar I</title>
      <link href="/2017/12/30/LeetCode-729-My-Calendar-I/"/>
      <url>/2017/12/30/LeetCode-729-My-Calendar-I/</url>
      
        <content type="html"><![CDATA[<p>Implement a <code>MyCalendar</code> class to store your events. A new event can be added if adding the event will not cause a double booking.</p><p>Your class will have the method, <code>book(int start, int end)</code>. Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.</p><p>A <em>double booking</em> happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)</p><p>For each call to the method <code>MyCalendar.book</code>, return <code>true</code> if the event can be added to the calendar successfully without causing a double booking. Otherwise, return <code>false</code> and do not add the event to the calendar.</p><p>Your class will be called like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyCalendar cal &#x3D; new MyCalendar();</span><br><span class="line">MyCalendar.book(start, end)</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyCalendar();</span><br><span class="line">MyCalendar.book(10, 20); &#x2F;&#x2F; returns true</span><br><span class="line">MyCalendar.book(15, 25); &#x2F;&#x2F; returns false</span><br><span class="line">MyCalendar.book(20, 30); &#x2F;&#x2F; returns true</span><br><span class="line">Explanation: </span><br><span class="line">The first event can be booked.  The second can&#39;t because time 15 is already booked by another event.</span><br><span class="line">The third event can be booked, as the first event takes every time less than 20, but not including 20.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>The number of calls to <code>MyCalendar.book</code> per test case will be at most <code>1000</code>.</p><p>In calls to <code>MyCalendar.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</p><a id="more"></a><p>暴力解法：遍历已经booked的每一个区间判断是否有冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; booked;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyCalendar() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> interval = make_pair(start, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : booked) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!notConflict(p, interval)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        booked.push_back(interval);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">notConflict</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p1, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p1.first &gt;= p2.second) || (p1.second &lt;= p2.first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改进：使用二分搜索找出区间的应插入位置，判断前后是否有重叠。并且可以在插入后合并相邻的区间，因为我使用vector，所以删除区间会比较耗时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; booked;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyCalendar() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> interval = make_pair(start, end);</span><br><span class="line">        <span class="keyword">if</span> (booked.empty()) &#123;</span><br><span class="line">            booked.push_back(interval);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> iter = upper_bound(booked.begin(), booked.end(), interval);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (iter == booked.begin()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!notConflict(*iter, interval))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (iter == booked.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!notConflict(*(iter - <span class="number">1</span>), interval)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!notConflict(*(iter - <span class="number">1</span>), interval) || !notConflict(*iter, interval)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> insert_iter = booked.insert(iter, interval);</span><br><span class="line">        <span class="keyword">if</span> (insert_iter == booked.begin()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (insert_iter-&gt;second == (insert_iter + <span class="number">1</span>)-&gt;first) &#123;</span><br><span class="line">                insert_iter-&gt;second = (insert_iter + <span class="number">1</span>)-&gt;second;</span><br><span class="line">                booked.erase(insert_iter + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (insert_iter == booked.end() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (insert_iter-&gt;first == (insert_iter - <span class="number">1</span>)-&gt;second) &#123;</span><br><span class="line">                insert_iter-&gt;first = (insert_iter - <span class="number">1</span>)-&gt;first;</span><br><span class="line">                booked.erase(insert_iter - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (insert_iter-&gt;second == (insert_iter + <span class="number">1</span>)-&gt;first) &#123;</span><br><span class="line">                insert_iter-&gt;second = (insert_iter + <span class="number">1</span>)-&gt;second;</span><br><span class="line">                booked.erase(insert_iter + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (insert_iter-&gt;first == (insert_iter - <span class="number">1</span>)-&gt;second) &#123;</span><br><span class="line">                insert_iter-&gt;first = (insert_iter - <span class="number">1</span>)-&gt;first;</span><br><span class="line">                booked.erase(insert_iter - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">notConflict</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p1, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p1.first &gt;= p2.second) || (p1.second &lt;= p2.first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 744. Network Delay Time</title>
      <link href="/2017/12/30/LeetCode-744-Network-Delay-Time/"/>
      <url>/2017/12/30/LeetCode-744-Network-Delay-Time/</url>
      
        <content type="html"><![CDATA[<p>There are <code>N</code> network nodes, labelled <code>1</code> to <code>N</code>.</p><p>Given <code>times</code>, a list of travel times as <strong>directed</strong> edges <code>times[i] = (u, v, w)</code>, where <code>u</code> is the source node, <code>v</code> is the target node, and <code>w</code> is the time it takes for a signal to travel from source to target.</p><p>Now, we send a signal from a certain node <code>K</code>. How long will it take for all nodes to receive the signal? If it is impossible, return <code>-1</code>.</p><p><strong>Note:</strong></p><ol><li><code>N</code> will be in the range <code>[1, 100]</code>.</li><li><code>K</code> will be in the range <code>[1, N]</code>.</li><li>The length of <code>times</code> will be in the range <code>[1, 6000]</code>.</li><li>All edges <code>times[i] = (u, v, w)</code> will have <code>1 &lt;= u, v &lt;= N</code> and <code>1 &lt;= w &lt;= 100</code>.</li></ol><a id="more"></a><p>要求出所有图中所有节点到某一个节点的最短距离。使用Dijkstra算法遍历所有节点一次就可以得到所有节点到某一节点的最短距离。</p><p>注意，题目中给的条件<code>1 &lt;= w &lt;= 100</code>不对，实际测试数据包含<code>w == 0</code>的情况，我被这个坑了一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrix</span><span class="params">(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : times) &#123;</span><br><span class="line">            matrix[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distance</span><span class="params">(N + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        distance[K] = <span class="number">0</span>;</span><br><span class="line">        visited[K] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> currNode = K;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> min_dis = INT_MAX, min_index;</span><br><span class="line">            <span class="keyword">auto</span>&amp; tmp = matrix[currNode];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp[i] == <span class="number">-1</span> || visited[i]) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                distance[i] = min(distance[i], distance[currNode] + tmp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i]) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (distance[i] &lt; min_dis) &#123;</span><br><span class="line">                    min_dis = distance[i];</span><br><span class="line">                    min_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (min_dis == INT_MAX)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            currNode = min_index;</span><br><span class="line">            visited[currNode] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[i] == INT_MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ans = max(ans, distance[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 747. Min Cost Climbing Stairs</title>
      <link href="/2017/12/30/LeetCode-747-Min-Cost-Climbing-Stairs/"/>
      <url>/2017/12/30/LeetCode-747-Min-Cost-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p><p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: cost &#x3D; [10, 15, 20]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>cost</code> will have a length in the range <code>[2, 1000]</code>.</li><li>Every <code>cost[i]</code> will be an integer in the range <code>[0, 999]</code>.</li></ol><a id="more"></a><p>非常耿直的动态规划。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cost.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cost[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 740. Delete and Earn</title>
      <link href="/2017/12/29/LeetCode-740-Delete-and-Earn/"/>
      <url>/2017/12/29/LeetCode-740-Delete-and-Earn/</url>
      
        <content type="html"><![CDATA[<p>Given an array <code>nums</code> of integers, you can perform operations on the array.</p><p>In each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. After, you must delete <strong>every</strong> element equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.</p><p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3, 4, 2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">Delete 4 to earn 4 points, consequently 3 is also deleted.</span><br><span class="line">Then, delete 2 to earn 2 points. 6 total points are earned.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2, 2, 3, 3, 3, 4]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: </span><br><span class="line">Delete 3 to earn 3 points, deleting both 2&#39;s and the 4.</span><br><span class="line">Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span><br><span class="line">9 total points are earned.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>The length of <code>nums</code> is at most <code>20000</code>.</p><p>Each element <code>nums[i]</code> is an integer in the range <code>[1, 10000]</code>.</p><a id="more"></a><p>动态规划问题，对于<code>nums</code>中出现的最大的数<code>n</code>来说，有两种可能：</p><ol><li>能挣到点数，那么最大的分数就是<code>n×n出现的次数</code>+<code>最大值为n-2时的分数</code></li><li>不能挣到点数，那么最大值就是最大值为<code>n-1</code>的分数</li></ol><p>因为<code>nums</code>的元素取值范围为<code>[1,10000]</code>所以可以用哈希表来保存每个数字出现了多少次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            flag[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = flag[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = max(flag[<span class="number">2</span>] * <span class="number">2</span>, dp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + flag[i] * i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 748. Shortest Completing Word</title>
      <link href="/2017/12/24/LeetCode-748-Shortest-Completing-Word/"/>
      <url>/2017/12/24/LeetCode-748-Shortest-Completing-Word/</url>
      
        <content type="html"><![CDATA[<p>Find the minimum length word from a given dictionary <code>words</code>, which has all the letters from the string <code>licensePlate</code>. Such a word is said to <em>complete</em> the given string <code>licensePlate</code></p><p>Here, for letters we ignore case. For example, <code>&quot;P&quot;</code> on the <code>licensePlate</code> still matches <code>&quot;p&quot;</code> on the word.</p><p>It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array.</p><p>The license plate might have the same letter occurring multiple times. For example, given a <code>licensePlate</code> of <code>&quot;PP&quot;</code>, the word <code>&quot;pair&quot;</code>does not complete the <code>licensePlate</code>, but the word <code>&quot;supper&quot;</code> does.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: licensePlate &#x3D; &quot;1s3 PSt&quot;, words &#x3D; [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</span><br><span class="line">Output: &quot;steps&quot;</span><br><span class="line">Explanation: The smallest length word that contains the letters &quot;S&quot;, &quot;P&quot;, &quot;S&quot;, and &quot;T&quot;.</span><br><span class="line">Note that the answer is not &quot;step&quot;, because the letter &quot;s&quot; must occur in the word twice.</span><br><span class="line">Also note that we ignored case for the purposes of comparing whether a letter exists in the word.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: licensePlate &#x3D; &quot;1s3 456&quot;, words &#x3D; [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]</span><br><span class="line">Output: &quot;pest&quot;</span><br><span class="line">Explanation: There are 3 smallest length words that contains the letters &quot;s&quot;.</span><br><span class="line">We return the one that occurred first.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>licensePlate</code> will be a string with length in range <code>[1, 7]</code>.</li><li><code>licensePlate</code> will contain digits, spaces, or letters (uppercase or lowercase).</li><li><code>words</code> will have a length in the range <code>[10, 1000]</code>.</li><li>Every <code>words[i]</code> will consist of lowercase letters, and have length in range <code>[1, 15]</code>.</li></ol><a id="more"></a><p>没什么难度，用哈希表记录<code>licensePlate</code>中每个字母的出现次数，在对<code>words</code>中的每一个词判断能否覆盖，记录其中的最短字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cnts;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestCompletingWord</span><span class="params">(<span class="built_in">string</span> licensePlate, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : licensePlate) &#123;</span><br><span class="line">            ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch)) &#123;</span><br><span class="line">                cnts[ch]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ans.empty() &amp;&amp; ans.length() &lt;= word.length())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cover(word)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans.empty() || ans.length() &gt; word.length())</span><br><span class="line">                    ans = word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmpCnts = cnts;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpCnts.count(ch) &amp;&amp; tmpCnts[ch] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tmpCnts[ch]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : tmpCnts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 753. Cracking the Safe</title>
      <link href="/2017/12/24/LeetCode-753-Cracking-the-Safe/"/>
      <url>/2017/12/24/LeetCode-753-Cracking-the-Safe/</url>
      
        <content type="html"><![CDATA[<p>There is a box protected by a password. The password is <code>n</code> digits, where each letter can be one of the first <code>k</code> digits <code>0, 1, ..., k-1</code>.</p><p>You can keep inputting the password, the password will automatically be matched against the last <code>n</code> digits entered.</p><p>For example, assuming the password is <code>&quot;345&quot;</code>, I can open it when I type <code>&quot;012345&quot;</code>, but I enter a total of 6 digits.</p><p>Please return any string of minimum length that is guaranteed to open the box after the entire string is inputted.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1, k &#x3D; 2</span><br><span class="line">Output: &quot;01&quot;</span><br><span class="line">Note: &quot;10&quot; will be accepted too.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2, k &#x3D; 2</span><br><span class="line">Output: &quot;00110&quot;</span><br><span class="line">Note: &quot;01100&quot;, &quot;10011&quot;, &quot;11001&quot; will be accepted too.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>n</code> will be in the range <code>[1, 4]</code>.</li><li><code>k</code> will be in the range <code>[1, 10]</code>.</li><li><code>k^n</code> will be at most <code>4096</code>.</li></ol><a id="more"></a><p>这道题我使用DFS来实现回溯，假设上一个迭代所得到的结果为字符串<code>s</code>，那么在本次迭代中就在<code>s</code>末尾加上所有可能的数字，如果加上后尾部的n个数字组合还没有出现过，那么就将它作为新的<code>s</code>进行递归，直到所有的组合都出现。</p><p>因为组合的总数目是确定的<code>k^n</code>个，所以递归深度不会超过<code>4096</code>。还有一个问题要注意，那就是递归的结束条件。因为我们每次只在<code>s</code>末尾增加一个字符，所以一旦所有的组合都出现了，那么结果串的长度就一定是最短的，此时就可以结束递归了，而不用把所有的可能结果串都找出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">    <span class="keyword">int</span> _n, _k;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">crackSafe</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        _n = n, _k = k;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">pow</span>(k, n);</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">input</span><span class="params">(n, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">        visited.insert(input);</span><br><span class="line">        dfs(num - <span class="number">1</span>, input);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> passwordNum, <span class="built_in">string</span> &amp;input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (passwordNum == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = input;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _k; i++) &#123;</span><br><span class="line">            input.push_back(i + <span class="string">'0'</span>);</span><br><span class="line">            <span class="built_in">string</span> back = input.substr(input.length() - _n);</span><br><span class="line">            <span class="keyword">if</span> (!visited.count(back)) &#123;</span><br><span class="line">                visited.insert(back);</span><br><span class="line">                dfs(passwordNum - <span class="number">1</span>, input);</span><br><span class="line">                <span class="keyword">if</span> (!ans.empty())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                visited.erase(back);</span><br><span class="line">            &#125;</span><br><span class="line">            input.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 752. Open the Lock</title>
      <link href="/2017/12/24/LeetCode-752-Open-the-Lock/"/>
      <url>/2017/12/24/LeetCode-752-Open-the-Lock/</url>
      
        <content type="html"><![CDATA[<p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>. The wheels can rotate freely and wrap around: for example we can turn <code>'9'</code> to be <code>'0'</code>, or <code>'0'</code> to be <code>'9'</code>. Each move consists of turning one wheel one slot.</p><p>The lock initially starts at <code>'0000'</code>, a string representing the state of the 4 wheels.</p><p>You are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.</p><p>Given a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.</span><br><span class="line">Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,</span><br><span class="line">because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;8888&quot;], target &#x3D; &quot;0009&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target &#x3D; &quot;8888&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">We can&#39;t reach the target without getting stuck.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;0000&quot;], target &#x3D; &quot;8888&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of <code>deadends</code> will be in the range <code>[1, 500]</code>.</li><li><code>target</code> will not be in the list <code>deadends</code>.</li><li>Every string in <code>deadends</code> and the string <code>target</code> will be a string of 4 digits from the 10,000 possibilities <code>'0000'</code> to <code>'9999'</code>.</li></ol><a id="more"></a><p>这道题我使用BFS从起点<code>0000</code>到<code>target</code>进行搜索（或者反过来进行），避开<code>deadends</code>中的组合，看能否到达，每次把其中一位移动一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; _deadends;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        _deadends = <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;(deadends.begin(), deadends.end());</span><br><span class="line">        <span class="keyword">return</span> bfs(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; steps;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="keyword">if</span> (_deadends.count(target))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        q.push(target);</span><br><span class="line">        steps.push(<span class="number">0</span>);</span><br><span class="line">        visited.insert(target);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> pw = q.front();</span><br><span class="line">            <span class="keyword">int</span> s = steps.front();</span><br><span class="line">            <span class="keyword">if</span> (pw == <span class="string">"0000"</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pw.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> digit = pw[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = digit == <span class="number">9</span> ? <span class="number">0</span> : digit + <span class="number">1</span>;</span><br><span class="line">                pw[i] = tmp + <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span> (!_deadends.count(pw) &amp;&amp; !visited.count(pw)) &#123;</span><br><span class="line">                    q.push(pw);</span><br><span class="line">                    steps.push(s + <span class="number">1</span>);</span><br><span class="line">                    visited.insert(pw);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = digit == <span class="number">0</span> ? <span class="number">9</span> : digit - <span class="number">1</span>;</span><br><span class="line">                pw[i] = tmp + <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span> (!_deadends.count(pw) &amp;&amp; !visited.count(pw)) &#123;</span><br><span class="line">                    q.push(pw);</span><br><span class="line">                    steps.push(s + <span class="number">1</span>);</span><br><span class="line">                    visited.insert(pw);</span><br><span class="line">                &#125;</span><br><span class="line">                pw[i] = digit + <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.pop();</span><br><span class="line">            steps.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 751. IP to CIDR</title>
      <link href="/2017/12/24/LeetCode-751-IP-to-CIDR/"/>
      <url>/2017/12/24/LeetCode-751-IP-to-CIDR/</url>
      
        <content type="html"><![CDATA[<p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p><p>A CIDR block is a string consisting of an IP, followed by a slash, and then the prefix length. For example: “123.45.67.89/20”. That prefix length “20” represents the number of common prefix bits in the specified range.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Input: ip &#x3D; &quot;255.0.0.7&quot;, n &#x3D; 10</span><br><span class="line">Output: [&quot;255.0.0.7&#x2F;32&quot;,&quot;255.0.0.8&#x2F;29&quot;,&quot;255.0.0.16&#x2F;32&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">The initial ip address, when converted to binary, looks like this (spaces added for clarity):</span><br><span class="line">255.0.0.7 -&gt; 11111111 00000000 00000000 00000111</span><br><span class="line">The address &quot;255.0.0.7&#x2F;32&quot; specifies all addresses with a common prefix of 32 bits to the given address,</span><br><span class="line">ie. just this one address.</span><br><span class="line"></span><br><span class="line">The address &quot;255.0.0.8&#x2F;29&quot; specifies all addresses with a common prefix of 29 bits to the given address:</span><br><span class="line">255.0.0.8 -&gt; 11111111 00000000 00000000 00001000</span><br><span class="line">Addresses with common prefix of 29 bits are:</span><br><span class="line">11111111 00000000 00000000 00001000</span><br><span class="line">11111111 00000000 00000000 00001001</span><br><span class="line">11111111 00000000 00000000 00001010</span><br><span class="line">11111111 00000000 00000000 00001011</span><br><span class="line">11111111 00000000 00000000 00001100</span><br><span class="line">11111111 00000000 00000000 00001101</span><br><span class="line">11111111 00000000 00000000 00001110</span><br><span class="line">11111111 00000000 00000000 00001111</span><br><span class="line"></span><br><span class="line">The address &quot;255.0.0.16&#x2F;32&quot; specifies all addresses with a common prefix of 32 bits to the given address,</span><br><span class="line">ie. just 11111111 00000000 00000000 00010000.</span><br><span class="line"></span><br><span class="line">In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .</span><br><span class="line"></span><br><span class="line">There were other representations, such as:</span><br><span class="line">[&quot;255.0.0.7&#x2F;32&quot;,&quot;255.0.0.8&#x2F;30&quot;, &quot;255.0.0.12&#x2F;30&quot;, &quot;255.0.0.16&#x2F;32&quot;],</span><br><span class="line">but our answer was the shortest possible.</span><br><span class="line"></span><br><span class="line">Also note that a representation beginning with say, &quot;255.0.0.7&#x2F;30&quot; would be incorrect,</span><br><span class="line">because it includes addresses like 255.0.0.4 &#x3D; 11111111 00000000 00000000 00000100 </span><br><span class="line">that are outside the specified range.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>ip</code> will be a valid IPv4 address.</li><li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li><li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li></ol><a id="more"></a><p>这道题要把一个IPv4地址段转换为恰好能完全覆盖的CIDR表示，关于IPv4和CIDR之间的转换就同题目中所说的一样，我就不赘述了。问题在于要得到一个正好精确覆盖的CIDR表示，我的思路是对每一个IPv4地址，一位一位地缩小CIDR的范围，知道其中的所有IP地址都落在我们的目标范围内。此外要注意去重。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ipToCIDR</span><span class="params">(<span class="built_in">string</span> ip, <span class="keyword">int</span> range)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ipBegin = stringToInt(ip);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ipEnd = ipBegin + range;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = ipBegin; i &lt; ipEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0xffffffff</span> &lt;&lt; j;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = i &amp; mask;</span><br><span class="line">                <span class="keyword">unsigned</span> minIp = tmp, maxIp = (tmp | ~mask);</span><br><span class="line">                <span class="keyword">if</span> (minIp &gt;= ipBegin &amp;&amp; maxIp &lt; ipEnd) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cidr = i &amp; (<span class="number">0xffffffff</span> &lt;&lt; j);</span><br><span class="line">            <span class="built_in">string</span> str = intToString(cidr);</span><br><span class="line">            ans.insert(str + <span class="string">"/"</span> + to_string(<span class="number">32</span> - j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(ans.begin(), ans.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">stringToInt</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; ip.length() &amp;&amp; p2 &lt; ip.length()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; ip.length() &amp;&amp; ip[p2] != <span class="string">'.'</span>)</span><br><span class="line">                p2++;</span><br><span class="line">            <span class="keyword">int</span> tmp = stoi(ip.substr(p1, p2 - p1));</span><br><span class="line">            ans = (ans &lt;&lt; <span class="number">8</span>) + tmp;</span><br><span class="line">            p1 = p2 + <span class="number">1</span>;</span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToString</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ip)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        ans += to_string((ip &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">        ans += <span class="string">"."</span>;</span><br><span class="line">        ans += to_string((ip &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        ans += <span class="string">"."</span>;</span><br><span class="line">        ans += to_string((ip &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        ans += <span class="string">"."</span>;</span><br><span class="line">        ans += to_string((ip &amp; <span class="number">0x000000ff</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纽约游记</title>
      <link href="/2017/12/21/%E7%BA%BD%E7%BA%A6%E6%B8%B8%E8%AE%B0/"/>
      <url>/2017/12/21/%E7%BA%BD%E7%BA%A6%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>考完试了，正好室友要去NYC面试，就一起去玩两天，<s>顺便蹭一下酒店和Uber</s>。</p><p><img src="https://lh3.googleusercontent.com/B8pvwif1AuUai9HAax8qMOMtLr5LtK4WCXvjvEQ00ps4pUMFlaUbqPEZ2r6sR7wS6Pw6OiAX2t6usnpKvA=w1920-no-tmp.jpg" alt=""></p><a id="more"></a><h2 id="day-1">Day 1</h2><p>酒店在中央车站和克莱斯勒大厦中间，对面的楼上还能看到克莱斯勒大厦的倒影。</p><p><img src="https://lh3.googleusercontent.com/LBf2wYnr4gbaHsGyU8yF7-9IwI_qo192LZYThZ2gw8igc3fbGGRUA9HpauTUYN1SU5r7_cIAhs664d4E_w=w1920-no-tmp.jpg" alt=""></p><p>离开酒店之后，我们就去了……PornHub实体店……其实就是个超小的卖文化衫和情趣用品的店，还有个女星可以做各种羞羞的合影……接下来吃了烤肉，然后去时代广场</p><p><img src="https://lh3.googleusercontent.com/ssQWTy3gIX9ZaqKMDAdKtgsyS-HvS8em45TJOg3Ed2rqGOM32PSUG0n2Mrb-N-fypsjmJQsLhQE4S_weVQ=w1920-no-tmp.jpg" alt=""></p><p>然后就回酒店了。</p><h2 id="day-2">Day 2</h2><p>联合国总部</p><p><img src="https://lh3.googleusercontent.com/VZg7ZZSoT8PJ0rrQLbKjHwL00UeG2L6qzVzVf8vcNUkyN6ZHwOvlAWt2XOxEpFH0lhljb_xJ2aQEs00wdA=w1920-no-tmp.jpg" alt=""></p><p><img src="https://lh3.googleusercontent.com/_2b-ZBZF-F55M85_0KJtKVqFbd72NJ6rFi2HvgHgSs1QAeHV6RZ6hbTEKix76F3Pj_GTDC1b8vZLqroIXw=w1920-no-tmp.jpg" alt=""></p><p><img src="https://lh3.googleusercontent.com/r_eRRjlhbNR34vRUPfSLl3p1XzeGOv5P1nqHJNnFDqTZZC2mQi5JRFl6NXt_t2r0X9qMNL7Wd1HwNzs52Q=w1920-no-tmp.jpg" alt=""></p><p>华尔街</p><p><img src="https://lh3.googleusercontent.com/LcSPILLl_cieEPRW1AuwvbQ4g8RCVkIm97ybDN16sVHOTSDb3k8Oxmr_nt9rswdbrENkbJGjukviqLwg8A=w1920-no-tmp.jpg" alt=""></p><p>自由女神像</p><p><img src="https://lh3.googleusercontent.com/rioFE6OW2sGgH_jbsJ8cCpgr4o7bRtPOu8Txzn9jcYlMkSMkVcn4eupMhguL4Bz1bxsJ-T1jgarX6d4waQ=w1920-no-tmp.jpg" alt=""></p><p><img src="https://lh3.googleusercontent.com/sJ-fXrewIe3H2EbK1zjy5irdYLK8q1FTFspAe9MFWVUhW7GsWy9Lb5cUTtgr3nnCllCIx3msb-QLS_P2gQ=w1920-no-tmp.jpg" alt=""></p><p>布鲁克林大桥</p><p><img src="https://lh3.googleusercontent.com/FGQRDguKUZWHWv5rFP7b9QbXnoy9wXopN-XD8ibdPk-gWjG9WvtxAZnD8khXINhS7fQF763sMfoYu_8ctw=w1920-no-tmp.jpg" alt=""></p><p>最后去了一家爵士乐酒吧</p><h2 id="day-3">Day 3</h2><p>中央公园</p><p><img src="https://lh3.googleusercontent.com/tWmXk_c_9SPKT34pmS2Yi2tvWVIXmgRjHuTOTw8Yy0LT6JOutlfMz4zTlIpj2tBQYdL-bntsJn9f04-HHQ=w1920-no-tmp.jpg" alt=""></p><p>然后逛了一天大都会博物馆，还没逛完……</p><h2 id="day-4">Day 4</h2><p>打道回府</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17 Fall 总结</title>
      <link href="/2017/12/21/17-Fall-%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/21/17-Fall-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>今天是12月21日，正好是来美国整整四个月，也是秋季学期正式结束的日子。昨天刚从纽约回到匹村，晚上就出了期末成绩，算是给这个学期正式画上了一个句号。也该是时候写写总结了。</p><a id="more"></a><p>对于像我这种死宅来说，美国的生活并没有什么难以适应的地方，相比于国内来说还更舒适一点。有很多人想念中国的食物，这一点从每天中午学校附近的中餐外卖就可以看出来，但是我并没有这种感觉，我曾经跟朋友说过，我对于食物的下限比较高。美国的基本食物不是burger就是sandwich，dessert可以甜掉牙，卡路里让人望而生畏，但是只要高于我的“能吃”的bar，那么我还是完全可以接受的。居住环境中规中矩，对于这一点我的要求也不算高。空气跟国内是不可同日而语。</p><p><img src="https://imgur.com/UWfisAd.jpg" alt="Morewood"></p><p>到了美国之后，我才真正感受到秒上Google，Twitter，不用挂代理是一种多么舒爽的感觉，仿佛是囚禁多年的人终于重获了自由。OneDrive也不抽风了，Gmail更好用了，不用再担心VPS哪天就被封了。恐怕我已经完全无法接受国内的那种压抑的环境了。</p><p>这一个学期在CMU的学习非常紧张，虽然只有三门课，可是每周要花近七八十个小时，基本上每天都有做不完的任务，上课，写作业，写读书笔记，做project，从早上一睁眼到晚上基本都在学习，赶完了一个due，下一个就在几天后。不过这倒是让我学到了怎么安排时间来同时做多件事情，比如今天做这门课的project，明天上午写reading summary，下午做另一门课的project。</p><p><img src="https://i.imgur.com/voiyked.jpg" alt="Hunt门前的草坪"></p><p>我选的第一门课是<a href="http://boston.lti.cs.cmu.edu/classes/11-642/" target="_blank" rel="noopener">11-642 Search Engines</a>。上半年选课的时候我是没有选这门课的，这学期开学之后才临时注册了这门课。这门课讲的就是如何构建一个基于文档的搜索引擎，包括ranking算法，效果评估，查询扩展，索引，垂直搜索等等。这门课不算是很“CS”的课，更多的是偏向于概念，考试时不许用cheat sheet，有许多东西要记忆。这门课每周都要写一篇reading summary，其实就是预习下一周的内容，前半学期主要是课本内容，后半学期则是一到两篇论文，此外还有五个project，大约两周一个，使用Java来实现一个真正的搜索引擎，这五个project是递进的关系，重点不在于编程，而是对于要实现的概念的理解，以及最终report中对于结果的分析。教授叫<a href="http://www.cs.cmu.edu/~callan/" target="_blank" rel="noopener">Jamie Callan</a>，银发银须，看起来和蔼可亲，上课也很清楚，天气不冷的话总是穿一双凉拖。我每次上课都坐第一排，奈何这门课的内容实在不是很对胃口，最终只拿到了B+的成绩。</p><p>第二门课是<a href="https://www.cs.cmu.edu/~prs/15-441-F17/index.html" target="_blank" rel="noopener">15-641 Computer Networks</a>。这门课跟国内的课程差不太多，把协议栈从上往下讲，包括传输层协议，路由协议，BGP，包交换，链路层协议，QoS，Wireless，加密等等。这门课的project比较有用，第一个是用C+Socket实现一个简单的HTTP/HTTPS服务器，类似于Apache/Nginx那样的，用select来实现多路复用，还要支持CGI脚本。第二个是实现P2P文件分发和TCP-like的拥塞控制，我觉得这对于理解TCP Reno非常有帮助，虽然本科也学了TCP，知道slow start，AIMD，dup-ACK这些名词，但是对于整个TCP的工作机制还是要真正亲手实现一次才能搞得比较清楚。最后一个project是一个视频流的CDN+DNS load balance，根据链接速率来选择不同码率的视频文件，以及利用DNS对不同的client返回不同的IP。这门课的内容如果以前没有学过相关的课程的话量还是挺大的，以前是由<a href="http://www.cs.cmu.edu/~prs/" target="_blank" rel="noopener">Peter Steenkiste</a>教授来上，这学期有一半是由一位新教授<a href="http://www.justinesherry.com/" target="_blank" rel="noopener">Justine Sherry</a>来上，Sherry教授很有热情，但是说话语速略快，有的时候听不太清楚，她每次上课都会带一大包棒棒糖or巧克力，回答问题或者提问都会给糖吃。据Sherry教授说，这门课的project下次应该会有较大的更新。</p><p>最后一门课是<a href="http://www.ece.cmu.edu/~ganger/746.fall17/index.html" target="_blank" rel="noopener">18-746 Storage Systems</a>。由<a href="http://www.ece.cmu.edu/~ganger/" target="_blank" rel="noopener">Greg Ganger</a>教授和<a href="http://www.cs.cmu.edu/~gamvrosi/" target="_blank" rel="noopener">George Amvrosiadis</a>来上，主要在于SSD，文件系统，分布式存储和网络存储。每周也要读论文，但不是强制的，不读也没有关系。上课内容不是很多，但是考试时并不会考的很直白，许多问题都没有一个最佳答案，<em>It depends!</em>，要自己做出trade-off。这门课有两个project，第一个是实现一个SSD的地址翻译层，因为SSD的读写特性而要进行垃圾回收，wear-balance等等的考量。第二个是实现一个local+cloud的文件系统，这个project是我之前做过的一个巨蠢无比的<a href="https://github.com/xiadong1994/RaspCloud" target="_blank" rel="noopener">大创项目</a>的完全体，它使用FUSE来实现一个真正的文件系统，通过handle文件系统调用来向用户提供一个透明的接口，大文件将会被上传到云端存储，本地磁盘只保留metadata。同时还使用文件分片，相同的分片只会在云端保存一份，还实现了snapshot，cache等功能。</p><p>我觉得CMU的许多课程用AutoLab来给project评分真是很有趣，用scoreboard的ranking来拯救我的拖延症，让写代码有了一种打天梯的刺激感。</p><p>这学期最大遗憾在于还没有找到工作，拿到的Google和Houzz的onsite我自认为题目基本都答出来了，但是还是没有通过，Amazon的video onsite竟然奇葩地因为head count满了被取消了，另一家CME发了onsite邮件后就彻底没了下文，Facebook的PE on campus面试也没过，其他的大公司投了简历也没有消息，秋招早就结束，对于未来真的觉得充满了迷惘，回国真的是看不到任何光明。下个月只有两家小公司的onsite，春招也不知道还有几个坑，刷了458道题也没有什么用，连面试都拿不到真的不知道刷题除了娱乐还有什么意义。现在放寒假了，这一学期基本都没有怎么更新LC的博客，趁着这个时间补一补吧。</p><p><img src="https://i.imgur.com/xUYg25L.jpg" alt="Stanford University"></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 684. Redundant Connection</title>
      <link href="/2017/09/24/LeetCode-684-Redundant-Connection/"/>
      <url>/2017/09/24/LeetCode-684-Redundant-Connection/</url>
      
        <content type="html"><![CDATA[<p>We are given a “tree” in the form of a 2D-array, with <code>distinct</code> values for each node.</p><p>In the given 2D-array, each element pair <code>[u, v]</code> represents that <code>v</code> is a child of <code>u</code> in the tree.</p><p>We can remove <code>exactly</code> one redundant pair in this “tree” to make the result a tree.</p><p>You need to find and output such a pair. If there are multiple answers for this question, output the one appearing last in the 2D-array. There is always at least one answer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: Original tree will be like this:</span><br><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [3,1]]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: Original tree will be like this:</span><br><span class="line">  1</span><br><span class="line"> &#x2F; \\</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>The size of the input 2D-array will be between 1 and 1000.</p><p>Every integer represented in the 2D-array will be between 1 and 2000.</p><a id="more"></a><p>这道题的题目描述相当的坑，我被<code>child</code>这个词和test case困扰了挺久。而且要再复习一个概念：我们常说的“父子节点”是针对<strong>有根树 Rooted Tree</strong>来说的，而树的定义：无向连通无环图是没有父子节点这种区分的，而这道题的输入数据是就是一个广义上的树，不要被题目误导了。</p><p>实际上这道题就是要判断一个无向图是否是一个棵树。主要探测两个条件：</p><ol><li>是否有环</li><li>是否连通</li></ol><p>最直接的办法就是用DFS遍历查找环，但是因为要删去一条下标最大的边，所以从后往前依次删除边，直到剩下的边可以组成一个树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> skip)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(<span class="number">2001</span>)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == skip) <span class="keyword">continue</span>;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">            nodes.insert(edges[i][<span class="number">0</span>]);</span><br><span class="line">            nodes.insert(edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">int</span> start = edges[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!dfs(graph, visited, path, start))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> visited.size() == nodes.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; &amp;visited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!path.empty()) parent = path.back();</span><br><span class="line">        path.push_back(node);</span><br><span class="line">        visited.insert(node);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.count(n) &amp;&amp; parent != <span class="number">-1</span> &amp;&amp; n != parent) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!visited.count(n)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dfs(graph, visited, path, n))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = edges.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isTree(edges, i)) &#123;</span><br><span class="line">                ans = edges[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而这个办法效率很低。更优的解法是使用并查集。当一条边连接了两个本来就在一个集合中的节点时，这条边就破坏了树的结构，只要返回这条边就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findHead</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;u, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(u[node] != node)</span><br><span class="line">            node = u[node];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u</span><span class="params">(<span class="number">2001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u.size(); i++) &#123;</span><br><span class="line">            u[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge: edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> h1 = findHead(u, edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> h2 = findHead(u, edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (h1 == h2) <span class="keyword">return</span> edge;</span><br><span class="line">            u[h1] = h2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans = uf(edges);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 683. K Empty Slots</title>
      <link href="/2017/09/24/LeetCode-683-K-Empty-Slots/"/>
      <url>/2017/09/24/LeetCode-683-K-Empty-Slots/</url>
      
        <content type="html"><![CDATA[<p>There is a garden with <code>N</code> slots. In each slot, there is a flower. The <code>N</code> flowers will bloom one by one in <code>N</code> days. In each day, there will be <code>exactly</code> one flower blooming and it will be in the status of blooming since then.</p><p>Given an array <code>flowers</code> consists of number from <code>1</code> to <code>N</code>. Each number in the array represents the place where the flower will open in that day.</p><p>For example, <code>flowers[i] = x</code> means that the unique flower that blooms at day <code>i</code> will be at position <code>x</code>, where <code>i</code> and <code>x</code> will be in the range from <code>1</code> to <code>N</code>.</p><p>Also given an integer <code>k</code>, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is <code>k</code> and these flowers are not blooming.</p><p>If there isn’t such day, output -1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">flowers: [1,3,2]</span><br><span class="line">k: 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: In the second day, the first and the third flower have become blooming.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">flowers: [1,2,3]</span><br><span class="line">k: 1</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The given array will be in the range [1, 20000].</li></ol><a id="more"></a><p>这道题是我上周才做过的Google内推OA题（这次Contest的另一道题681. Next Closest Time则是第一题，这是第二题，LC真是消息灵通啊）。不过有一点小不一样，就是Google的OA没有要求靠近两边的连续未开花花圃不算数。</p><p>LeetCode上这道题，用二叉堆（也就是STL里的<code>set</code>）能过，但是我觉得理论上的时间复杂度不太对（Google的OA要求是O(nlogn)的复杂度），最坏情况下我觉得是O(nklogn)，如果k比较大的话我就不太确定这个复杂度的问题了……</p><p>我当时做OA的时候是用的deque+二分搜索（时间很紧，而且当时还有点看错题），之所以用deque是因为它既可以随即访问（适用二分搜索）也可以常数复杂度实现插入删除，所以我用它来维护一个区间列表，每次搜索到开花所在区间，将其拆分后插入到原位置。在这个过程中判断区间长度是否为k。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchInterval</span><span class="params">(<span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;intervals, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = intervals.size(), m = (r + l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[m].first &lt;= target &amp;&amp; intervals[m].second &gt;= target) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (intervals[m].first &gt; target) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowers, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = flowers.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; intervals;</span><br><span class="line">        intervals.push_back(make_pair(<span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = flowers[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> index = binarySearchInterval(intervals, pos);</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">auto</span> interval = intervals[index];</span><br><span class="line">            intervals.erase(intervals.begin() + index);</span><br><span class="line">            <span class="keyword">if</span> (pos - interval.first == k &amp;&amp; interval.first != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interval.second - pos == k &amp;&amp; interval.second != n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos + <span class="number">1</span> &lt;= interval.second)</span><br><span class="line">                intervals.insert(intervals.begin() + index, make_pair(pos + <span class="number">1</span>, interval.second));</span><br><span class="line">            <span class="keyword">if</span> (interval.first &lt;= pos - <span class="number">1</span>)</span><br><span class="line">                intervals.insert(intervals.begin() + index, make_pair(interval.first, pos - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这道题的更好解法是用二叉索引树（<a href="http://www.cnblogs.com/pengzhen/p/4373491.html" target="_blank" rel="noopener">BIT</a>）。讲真，我在LC上还没用过二叉索引树，当时做OA时想到一种什么树的数据结构可以高效的解决这种前缀和的问题但是没想到。BIT在可以允许更新元素的情况下在logn的复杂度内计算一个数组的前缀和，进而计算任意区间的元素和。而我们就是要找到长度为k和为0的区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; slots;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BIT(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        slots = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = pos;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; slots.size()) &#123;</span><br><span class="line">            slots[p]++;</span><br><span class="line">            p = p + lowBit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPrefixSum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="number">0</span>) <span class="keyword">return</span> slots[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> p = pos, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += slots[p];</span><br><span class="line">            p = p - lowBit(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIntervalSum</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrefixSum(end) - getPrefixSum(begin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowers, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(flowers.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bloom</span><span class="params">(flowers.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowers.size(); i++) &#123;</span><br><span class="line">            bit.update(flowers[i]);</span><br><span class="line">            bloom[flowers[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (flowers[i] - k - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; bloom[flowers[i] - k - <span class="number">1</span>] &amp;&amp; bit.getIntervalSum(flowers[i] - k - <span class="number">1</span>, flowers[i] - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flowers[i] + k + <span class="number">1</span> &lt; flowers.size() + <span class="number">1</span> &amp;&amp; bloom[flowers[i] + k + <span class="number">1</span>] &amp;&amp; bit.getIntervalSum(flowers[i], flowers[i] + k) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉索引树BIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无题</title>
      <link href="/2017/09/17/%E6%97%A0%E9%A2%98/"/>
      <url>/2017/09/17/%E6%97%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>现在离家正好四个星期，匹村的温度像过山车，还好我没有感冒。</p><a id="more"></a><h1 id="壹">壹</h1><p>出发时上海电闪雷鸣，飞机延误4小时，到达香港的时候眼睁睁看着下一程的航班飞走。好在国泰服务不错，在酒店睡了3小时候就上了飞往伦敦的飞机，抵达伦敦再转机飞往纽约。</p><blockquote><p>绕远路就是我最短的捷径。</p> <div style="text-align: right;">——哈里发 爽</div></blockquote><p>我的第一次留学生活就在各种初体验的情况下开始了……</p><p>二十多个小时的长途旅行，飞跃大半个地球之后，我终于到了纽约肯尼迪国际机场，终于真正地踏上这片只在电视上看到过的土地。我的行程本来是早上七点到达纽约，玩一天后晚上坐大巴去匹村，奈何迟到了12个小时，只够赶到大巴车站，纽约这座城市怕是要下次再见了。</p><p>清晨时分大巴基本已经快要抵达匹兹堡，路边没有国内的高层公寓和小区，只有美式的二三层小楼，我才真真切切的意识到：我已经到了另外一个国家，我可能要在这里度过数年的时光。</p><h1 id="贰">贰</h1><p>留学生活肯定免不了琐碎，家具、生活用品、食物等等都是添置，好在我要求不高，否则真的是不小的开销。</p><p>一个挺大感触就是灯塔国的空气质量确实好，能见度非常高，眺望远方的感觉就是通透。我住的地方附近的树都长的很高大，都有八九层楼那么高，从窗户往外看总是让我忘记了身处十层的事实。</p><p>生活上的语言关是必需要克服的，上课的问题倒是不大，但是平常的交流中就充分暴露了我听力、口语和词汇量的差距。在自动售货机吞钱后打电话扯皮时，在打电话给银行结果是个印度妹子接电话时，在招聘会跟hr尬聊时，我都深深的意识到英语还是任重而道远。</p><p>也许是我时差还没有完全倒过来，或者是我还没有适应夏令时，每天从12点多睡到久点多还是很困，下午必须再睡一会才行。</p><h1 id="叁">叁</h1><p>CMU的校园真的很小，从东走到西，从南走到北用不了十分钟。可是就是这所小小的大学，声誉和学术水平却比国内一个比一个大的学校不知道高到哪里去。比较可惜的是我到现在都还没有时间去学校拍拍照片。</p><p>在这里上课是一件很舒服的事情，课堂上你可以用各种舒服的姿势坐着，甚至你可以坐在第一排边上课边吃饭，但是课后的作业和项目却是真的逼着你去学习，去写代码，想要真正懈怠混过去怕是不可能。</p><h1 id="肆">肆</h1><p>说完了学习，接下来说找工作。上周CMU开了三天的招聘会，我也奔波了三天，投了近二十份简历，但是不知道有几个能有回音。刚刚做完Google内推的OA，第二题难度爆炸，感觉是要跪了，Amazon的内推还没有下文，FB已经拒了一波简历，招聘会上也只有一家做期货的金融的公司的面试，找工之路漫漫，何时是个头呢？</p><p>以前觉得刷题就行，现在觉得啥都不行，唉……</p><p>不写了，还有报告，读书笔记和project要写……</p><p><em>写于 14：30, 17 Sep EDT</em></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于舰C直连</title>
      <link href="/2017/09/07/%E5%85%B3%E4%BA%8E%E8%88%B0C%E7%9B%B4%E8%BF%9E/"/>
      <url>/2017/09/07/%E5%85%B3%E4%BA%8E%E8%88%B0C%E7%9B%B4%E8%BF%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="关于直连">关于直连</h1><p>舰C游戏不允许非日本ip访问，然而在国内用代理访问经常会偶遇猫神。我现在即使在一个没有墙的地方，距离日本却隔了半个地球，用我的服务器也总是狂猫不止。没办法就只能琢磨琢磨直连了。</p><p><strong>注意⚠️</strong>：由于舰C本身就是禁止非日本ip访问，使用直连方法可能会有不可预估的风险，包括但不限于<strong>封号</strong>等后果。如果担心这个问题请全程代理。</p><p>准备工作：一个可用的日本代理，如ss。不要用全局vpn。</p><p>其实也可以使用改hosts的方法来使用反向代理服务器实现直连，但是反代不是这篇文章的内容，所以请自行搜索。<strong>这篇文章的方法适合手上有代理，但是连接不是很稳定的玩家。</strong></p><a id="more"></a><h1 id="原理">原理</h1><p>舰C登录使用dmm，但是登录之后游戏服务器是裸ip，而游戏服务器是不检测ip地理位置的。也就是说，只有登录阶段有需要用到代理，而游戏阶段是不用走代理的，所以我们只要代理<code>www.dmm.com</code>域名就可以了。然而一般的代理设置（填写代理地址和端口）是使应用内流量全部走代理的。如果是使用全局vpn，那么有登录后关闭vpn的办法，但是对于socks或者http代理却不行。</p><p>接下来我说一说我使用的poi浏览器和74eo的设置方法，其他工具的设置大同小异。</p><h1 id="poi浏览器">poi浏览器</h1><p>新版poi浏览器中有使用pac文件来访问代理的方法</p><img src="http://wx3.sinaimg.cn/large/4c1654ddgy1fjbbwbnqlyj20ey0af74y.jpg" alt="" referrerpolicy="no-referrer"></img><p>因此只要新建一个如下的pac文件，再把它的地址填上就ok了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function FindProxyForURL(url, host) &#123;</span><br><span class="line">    if (host.endsWith(&#39;.dmm.com&#39;) || host.endsWith(&#39;.dmm.co.jp&#39;)) &#123;</span><br><span class="line">        url &#x3D; url.split(&#39;&#x2F;&#39;);</span><br><span class="line">        if (url[0] &#x3D;&#x3D; &#39;http:&#39;) return &#39;PROXY 127.0.0.1:1080&#39;;</span><br><span class="line">        if (url[0] &#x3D;&#x3D; &#39;https:&#39;) return &#39;PROXY 127.0.0.1:1080&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;DIRECT&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要把<code>127.0.0.1：1080</code>换成自己的代理地址。</p><h1 id="74eo">74eo</h1><p>74eo不能使用pac文件，但是我们可以用一个工具：proxifier，来指定代理规则。</p><p>首先，还是设置好代理</p><p><img src="http://i.imgur.com/7apAhgs.png" alt=""></p><p>然后对74eo的可执行程序设置代理规则</p><p><img src="http://i.imgur.com/RpzoLAq.png" alt=""></p><p>注意要把默认的规则改为direct，否则就是全局代理了。</p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> ACG </tag>
            
            <tag> 舰C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 617. Merge Two Binary Trees</title>
      <link href="/2017/08/25/LeetCode-617-Merge-Two-Binary-Trees/"/>
      <url>/2017/08/25/LeetCode-617-Merge-Two-Binary-Trees/</url>
      
        <content type="html"><![CDATA[<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p><a id="more"></a><hr><p>同时遍历两棵二叉树就行了，两棵二叉树都是空时结果二叉树也为空，其他情况下继续遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1) val += t1-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (t2) val += t2-&gt;val;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        TreeNode *t1next, *t2next;</span><br><span class="line">        t1next = t1 ? t1-&gt;left : <span class="literal">nullptr</span>;</span><br><span class="line">        t2next = t2 ? t2-&gt;left : <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        node-&gt;left = mergeTrees(t1next, t2next);</span><br><span class="line">        </span><br><span class="line">        t1next = t1 ? t1-&gt;right : <span class="literal">nullptr</span>;</span><br><span class="line">        t2next = t2 ? t2-&gt;right : <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        node-&gt;right = mergeTrees(t1next, t2next);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 606. Construct String from Binary Tree</title>
      <link href="/2017/08/25/LeetCode-606-Construct-String-from-Binary-Tree/"/>
      <url>/2017/08/25/LeetCode-606-Construct-String-from-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p><p>The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: Binary tree: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">   &#x2F;    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">Output: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, </span><br><span class="line">but you need to omit all the unnecessary empty parenthesis pairs. </span><br><span class="line">And it will be &quot;1(2(4))(3)&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: Binary tree: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">Output: &quot;1(2()(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">Explanation: Almost the same as the first example, </span><br><span class="line">except we can&#39;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.</span><br></pre></td></tr></table></figure><a id="more"></a><hr><p>把一颗二叉树用前序遍历的方法序列化成一个字符串，但是除了节点的值以外，还要用括号来表示子节点的信息，而且不能有歧义，要能完全反序列化成原来的二叉树，也不能有多余的括号。</p><p>关于括号的问题的问题其实就是右子树不为空时左子树的括号不能省略，其他情况下都不用为空节点添加括号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        tree2strImpl(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(ans.begin() + <span class="number">1</span>, ans.end() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tree2strImpl</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        ans += <span class="string">"("</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ans += to_string(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left || t-&gt;right) &#123;</span><br><span class="line">                tree2strImpl(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) tree2strImpl(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 605. Can Place Flowers</title>
      <link href="/2017/08/25/LeetCode-605-Can-Place-Flowers/"/>
      <url>/2017/08/25/LeetCode-605-Can-Place-Flowers/</url>
      
        <content type="html"><![CDATA[<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p><p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number <strong>n</strong>, return if <strong>n</strong> new flowers can be planted in it without violating the no-adjacent-flowers rule.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The input array won’t violate no-adjacent-flowers rule.</li><li>The input array size is in the range of [1, 20000].</li><li><strong>n</strong> is a non-negative integer which won’t exceed the input array size.</li></ol><a id="more"></a><hr><p>使用贪心法求出最多能种多少支花。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i &gt; <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] == <span class="number">1</span>) || (i &lt; flowerbed.size() - <span class="number">1</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                    maxNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 560. Subarray Sum Equals K</title>
      <link href="/2017/08/09/LeetCode-560-Subarray-Sum-Equals-K/"/>
      <url>/2017/08/09/LeetCode-560-Subarray-Sum-Equals-K/</url>
      
        <content type="html"><![CDATA[<p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the array is in range [1, 20,000].</li><li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li></ol><a id="more"></a><hr><p>因为数组中可能出现负数，所以不能用双指针。</p><p>用一个哈希表记录所有前缀和出现的下标，然后对于每一个下标<code>i</code>对应的前缀和<code>sum</code>，找到<code>sum+k</code>出现的下标，其中<strong>大于等于</strong>i的下标的个数就是从i开始的和为k的连续子串的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sum2index;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            sum2index[sum].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sum2index.count(sum + k)) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;indexes = sum2index[sum + k];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; indexes.size() &amp;&amp; indexes[j] &lt; i; j++);</span><br><span class="line">            ans += (indexes.size() - j);</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 565. Array Nesting</title>
      <link href="/2017/08/09/LeetCode-565-Array-Nesting/"/>
      <url>/2017/08/09/LeetCode-565-Array-Nesting/</url>
      
        <content type="html"><![CDATA[<p>A zero-indexed array A consisting of N different integers is given. The array contains all integers in the range [0, N - 1].</p><p>Sets S[K] for 0 &lt;= K &lt; N are defined as follows:</p><p>S[K] = { A[K], A[A[K]], A[A[A[K]]], … }.</p><p>Sets S[K] are finite for each K and should NOT contain duplicates.</p><p>Write a function that given an array A consisting of N integers, return the size of the largest set S[K] for this array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [5,4,0,3,1,6,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">A[0] &#x3D; 5, A[1] &#x3D; 4, A[2] &#x3D; 0, A[3] &#x3D; 3, A[4] &#x3D; 1, A[5] &#x3D; 6, A[6] &#x3D; 2.</span><br><span class="line"></span><br><span class="line">One of the longest S[K]:</span><br><span class="line">S[0] &#x3D; &#123;A[0], A[5], A[6], A[2]&#125; &#x3D; &#123;5, 6, 2, 0&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>N is an integer within the range [1, 20,000].</li><li>The elements of A are all distinct.</li><li>Each element of array A is an integer within the range [0, N-1].</li></ol><a id="more"></a><hr><p>以数组中的当前元素值作为下一个下标，依次访问直到到达一个已经访问过的元素。类似于构造一个链表。</p><p>因为数组中的元素是连续的而且不重复，所以不存在多个元素指向同一个下标。所以最后得到的一定是一个或者多个循环链表的结构。</p><p>因此遍历数组，从每个元素开始构造到结束，把遍历过的所有位置设为-1表示访问过不用再处理，记录得到的最大长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> index = nums[i];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[index] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> pre = index;</span><br><span class="line">                index = nums[index];</span><br><span class="line">                nums[pre] = <span class="number">-1</span>;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 540. Single Element in a Sorted Array</title>
      <link href="/2017/08/09/LeetCode-540-Single-Element-in-a-Sorted-Array/"/>
      <url>/2017/08/09/LeetCode-540-Single-Element-in-a-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<p>Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,7,7,10,11,11]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Your solution should run in O(log n) time and O(1) space.</p><a id="more"></a><hr><p>很经典的题，用异或。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            ans ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 599. Minimum Index Sum of Two Lists</title>
      <link href="/2017/08/09/LeetCode-599-Minimum-Index-Sum-of-Two-Lists/"/>
      <url>/2017/08/09/LeetCode-599-Minimum-Index-Sum-of-Two-Lists/</url>
      
        <content type="html"><![CDATA[<p>Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.</p><p>You need to help them find out their <strong>common interest</strong> with the <strong>least list index sum</strong>. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</span><br><span class="line">[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]</span><br><span class="line">Output: [&quot;Shogun&quot;]</span><br><span class="line">Explanation: The only restaurant they both like is &quot;Shogun&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</span><br><span class="line">[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]</span><br><span class="line">Output: [&quot;Shogun&quot;]</span><br><span class="line">Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1).</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of both lists will be in the range of [1, 1000].</li><li>The length of strings in both lists will be in the range of [1, 30].</li><li>The index is starting from 0 to the list length minus 1.</li><li>No duplicates in both lists.</li></ol><a id="more"></a><hr><p>使用哈希表保存第一个列表中每个字符串对应的下标。接着遍历第二个列表，对每个字符串查找它在第一个列表中出现的位置（不存在则跳过），求出下标和。在这个过程中记录最小的下表和和对应的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRestaurant</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.size(); i++) &#123;</span><br><span class="line">            m[list1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ansStr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!m.count(list2[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> tSum = i + m[list2[i]];</span><br><span class="line">            <span class="keyword">if</span> (tSum &lt; minSum) &#123;</span><br><span class="line">                minSum = tSum;</span><br><span class="line">                ansStr.clear();</span><br><span class="line">                ansStr.push_back(list2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tSum == minSum) &#123;</span><br><span class="line">                ansStr.push_back(list2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 598. Range Addition II</title>
      <link href="/2017/08/09/LeetCode-598-Range-Addition-II/"/>
      <url>/2017/08/09/LeetCode-598-Range-Addition-II/</url>
      
        <content type="html"><![CDATA[<p>Given an m * n matrix <strong>M</strong> initialized with all <strong>0</strong>’s and several update operations.</p><p>Operations are represented by a 2D array, and each operation is represented by an array with two <strong>positive</strong> integers <strong>a</strong> and <strong>b</strong>, which means <code>M[i][j]</code> should be <strong>added by one</strong> for all <strong>0 &lt;= i &lt; a</strong> and <strong>0 &lt;= j &lt; b</strong>.</p><p>You need to count and return the number of maximum integers in the matrix after performing all the operations.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">m &#x3D; 3, n &#x3D; 3</span><br><span class="line">operations &#x3D; [[2,2],[3,3]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">Initially, M &#x3D; </span><br><span class="line">[[0, 0, 0],</span><br><span class="line"> [0, 0, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line"></span><br><span class="line">After performing [2,2], M &#x3D; </span><br><span class="line">[[1, 1, 0],</span><br><span class="line"> [1, 1, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line"></span><br><span class="line">After performing [3,3], M &#x3D; </span><br><span class="line">[[2, 2, 1],</span><br><span class="line"> [2, 2, 1],</span><br><span class="line"> [1, 1, 1]]</span><br><span class="line"></span><br><span class="line">So the maximum integer in M is 2, and there are four of it in M. So return 4.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The range of m and n is [1,40000].</li><li>The range of a is [1,m], and the range of b is [1,n].</li><li>The range of operations size won’t exceed 10,000.</li></ol><a id="more"></a><hr><p>首先注意到每一步的更新策略：</p><blockquote><p><code>M[i][j]</code> should be <strong>added by one</strong> for all <strong>0 &lt;= i &lt; a</strong> and <strong>0 &lt;= j &lt; b</strong>.</p></blockquote><p>也就是说，<code>M[0][0]</code>是每次都必然+1的，也就是说最大的值一定是<code>M[0][0]</code>，而且这个最大的值也等于操作的次数。这样，我们要找的就是每一次都发生了+1操作的位置，换句话说，只要求所有操作所对应的区域的交集就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">final</span> = &#123;m, n&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ops.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span>[<span class="number">0</span>] = min(<span class="keyword">final</span>[<span class="number">0</span>], ops[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">final</span>[<span class="number">1</span>] = min(<span class="keyword">final</span>[<span class="number">1</span>], ops[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">final</span>[<span class="number">0</span>] * <span class="keyword">final</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 594. Longest Harmonious Subsequence</title>
      <link href="/2017/08/09/LeetCode-594-Longest-Harmonious-Subsequence/"/>
      <url>/2017/08/09/LeetCode-594-Longest-Harmonious-Subsequence/</url>
      
        <content type="html"><![CDATA[<p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is <strong>exactly</strong> 1.</p><p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible <a href="https://en.wikipedia.org/wiki/Subsequence" target="_blank" rel="noopener">subsequences</a>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2,2,5,2,3,7]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest harmonious subsequence is [3,2,2,2,3].</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The length of the input array will not exceed 20,000.</p><a id="more"></a><hr><p>这道题要注意两点：</p><ol><li>是<strong>子串</strong>而不是连续子串</li><li>是<strong>exactly one</strong>而不是less than one</li></ol><p>因为不要求连续，所以实际上找到两个连续的数，把他们的出现次数加起来就是要找的子串长度了。每个整数出现了多少次用哈希表来保存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; existTimes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            existTimes[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : existTimes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existTimes.count(iter.first + <span class="number">1</span>)) &#123;</span><br><span class="line">                ans = max(ans, iter.second + existTimes[iter.first + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 593. Valid Square</title>
      <link href="/2017/08/08/LeetCode-593-Valid-Square/"/>
      <url>/2017/08/08/LeetCode-593-Valid-Square/</url>
      
        <content type="html"><![CDATA[<p>Given the coordinates of four points in 2D space, return whether the four points could construct a square.</p><p>The coordinate (x,y) of a point is represented by an integer array with two integers.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: p1 &#x3D; [0,0], p2 &#x3D; [1,1], p3 &#x3D; [1,0], p4 &#x3D; [0,1]</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p>Note:</p><ol><li>All the input integers are in the range [-10000, 10000].</li><li>A valid square has four equal sides with positive length and four equal angles (90-degree angles).</li><li>Input points have no order.</li></ol><a id="more"></a><hr><p>判断四个点能不能组成正方形，我是直接算了四个点两两之间的距离（共六个），其中应该有四个边和两个对角线，判断这六个长度是不是这个规律就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p4)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; length;</span><br><span class="line">        length.push_back(getLength(p1, p2));</span><br><span class="line">        length.push_back(getLength(p1, p3));</span><br><span class="line">        length.push_back(getLength(p1, p4));</span><br><span class="line">        length.push_back(getLength(p2, p3));</span><br><span class="line">        length.push_back(getLength(p2, p4));</span><br><span class="line">        length.push_back(getLength(p3, p4));</span><br><span class="line">        sort(length.begin(), length.end());</span><br><span class="line">        <span class="keyword">return</span> (length[<span class="number">0</span>] == length[<span class="number">1</span>] &amp;&amp; length[<span class="number">0</span>] == length[<span class="number">2</span>] &amp;&amp; length[<span class="number">0</span>] == length[<span class="number">3</span>] &amp;&amp; length[<span class="number">4</span>] == length[<span class="number">5</span>] &amp;&amp; length[<span class="number">3</span>] != length[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) * (p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) + (p1[<span class="number">1</span>] - p2[<span class="number">1</span>]) * (p1[<span class="number">1</span>] - p2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 592. Fraction Addition and Subtraction</title>
      <link href="/2017/08/07/LeetCode-592-Fraction-Addition-and-Subtraction/"/>
      <url>/2017/08/07/LeetCode-592-Fraction-Addition-and-Subtraction/</url>
      
        <content type="html"><![CDATA[<p>Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be <a href="https://en.wikipedia.org/wiki/Irreducible_fraction" target="_blank" rel="noopener">irreducible fraction</a>. If your final result is an integer, say <code>2</code>, you need to change it to the format of fraction that has denominator <code>1</code>. So in this case, <code>2</code> should be converted to <code>2/1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:&quot;-1&#x2F;2+1&#x2F;2&quot;</span><br><span class="line">Output: &quot;0&#x2F;1&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:&quot;-1&#x2F;2+1&#x2F;2+1&#x2F;3&quot;</span><br><span class="line">Output: &quot;1&#x2F;3&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:&quot;1&#x2F;3-1&#x2F;2&quot;</span><br><span class="line">Output: &quot;-1&#x2F;6&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:&quot;5&#x2F;3+1&#x2F;3&quot;</span><br><span class="line">Output: &quot;2&#x2F;1&quot;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The input string only contains <code>'0'</code> to <code>'9'</code>, <code>'/'</code>, <code>'+'</code> and <code>'-'</code>. So does the output.</li><li>Each fraction (input and output) has format <code>±numerator/denominator</code>. If the first input fraction or the output is positive, then <code>'+'</code>will be omitted.</li><li>The input only contains valid <strong>irreducible fractions</strong>, where the <strong>numerator</strong> and <strong>denominator</strong> of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.</li><li>The number of given fractions will be in the range [1,10].</li><li>The numerator and denominator of the <strong>final result</strong> are guaranteed to be valid and in the range of 32-bit int.</li></ol><a id="more"></a><hr><p>模拟分数的计算，我总是觉得好像做过类似的题。</p><p>其实就是单纯的模拟手算就可以了，一个分数有三个属性：</p><ol><li>分子</li><li>分母</li><li>符号</li></ol><p>依次地读取和计算就可以了，最后再求一个最大公约数（辗转相除法）。</p><p>为了实现的简洁优雅一些，并且提高代码复用性，我定义了一个<code>Fraction</code>类并重载了<code>+</code>运算符来进行分数的计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> numerator;</span><br><span class="line">    <span class="keyword">int</span> denominator;</span><br><span class="line">    <span class="keyword">int</span> sign;</span><br><span class="line">    </span><br><span class="line">    Fraction(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : numerator(a), denominator(b), sign(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    Fraction(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> s) : numerator(a), denominator(b), sign(s) &#123;&#125;</span><br><span class="line">    Fraction() : numerator(<span class="number">0</span>), denominator(<span class="number">1</span>), sign(<span class="number">1</span>) &#123;&#125; <span class="comment">// 初始化为0(0/1)</span></span><br><span class="line">    Fraction <span class="keyword">operator</span> + (<span class="keyword">const</span> Fraction&amp; b) &#123;</span><br><span class="line">        <span class="keyword">int</span> ta, tb; <span class="comment">// ta分子，tb分母</span></span><br><span class="line">        tb = denominator * b.denominator;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;sign == <span class="number">-1</span>) ta = -numerator;</span><br><span class="line">        <span class="keyword">else</span> ta = numerator;</span><br><span class="line">        </span><br><span class="line">        ta *= b.denominator;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (b.sign == <span class="number">-1</span>) ta += (-b.numerator * denominator);</span><br><span class="line">        <span class="keyword">else</span> ta += (b.numerator * denominator);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Fraction(<span class="built_in">abs</span>(ta), tb, ta &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s%d/%d\n"</span>, sign == <span class="number">1</span> ? <span class="string">""</span> : <span class="string">"-"</span>, numerator, denominator);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numerator == <span class="number">0</span>) denominator = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> gcd = getGcd(numerator, denominator);</span><br><span class="line">            numerator /= gcd;</span><br><span class="line">            denominator /= gcd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans = (sign == <span class="number">1</span> ? <span class="string">""</span> : <span class="string">"-"</span>);</span><br><span class="line">        ans += (to_string(numerator) + <span class="string">"/"</span> + to_string(denominator));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getGcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) swap(a, b);</span><br><span class="line">        <span class="keyword">if</span> (a % b == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> getGcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionAddition</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expression[<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            expression.insert(expression.begin(), <span class="string">'+'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Fraction ans;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; expression.size()) &#123;</span><br><span class="line">            Fraction next;</span><br><span class="line">            p = readFraction(expression, p, next);</span><br><span class="line">            ans  = ans + next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.getString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readFraction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; expression, <span class="keyword">int</span> p, Fraction &amp;frac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expression[p++] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            frac.sign = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            frac.sign = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> nextP = p;</span><br><span class="line">        <span class="keyword">while</span> (nextP &lt; expression.size() &amp;&amp; <span class="built_in">isdigit</span>(expression[nextP])) nextP++;</span><br><span class="line">        frac.numerator = stoi(<span class="built_in">string</span>(expression.begin() + p, expression.begin() + nextP));</span><br><span class="line">        </span><br><span class="line">        p = nextP + <span class="number">1</span>;</span><br><span class="line">        nextP = p;</span><br><span class="line">        <span class="keyword">while</span> (nextP &lt; expression.size() &amp;&amp; <span class="built_in">isdigit</span>(expression[nextP])) nextP++;</span><br><span class="line">        frac.denominator = stoi(<span class="built_in">string</span>(expression.begin() + p, expression.begin() + nextP));</span><br><span class="line">        <span class="keyword">return</span> nextP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 591. Tag Validator</title>
      <link href="/2017/08/07/LeetCode-591-Tag-Validator/"/>
      <url>/2017/08/07/LeetCode-591-Tag-Validator/</url>
      
        <content type="html"><![CDATA[<p>Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:</p><ol><li>The code must be wrapped in a <strong>valid closed tag</strong>. Otherwise, the code is invalid.</li><li>A <strong>closed tag</strong> (not necessarily valid) has exactly the following format : <code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>. Among them, <code>&lt;TAG_NAME&gt;</code> is the start tag, and <code>&lt;/TAG_NAME&gt;</code> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is <strong>valid</strong> if and only if the TAG_NAME and TAG_CONTENT are valid.</li><li>A <strong>valid</strong> <code>TAG_NAME</code> only contain <strong>upper-case letters</strong>, and has length in range [1,9]. Otherwise, the <code>TAG_NAME</code> is <strong>invalid</strong>.</li><li>A <strong>valid</strong> <code>TAG_CONTENT</code> may contain other <strong>valid closed tags</strong>, <strong>cdata</strong> and any characters (see note1) <strong>EXCEPT</strong> unmatched <code>&lt;</code>, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the <code>TAG_CONTENT</code> is <strong>invalid</strong>.</li><li>A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.</li><li>A <code>&lt;</code> is unmatched if you cannot find a subsequent <code>&gt;</code>. And when you find a <code>&lt;</code> or <code>&lt;/</code>, all the subsequent characters until the next <code>&gt;</code> should be parsed as TAG_NAME (not necessarily valid).</li><li>The cdata has the following format : <code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>. The range of <code>CDATA_CONTENT</code> is defined as the characters between <code>&lt;![CDATA[</code> and the <strong>first subsequent</strong> <code>]]&gt;</code>.</li><li><code>CDATA_CONTENT</code> may contain <strong>any characters</strong>. The function of cdata is to forbid the validator to parse <code>CDATA_CONTENT</code>, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as <strong>regular characters</strong>.</li></ol><p><strong>Valid Code Examples:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;&#x2F;DIV&gt;&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">The code is wrapped in a closed tag : &lt;DIV&gt; and &lt;&#x2F;DIV&gt;. </span><br><span class="line"></span><br><span class="line">The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. </span><br><span class="line"></span><br><span class="line">Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.</span><br><span class="line"></span><br><span class="line">So TAG_CONTENT is valid, and then the code is valid. Thus return true.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;&#x2F;DIV&gt;&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">We first separate the code into : start_tag|tag_content|end_tag.</span><br><span class="line"></span><br><span class="line">start_tag -&gt; &quot;&lt;DIV&gt;&quot;</span><br><span class="line"></span><br><span class="line">end_tag -&gt; &quot;&lt;&#x2F;DIV&gt;&quot;</span><br><span class="line"></span><br><span class="line">tag_content could also be separated into : text1|cdata|text2.</span><br><span class="line"></span><br><span class="line">text1 -&gt; &quot;&gt;&gt;  ![cdata[]] &quot;</span><br><span class="line"></span><br><span class="line">cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;, where the CDATA_CONTENT is &quot;&lt;div&gt;]&gt;&quot;</span><br><span class="line"></span><br><span class="line">text2 -&gt; &quot;]]&gt;&gt;]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The reason why start_tag is NOT &quot;&lt;DIV&gt;&gt;&gt;&quot; is because of the rule 6.</span><br><span class="line">The reason why cdata is NOT &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; is because of the rule 7.</span><br></pre></td></tr></table></figure><p><strong>Invalid Code Examples:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&lt;A&gt;  &lt;B&gt; &lt;&#x2F;A&gt;   &lt;&#x2F;B&gt;&quot;</span><br><span class="line">Output: False</span><br><span class="line">Explanation: Unbalanced. If &quot;&lt;A&gt;&quot; is closed, then &quot;&lt;B&gt;&quot; must be unmatched, and vice versa.</span><br><span class="line"></span><br><span class="line">Input: &quot;&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;&quot;</span><br><span class="line">Output: False</span><br><span class="line"></span><br><span class="line">Input: &quot;&lt;DIV&gt;  unmatched &lt;  &lt;&#x2F;DIV&gt;&quot;</span><br><span class="line">Output: False</span><br><span class="line"></span><br><span class="line">Input: &quot;&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;&#x2F;b&gt; &lt;&#x2F;DIV&gt;&quot;</span><br><span class="line">Output: False</span><br><span class="line"></span><br><span class="line">Input: &quot;&lt;DIV&gt; unmatched tags with invalid tag name  &lt;&#x2F;1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;&#x2F;DIV&gt;&quot;</span><br><span class="line">Output: False</span><br><span class="line"></span><br><span class="line">Input: &quot;&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;&#x2F;C&gt;  &lt;&#x2F;DIV&gt;&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>For simplicity, you could assume the input code (including the <strong>any characters</strong> mentioned above) only contain <code>letters</code>, <code>digits</code>, <code>'&lt;'</code>,<code>'&gt;'</code>,<code>'/'</code>,<code>'!'</code>,<code>'['</code>,<code>']'</code> and <code>' '</code>.</li></ol><a id="more"></a><hr><p>这道题目最大的难点就是题目过于冗长，容易让人找不着北。其实基本的要求只有两个：</p><ol><li>处理close的tag</li><li>处理cdata</li></ol><p>分为这两部分来实现就可以了，其中处理tag的部分使用栈。实现时要注意下标的正确性。</p><p>我想说的另一点跟算法没什么关系，是代码写法的问题。这个题目由于只要返回字符串是否合法，因此只要发现了非法的情况就可以立即返回，但是这给调试带来了不小的麻烦，因为非法的字符串可能有10个以上的原因，我们并不知道是在哪里返回的。除了打各种log之外，我的解决方法是使用一个包装函数包装真正的实现函数，在实现函数中使用返回值来表示返回的位置（实际上应该先用宏定义或者枚举来定义好不同错误原因的返回码），这样就可以快速地定位到错误出现在哪里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> debugFlag = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> cdataLeft = <span class="string">"&lt;![CDATA["</span>;</span><br><span class="line">    <span class="built_in">string</span> cdataRight = <span class="string">"]]&gt;"</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = isValidImpl(code);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debugFlag) <span class="built_in">printf</span>(<span class="string">"Return code: %d\n"</span>, ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isValidImpl</span><span class="params">(<span class="built_in">string</span> &amp;code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (code[p] != <span class="string">'&lt;'</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; tags;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; code.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (code[p] == <span class="string">'&lt;'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p + <span class="number">1</span> &gt;= code.size()) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (code[p + <span class="number">1</span>] != <span class="string">'!'</span>) &#123;</span><br><span class="line">                    <span class="built_in">string</span> tag = getTag(code, p);</span><br><span class="line">                    <span class="keyword">if</span> (debugFlag) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, tag.c_str());</span><br><span class="line">                    <span class="keyword">if</span> (tag.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">                    <span class="keyword">bool</span> bIsLeftTag = isLeftTag(tag);</span><br><span class="line">                    <span class="keyword">if</span> (!validTagName(tag, bIsLeftTag ? <span class="number">1</span> : <span class="number">2</span>, tag.size() - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (bIsLeftTag) &#123;</span><br><span class="line">                        tags.push(tag);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (tags.empty()) <span class="keyword">return</span> <span class="number">-5</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matchTags(tags.top(), tag)) &#123;</span><br><span class="line">                            tags.pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-6</span>; <span class="comment">// unbalanced</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p + cdataLeft.size() + cdataRight.size() &gt; code.size()) <span class="keyword">return</span> <span class="number">-7</span>;</span><br><span class="line">                    <span class="keyword">if</span> (code.substr(p, cdataLeft.size()) != cdataLeft) <span class="keyword">return</span> <span class="number">-8</span>;</span><br><span class="line">                    <span class="keyword">if</span> (debugFlag) <span class="built_in">printf</span>(<span class="string">"Found CDATA at %d.\n"</span>, p);</span><br><span class="line">                    p += cdataLeft.size();</span><br><span class="line">                    <span class="keyword">while</span> (p &lt; code.size() - <span class="number">3</span> &amp;&amp; code.substr(p, cdataRight.size()) != cdataRight) p++;</span><br><span class="line">                    <span class="keyword">if</span> (code.substr(p, cdataRight.size()) != cdataRight) <span class="keyword">return</span> <span class="number">-9</span>;</span><br><span class="line">                    <span class="keyword">if</span> (debugFlag) <span class="built_in">printf</span>(<span class="string">"CDATA end at %d.\n"</span>, p);</span><br><span class="line">                    p += cdataRight.size() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">if</span> (p != code.size() &amp;&amp; tags.empty()) <span class="keyword">return</span> <span class="number">-10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tags.empty()) <span class="keyword">return</span> <span class="number">-11</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchTags</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;left, <span class="keyword">const</span> <span class="built_in">string</span> &amp;right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right.size() != left.size() + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.size() - <span class="number">1</span> &amp;&amp; i &lt; right.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i + <span class="number">1</span>] != right[i + <span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeftTag</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tag[<span class="number">1</span>] != <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validTagName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = end - begin;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span> || len &gt; <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isupper</span>(s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getTag</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; code, <span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">for</span> (end = p; end &lt; code.size() &amp;&amp; code[end] != <span class="string">'&gt;'</span>; end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; p &amp;&amp; code[end] == <span class="string">'&lt;'</span>) <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">""</span>); <span class="comment">// 如果又出现了&lt;。说明invalid</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> tagName;</span><br><span class="line">        <span class="keyword">if</span> (end == code.size()) &#123;</span><br><span class="line">            p = end;</span><br><span class="line">            <span class="keyword">return</span> tagName;</span><br><span class="line">        &#125;</span><br><span class="line">        tagName.assign(code.begin() + p, code.begin() + end + <span class="number">1</span>);</span><br><span class="line">        p = end;</span><br><span class="line">        <span class="keyword">return</span> tagName;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 638. Shopping Offers</title>
      <link href="/2017/08/05/LeetCode-638-Shopping-Offers/"/>
      <url>/2017/08/05/LeetCode-638-Shopping-Offers/</url>
      
        <content type="html"><![CDATA[<p>In LeetCode Store, there are some kinds of items to sell. Each item has a price.</p><p>However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.</p><p>You are given the each item’s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for <strong>exactly</strong> certain items as given, where you could make optimal use of the special offers.</p><p>Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.</p><p>You could use any of special offers as many times as you want.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,5], [[3,0,5],[1,2,10]], [3,2]</span><br><span class="line">Output: 14</span><br><span class="line">Explanation: </span><br><span class="line">There are two kinds of items, A and B. Their prices are $2 and $5 respectively. </span><br><span class="line">In special offer 1, you can pay $5 for 3A and 0B</span><br><span class="line">In special offer 2, you can pay $10 for 1A and 2B. </span><br><span class="line">You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: </span><br><span class="line">The price of A is $2, and $3 for B, $4 for C. </span><br><span class="line">You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. </span><br><span class="line">You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. </span><br><span class="line">You cannot add more items, though only $9 for 2A ,2B and 1C.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>There are at most 6 kinds of items, 100 special offers.</li><li>For each item, you need to buy at most 6 of them.</li><li>You are <strong>not</strong> allowed to buy more items than you want, even if that would lower the overall price.</li></ol><a id="more"></a><hr><p>这道题一看容易往DP去想，但是维度有点太高，我写的会超时。然后发现可以用直接DFS暴力求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lowestPrice = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextNeeds = needs;</span><br><span class="line">            <span class="keyword">bool</span> validSpecial = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nextNeeds.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextNeeds[j] - special[i][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    nextNeeds[j] -= special[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    validSpecial = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validSpecial) &#123;</span><br><span class="line">                lowestPrice = min(lowestPrice, shoppingOffers(price, special, nextNeeds) + special[i].back());</span><br><span class="line">            &#125;</span><br><span class="line">            lowestPrice = min(lowestPrice, calcNormalPrice(price, needs));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowestPrice;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcNormalPrice</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;price, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; needs.size(); i++) &#123;</span><br><span class="line">            p += price[i] * needs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 611. Valid Triangle Number</title>
      <link href="/2017/08/05/LeetCode-611-Valid-Triangle-Number/"/>
      <url>/2017/08/05/LeetCode-611-Valid-Triangle-Number/</url>
      
        <content type="html"><![CDATA[<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Valid combinations are: </span><br><span class="line">2,3,4 (using the first 2)</span><br><span class="line">2,3,4 (using the second 2)</span><br><span class="line">2,2,3</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the given array won’t exceed 1000.</li><li>The integers in the given array are in the range of [0, 1000].</li></ol><a id="more"></a><hr><p>三角形三边的成立条件是：任意两边之和大于第三边/任意两边之差小于第三边。为了方便使用双指针，先对数组进行排序。</p><p>然后遍历数组，选定每一个元素作为一条边L1，接下来就是找到另外两条边了。在内层循环中遍历所有比L1短的边，作为另一条边L2。在寻找第三条边的过程中，使用另一个指针扫描比L1长的边（L3），因为在扫描L2的过程中，L1+L2是递减的，因此我们不必从最长的边开始扫描，而可以从上一次的L3位置继续，这样，对于每一个L1，只需要遍历整个数组一次，因此复杂度为O(n^2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = i - <span class="number">1</span>; left &gt;= <span class="number">0</span>; left--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; i &amp;&amp; nums[right] &gt;= nums[i] + nums[left]) right--;</span><br><span class="line">                ans += right - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 583. Delete Operation for Two Strings</title>
      <link href="/2017/08/04/LeetCode-583-Delete-Operation-for-Two-Strings/"/>
      <url>/2017/08/04/LeetCode-583-Delete-Operation-for-Two-Strings/</url>
      
        <content type="html"><![CDATA[<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to make <em>word1</em> and <em>word2</em> the same, where in each step you can delete one character in either string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of given words won’t exceed 500.</li><li>Characters in given words can only be lower-case letters.</li></ol><a id="more"></a><hr><p>使用动态规划求出最长公共子串是很容易想到的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1.empty() || word2.empty()) <span class="keyword">return</span> word1.length() + word2.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(word1.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(word2.size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (word1[<span class="number">0</span>] == word2[<span class="number">0</span>]) dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] == word2[<span class="number">0</span>]) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word2.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[<span class="number">0</span>] == word2[i]) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; word2.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = dp.back().back();</span><br><span class="line">        <span class="keyword">return</span> word1.length() - len + word2.length() - len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是也可以通过dp直接求解而不是找出最长公共子串的长度，思路基本相同，<code>dp[i][j]</code>表示<code>word1[0:i]</code>和<code>word2[0:j]</code>需要删除的次数，状态转移方程为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (word1[i] &#x3D;&#x3D; word2[j]) dp[i][j] &#x3D; dp[i - 1][j - 1]</span><br><span class="line">else dp[i][j] &#x3D; min(dp[i - 1][j], dp[i][j - 1]) + 1</span><br></pre></td></tr></table></figure><p>如果<code>word1[i] == word2[j]</code>，那么不需要删除字符，删除操作次数不变；如果不相等，那么就要在原来的基础上再删除一个字符（word1或者word2的）。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 581. Shortest Unsorted Continuous Subarray</title>
      <link href="/2017/08/04/LeetCode-581-Shortest-Unsorted-Continuous-Subarray/"/>
      <url>/2017/08/04/LeetCode-581-Shortest-Unsorted-Continuous-Subarray/</url>
      
        <content type="html"><![CDATA[<p>Given an integer array, you need to find one <strong>continuous subarray</strong> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p><p>You need to find the <strong>shortest</strong> such subarray and output its length.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>Then length of the input array is in range [1, 10,000].</li><li>The input array may contain duplicates, so ascending order here means <strong>&lt;=</strong>.</li></ol><a id="more"></a><hr><p>这道题最直观的解法就是排序，对输入数组排序之后分别从两段向中间查找，直到出现与有序数组不同的元素就停下来，去掉两端的有序数组，中间就是我们要找的子数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order_nums = nums;</span><br><span class="line">        sort(order_nums.begin(), order_nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (left = <span class="number">0</span>; left &lt; order_nums.size(); left++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order_nums[left] != nums[left]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (right = order_nums.size() - <span class="number">1</span>; right &gt;= <span class="number">0</span>; right--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order_nums[right] != nums[right]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是使用栈的解法，这个解法的核心思想是左边的不用排序的子串的结尾后一个元素的位置是不对的，我们应该找到这个元素。首先建立一个栈，从左边开始依次按升序入栈，当出现下一个元素小于栈顶时，不断弹出栈顶元素直到栈顶小于下一个元素，假设此时栈的长度为L， 那么L就是这个左边的合法子串的长度，重复这个操作，记录最小的L。对于右边同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = nums.size(), right = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">stack</span>.empty() || nums[i] &gt;= <span class="built_in">stack</span>.back()) <span class="built_in">stack</span>.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.back() &gt; nums[i]) <span class="built_in">stack</span>.pop_back();</span><br><span class="line">                left = min(left, (<span class="keyword">int</span>)<span class="built_in">stack</span>.size());</span><br><span class="line">                <span class="built_in">stack</span>.push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">stack</span>.empty() || nums[i] &lt;= <span class="built_in">stack</span>.back()) <span class="built_in">stack</span>.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.back() &lt; nums[i]) <span class="built_in">stack</span>.pop_back();</span><br><span class="line">                right = min(right, (<span class="keyword">int</span>)<span class="built_in">stack</span>.size());</span><br><span class="line">                <span class="built_in">stack</span>.push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left + right &gt; nums.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> nums.size() - left - right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 排序 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 575. Distribute Candies</title>
      <link href="/2017/08/04/LeetCode-575-Distribute-Candies/"/>
      <url>/2017/08/04/LeetCode-575-Distribute-Candies/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies &#x3D; [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies &#x3D; [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><a id="more"></a><hr><p>很简单的数学问题，平均分n颗糖（n为偶数）给两个人，这些糖中有不同的种类，问其中一个人最多能得到多少种糖。</p><p>很显然，如果糖的种类m大于等于n/2，那么一方最多能得到n/2种糖；如果糖的种类m小于n/2，那么一方最多能得到m种糖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = candies.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; type;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : candies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!type.count(i)) type.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (type.size() &gt; size / <span class="number">2</span>) <span class="keyword">return</span> size / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> type.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习见闻</title>
      <link href="/2017/08/01/%E5%AE%9E%E4%B9%A0%E8%A7%81%E9%97%BB/"/>
      <url>/2017/08/01/%E5%AE%9E%E4%B9%A0%E8%A7%81%E9%97%BB/</url>
      
        <content type="html"><![CDATA[<p>前几天结束了两个多月的实习，感觉体会到的东西还是不少的，就随便写写吧。</p><a id="more"></a><h1 id="cons">Cons</h1><h2 id="大公司没那么完美">大公司没那么完美</h2><p>我这次实习是在国内的一家大型互联网公司，本来会觉得大公司在技术方面会很厉害，应用很多新技术，拥有很多先进的工程经验。然而事实却不是这样，大公司会有很多很厉害的轮子，比如存储、服务器、通信协议等，毕竟是要支持亿级服务的，但是业务代码以及文档方面却是完全没有想象中那样严谨。</p><p>各个不同组件的代码有时候差别很大，已经<s>7102</s>2017年了，竟然还有的代码是用的GBK编码，缩进也不统一，有制表符也有空格。大多数公共组件的文档虽然不算很详细，但也勉强可以看，但是基本上所有的业务代码都没有可用的文档，只能去看代码。</p><p>关于构建和部署也没有想的优雅，也许是为了减少编写Makefile的时间，基本上所有的项目都会有一个通用的Makefile，它做的就是把目录下所有的源文件都编译成目标文件然后全部链接起来。另外，因为测试环境、运营环境和开发环境的库版本不同，为了避免兼容性问题基本全部采用静态链接，导致最后的二进制文件体积巨大。</p><h2 id="工具陈旧">工具陈旧</h2><p>因为我所在的组负责的是有一定历史的业务，因此VCS还是用的svn，开发机GCC版本还停留在4.4.3，连C++11的特性都支持不完全。很多人常说：工具并不重要。这句话虽然很有道理，但是我认为不代表可以完全忽略工具的作用，新的工具支持新的特性，开发起来效率更高，性能更好，<s>让人心情更愉悦</s>。</p><h2 id="可能会很无聊">可能会很无聊</h2><p>大概也是因为我的组负责的是比较稳定的有历史的业务，因此平常工作就是做做产品需求，维护一下已有的功能，说实话并没有什么会驱使你去学习的东西，也没有什么激动人心的东西，工作内容基本还停留在舒适区。</p><h2 id="留给自己学习的时间不多">留给自己学习的时间不多</h2><p>一天在公司花八个小时甚至以上的时间编写没有什么意义的业务代码会大大地挤压学习和自我提升的时间，下班回家后洗漱一下就快要睡觉了，周末也只想着能多休息一下，不能像在学校里一样每天能有大把的时间用来学习新知识。所以工作之后如果没有超人的毅力来牺牲自己的休息和娱乐时间，那么几年都没有什么提升是绝对很有可能的。</p><h1 id="pro">Pro</h1><h2 id="开了眼界">开了眼界</h2><p>见识到了真正在现网运营的后端的基础架构是什么样的，以及大公司内部使用的轮子是怎么设计的。</p><h2 id="学了一些新东西">学了一些新东西</h2><p>学习了如何编写shell脚本；深入地了解了一下Makefile的语法；锻炼了VIM的使用。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从一段代码想到的</title>
      <link href="/2017/07/23/%E4%BB%8E%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%83%B3%E5%88%B0%E7%9A%84/"/>
      <url>/2017/07/23/%E4%BB%8E%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%83%B3%E5%88%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>今天看到一篇微信推送，说下面这段代码有可能引起死循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>], i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看文章下面的评论，基本上都是认为对于<code>a[10]</code>的引用实际上是变量<code>i</code>的地址，然而即使是我这个半吊子水平也知道这显然是错误的解释。但是实际实验了一下之后发现我的第一印象也是有点想当然了。</p><a id="more"></a><h1 id="第一反应">第一反应</h1><p>我之所以认为评论中的解释是错误的，所基于的理由是：<strong>函数栈是从高地址往低地址生长的</strong>。因此在不考虑使用寄存器的情况下，先定义的变量应该会出现在高地址，如果编译器按照声明的顺序来分配栈，那么<code>i</code>应该在<code>a[0]</code>之前而非<code>a[9]</code>之后，因此数组越界写入到<code>i</code>里面去是显然错误的。我在我的机器上使用GCC 5.4.0版本编译上述代码的结果也符合我的预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">        .file   &quot;main.c&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        subq    $64, %rsp</span><br><span class="line">        movq    %fs:40, %rax</span><br><span class="line">        movq    %rax, -8(%rbp)</span><br><span class="line">        xorl    %eax, %eax</span><br><span class="line">        movl    $1, -52(%rbp)</span><br><span class="line">        jmp     .L2</span><br><span class="line">.L3:</span><br><span class="line">        movl    -52(%rbp), %eax</span><br><span class="line">        cltq</span><br><span class="line">        movl    $0, -48(%rbp,%rax,4)</span><br><span class="line">        addl    $1, -52(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">        cmpl    $10, -52(%rbp)</span><br><span class="line">        jle     .L3</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        movq    -8(%rbp), %rdx</span><br><span class="line">        xorq    %fs:40, %rdx</span><br><span class="line">        je      .L5</span><br><span class="line">        call    __stack_chk_fail</span><br><span class="line">.L5:</span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>可以看到变量<code>i</code>的位置是在<code>-52(%rbp)</code>中，而数组<code>a</code>是从<code>-48(%rbp)</code>开始的，并不存在<code>a[10]</code>就是<code>i</code>的情况。以上的汇编代码执行结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** stack smashing detected ***: .&#x2F;main terminated</span><br><span class="line">已放弃 (核心已转储)</span><br></pre></td></tr></table></figure><p>原因是第31行的<code>call __stack_chk_fail</code>检测到了数组越界，而如何检测数组越界？是靠的第14、15行对于<code>-8(%rbp)</code>的设置和第28、29行对它的检测（这种检测也并不是很靠谱）。</p><h1 id="然而">然而……</h1><p>我在另一台机器上使用GCC 4.4.6编译却得到了完全不同的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    .file   &quot;main.c&quot;                             </span><br><span class="line">    .text</span><br><span class="line">.globl main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    $1, -4(%rbp)</span><br><span class="line">    jmp .L2</span><br><span class="line">.L3:</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    cltq</span><br><span class="line">    movl    $0, -48(%rbp,%rax,4)</span><br><span class="line">    addl    $1, -4(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">    cmpl    $10, -4(%rbp)</span><br><span class="line">    jle .L3</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  &quot;GCC: (GNU) 4.4.6 20110731 (Red Hat 4.4.6-4)&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>这次编译器把变量<code>i</code>给放到了数组<code>a</code>之后的<code>-4(%rbp)</code>中（但是这段代码也仍然不会出现死循环，把循环终止条件从<code>&lt;=10</code>变成<code>&lt;=11</code>就可以造成死循环了，原因从汇编中很容易就能发现）。同一编译器的不同版本都把相同声明顺序的变量放到了不同的地址，说明我的第一印象是错误的，<strong>编译器并不会严格地按顺序在栈中分配变量空间</strong>，所有对于顺序的假定都是没什么意义的。</p><h1 id="编译器的警告">编译器的警告</h1><p>实际上，在GCC 5.4.0中使用<code>-O2</code>或<code>-O3</code>选项编译开头代码的话，是会产生警告的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main.c: In function ‘main’:</span><br><span class="line">main.c:6:8: warning: iteration 9u invokes undefined behavior [-Waggressive-loop-optimizations]</span><br><span class="line">   a[i] &#x3D; 0;</span><br><span class="line">        ^</span><br><span class="line">main.c:4:2: note: containing loop</span><br><span class="line">  for (i &#x3D; 1; i &lt;&#x3D; 10; i++)</span><br><span class="line">  ^</span><br></pre></td></tr></table></figure><p>而这个警告的含义是：</p><blockquote><p>Warn if in a loop with constant number of iterations the compiler detects undefined behavior in some statement during one or more of the iterations.</p></blockquote><p>也就是说，这段代码会引起<strong>Undefined Behavior</strong>。</p><h1 id="常见的误解与老生常谈">常见的误解与老生常谈</h1><p>很多人一直认为（包括我），数组越界最多只是引起<em>Segment Fault</em>或者写坏其他变量，然而这是错误的，数组越界是一个<strong>未定义行为(Undefined Behavior)</strong>。具体原因可参考<a href="https://stackoverflow.com/a/18727216/3317502" target="_blank" rel="noopener">这个链接</a>。</p><p>未定义行为是一个常常被提起的概念，它常常被调侃为一旦出现，编译器可以选择忽略，或者烧掉你的CPU，或者格式化整个硬盘，又或者按下核弹发射按钮。这些都是符合标准的行为，因为标准把处理方式的选择权交给了编译器实现者，实现者可以自由发挥。所以，开头的那段代码说可能引起死循环也不能算错，因为<strong>完全可能出现任何情况！</strong></p><div style="font-size: 2.5em;font-weight: bold;">任何依赖于UB的问题和代码都是耍流氓！</div>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应该如何学编程？</title>
      <link href="/2017/07/16/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E7%BC%96%E7%A8%8B%EF%BC%9F/"/>
      <url>/2017/07/16/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E7%BC%96%E7%A8%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>掐指算来我开始学习编程也差不多快要五年了，在此道上我应该算是略显愚笨之人，看到大神的光鲜履历实在难以望其项背。直到现在我也常常问我自己：我应该如何学习编程？五年了，虽然我觉得我还只是管中窥豹，但是我也不是初出茅庐的小菜鸟了，昨天看到了王垠的博文：<a href="http://www.yinwang.org/blog-cn/2017/07/06/master-pl" target="_blank" rel="noopener">如何掌握所有的程序语言</a> ，想说说我自己的想法。当然即使王垠在微软不得志，我跟他的水平也有着数量级的差距，就当是一些瞎BB吧。</p><p>我没接触过函数式编程，所以这一块就……</p><img src="https://wx3.sinaimg.cn/large/4c1654ddgy1fhcv6mwgoej20bm095dg1.jpg" alt="" referrerpolicy="no-referrer"></img><p>有的东西写错了也没办法……<s>反正也不会有人看</s>。全文约3400字。</p><a id="more"></a><h1 id="学编程是学什么">学编程是学什么</h1><h2 id="学计算机还是学编程">学计算机还是学编程</h2><p>现在的大学是没有专门的CODE专业的，只有计算机相关的专业，这不是没有道理的，也不是因为coder码农是最近才出现的职业，而是因为<strong>编程</strong>本身并没有什么学习的意义；</p><ol><li>记住一些关键字</li><li>把脑内的解决方案翻译一遍</li><li>键盘上敲出来（编程）</li></ol><p>这就是所谓“编写一个程序”<s>把大象塞进冰箱</s>的工作。第一步和最后一步我想不是什么问题，所以编程难，难就难在第二步。</p><p>而第二步又分为</p><ul><li>如何分析问题</li><li>如何得到解决问题的步骤</li><li>如何用编程语言来表达这些步骤</li></ul><p>如何分析问题是算法，乃至于数学与逻辑学的范畴。第二步则需要你对于所能使用的工具足够熟悉，就像数学家可以把尺寸算的很精确，但是不会用锯子榔头也做不出来一把椅子；这要求你懂得操作系统、计算机网络、数据库、数据结构等应用型的知识。第三步才是编程语言介入的环节，选一种编程语言来实现你脑中构思好的步骤。</p><p>所以不存在可以单独学习的“编程”这种东西，编程必然是要建立在扎实的<s>@楚哥</s>计算机知识的基础上，三大件不行只有方向盘手感不错的车必然不是好车，单纯的从语言入手而不顾及其他的知识是注定学不好编程的。</p><h2 id="学语言是要学什么">学语言是要学什么</h2><blockquote><p>举个夸张点的例子。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……</p></blockquote><p>这是垠神博客里的一段话，我现在看来是真的觉得很有道理。学一种语言写的第一个程序都是输出一个“Hello world.”这个习惯来自于K&amp;R的<em>C Programming Language</em>，因为C语言以及这本书的历史地位而成为了一种惯例。但是实际上<code>printf</code>并不是C语言的一部分，它是函数库提供的一个输出函数，用这个函数来写第一个C程序无可厚非，但是一上来就要求死记硬背各种格式控制字符就属于很扯了。</p><p>但是初学者几乎肯定是分不清这其中的区别的，他们很可能会纠结于一些函数的实现细节而忽略了什么是语言本身的特性，什么是库函数提供的特性。我想说的是学习一门语言学的不是函数的使用，而是语言的变量定义、流程控制、函数定义等部分。垠神的博客中还提到了类型推导、lambda表达式、垃圾回收、指针等应该学习的东西，我觉得这些已经超出了最简单的“使用”语言的范畴，程序员这个群体中大概大多数都没怎么也不会接触这些东西吧，包括我也是对这其中不少东西还是了解的不是很清楚（比如C++的类型推导），我认为对于一两门有兴趣的语言有所了解就行。</p><h2 id="为什么要学">为什么要学</h2><p>我想很多人都是为了高薪来当码农，当然我也不例外。高薪是一部分，但是只为了高薪是不够的，编程是一种让人快乐的事情。下面这段话深得我心：</p><blockquote><p>首先，这种快乐是一种创造事物的纯粹快乐。如同小孩在玩泥巴时感到的快乐一样，成年人喜欢创建事物，特别是自己进行设计。……</p><p>其次，这种快乐来自于开发对他人有用的东西。……</p><p>第三，快乐来自于整个过程体现的一股强大的魅力——将相互啮合的零部件组装在一起，看到它们以精妙的方式运行着，并收到了预期的效果。……</p><p>第四，这种快乐是持续学习的快乐，它来自于这项工作的非重复性。……</p><p>最后，这种快乐还来自于在易于驾驭的介质上工作。程序员，就像诗人一样，几乎仅仅在单纯的思考中工作。程序员凭空地运用自己的想象，来建造自己的“城堡”。……</p></blockquote><p><em>——《人月神话》第一章</em></p><p>我认为编程这一活动属于马斯洛需求层次理论中最高的<strong>自我实现</strong>，就像是文学、电影、音乐等创作型活动一样，本身就是有足够的魅力的，能从中找到乐趣那么学起来自然事半功倍。</p><h1 id="学到什么程度">学到什么程度</h1><h2 id="程度随语言不同">程度随语言不同</h2><p>现在所能见到的大多数流行语言（非函数式）都是所谓类C语言，在最基本的语法上总是能见到C的影子。所以对于不同的语言，他们的基本语法是相通的，搞明白了一种比较<strong>基础的</strong>语言，就可以说基本可以使用现在所能见到的大部分语言了。</p><p>我曾经在知乎上看到一个说法，建议一个程序员应该掌握三种语言：</p><ol><li>一门OOP语言（C++/Java）</li><li>一门脚本语言</li><li>一门函数式语言</li></ol><p>当然我还要再加上一门C语言。我觉得这种说法还是比较合理的，同样，我也认为需要达到的掌握程度是递减的。</p><h2 id="关于c">关于C</h2><p>其中比较特殊的是C，我认为C是每个想要学习计算机（编程）的人都必须掌握的。当然，C的语法是比较简单的，但是因为C是那么底层，那么贴近硬件，而且基本上最底层的软件如OS、数据库、服务器、解释器、硬件驱动等都使用C，所以想要深入的学习下去，C是绕不过去的。另一方面，通过学习C，比如函数的调用、指针的使用、编译链接的细节等，可以与其他部分的知识相对照，会有一种茅塞顿开的感觉，不禁想说一句なるほど。</p><p>所以，掌握C不仅是C的语法本身，更是它背后的传统计算机科学知识，我觉得这应该是研究最深的。</p><h2 id="关于c-java">关于C++/Java</h2><p>这一部分可能还要加上Go？不过Go现在还躺在的我的<strong>学习计划</strong><s>小本子</s>中，所以……不提不提<s>溜了溜了</s>。</p><p>我认为这是应该第二深入的部分，具体到什么程度呢……我想应该是编译、运行的细节吧。也就是两个方面：编译器+运行环境。</p><p>对于编译，不仅要知道一个语言特性是如何使用的，也应该知道编译器是如何实现这一特性的（比如面试必问的虚函数）。知其然而且知其所以然，虽然不一定能提高代码效率和质量，但是可以做到真正的心中有数，不会被编译器的一些诡异行为带到沟里去，调试的时候也可以做到游刃有余，对于生成的目标代码不至于有一些错误的印象。</p><p>对于运行环境，C++和Java有所不同，C++与C类似，而Java却需要去了解JVM等虚拟机的实现（仍然是C/C++）。同样，了解了运行环境才能对程序的运行情况了然于心，知道在什么阶段可能会出什么样的问题。比如我最近用C++写的一个动态库放到测试服务器上直接coredump，原因是SIGFPE浮点错误，而我的程序中根本就没有浮点计算，最终发现原因出现在ld.so这个库的版本不一致导致加载动态库出错。这样的问题看源代码是没有用的，因为本来就没有问题，需要你对于运行时的整个过程有一定了解才行。</p><h2 id="关于脚本语言">关于脚本语言</h2><p>对于脚本语言我是没有什么深入研究的，虽然用过Python，PHP，JS来写过程序，但是都没有怎么深入的了结果，全部都是拿来就用，连一本教程都没看过。其实这才是熟练掌握了几门语言后在遇到一门新语言时应该出现的情况。打开语言官网，找到tutorial/handbook/documentation，花几十分钟读一下前几章就可以上手了。</p><p>实习期间我有一次需要写一个Shell脚本来封装一下我写的一个可执行程序，需要检查重复进程，处理输出文件，检查出错以及数据上报等功能，本来我是从来没有写过也没有学习过Shell脚本的，但是花了一上午不到两个小时的时间看了看语法后就可以写了。虽然没有研究一些细节的深入的特性，但是也达到了能使用的程度；而且也没有必要学的那么仔细对不对？毕竟是临时有用的东西，等到什么时候需要了解其他特性的时候再去学习也不迟。</p><h1 id="应该怎么学">应该怎么学</h1><h2 id="google是最好的老师">Google是最好的老师</h2><p>国内大学中的课程实在是太慢了，而且也远远地与现实脱节，因此，自学是想学好计算机的人所必须具备的技能。而都是自学，用百度自学的和用Google自学的效率完全不可同日而语。所以，想学编程，第一步从扔掉百度开始。</p><h2 id="选好教材">选好教材</h2><p>对于初学者来说一本好的教材是很重要的，当然入门之后就不是很需要语言教材了，因为更深层的东西不会写在语言教材里，它们在操作系统，计算机网络，编译原理，虚拟机等书籍中。国外的经典教材是最好的，也不要畏惧大部头，一般不会跟国内拼凑版的教材一样那么枯燥无味。更重要的是要坚持读下去。我是不支持通过看视频来学习的，信息密度相比于读书来说低了太多，而且质量也没有保证。</p><h2 id="英语可能更重要">英语可能更重要</h2><p>是的，相比于一门编程语言来说，要想学好编程，英语可能更重要一点。我一直认为数学能力不是必须的，但是逻辑思维能力和足够的英语能力是成为好程序员的重要条件。也不需要太高，过了六级就差不多，毕竟技术书籍和文档不会出现过于晦涩的文法和单词。英语搭配Google会使你的学习直接走上快车道。</p><h2 id="还是要多练习">还是要多练习</h2><p>这一点是说给我自己听的，我也知道要多看源码，多写。看源码也不是什么过于艰难的事情，但是我总是以没时间，没有引起我的兴趣而不去做。这样不行，是时候定个小目标了。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大梅沙半日游</title>
      <link href="/2017/07/01/%E5%A4%A7%E6%A2%85%E6%B2%99%E5%8D%8A%E6%97%A5%E6%B8%B8/"/>
      <url>/2017/07/01/%E5%A4%A7%E6%A2%85%E6%B2%99%E5%8D%8A%E6%97%A5%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<img src="https://wx4.sinaimg.cn/large/4c1654ddgy1fh4oz0i2r1j23s024i1kx.jpg" alt="" referrerpolicy="no-referrer"></img><p>上星期也不知道我脑子里面的哪根筋搭错了想要跑去深圳的海边玩玩，说走就走啊，Google一搜，去大小梅沙吧。</p><a id="more"></a><h1 id="0x0">0x0</h1><p>地图一看也不是很远，公交车区区两小时而已嘛。于是今天我就单枪匹马地去了，然而整个经历让我深深地思考了如何防止脑袋再次被驴踢。</p><p>首先我选择了下午两点出发，目的是为了避过太阳直射的时间。如意算盘打得叮当响，可是没想到这个时间挤掉了午睡时间，加上中午只吃了一包方便面+俩荷包蛋，在公交车上又困又饿，再加上深圳的电动公交加速减速那叫一个汹涌澎湃，不出二十分钟我的胃里就仿佛翻江倒海一样——晕车了。</p><p>忍了一个多小时，在离终点还有几站路（然而距离却不近）的时候终于还是没忍住，问售票员要了个塑料袋把可怜的方便面又全都吐了出来。吐完之后我的脑子里只有这么几个问题：我是谁？我在哪？我在干什么？</p><p>我真的怀疑去年从成都到九寨沟单程8小时山路的大巴我是怎么忍的<s>得了吧，去的时候最后一段山路一样没忍住</s>。</p><h1 id="0x1">0x1</h1><p>两点出发，四点半到达，好歹是到了。走到海滨公园的入口，WTF？还要预约？好在是免费的，当场掏出手机打开微信完成预约。不不，我不会称赞微信有多方便，要是没有微信的话可能就会因为预约太麻烦而不会实施预约了呢对不对。科技进步了也不一定会让生活更便捷，因为总是有人想办法给你添堵。</p><h1 id="0x2">0x2</h1><p>进了海滨公园的大门，映入眼帘的是一大片沙滩和<s>一大锅饺子</s>划掉，是一大群人。目测人口密度大于4人/平方米，我又一次产生了我为什么要来这里的疑问……</p><p>既然来都来了，我也只好在沙滩上走走吧，于是我花了半个小时从一头走到了另一头……</p><p>对，没有错。坐公交两个半小时，进去逛了半小时……</p><p>然后，我就出来了……来了……了……</p><p>然后，我就回家了……家了……了……</p><h1 id="0x3">0x3</h1><p>回程选择公交+地铁，好在胃里空了，没有晕车。</p><p>走出地铁站的时候，突然下起了骤雨，哗啦啦我一开始还以为是刮风，然而豆大的雨滴几秒内就让我意识到了错误，只能狂奔到商场躲雨来避免湿透的命运，每一滴落在我头上的雨，都是我决定今天出门时脑子里进的水。</p><h1 id="0x4">0x4</h1><p>真是完美的一天啊。（笑</p><h1 id="0x5">0x5</h1><img src="https://wx1.sinaimg.cn/large/4c1654ddgy1fh4oyv83d5j23s02io7wh.jpg" alt="" referrerpolicy="no-referrer"></img><img src="https://wx2.sinaimg.cn/large/4c1654ddgy1fh4oywr300j23s02io7wh.jpg" alt="" referrerpolicy="no-referrer"></img><img src="https://wx4.sinaimg.cn/large/4c1654ddgy1fh4oyyzu5sj23s02io7wi.jpg" alt="" referrerpolicy="no-referrer"></img><img src="https://wx1.sinaimg.cn/large/4c1654ddgy1fh4oz1qcxrj23s02iono1.jpg" alt="" referrerpolicy="no-referrer"></img>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离线手动配置VIM</title>
      <link href="/2017/06/29/%E7%A6%BB%E7%BA%BF%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEVIM/"/>
      <url>/2017/06/29/%E7%A6%BB%E7%BA%BF%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEVIM/</url>
      
        <content type="html"><![CDATA[<p>实习公司的后台开发都在一台内网的开发机上，登录还要通过跳板机，并且禁止SCP、FTP等协议，开发只能使用VIM等命令行编辑器，使用sz/rz来临时上传下载文件。开发机上的vim没有任何插件，撑死了使用vimrc来打开行号、代码高亮等基础功能，自动补全只能用<code>Ctrl-N</code>这种原始的单词匹配来勉强使用。由于开发机不能连接外网，所以废掉了几乎所有一件配置脚本，Vundle什么的也是基本无解，只能进行手动配置了。本文记录一下我的折腾过程。</p><p><s>// 还有一个月就走了费什么劲呢</s></p><p><s>// 生命在于折腾</s></p><a id="more"></a><h1 id="编译安装新版本vim">编译安装新版本VIM</h1><p>机器上的VIM版本还停留在7.2，已经过于老旧了，所以先自己编译一个新版本的VIM。</p><p>先下载VIM 8.0的源码，下载地址：<a href="ftp://ftp.vim.org/pub/vim/unix/vim-8.0.tar.bz2">ftp://ftp.vim.org/pub/vim/unix/vim-8.0.tar.bz2</a></p><p>解压后运行<code>./configure --prefix=~/local/ --with-features=huge --enable-pythoninterp</code>，然后<code>make;make install;</code>。</p><p>我用gcc 4.4.6在3.10.94内核上编译成功。</p><h1 id="外观-按键映射等设置">外观，按键映射等设置</h1><p>我是使用<a href="https://github.com/kaochenlong/eddie-vim" target="_blank" rel="noopener">https://github.com/kaochenlong/eddie-vim</a>的.vim目录和.vimrc文件。</p><p>关于颜色主题，可以使用这个网站<a href="http://bytefluent.com/vivify/" target="_blank" rel="noopener">http://bytefluent.com/vivify/</a>，大量配色方案可选。我还是选最经典的molokai。</p><h1 id="插件">插件</h1><p>VIM强大的一个主要原因就是插件。</p><p>其实本来这些插件都是用pathogen或者Vundle之类来自动安装的，但是谁让开发机连不上Github呢，所以只能手动把插件从Github上下载下来再复制到<code>~/.vim/bundle/</code>的相应目录下。</p><p>我准备安装的插件：</p><ul><li><a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">https://github.com/tpope/vim-pathogen</a>|插件管理，不装会报错（装了也没用），当然也可以编辑.vimrc来避免</li><li><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">https://github.com/scrooloose/nerdtree</a>|文件浏览，安装后可以使用<code>&lt;leader&gt;r</code>来快速打开</li><li><a href="https://github.com/jistr/vim-nerdtree-tabs" target="_blank" rel="noopener">https://github.com/jistr/vim-nerdtree-tabs</a>|默认的NERDTree是跟随tab的，使用这个插件可以在任何tab中都显示一个NERDTree。用t在新标签中打开，i横向分割窗口，s纵向分隔窗口。</li><li><a href="https://github.com/ervandew/supertab" target="_blank" rel="noopener">https://github.com/ervandew/supertab</a>|用tab键来触发自动补全</li><li><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">https://github.com/majutsushi/tagbar</a>|显示当前文件中的所有tag（使用ctags），但是不会生成ctags文件</li><li><a href="https://github.com/kien/ctrlp.vim" target="_blank" rel="noopener">https://github.com/kien/ctrlp.vim</a>|文件搜索</li><li><a href="https://github.com/kien/tabman.vim" target="_blank" rel="noopener">https://github.com/kien/tabman.vim</a>|标签管理，默认快捷键<code>&lt;leader&gt;mt</code></li><li><a href="https://github.com/Raimondi/delimitMate" target="_blank" rel="noopener">https://github.com/Raimondi/delimitMate</a>|自动插入匹配的括号</li><li><a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">https://github.com/vim-airline/vim-airline</a>|底部状态栏美化</li></ul><h1 id="其他">其他</h1><p>按<code>Ctrl-W</code>后，可以用<code>9</code>来减少高度，<code>0</code>来增加高度，<code>,</code>来减少宽度，<code>.</code>来增加宽度。</p><h1 id="最终效果">最终效果</h1><img src="http://wx2.sinaimg.cn/large/4c1654ddgy1fh29u9l3znj21hc0nm418.jpg" alt="" referrerpolicy="no-referrer"></img>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近况</title>
      <link href="/2017/06/04/%E8%BF%91%E5%86%B5/"/>
      <url>/2017/06/04/%E8%BF%91%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>从上个月中旬开始，我就到国内的某互联网大厂实习了。其实本来在Google东京的实习面试中也过了面试进入了Team match的阶段，但是由于时间不够了只能忍痛放弃。现在具体在哪家就不说了。这几个星期也没有什么时间来刷LeetCode了，估计被落下了一大截。上一篇Node.js的博文也只能先停下来了。</p><p>实习的感受就是国内的加班真的很严重，而且很多员工似乎是并没有认为有什么不妥，八九点钟下班是常态。我的职位是后台开发，说实话，在大厂干这种工作是挺无聊的，就是不停的调接口调接口（大概是因为我所在的组所负责的业务已经非常成熟了）总之并没有什么有趣的地方，在这里一干好多年应该不是我想要的生活。</p><p>下周就会收到I-20，已经预约了月底的面签，终于到了最后一道坎了，祝我九月北美找工顺利吧~</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[边做边学]用Node.js+React+Express来写个聊天室(2)</title>
      <link href="/2017/05/13/%E8%BE%B9%E5%81%9A%E8%BE%B9%E5%AD%A6-%E7%94%A8Node-js-React-Express%E6%9D%A5%E5%86%99%E4%B8%AA%E8%81%8A%E5%A4%A9%E5%AE%A4-2/"/>
      <url>/2017/05/13/%E8%BE%B9%E5%81%9A%E8%BE%B9%E5%AD%A6-%E7%94%A8Node-js-React-Express%E6%9D%A5%E5%86%99%E4%B8%AA%E8%81%8A%E5%A4%A9%E5%AE%A4-2/</url>
      
        <content type="html"><![CDATA[<p><s>期末考完了，春活也全甲全船了，来继续更这个没人看的系列</s></p><p><s>我的前端写的很丑，就不提CSS了……</s></p><!-- toc --><a id="more"></a><h1 id="前端">前端</h1><h2 id="react">React</h2><p><a href="tps://facebook.github.io/react/">React</a>是Facebook开源的一个前端框架，它把本来应该写在HTML文件中的HTML语句放到JS中，HTML结构不是由浏览器直接下载解析，而是执行JS语句之后才会生成，再交给浏览器解析。那么相比于传统的HTML+JS的结构，React这种框架有什么优势呢，以下的链接可能会有帮助：</p><ul><li>https://facebook.github.io/react/blog/2013/06/05/why-react.html</li><li>https://blog.syncano.io/reactjs-reasons-why-part-1/</li></ul><p>从我这个初学者的角度来说，React的组件化开发方式相比于HTML的树状结构在结构上更清晰，开发效率也更高，更接近传统桌面应用程序的结构。对于页面结构（也就是HTML的结构）的变化更容易处理，适合构建<a href="https://www.wikiwand.com/en/Single-page_application" target="_blank" rel="noopener">单页应用</a>。</p><p>React文档地址：<a href="https://facebook.github.io/react/docs/hello-world.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/hello-world.html</a></p><h2 id="初始化react应用程序">初始化React应用程序</h2><p>安装指引：<a href="https://facebook.github.io/react/docs/installation.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/installation.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app frontend</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> frontend</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>我当前的React版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">  <span class="string">"react"</span>: <span class="string">"^15.5.4"</span>,</span><br><span class="line">  <span class="string">"react-dom"</span>: <span class="string">"^15.5.4"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>最后的<code>npm start</code>会启动一个HTTP调试服务器，访问<code>http://localhost:3000</code>可以看到初始页面。运行<code>npm run build</code>可以在<code>build/static</code>目录下编译出静态js和css文件。</p><p>虽然React把HTML放在了JS中，但是还是要有一个最简单的HTML文件作为基础，这个文件在<code>public/index.html</code>。这个文件很简单，<code>body</code>标签中只有一个<code>id=&quot;root&quot;</code>的<code>div</code>标签，整个过程中我们基本不需要修改这个文件，我们的主要目标在<code>src</code>目录中。</p><h2 id="渲染组件">渲染组件</h2><p><code>src</code>目录中有一个<code>index.js</code>文件，该文件调用<code>ReactDOM.render</code>来进行组件的渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而<code>App.js</code>中创建了一个继承<code>Component</code>的<code>App</code>类，并把它导出。这个类中的<code>render()</code>方法返回了HTML文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./logo.svg'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">"App-header"</span>&gt;</span><br><span class="line">          &lt;img src=&#123;logo&#125; className=<span class="string">"App-logo"</span> alt=<span class="string">"logo"</span> /&gt;</span><br><span class="line">          &lt;h2&gt;Welcome to React&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;p className=<span class="string">"App-intro"</span>&gt;</span><br><span class="line">          To <span class="keyword">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><h2 id="增加组件">增加组件</h2><p>创建一个<code>Chatroom.js</code>文件用于保存聊天室js代码。页面上显示三个component：标题，消息列表，发送消息的表单。所以先创建一个<code>Chatroom</code>类，它再创建这三个组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;<span class="keyword">this</span>.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;MessageList messages = &#123;this.messages&#125;/</span>&gt;</span><br><span class="line">    &lt;NewMessageForm /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="messagelist"><code>MessageList</code></h3><p><code>MessageList</code>用于显示消息列表，它就是一个简单的<code>&lt;ul&gt;</code>标签，它的传入参数中有一个<code>messages</code>是要显示的消息的list。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMessageList (messages) &#123;</span><br><span class="line">    <span class="keyword">return</span> messages.map(<span class="function">(<span class="params">msg</span>) =&gt;</span></span><br><span class="line">      &lt;li&gt;</span><br><span class="line">      &lt;Message message = &#123;msg&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &#123;this.getMessageList(this.props.messages)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMessageList</code>这个函数使用<code>map</code>方法为<code>messages</code>中的每一条message创建一个<code>&lt;li&gt;</code>标签，<code>&lt;li&gt;</code>标签中包含<code>Message</code>组件。</p><h3 id="message"><code>Message</code></h3><p><code>Message</code>组件返回一个包含message内容的<code>&lt;div&gt;</code>标签。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="keyword">this</span>.props.message&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newmessageform"><code>NewMessageForm</code></h3><p><code>NewMessageForm</code>是发送消息的表单，关于React表单的使用参考这里<a href="https://facebook.github.io/react/docs/forms.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/forms.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewMessageForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">inputMessage</span>: <span class="string">''</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit (event) &#123;</span><br><span class="line">    alert(<span class="string">"Message: "</span> + <span class="keyword">this</span>.state.inputMessage);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange (event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">inputMessage</span>: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &lt;label&gt;Message:&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;textarea value=&#123;this.state.inputMessage&#125; onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button type='submit'&gt;Send&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>该类的实现中使用了<code>this.state</code>，它可以用于保存组件的各种状态，并且在<code>state</code>发生变更时自动地更新使用它的值的位置所显示的内容。关于state参考这里：<a href="https://facebook.github.io/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/state-and-lifecycle.html</a>。</p><p>在表单提交的时候，为了避免页面刷新，以前我都是使用AJAX来提交数据，不过这次我打算使用WebSocket来进行通信。</p><h1 id="下一步">下一步</h1><p>实现WebSocket通信。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
            <tag> React </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 567. Permutation in String</title>
      <link href="/2017/05/01/LeetCode-567-Permutation-in-String/"/>
      <url>/2017/05/01/LeetCode-567-Permutation-in-String/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><p>Given two strings <strong>s1</strong> and <strong>s2</strong>, write a function to return true if <strong>s2</strong> contains the permutation of <strong>s1</strong>. In other words, one of the first string’s permutations is the <strong>substring</strong> of the second string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">Output:True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The input strings only contain lower case letters.</li><li>The length of both given strings is in range [1, 10,000].</li></ol><hr><p>双指针，在s2中寻找一个连续子串，其中包含所有的s1中的字符并且没有其他字符。用一个哈希表记录s1中每个字符的出现次数，然后右指针前进，直到左右指针之间的子串不满足条件（也就是有字符的出现次数多于其在s1中的出现次数），再向前移动左指针直到满足条件，当子串长度等于s1的长度时返回true，如果没有这样的子串返回false。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">occurs</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s1) &#123;</span><br><span class="line">            occurs[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = p1;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--occurs[s2[p2] - <span class="string">'a'</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; s2[p1] != s2[p2]) &#123;</span><br><span class="line">                    occurs[s2[p1] - <span class="string">'a'</span>]++;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;</span><br><span class="line">                occurs[s2[p2] - <span class="string">'a'</span>]++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            p2++;</span><br><span class="line">            <span class="keyword">if</span> (p2 - p1 == s1.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 566. Reshape the Matrix</title>
      <link href="/2017/05/01/LeetCode-566-Reshape-the-Matrix/"/>
      <url>/2017/05/01/LeetCode-566-Reshape-the-Matrix/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums &#x3D; </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r &#x3D; 1, c &#x3D; 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums &#x3D; </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r &#x3D; 2, c &#x3D; 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><hr><p>没什么好说的，就按照顺序遍历矩阵把元素放进新矩阵就可以了。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrixReshape</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size() * nums.front().size();</span><br><span class="line">        <span class="keyword">if</span> (n != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">                tmp.push_back(col);</span><br><span class="line">                <span class="keyword">if</span> (tmp.size() == c) &#123;</span><br><span class="line">                    ans.push_back(tmp);</span><br><span class="line">                    tmp.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[边做边学]用Node.js+React+Express来写个聊天室(1)</title>
      <link href="/2017/04/28/%E8%BE%B9%E5%81%9A%E8%BE%B9%E5%AD%A6-%E7%94%A8Node-js-React-Express%E6%9D%A5%E5%86%99%E4%B8%AA%E8%81%8A%E5%A4%A9%E5%AE%A4(1)/"/>
      <url>/2017/04/28/%E8%BE%B9%E5%81%9A%E8%BE%B9%E5%AD%A6-%E7%94%A8Node-js-React-Express%E6%9D%A5%E5%86%99%E4%B8%AA%E8%81%8A%E5%A4%A9%E5%AE%A4(1)/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="前言">前言</h1><p>Node.js现在实在是火的不行，搞得我也想来学一学。以我的经验，上手的最快办法就是直接开始做这篇文章就是我边做边学的记录吧。但是以我几年前学的三脚猫js水平，想要直接开始做真的是有点困难。所以先找几篇文章来补补基础知识。</p><p><strong>我也是只个纯新手，难免有错漏之处，欢迎指出。</strong></p><a id="more"></a><h2 id="事前学习">事前学习</h2><p>首先，你不能一点编程不会，至少要有基本js语法知识，比如变量、函数、类之类的东西多少懂一点。在开始动手前，我先看了以下的资料：</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript</a>：如果你没接触过js但是对自己有信心或者接触过但是记忆模糊了，花几十分钟时间看看MDN的这个简单介绍吧。</li><li><a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">http://www.nodebeginner.org/index-zh-cn.html</a>：Node.js简单入门。</li><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a>：《ECMAScript 6入门》，主流浏览器基本已经全部支持了ECMAScript 6，Node.js也基本都支持了，但是诸如<code>import</code>之类的却没有支持。所幸可以用<a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>来提供ES6的支持，不用在前端与后端之间使用不同的代码风格。</li></ol><p>以下的资料都是在代码编写过程中参考：</p><ol><li><a href="https://expressjs.com/" target="_blank" rel="noopener">https://expressjs.com/</a>：Express官方网站</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a>：Node.js官方网站</li><li><a href="https://facebook.github.io/react/" target="_blank" rel="noopener">https://facebook.github.io/react/</a>：React官方网站</li></ol><h2 id="环境">环境</h2><p>Node.js的安装方法、框架的安装方法，编辑器的安装与使用都请参考官方网站的指导，任何其他人的教程都没有官方指导来的及时权威。</p><h1 id="后端">后端</h1><h2 id="初始化一个express项目">初始化一个Express项目</h2><p>我们可以使用<em>Express generator</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>来创建一个Express项目的基本骨架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express-generator -g</span><br><span class="line">$ express --view=pug myapp</span><br><span class="line">$ <span class="built_in">cd</span> myapp</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>目前的Express默认使用Jade模板引擎，但是Jade因为商标原因更名为Pug<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，所以我就直接使用Pug了。</p><p>目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style.css</span><br><span class="line">├── routes</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views</span><br><span class="line">    ├── error.pug</span><br><span class="line">    ├── index.pug</span><br><span class="line">    └── layout.pug</span><br><span class="line"></span><br><span class="line">7 directories, 9 files</span><br></pre></td></tr></table></figure><p>在<code>myapp</code>目录中运行<code>npm start</code>，然后在浏览器内打开<code>http://localhost:3000/</code>就可以看到示例页面了。</p><img src="http://wx3.sinaimg.cn/mw690/4c1654ddgy1ff1jp2n1bcj20dn096jrf.jpg" alt="" referrerpolicy="no-referrer"></img><h2 id="看看初始化了些什么">看看初始化了些什么</h2><p>从<code>package.json</code>中可以看到以下配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "node ./bin/www"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>所以我们刚才的<code>npm start</code>便是执行了<code>./bin/www</code>这个文件。这个文件中注释很清晰，主要是做了一些HTTP服务器的初始化工作，其中引入了<code>app</code>这个依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br></pre></td></tr></table></figure><p>在<code>./app.js</code>这个文件中，同样先是引入依赖，然后设置了一些<em>中间件</em><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，然后增加了两个<em>路由</em><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> index = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);</span><br><span class="line"><span class="keyword">var</span> users = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>);</span><br><span class="line">...</span><br><span class="line">app.use(<span class="string">'/'</span>, index);</span><br><span class="line">app.use(<span class="string">'/users'</span>, users);</span><br></pre></td></tr></table></figure><p>再接下来是一些错误处理。</p><p>我们再到<code>./routes/index</code>里看看主页的处理函数是怎么写的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123; <span class="attr">title</span>: <span class="string">'Express'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>可以看出主页是通过渲染<code>index</code>这个文件来的（实际是<code>views/index.pug</code>），<code>index.pug</code>的文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extends layout</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  h1&#x3D; title</span><br><span class="line">  p Welcome to #&#123;title&#125;</span><br></pre></td></tr></table></figure><p>关于Pug的语法如果有兴趣的话可以参见文档<a href="https://pugjs.org/api/getting-started.html" target="_blank" rel="noopener">https://pugjs.org/api/getting-started.html</a>。</p><p>现在我们搞明白了一个最简单的页面是怎么产生的，但是在后端部分我并不打算通过模板引擎来产生前端页面，这是React的工作，后台我们只要提供API就可以了，也就是说返回的数据是JSON而不是HTML。</p><h2 id="添加一个新的路由">添加一个新的路由</h2><p>现在我们添加一个新的路由用来处理<code>/chat</code>这个path，或者以它开头的path。先在<code>routes</code>目录下创建一个新的文件<code>chat.js</code>，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Chat room homepage.*/</span></span><br><span class="line">router.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">"Welcome to chat room!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A sample sub page.*/</span></span><br><span class="line">router.get(<span class="string">'/sub-page'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">"Welcome to chat room sub page!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>然后回到<code>app.js</code>中，增加路由的绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> chat = <span class="built_in">require</span>(<span class="string">'./routes/chat'</span>);</span><br><span class="line">...</span><br><span class="line">app.use(<span class="string">'/chat'</span>, chat);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后启动服务器，访问<code>http://localhost:3000/chat</code>，和<code>http://localhost:3000/chat/sub-page</code>就可以看到我们在处理函数中设置的文字了。</p><p>怎么样？依葫芦画瓢是不是很简单？接下来工作就没有模板来参照了，换句话说下面的实现都是我的一家之言，如果写得太烂还请多多包涵。</p><h2 id="要增加的功能">要增加的功能</h2><p>回到我最初的目的上来，我想做一个最最简单的在线聊天的页面，有这么几个功能：</p><ul><li>有个页面来显示聊天信息和输入框</li><li>增加新的聊天内容</li><li>新的内容能<strong>推送</strong>给所有用户（需要WebSocket）</li></ul><p>酌情考虑的功能：</p><ul><li>数据持久化；一开始我可能不会使用数据库，数据直接放在内存中</li><li>用户登录；可能会使用cookie来进行身份识别，但是因为是个匿名的聊天室所以不打算有注册登录功能</li></ul><p>下面我一步一步地来增加这些功能。</p><h2 id="聊天信息保存">聊天信息保存</h2><p>出于简化的考虑，我先不引入数据库，直接使用一个数组来保存所有的消息。暂时决定每一条消息记录有三个字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>time</td><td>消息发送的时间</td></tr><tr><td>msg</td><td>消息内容</td></tr><tr><td>sender</td><td>消息发送者，需要cookie的配合，暂时留空</td></tr></tbody></table><p>增加数组和创建消息记录的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chat_content = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> makeMsgRecord = <span class="function">(<span class="params">msg, sender</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'time'</span>: date.toString(), </span><br><span class="line">        <span class="string">'msg'</span>: msg,</span><br><span class="line">        <span class="string">'sender'</span>: sender</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过post提交数据">通过POST提交数据</h2><p>网页向服务器提交数据一般都是通过POST（当然也可以通过GET，只不过我们是要更新服务器上的数据，GET并不太合适），那么就要从Express中获取浏览器通过POST提交的数据。分析HTTP Request的body来获取POST数据，这个工作是由<code>bodyParser</code>中间件来完成的，而我们在初始化项目时就已经为我们在<code>app.js</code>中设置好了这个中间件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line">...</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们可以直接在<code>chat.js</code>中的处理函数里取得POST提交的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add new message.*/</span></span><br><span class="line">router.post(<span class="string">'/add-new'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    chat_content.push(makeMsgRecord(req.body.msg, <span class="string">''</span>));</span><br><span class="line">    res.json(&#123;<span class="attr">result</span>: <span class="string">'OK'</span>&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="返回消息列表">返回消息列表</h2><p>返回消息列表就很简单了，不过每次都返回所有的消息太浪费，所以我用了两个URL，<code>/range-list</code>和<code>/list</code>，前者返回一个范围内的消息，后者可以返回最近的<code>num</code>条消息，为了配合<code>/range-list</code>增加了<code>/list-length</code>来返回消息数目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* For router '/range-list', check and set the value. */</span></span><br><span class="line"><span class="keyword">let</span> checkBeginEnd = <span class="function">(<span class="params">begin, end</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _begin = <span class="number">0</span>, _end = chat_content.length;</span><br><span class="line">    <span class="keyword">if</span> (begin !== <span class="literal">undefined</span> &amp;&amp; <span class="built_in">parseInt</span>(begin) !== <span class="literal">NaN</span>) &#123;</span><br><span class="line">        _begin = <span class="built_in">parseInt</span>(begin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end !== <span class="literal">undefined</span> &amp;&amp; <span class="built_in">parseInt</span>(end) !== <span class="literal">NaN</span>) &#123;</span><br><span class="line">        _end = <span class="built_in">parseInt</span>(end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [_begin, _end];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Return the range of message list, from begin to end. */</span></span><br><span class="line">router.get(<span class="string">'/range-list'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> [begin, end] = checkBeginEnd(req.query.begin, req.query.end);</span><br><span class="line">    res.json(chat_content.slice(begin, end));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the last num records of message. If the num is not specified, return the whole list.*/</span></span><br><span class="line">router.get(<span class="string">'/list'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.query.num !== <span class="literal">undefined</span> &amp;&amp; <span class="built_in">parseInt</span>(req.query.num) !== <span class="literal">NaN</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(req.query.num);</span><br><span class="line">        res.json(chat_content.slice(chat_content.length - num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(chat_content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the length of the messages list. */</span></span><br><span class="line">router.get(<span class="string">'/list-length'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;<span class="attr">length</span>: chat_content.length&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="つづく">つづく</h1><p>最简单的功能已经差不多了，先写到这里，接下来的工作就需要前端的配合，包括</p><ul><li>使用WebSocket与服务器连接</li><li>通过Cookie来生成随机的用户名</li></ul><p>下一篇Blog开始用React写前端页面。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1"  class="footnote-item"><p>http://expressjs.com/en/starter/generator.html <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2"  class="footnote-item"><p>https://github.com/pugjs/pug#rename-from-jade <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3"  class="footnote-item"><p>http://expressjs.com/en/guide/using-middleware.html <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4"  class="footnote-item"><p>http://expressjs.com/en/guide/routing.html <a href="#fnref4" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
            <tag> React </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 563. Binary Tree Tilt</title>
      <link href="/2017/04/24/LeetCode-563-Binary-Tree-Tilt/"/>
      <url>/2017/04/24/LeetCode-563-Binary-Tree-Tilt/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">     1</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| &#x3D; 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><hr><p>使用递归来分别计算左右子树。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        tilt(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tilt</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftTilt = tilt(node-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightTilt = tilt(node-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> tilt = <span class="built_in">abs</span>(leftTilt - rightTilt);</span><br><span class="line">        ans += tilt;</span><br><span class="line">        <span class="keyword">return</span> leftTilt + rightTilt + node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 561. Array Partition I</title>
      <link href="/2017/04/24/LeetCode-561-Array-Partition-I/"/>
      <url>/2017/04/24/LeetCode-561-Array-Partition-I/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Example 1:</strong></p><pre><code>Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4.</code></pre><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol></blockquote><p>将数组排序之后从第一个元素开始相邻的元素为一组，将每一组中较小的值加起来就可以了。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size() / <span class="number">2</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            ans += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 553. Optimal Division</title>
      <link href="/2017/04/19/LeetCode-553-Optimal-Division/"/>
      <url>/2017/04/19/LeetCode-553-Optimal-Division/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a list of <strong>positive integers</strong>, the adjacent integers will perform the float division. For example, [2,3,4] -&gt; 2 / 3 / 4.</p><p>However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the <strong>maximum</strong> result, and return the corresponding expression in string format. <strong>Your expression should NOT contain redundant parenthesis.</strong></p><p><strong>Example:</strong></p><pre><code>  Input: [1000,100,10,2]  Output: &quot;1000/(100/10/2)&quot;  Explanation:  1000/(100/10/2) = 1000/((100/10)/2) = 200  However, the bold parenthesis in &quot;1000/((100/10)/2)&quot; are redundant,   since they don't influence the operation priority. So you should return &quot;1000/(100/10/2)&quot;.     Other cases:  1000/(100/10)/2 = 50  1000/(100/(10/2)) = 50  1000/100/10/2 = 0.5  1000/100/(10/2) = 2</code></pre><p><strong>Note:</strong></p><ol><li>The length of the input array is [1, 10].</li><li>Elements in the given array will be in range [2, 1000].</li><li>There is only one optimal division for each test case.</li></ol></blockquote><p>这道题对一个连续除法加上括号，使得到的最终结果最大。像这样的算式：<code>1000/(100/10)/2</code>，如果去掉括号并且保证值不变的话就是：<code>1000/100*10/2</code>，所有的括号都可以打开最终变成一个没有括号的乘除混合的算式。</p><p>因此可以用穷举法穷举每一个运算符位置的可能性（<code>*</code>或<code>/</code>），从中选择结果最大的，然后用括号把乘法括起来，就可以得到结果。左括号的位置应该在前一个符号为<code>/</code>后一个符号为<code>*</code>的数字前，右括号的位置应该在前一个符号为<code>*</code>后一个符号为<code>/</code>的数字后（最后一个数字应该认为后面一个符号为<code>/</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ops;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MULTIPLY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> DIVIDE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> maxResult = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">optimalDivision</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) <span class="keyword">return</span> to_string(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmpOps</span><span class="params">(nums.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxResult = INT_MIN;</span><br><span class="line">        tmpOps[<span class="number">0</span>] = DIVIDE;</span><br><span class="line">        <span class="keyword">double</span> tmpResult = (<span class="keyword">double</span>)nums[<span class="number">0</span>] / nums[<span class="number">1</span>];</span><br><span class="line">        findMaxResult(nums, <span class="number">1</span>, tmpOps, tmpResult);</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ops[i - <span class="number">1</span>] == DIVIDE &amp;&amp; ops[i] == MULTIPLY) &#123;</span><br><span class="line">                ans += (<span class="string">"("</span> + to_string(nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ops[i - <span class="number">1</span>] == MULTIPLY &amp;&amp; ops[i] == DIVIDE) &#123;</span><br><span class="line">                ans += (to_string(nums[i]) + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += to_string(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="string">"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = to_string(nums[<span class="number">0</span>]) + <span class="string">"/"</span> + ans;</span><br><span class="line">        <span class="keyword">if</span> (ops.back() == MULTIPLY) &#123;</span><br><span class="line">            ans += (to_string(nums.back()) + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += to_string(nums.back());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findMaxResult</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmpOps, <span class="keyword">const</span> <span class="keyword">double</span> &amp;result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == nums.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; maxResult) &#123;</span><br><span class="line">                maxResult = result;</span><br><span class="line">                ops = tmpOps;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpOps[begin] = DIVIDE;</span><br><span class="line">        findMaxResult(nums, begin + <span class="number">1</span>, tmpOps, result / nums[begin + <span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        tmpOps[begin] = MULTIPLY;</span><br><span class="line">        findMaxResult(nums, begin + <span class="number">1</span>, tmpOps, result * nums[begin + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 551. Student Attendance Record I</title>
      <link href="/2017/04/16/leetcode-551-Student-Attendance-Record-I/"/>
      <url>/2017/04/16/leetcode-551-Student-Attendance-Record-I/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:</p><ol><li><strong>‘A’</strong> : Absent.</li><li><strong>‘L’</strong> : Late.</li><li><strong>‘P’</strong> : Present.</li></ol><p>A student could be rewarded if his attendance record doesn’t contain <strong>more than one ‘A’ (absent)</strong> or <strong>more than two continuous ‘L’ (late)</strong>.</p><p>You need to return whether the student could be rewarded according to his attendance record.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;PPALLP&quot;Output: True</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;PPALLL&quot;Output: False</code></pre></blockquote><p>题目很简单，就是扫一遍字符串就可以了，但是要注意一些边界情况。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> acnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">2</span> &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'A'</span>) &#123;</span><br><span class="line">                acnt++;</span><br><span class="line">                <span class="keyword">if</span> (acnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'L'</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">'L'</span> &amp;&amp; s[i + <span class="number">2</span>] == <span class="string">'L'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = max(<span class="number">0</span>, (<span class="keyword">int</span>)s.length() - <span class="number">2</span>); i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'A'</span>) &#123;</span><br><span class="line">                acnt++;</span><br><span class="line">                <span class="keyword">if</span> (acnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客启用SSL</title>
      <link href="/2017/04/16/%E5%8D%9A%E5%AE%A2%E5%90%AF%E7%94%A8SSL/"/>
      <url>/2017/04/16/%E5%8D%9A%E5%AE%A2%E5%90%AF%E7%94%A8SSL/</url>
      
        <content type="html"><![CDATA[<p>GitHub Pages默认是启用SSL的，但是绑定了自己的域名之后证书就不匹配了。通过Cloudfare官方的免费服务<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>就可以给博客启用SSL了（当然也就默认使用了他家的CDN）。终于可以跟国内无良ISP的劫持说再见了。</p><img src="https://wx4.sinaimg.cn/large/4c1654ddgy1feodo69jpej207600twea.jpg" alt="" referrerpolicy="no-referrer"></img><a id="more"></a><h1 id="优点">优点</h1><ul><li>杜绝了HTTP劫持</li><li>小绿锁满足强迫症</li><li>Google收录的权重不会受影响</li></ul><h1 id="缺点">缺点</h1><ul><li>免费证书很少，而且总的来说风评不是很好，但是谁让人家免费呢</li><li>对于没有什么重要敏感信息的个人站来说优点不是很明显</li><li>如果要是使用了CDN的话，需要CDN服务商的支持，比如我以前用的Incapsula的免费套餐就不支持</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1"  class="footnote-item"><p>blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/ <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客迁移至Hexo</title>
      <link href="/2017/04/15/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3Hexo/"/>
      <url>/2017/04/15/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3Hexo/</url>
      
        <content type="html"><![CDATA[<p>前段时间多说宣布准备关闭服务，之后偶然看到一个用GitHub Issues来做评论系统的项目：<a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">https://github.com/imsun/gitment</a>，倒不是说对这个想法很感兴趣，而且因为它又激起了我转移到静态博客+GitHub Pages的念头。今天算是付诸行动了吧。</p><a id="more"></a><h1 id="1-为什么要迁移？">1. 为什么要迁移？</h1><p>当初搭博客的时候还是个小白，Hexo，Jekyll这种高大上<s>并不</s>的东西玩不转，所以退而求其次用了比较傻瓜化的WordPress。这几年用着也还可以，但是频繁的更新挺烦人的，而且不支持Markdown(JetPack提供的Markdown支持不知道为什么我总是用不了)，总体来说也还是太“重”了。最最主要的一点是从上个月开始每次更新插件/主题之后都不能退出维护模式，只能ssh到服务器上去手动删除<code>.maintenance</code>文件，所以我决定还是换一个轻量级的静态博客。并且静态博客折腾起主题之类的东西也方便的多。</p><h1 id="2-hexo安装配置">2. Hexo安装配置</h1><p>网上教程到处都有，就不赘述了。</p><h1 id="3-数据导入">3. 数据导入</h1><p>Hexo提供从Wordpress迁移数据的插件<a href="https://hexo.io/docs/migration.html" target="_blank" rel="noopener">https://hexo.io/docs/migration.html</a>，是通过分析WP导出的数据文件来工作的，省去了我写脚本分析数据的麻烦。但是还是不可避免地会有许多问题。</p><p>这个插件会保留WP中的tag和分类，tag是正常的，但是因为Hexo不支持一个页面多个分类（其实我也不太理解为什么WP会支持，跟tag的功能重复了），所以在WP中属于多个分类的页面在导入后会变成子分类的形式，比如一篇文章<code>article</code>分别属于<code>A</code>和<code>B</code>两个分类，在WP中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> article</span><br><span class="line"> &#x2F;      \</span><br><span class="line">A        B</span><br></pre></td></tr></table></figure><p>而导入到Hexo之后会变成类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">article</span><br><span class="line">  |</span><br><span class="line">  B</span><br><span class="line">  |</span><br><span class="line">  A</span><br></pre></td></tr></table></figure><p>这样的形式，在Hexo中看起来是相当的烦人。</p><p>另一个问题是导入插件是通过把HTML文本转换为Markdown来进行数据导入的，这个逆向转换的过程很有可能让你的页面面目全非。不过我的博客数据主要是LeetCode的笔记，原本的Markdown文件都有保留，所以可以直接放弃转换出来的Markdown而使用正确的数据。</p><p>以上两个问题我是通过Python脚本来解决的，脚本拼接导入数据的Front-matter部分和原始Markdown文件的正文部分，同时删除Front-matter<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>中除了第一个分类以外的分类。这个脚本只能处理LeetCode笔记（因为可以通过题号匹配起来），其余的文章不多，我就手动修改了。</p><p>最后一个问题，Hexo的Markdown语法与我一直使用的语法不太一致，导致有的地方渲染不太正常。比如</p><p><img src="/image/post/Screenshot%20from%202017-04-15%2020-45-51.png" alt=""></p><p>这段Markdown，GitHub和Pandoc都会生成引用内的代码块的形式，而Hexo中的三个反引号似乎优先级更高。这个问题我还没有解决，涉及的页面太多了，情况也比较复杂。</p><h1 id="4-主题">4. 主题</h1><p>Hexo的主题并没多到让人挑花眼的程度，但是普遍质量都很高，而且自己修改起来也比较容易。在GitHub上搜索就可以找到很多，我现在用的是<a href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>这个主题，稍微改了一下字体。</p><h1 id="5-托管">5. 托管</h1><p>我以前的Wordpress博客是用我自己的服务器+CDN的形式，Hexo虽然也可以放在我的服务器上，不过既然已经是静态博客了还是GitHub Pages省心省力。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1"  class="footnote-item"><p>https://hexo.io/docs/front-matter.html <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 557. Reverse Words in a String III</title>
      <link href="/2017/04/09/leetcode-557-reverse-words-in-a-string-iii/"/>
      <url>/2017/04/09/leetcode-557-reverse-words-in-a-string-iii/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Let&#39;s take LeetCode contest&quot;</span><br><span class="line">Output: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p></blockquote><p><s>这么简单的题真的会出现？</s></p><p>由于没有多余的空格，所以用双指针找到下一个空格，翻转当前位置与下一个空格之间的字符，设置左指针为下一个空格的位置+1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> p2 = p1;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; s.length() &amp;&amp; s[p2] != <span class="string">' '</span>) p2++;</span><br><span class="line">            reverse(s.begin() + p1, s.begin() + p2);</span><br><span class="line">            p1 = p2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 554. Brick Wall</title>
      <link href="/2017/04/09/leetcode-554-brick-wall/"/>
      <url>/2017/04/09/leetcode-554-brick-wall/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the <strong>top</strong> to the <strong>bottom</strong> and cross the <strong>least</strong> bricks.</p><p>The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.</p><p>If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.</p><p><strong>You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.</strong></p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,2,2,1],</span><br><span class="line">[3,1,2],</span><br><span class="line">[1,3,2],</span><br><span class="line">[2,4],</span><br><span class="line">[3,1,2],</span><br><span class="line">[1,3,1,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The width sum of bricks in different rows are the same and won’t exceed INT_MAX.</li><li>The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won’t exceed 20,000.</li></ol></blockquote><p>虽然行数与每一行的砖块数都可能达到10000，但是总的砖块数最大只有20000，又因为总的砖块间缝隙的数量一定小于砖块总数，所以可以用Hash表来记录每一个出现缝隙的位置一共出现了几次缝隙，出现缝隙次数最多的位置就是穿过砖块数最少的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastBricks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; wall)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wall.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = wall.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; occurTimes;</span><br><span class="line">        <span class="keyword">int</span> width;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : wall[i]) &#123;</span><br><span class="line">                sum += j;</span><br><span class="line">                occurTimes[sum]++;</span><br><span class="line">            &#125;</span><br><span class="line">            width = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        occurTimes[width] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxOccur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : occurTimes) &#123;</span><br><span class="line">            maxOccur = max(maxOccur, i.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row - maxOccur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 547. Friend Circles</title>
      <link href="/2017/04/09/leetcode-547-friend-circles/"/>
      <url>/2017/04/09/leetcode-547-friend-circles/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>There are <strong>N</strong> students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a <strong>direct</strong> friend of B, and B is a <strong>direct</strong> friend of C, then A is an <strong>indirect</strong> friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p><p>Given a <strong>N*N</strong> matrix <strong>M</strong> representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are <strong>direct</strong> friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. </span><br><span class="line">The 2nd student himself is in a friend circle. So return 2.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, </span><br><span class="line">so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>N is in range [1,200].</li><li>M[i][i] = 1 for all students.</li><li>If M[i][j] = 1, then M[j][i] = 1.</li></ol></blockquote><p>比较典型的并查集题目，也可以使用广度优先搜索来解决。</p><p><em>话说朋友圈就直接翻译成Friend Circle?</em></p><p>并查集：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = M.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uf</span><span class="params">(num)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) uf[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!M[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (uf[i] == i &amp;&amp; uf[j] == j) &#123;</span><br><span class="line">                    uf[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (uf[i] == i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = j;</span><br><span class="line">                    <span class="keyword">while</span> (uf[h] != h) h = uf[h];</span><br><span class="line">                    uf[i] = h;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (uf[j] == j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = i;</span><br><span class="line">                    <span class="keyword">while</span> (uf[h] != h) h = uf[h];</span><br><span class="line">                    uf[j] = h;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> h1 = j, h2 = i;</span><br><span class="line">                    <span class="keyword">while</span> (uf[h1] != h1) h1 = uf[h1];</span><br><span class="line">                    <span class="keyword">while</span> (uf[h2] != h2) h2 = uf[h2];</span><br><span class="line">                    uf[h2] = h1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> circleNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf[i] == i) circleNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circleNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BFS：每发现一个未标记的人，则通过广度优先搜索找出他所在的朋友圈的所有人并全部标记为访问过，朋友圈数量+1<s>s</s>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(M.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> friendCircleNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                setMatrix(M, visited, i);</span><br><span class="line">                ++friendCircleNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> friendCircleNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(x);</span><br><span class="line">        visited[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[p][i] &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                    visited[i] = <span class="number">1</span>;</span><br><span class="line">                    q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 543. Diameter of Binary Tree</title>
      <link href="/2017/03/27/leetcode-543-diameter-of-binary-tree/"/>
      <url>/2017/03/27/leetcode-543-diameter-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Example:</strong>Given a binary tree</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p></blockquote><p>这道题可以采用分治法，对于一颗树来说，任意两个节点之间的最长路径从大的方面来说存在两种情况：</p><ul><li>路径经过根节点，则最长路径为左子数的最大深度与右子树的最大深度之和</li><li>路径不经过根节点，又有两种情况：<ul><li>最长路径为左子树的最长路径</li><li>最长路径为右子树的最长路径</li></ul></li></ul><p>所以就可以通过递归求出根节点的这三个长度取最大值就是整棵树的最长路径。</p><p>计算子树的深度可以和计算子树的最长路径结合到一起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> diameterOfBinaryTreeImpl(root, maxDepth);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTreeImpl</span><span class="params">(TreeNode* node, <span class="keyword">int</span> &amp;maxDepth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMaxDepth = <span class="number">0</span>, rightMaxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftAns = diameterOfBinaryTreeImpl(node-&gt;left, leftMaxDepth);</span><br><span class="line">        <span class="keyword">int</span> rightAns = diameterOfBinaryTreeImpl(node-&gt;right, rightMaxDepth);</span><br><span class="line">        maxDepth = max(leftMaxDepth, rightMaxDepth) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(leftMaxDepth + rightMaxDepth, max(leftAns, rightAns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 538. Convert BST to Greater Tree</title>
      <link href="/2017/03/27/leetcode-538-convert-bst-to-greater-tree/"/>
      <url>/2017/03/27/leetcode-538-convert-bst-to-greater-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: The root of a Binary Search Tree like this:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">Output: The root of a Greater Tree like this:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure></blockquote><p>转换一颗二叉搜索树，使其每一个节点都变为原来的值+所有比它大的节点的值的和。</p><p>这道题只要从大往小遍历BST就可以了，也就是DFS先右后左，记录已经遍历过的节点的值的和，每遍历到一个新节点就把节点值加上这个和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        DFS(root, sum);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode *node, <span class="keyword">int</span> &amp;sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        DFS(node-&gt;right, sum);</span><br><span class="line">        <span class="keyword">int</span> v = node-&gt;val;</span><br><span class="line">        node-&gt;val += sum;</span><br><span class="line">        sum += v;</span><br><span class="line">        DFS(node-&gt;left, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 537. Complex Number Multiplication</title>
      <link href="/2017/03/27/leetcode-537-complex-number-multiplication/"/>
      <url>/2017/03/27/leetcode-537-complex-number-multiplication/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given two strings representing two <a href="https://en.wikipedia.org/wiki/Complex_number" target="_blank" rel="noopener">complex numbers</a>.</p><p>You need to return a string representing their multiplication. Note i2 = -1 according to the definition.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1+1i&quot;, &quot;1+1i&quot;</span><br><span class="line">Output: &quot;0+2i&quot;</span><br><span class="line">Explanation: (1 + i) * (1 + i) &#x3D; 1 + i2 + 2 * i &#x3D; 2i, and you need convert it to the form of 0+2i.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1+-1i&quot;, &quot;1+-1i&quot;</span><br><span class="line">Output: &quot;0+-2i&quot;</span><br><span class="line">Explanation: (1 - i) * (1 - i) &#x3D; 1 + i2 - 2 * i &#x3D; -2i, and you need convert it to the form of 0+-2i.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The input strings will not have extra blank.</li><li>The input strings will be given in the form of <strong>a+bi</strong>, where the integer <strong>a</strong> and <strong>b</strong> will both belong to the range of [-100, 100]. And <strong>the output should be also in this form</strong>.</li></ol></blockquote><p>比较简单的题，因为不用考虑非法的输入，所以直接用<code>+</code>把字符串分割，然后分别提取实部和虚部进行运算，把结果再转换为字符串即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">complexNumberMultiply</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ap = convert(a), bp = convert(b);</span><br><span class="line">        <span class="keyword">int</span> ra = ap.first * bp.first + (<span class="number">-1</span>) * ap.second * bp.second;</span><br><span class="line">        <span class="keyword">int</span> rb = ap.first * bp.second + ap.second * bp.first;</span><br><span class="line">        <span class="keyword">return</span> to_string(ra) + <span class="string">"+"</span> + to_string(rb) + <span class="string">"i"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;int, int&gt; convert (string s) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">int</span> plusIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">                a = stoi(s.substr(<span class="number">0</span>, i));</span><br><span class="line">                plusIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b = stoi(s.substr(plusIndex + <span class="number">1</span>, s.length() - plusIndex - <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> make_pair(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 514. Freedom Trail</title>
      <link href="/2017/03/27/leetcode-514-freedom-trail/"/>
      <url>/2017/03/27/leetcode-514-freedom-trail/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>In the video game Fallout 4, the quest “Road to Freedom” requires players to reach a metal dial called the “Freedom Trail Ring”, and use the dial to spell a specific keyword in order to open the door.</p><p>Given a string <strong>ring</strong>, which represents the code engraved on the outer ring and another string <strong>key</strong>, which represents the keyword needs to be spelled. You need to find the <strong>minimum</strong> number of steps in order to spell all the characters in the keyword.</p><p>Initially, the first character of the <strong>ring</strong> is aligned at 12:00 direction. You need to spell all the characters in the string <strong>key</strong> one by one by rotating the ring clockwise or anticlockwise to make each character of the string <strong>key</strong> aligned at 12:00 direction and then by pressing the center button.</p><p>At the stage of rotating the ring to spell the key character <strong>key[i]</strong>:</p><ol><li>You can rotate the <strong>ring</strong> clockwise or anticlockwise <strong>one place</strong>, which counts as 1 step. The final purpose of the rotation is to align one of the string <strong>ring’s</strong> characters at the 12:00 direction, where this character must equal to the character <strong>key[i]</strong>.</li><li>If the character <strong>key[i]</strong> has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you’ve finished all the spelling.</li></ol><p><strong>Example:</strong></p><p><img src="https://leetcode.com/static/images/problemset/ring.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: ring &#x3D; &quot;godding&quot;, key &#x3D; &quot;gd&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line"> For the first key character &#39;g&#39;, since it is already in place, we just need 1 step to spell this character. </span><br><span class="line"> For the second key character &#39;d&#39;, we need to rotate the ring &quot;godding&quot; anticlockwise by two steps to make it become &quot;ddinggo&quot;.</span><br><span class="line"> Also, we need 1 more step for spelling.</span><br><span class="line"> So the final output is 4.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>Length of both <strong>ring</strong> and <strong>key</strong> will be in range 1 to 100.</li><li>There are only lowercase letters in both strings and might be some duplcate characters in both strings.</li><li>It’s guaranteed that string <strong>key</strong> could always be spelled by rotating the string <strong>ring</strong>.</li></ol></blockquote><p>LeetCode做得比较多了就很容易发现一个规律，就是LeetCode所能接受的最大总时间复杂度大约在<code>10^6</code>左右，根据观察输入数据的规模就能大致的知道所用算法的时间复杂度上限是多少。比如输入数据是10000或以上，那么<code>O(n^2)</code>一般就是TLE（除非大量剪枝有可能勉强能过），如果输入数据是1000，那么<code>O(n^2)</code>就是可接受的。这道题的输入数据规模只有100，所以<code>O(n^3)</code>的算法也是可以的，我用的DP就是三次方的复杂度。</p><p>设一个二维数组<code>dp</code>，<code>dp[i][j]</code>表示输入<code>key[i]</code>字符时位于12点位置的是<code>ring[j]</code>字符时所使用的总的步数。显然<code>ring[j]</code>和<code>key[i]</code>要相同，否则直接不用考虑。</p><p>DP的基本思想是对于<code>key[i]</code>，从<code>key[i - 1]</code>时所有可能的<code>ring</code>结束位置的总步数+从该位置转到<code>ring[j]</code>所需要的步数+按按钮中选出最小值，就是<code>dp[i][j]</code>的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; min(dp[i - 1][k] + 1 + min(abs(k - j), ringLength - abs(k - j))), 0 &lt;&#x3D; k &lt; ringLength</span><br></pre></td></tr></table></figure><p>最后再从<code>dp[keyLength - 1]</code>的所有元素中找到最小值，就是所求的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ringChar2Index, dp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> keyLen = key.length(), ringLen = ring.length();</span><br><span class="line">        </span><br><span class="line">        dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(keyLen, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(ringLen, <span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ringLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ring[i] == key[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = min(i, ringLen - i) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; keyLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ringLen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ring[j] == key[i]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> step = INT_MAX;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ringLen; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i - <span class="number">1</span>][k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> t = <span class="built_in">abs</span>(k - j);</span><br><span class="line">                            step = min(step, min(t, ringLen - t) + <span class="number">1</span> + dp[i - <span class="number">1</span>][k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j] = step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minStep = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ringLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[keyLen - <span class="number">1</span>][i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                minStep = min(minStep, dp[keyLen - <span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minStep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在终端中用ASCII字符播放视频</title>
      <link href="/2017/03/23/%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%94%A8ascii%E5%AD%97%E7%AC%A6%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"/>
      <url>/2017/03/23/%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%94%A8ascii%E5%AD%97%E7%AC%A6%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>在终端中用ASCII字符播放视频，不是什么新鲜玩意了，只是今天突然想写来玩一玩。</p><h1 id="用法">用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;ascii_video.py -h</span><br><span class="line">ascii_video.py -i &lt;inputfile&gt; [-s &lt;speed&gt;]</span><br><span class="line">-i: 指定输入视频文件</span><br><span class="line">-s: 播放速度, 与硬件性能有关, 默认为10, 数值越大越快</span><br><span class="line">运行中按q退出, 按p暂停&#x2F;恢复</span><br></pre></td></tr></table></figure><ul><li>不仅对视频，对图片也可以用。</li><li>调小终端字体可以提高效果，但是性能就呵呵了……</li><li>自适应终端大小，但是比例默认拉伸为16:9</li></ul><h1 id="依赖库">依赖库</h1><p>本来想直接用C++和ffmpeg来解码视频，但是太复杂了搞得头大，所以就用Python+OpenCV这个组合了。</p><ul><li>OpenCV</li><li>numpy</li><li>curses</li><li>FFmpeg</li></ul><h1 id="系统">系统</h1><p>我在Ubuntu 16.04上写的，Python版本3.5，默认终端。其他系统和终端模拟器没有测试过，我自己也只拿几个视频跑了一下。</p><h1 id="效果">效果</h1><table><thead><tr><th>原始</th><th>ASCII</th></tr></thead><tbody><tr><td><img src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/bad_apple.png" alt="bad_apple.png"></td><td><img src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/bad_apple_ascii.png" alt="bad_apple_ascii"></td></tr><tr><td><img src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/hyouka.png" alt=""></td><td><img src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/hyouka_ascii.png" alt=""></td></tr><tr><td><img src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/kobayashi.png" alt=""></td><td><img src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/kobayashi_ascii.png" alt=""></td></tr><tr><td><img src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/konosuba.png" alt=""></td><td><img src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/konosuba_ascii.png" alt=""></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Docker设置下载代理</title>
      <link href="/2017/03/18/%E4%B8%BAdocker%E8%AE%BE%E7%BD%AE%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%90%86/"/>
      <url>/2017/03/18/%E4%B8%BAdocker%E8%AE%BE%E7%BD%AE%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>今天装Docker，在下载image的时候总是链接被重置，用Proxychain也没法代理。通过Google找到<a href="https://stackoverflow.com/questions/23111631/cannot-download-docker-images-behind-a-proxy/28093517#28093517" target="_blank" rel="noopener">https://stackoverflow.com/questions/23111631/cannot-download-docker-images-behind-a-proxy/28093517#28093517</a>，官方文档地址：<a href="https://docs.docker.com/engine/admin/systemd/#http-proxy" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/systemd/#http-proxy</a> 。通过配置文件来指定http代理。</p><p>具体步骤如下：</p><ol><li>在<code>/etc/systemd/system</code>目录下创建<code>docker.service.d</code>目录</li><li>在<code>docker.service.d</code>目录中创建文件<code>http-proxy.conf</code>文件</li><li>在配置文件中添加：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment&#x3D;&quot;HTTP_PROXY&#x3D;http:&#x2F;&#x2F;proxy.example.com:80&#x2F;&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>可以使用<code>NO_PROXY</code>变量指定不走代理的地址：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment&#x3D;&quot;NO_PROXY&#x3D;localhost,127.0.0.0&#x2F;8,docker-registry.somecorporation.com&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行<code>sudo systemctl daemon-reload</code>更新设置</li><li>使用<code>systemctl show --property=Environment docker</code>来查看设置是否生效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment&#x3D;HTTP_PROXY&#x3D;http:&#x2F;&#x2F;proxy.example.com:80&#x2F;</span><br></pre></td></tr></table></figure><ol start="7"><li>重启Docker：<code>sudo systemctl restart docker</code></li></ol><p>我的系统是Ubuntu 16.04，用ss-qt来科学上网，代理服务器的地址填写ss的地址就可以了。要注意ss应设置为http代理而不是socks5。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 541. Reverse String II</title>
      <link href="/2017/03/14/leetcode-541-reverse-string-ii/"/>
      <url>/2017/03/14/leetcode-541-reverse-string-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">Output: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><p>**Restrictions:**The string consists of lower English letters only.Length of the given string and k will in the range [1, 10000]</p></blockquote><p>按照题目要求翻转字符串即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k2 = k &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.length(); i += k2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.length())</span><br><span class="line">                reverseStr(s, i, i + k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                reverseStr(s, i, s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseStr</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; left + i &lt; right - i - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            swap(s[left + i], s[right - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 539. Minimum Time Difference</title>
      <link href="/2017/03/14/leetcode-539-minimum-time-difference/"/>
      <url>/2017/03/14/leetcode-539-minimum-time-difference/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum <strong>minutes</strong> difference between any two time points in the list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">Output: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The number of time points in the given list is at least 2 and won’t exceed 20000.</li><li>The input time is legal and ranges from 00:00 to 23:59.</li></ol></blockquote><p>先进行排序，然后依次计算相邻时间的时间差，这个时间差有两个方向，选择较小的一个。最后要注意还要算最后一个时间与第一个时间的时间差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timePoints.size() &gt;= <span class="number">1440</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(timePoints.begin(), timePoints.end());</span><br><span class="line">        <span class="keyword">int</span> minDiff = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timePoints.size(); i++) &#123;</span><br><span class="line">            minDiff = min(minDiff, calcDiff(timePoints[i - <span class="number">1</span>], timePoints[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        minDiff = min(minDiff, calcDiff(timePoints[<span class="number">0</span>], timePoints.back()));</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcDiff</span> <span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aH = stoi(a.substr(<span class="number">0</span>, <span class="number">2</span>)), </span><br><span class="line">            bH = stoi(b.substr(<span class="number">0</span>, <span class="number">2</span>)),</span><br><span class="line">            aM = stoi(a.substr(<span class="number">3</span>, <span class="number">2</span>)),</span><br><span class="line">            bM = stoi(b.substr(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> diff;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bH == aH) &#123;</span><br><span class="line">            <span class="keyword">return</span> bM - aM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            diff = (<span class="number">60</span> - aM) + bM + (bH - aH - <span class="number">1</span>) * <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(diff, <span class="number">1440</span> - diff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 516. Longest Palindromic Subsequence</title>
      <link href="/2017/03/14/leetcode-516-longest-palindromic-subsequence/"/>
      <url>/2017/03/14/leetcode-516-longest-palindromic-subsequence/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p><p><strong>Example 1:</strong>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;bbbab&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>One possible longest palindromic subsequence is “bbbb”.</p><p><strong>Example 2:</strong>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;cbbd&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>One possible longest palindromic subsequence is “bb”.</p></blockquote><p>二维DP。<code>dp[i][j]</code>表示<code>s[i]</code>到<code>s[j]</code>（含两端）的字符串中最长的回文子串。状态转移方程如下：</p><ol><li><code>i==j</code>，<code>dp[i][j]=1</code></li><li><code>s[i]==s[j-1]</code>，<code>dp[i][j]=2</code></li><li><code>s[i]==s[j]</code>， <code>dp[i][j]=dp[i+1][j-1]+2</code></li><li><code>s[i]!=s[j]</code>，<code>dp[i][j]=max(dp[i+1][j], dp[i][j-1])</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.length(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">1</span> == j) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 241. Different Ways to Add Parentheses</title>
      <link href="/2017/03/10/leetcode-241-different-ways-to-add-parentheses/"/>
      <url>/2017/03/10/leetcode-241-different-ways-to-add-parentheses/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p><p>Example 1</p><p>Input: <code>&quot;2-1-1&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((2-1)-1) &#x3D; 0</span><br><span class="line">(2-(1-1)) &#x3D; 2</span><br></pre></td></tr></table></figure><p>Output: <code>[0, 2]</code></p><p>Example 2</p><p>Input: <code>&quot;2*3-4*5&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(2*(3-(4*5))) &#x3D; -34</span><br><span class="line">((2*3)-(4*5)) &#x3D; -14</span><br><span class="line">((2*(3-4))*5) &#x3D; -10</span><br><span class="line">(2*((3-4)*5)) &#x3D; -10</span><br><span class="line">(((2*3)-4)*5) &#x3D; 10</span><br></pre></td></tr></table></figure><p>Output: <code>[-34, -14, -10, -10, 10]</code></p></blockquote><p>一开始我以为这是个排列组合问题，实际上也确实是，但是使用分治+递归可以更容易的解决。使用每个运算符把算式分割成两部分，再对两部分分别递归地处理，直到没有运算符，就直接返回数值。两边的字符串分别返回一个结果数组，根据操作符对数组中的元素两两进行运算，将结果放到结果集中返回给上一层函数。</p><p>要注意的是这道题并不用去重。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> diffWaysToComputeImpl(input, <span class="number">0</span>, input.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToComputeImpl</span><span class="params">(<span class="built_in">string</span> &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isOperation(input[i])) &#123;</span><br><span class="line">                <span class="keyword">auto</span> leftResult = diffWaysToComputeImpl(input, left, i);</span><br><span class="line">                <span class="keyword">auto</span> rightResult = diffWaysToComputeImpl(input, i + <span class="number">1</span>, right);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> j : leftResult) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> k : rightResult) &#123;</span><br><span class="line">                        ans.push_back(operate(j, k, input[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.empty()) &#123;</span><br><span class="line">            ans.push_back(stoi(input.substr(left, right - left)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operate</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">return</span> a - b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOperation</span> <span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || c == <span class="string">'*'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 532. K-diff Pairs in an Array</title>
      <link href="/2017/03/10/leetcode-532-k-diff-pairs-in-an-array/"/>
      <url>/2017/03/10/leetcode-532-k-diff-pairs-in-an-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given an array of integers and an integer <strong>k</strong>, you need to find the number of <strong>unique</strong> k-diff pairs in the array. Here a <strong>k-diff</strong> pair is defined as an integer pair (i, j), where <strong>i</strong> and <strong>j</strong> are both numbers in the array and their <a href="https://en.wikipedia.org/wiki/Absolute_difference" target="_blank" rel="noopener">absolute difference</a> is <strong>k</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 1, 4, 1, 5], k &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</span><br><span class="line">Although we have two 1s in the input, we should only return the number of unique pairs.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:[1, 2, 3, 4, 5], k &#x3D; 1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 1, 5, 4], k &#x3D; 0</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: There is one 0-diff pair in the array, (1, 1).</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The pairs (i, j) and (j, i) count as the same pair.</li><li>The length of the array won’t exceed 10,000.</li><li>All the integers in the given input belong to the range: [-1e7, 1e7].</li></ol></blockquote><p>寻找有多少组差的绝对值等于k的数。先对数组进行排序，然后用双指针从前向后搜索：</p><ol><li>移动右指针，直到左右指针元素之差的绝对值大于等于k；</li><li>再移动左指针，直到左右指针元素之差的绝对值小于k；</li><li>重复1,2步直到右指针到达数组结尾，记录下出现过的k的次数；</li></ol><p>为了去重要跳过已经出现的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; len &amp;&amp; p2 &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = nums[p2] - nums[p1];</span><br><span class="line">            <span class="keyword">if</span> (diff == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">do</span> &#123;p1++;&#125; <span class="keyword">while</span> (p1 &lt; len &amp;&amp; nums[p1 - <span class="number">1</span>] == nums[p1]);</span><br><span class="line">                <span class="keyword">do</span> &#123;p2++;&#125; <span class="keyword">while</span> (p2 &lt; len &amp;&amp; nums[p2 - <span class="number">1</span>] == nums[p2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &lt; k) &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1 &gt;= p2) p2 = p1 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 535. Encode and Decode TinyURL</title>
      <link href="/2017/03/04/leetcode-535-encode-and-decode-tinyurl/"/>
      <url>/2017/03/04/leetcode-535-encode-and-decode-tinyurl/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>.</p><p>Design the <code>encode</code> and <code>decode</code> methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p><p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.</p></blockquote><p>短链接的维护，但不限制内部如何生成短链接。就是Hash表的问题，我直接使用的<code>unordered_map</code>容器所提供的Hash函数对原链接进行处理，得到一个数值，然后将该数值转换为62进制字符串（10个数字+大小写字母各26个），该字符串作为短链接的后缀部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> tinyUrlPrefix = <span class="string">"http://tinyurl.com/"</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; urls;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encode</span><span class="params">(<span class="built_in">string</span> longUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> hashFunc = urls.hash_function();</span><br><span class="line">        <span class="keyword">size_t</span> key = hashFunc(longUrl);</span><br><span class="line">        <span class="built_in">string</span> shortUrl = tinyUrlPrefix + convertToSixtyTwoBase(key);</span><br><span class="line">        urls[shortUrl] = longUrl;</span><br><span class="line">        <span class="keyword">return</span> shortUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> shortUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> urls[shortUrl];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToSixtyTwoBase</span> <span class="params">(<span class="keyword">size_t</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">while</span> (key &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = key % <span class="number">62</span>;</span><br><span class="line">            <span class="keyword">if</span> (mod &lt; <span class="number">10</span>) str.push_back(mod + <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mod &lt; <span class="number">36</span>) str.push_back(mod - <span class="number">10</span> + <span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">else</span> str.push_back(mod - <span class="number">36</span> + <span class="string">'A'</span>);</span><br><span class="line">            key /= <span class="number">62</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Solution solution;</span></span><br><span class="line"><span class="comment">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 530. Minimum Absolute Difference in BST</title>
      <link href="/2017/03/04/leetcode-530-minimum-absolute-difference-in-bst/"/>
      <url>/2017/03/04/leetcode-530-minimum-absolute-difference-in-bst/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a binary search tree with non-negative values, find the minimum <a href="https://en.wikipedia.org/wiki/Absolute_difference" target="_blank" rel="noopener">absolute difference</a> between values of any two nodes.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> There are at least two nodes in this BST.</p></blockquote><p>一个只包含非负元素的二叉搜索树中找到两个元素之间的最小差的绝对值。因为是二叉搜索树所以用中序遍历就可以得到一个有序序列，最小的差值一定是出现在相邻的元素中，只比较相邻元素的差值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> prevVal = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span> <span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> ;</span><br><span class="line">        inOrder(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(prevVal &gt;= <span class="number">0</span>) ans = min (ans, node-&gt;val - prevVal);</span><br><span class="line">        prevVal = node-&gt;val;</span><br><span class="line">        inOrder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 529. Minesweeper</title>
      <link href="/2017/03/03/leetcode-529-minesweeper/"/>
      <url>/2017/03/03/leetcode-529-minesweeper/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Let’s play the minesweeper game (<a href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)" target="_blank" rel="noopener">Wikipedia</a>, <a href="http://minesweeperonline.com/" target="_blank" rel="noopener">online game</a>)!</p><p>You are given a 2D char matrix representing the game board. <strong>‘M’</strong> represents an <strong>unrevealed</strong> mine, <strong>‘E’</strong> represents an <strong>unrevealed</strong> empty square, <strong>‘B’</strong> represents a <strong>revealed</strong> blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, <strong>digit</strong> (‘1’ to ‘8’) represents how many mines are adjacent to this <strong>revealed</strong> square, and finally <strong>‘X’</strong> represents a <strong>revealed</strong> mine.</p><p>Now given the next click position (row and column indices) among all the <strong>unrevealed</strong> squares (‘M’ or ‘E’), return the board after revealing this position according to the following rules:</p><ol><li>If a mine (‘M’) is revealed, then the game is over - change it to <strong>‘X’</strong>.</li><li>If an empty square (‘E’) with <strong>no adjacent mines</strong> is revealed, then change it to revealed blank (‘B’) and all of its adjacent <strong>unrevealed</strong> squares should be revealed recursively.</li><li>If an empty square (‘E’) with <strong>at least one adjacent mine</strong> is revealed, then change it to a digit (‘1’ to ‘8’) representing the number of adjacent mines.</li><li>Return the board when no more squares will be revealed.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The range of the input matrix’s height and width is [1,50].</li><li>The click position will only be an unrevealed square (‘M’ or ‘E’), which also means the input board contains at least one clickable square.</li><li>The input board won’t be a stage when game is over (some mines have been revealed).</li><li>For simplicity, not mentioned rules should be ignored in this problem. For example, you <strong>don’t</strong> need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li></ol></blockquote><p>扫雷游戏，根据题目要求做相应的处理就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> totalRow, totalCol;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; <span class="title">updateBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click)</span> </span>&#123;</span><br><span class="line">        totalRow = board.size();</span><br><span class="line">        totalCol = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">char</span> cur = board[click[<span class="number">0</span>]][click[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">switch</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                updateM(board, click[<span class="number">0</span>], click[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">                updateE(board, click[<span class="number">0</span>], click[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateM</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        board[row][col] = <span class="string">'X'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateE</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= totalRow || col &gt;= totalCol || board[row][col] != <span class="string">'E'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mine = adjacentMine(board, row, col);</span><br><span class="line">        <span class="keyword">if</span> (mine) &#123;</span><br><span class="line">            board[row][col] = mine + <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            board[row][col] = <span class="string">'B'</span>;</span><br><span class="line">            updateE(board, row - <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">            updateE(board, row - <span class="number">1</span>, col);</span><br><span class="line">            updateE(board, row - <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">            updateE(board, row, col + <span class="number">1</span>);</span><br><span class="line">            updateE(board, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">            updateE(board, row + <span class="number">1</span>, col);</span><br><span class="line">            updateE(board, row + <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">            updateE(board, row, col - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">adjacentMine</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[row - <span class="number">1</span>][col - <span class="number">1</span>] == <span class="string">'M'</span>)                cnt++;</span><br><span class="line">        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[row - <span class="number">1</span>][col] == <span class="string">'M'</span>)                                    cnt++;</span><br><span class="line">        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; col + <span class="number">1</span> &lt; totalCol &amp;&amp; board[row - <span class="number">1</span>][col + <span class="number">1</span>] == <span class="string">'M'</span>)          cnt++;</span><br><span class="line">        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; totalCol &amp;&amp; board[row][col + <span class="number">1</span>] == <span class="string">'M'</span>)                              cnt++;</span><br><span class="line">        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; totalRow &amp;&amp; col + <span class="number">1</span> &lt; totalCol &amp;&amp; board[row + <span class="number">1</span>][col + <span class="number">1</span>] == <span class="string">'M'</span>)    cnt++;</span><br><span class="line">        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; totalRow &amp;&amp; board[row + <span class="number">1</span>][col] == <span class="string">'M'</span>)                              cnt++;</span><br><span class="line">        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; totalRow &amp;&amp; col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[row + <span class="number">1</span>][col - <span class="number">1</span>] == <span class="string">'M'</span>)          cnt++;</span><br><span class="line">        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[row][col - <span class="number">1</span>] == <span class="string">'M'</span>)                                    cnt++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 526. Beautiful Arrangement</title>
      <link href="/2017/03/03/leetcode-526-beautiful-arrangement/"/>
      <url>/2017/03/03/leetcode-526-beautiful-arrangement/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Suppose you have <strong>N</strong> integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these <strong>N</strong> numbers successfully if one of the following is true for the ith position (1 ≤ i ≤ N) in this array:</p><ol><li>The number at the ith position is divisible by <strong>i</strong>.</li><li><strong>i</strong> is divisible by the number at the ith position.</li></ol><p>Now given N, how many beautiful arrangements can you construct?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">The first beautiful arrangement is [1, 2]:</span><br><span class="line"></span><br><span class="line">Number at the 1st position (i&#x3D;1) is 1, and 1 is divisible by i (i&#x3D;1).</span><br><span class="line"></span><br><span class="line">Number at the 2nd position (i&#x3D;2) is 2, and 2 is divisible by i (i&#x3D;2).</span><br><span class="line"></span><br><span class="line">The second beautiful arrangement is [2, 1]:</span><br><span class="line"></span><br><span class="line">Number at the 1st position (i&#x3D;1) is 2, and 2 is divisible by i (i&#x3D;1).</span><br><span class="line"></span><br><span class="line">Number at the 2nd position (i&#x3D;2) is 1, and i (i&#x3D;2) is divisible by 1.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><strong>N</strong> is a positive integer and will not exceed 15.</li></ol></blockquote><p>因为数据规模比较小，可以先确定对于每一个位置可以选择数值有哪些，然后再用回溯法穷举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; possibleValue;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        setPossibleValue(N);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">        tryValue(<span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryValue</span> <span class="params">(<span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == visited.size()) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; possibleValue[index].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[possibleValue[index][i]]) &#123;</span><br><span class="line">                visited[possibleValue[index][i]] = <span class="number">1</span>;</span><br><span class="line">                tryValue(index + <span class="number">1</span>, visited);</span><br><span class="line">                visited[possibleValue[index][i]] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPossibleValue</span> <span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span> || j % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    val.push_back(j - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            possibleValue.push_back(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 525. Contiguous Array</title>
      <link href="/2017/03/03/leetcode-525-contiguous-array/"/>
      <url>/2017/03/03/leetcode-525-contiguous-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p></blockquote><p>这道题一看上去我想到了贪心orDP的方向，但是可以用哈希表来解决。思考的关键在于连续子数组中含有相同数目的0和1会具有什么样的特征，另外一点要考虑的是数据规模。数据规模达到50000，说明解法是小于O(n^2)的，而通过对数组一次遍历可以得到的结果有从数组开始到某一个下标为止所包含的0和1的个数。</p><p>如果一个连续子数组<code>[i:j]</code>中的0和1数目相等，那么子数组<code>[0:i]</code>和<code>[0:j]</code>中的0的个数与1的个数之差是相等的。因此对于每一个差值记录最小的下标，当再次出现这个差值时，两个下标之间的子数组就含有相同的0和1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        diff[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            cnt[nums[i]]++;</span><br><span class="line">            <span class="keyword">int</span> t = cnt[<span class="number">0</span>] - cnt[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (diff.count(t)) &#123;</span><br><span class="line">                ans = max(ans, i - diff[t]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                diff[t] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 524. Longest Word in Dictionary through Deleting</title>
      <link href="/2017/03/01/leetcode-524-longest-word-in-dictionary-through-deleting/"/>
      <url>/2017/03/01/leetcode-524-longest-word-in-dictionary-through-deleting/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">&quot;apple&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">&quot;a&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>All the strings in the input will only contain lower-case letters.</li><li>The size of the dictionary won’t exceed 1,000.</li><li>The length of all the strings in the input won’t exceed 1,000.</li></ol></blockquote><p>用双指针来判断一个单词可不可以从另一个单词通过删除字母的来。依次判断，选出最长的。如果有多个最长的，就保留字典序较小的。当遍历到一个单词时，可以进行一定的剪枝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : d) &#123;</span><br><span class="line">            <span class="keyword">int</span> wordLen = word.length(), ansLen = ans.length();</span><br><span class="line">            <span class="keyword">if</span> (wordLen &lt;= s.length() &amp;&amp; wordLen &gt;= ansLen &amp;&amp; match(s, word)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (wordLen &gt; ansLen) ans = word;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (wordLen == ansLen) &#123;</span><br><span class="line">                    ans = min(ans, word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> si = <span class="number">0</span>, wi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (si &lt; s.length() &amp;&amp; wi &lt; w.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[si] == w[wi]) &#123;</span><br><span class="line">                wi++;</span><br><span class="line">                si++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                si++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wi == w.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 520. Detect Capital</title>
      <link href="/2017/03/01/leetcode-520-detect-capital/"/>
      <url>/2017/03/01/leetcode-520-detect-capital/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ol><li>All letters in this word are capitals, like “USA”.</li><li>All letters in this word are not capitals, like “leetcode”.</li><li>Only the first letter in this word is capital if it has more than one letter, like “Google”.</li></ol><p>Otherwise, we define that this word doesn’t use capitals in a right way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p></blockquote><p>遍历一遍字符串，记录大写字母的出现次数与首字母是否大写，然后根据题目要求返回结果就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> capitalNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> firstCapital = <span class="built_in">isupper</span>(word[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(c)) capitalNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (capitalNum == <span class="number">0</span> || capitalNum == word.length() || (firstCapital &amp;&amp; capitalNum == <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 515. Find Largest Value in Each Tree Row</title>
      <link href="/2017/02/21/leetcode-515-find-largest-value-in-each-tree-row/"/>
      <url>/2017/02/21/leetcode-515-find-largest-value-in-each-tree-row/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>You need to find the largest value in each row of a binary tree.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         &#x2F; \</span><br><span class="line">        3   2</span><br><span class="line">       &#x2F; \   \  </span><br><span class="line">      5   3   9 </span><br><span class="line"></span><br><span class="line">Output: [1, 3, 9]</span><br></pre></td></tr></table></figure></blockquote><p>我使用BFS来遍历二叉树，这样可以保证一行的节点是连续出现的。对于每一行维护一个当前搜索到的最大值，当遇到下一行时说明这一行已经搜索完了，保存结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        BFS(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;       depthQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        depthQueue.push(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxInDepth = root-&gt;val;</span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode *node = nodeQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = depthQueue.front();</span><br><span class="line">            depthQueue.pop();</span><br><span class="line">            <span class="keyword">if</span> (maxDepth &lt; depth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                ans.push_back(maxInDepth);</span><br><span class="line">                maxInDepth = node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                maxInDepth = max(maxInDepth, node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                nodeQueue.push(node-&gt;left);</span><br><span class="line">                depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                nodeQueue.push(node-&gt;right);</span><br><span class="line">                depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(maxInDepth); <span class="comment">// Last row</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 513. Find Bottom Left Tree Value</title>
      <link href="/2017/02/21/leetcode-513-find-bottom-left-tree-value/"/>
      <url>/2017/02/21/leetcode-513-find-bottom-left-tree-value/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a binary tree, find the leftmost value in the last row of the tree.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**Example 2: **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   3</span><br><span class="line">     &#x2F;   &#x2F; \</span><br><span class="line">    4   5   6</span><br><span class="line">       &#x2F;</span><br><span class="line">      7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> You may assume the tree (i.e., the given root node) is not <strong>NULL</strong>.</p></blockquote><p>用DFS/BFS遍历一遍二叉树，要保证左子树比右子树先遍历到，这样没出现一个更深的节点就一定是该深度的最左边的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BFS(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;       depthQueue; <span class="comment">// Store the corresponding depth</span></span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        depthQueue.push(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftBottomVal;</span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode *node = nodeQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = depthQueue.front();</span><br><span class="line">            depthQueue.pop();</span><br><span class="line">            <span class="keyword">if</span> (maxDepth &lt; depth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                leftBottomVal = node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                nodeQueue.push(node-&gt;left);</span><br><span class="line">                depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                nodeQueue.push(node-&gt;right);</span><br><span class="line">                depthQueue.push(depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBottomVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 508. Most Frequent Subtree Sum</title>
      <link href="/2017/02/21/leetcode-508-most-frequent-subtree-sum/"/>
      <url>/2017/02/21/leetcode-508-most-frequent-subtree-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</p><p><strong>Examples 1</strong>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> &#x2F;  \</span><br><span class="line">2   -3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return [2, -3, 4], since all the values happen only once, return all of them in any order.</p><p><strong>Examples 2</strong>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> &#x2F;  \</span><br><span class="line">2   -5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return [2], since 2 happens twice, however -5 only occur once.</p><p><strong>Note:</strong> You may assume the sum of values in any subtree is in the range of 32-bit signed integer.</p></blockquote><p>用递归来计算每个节点的subtree sum，然后用哈希表保存每个sum的出现次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; sumFreq;</span><br><span class="line">    <span class="keyword">int</span> maxSumFreq = INT_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        DFS_sum(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : sumFreq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.second == maxSumFreq) </span><br><span class="line">                ans.push_back(i.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS_sum</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = DFS_sum(node-&gt;left) + DFS_sum(node-&gt;right) + node-&gt;val;</span><br><span class="line">        maxSumFreq = max(maxSumFreq, ++sumFreq[sum]);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 498. Diagonal Traverse</title>
      <link href="/2017/02/19/leetcode-498-diagonal-traverse/"/>
      <url>/2017/02/19/leetcode-498-diagonal-traverse/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output:  [1,2,4,7,5,3,6,8,9]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The total number of elements of the given matrix will not exceed 10,000.</li></ol></blockquote><p>这道题就是按照题目要求的顺序遍历这个矩阵就可以了。首先有两个方向，对于每个方向在到达矩阵边缘的时候又有两种处理方式，分情况来处理就可以了。值得注意的是矩阵的右上角与左下角。他们的处理方式分别与矩阵的右边缘和下边缘相同，要注意安排判断横纵坐标的顺序以免越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> DIRECTION &#123;</span><br><span class="line">        DownLeft = <span class="number">0</span>,</span><br><span class="line">        UpRight = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (col == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        DIRECTION direction = UpRight;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != row - <span class="number">1</span> || y != col - <span class="number">1</span>) &#123;</span><br><span class="line">            ans.push_back(matrix[x][y]);</span><br><span class="line">            <span class="keyword">if</span> (direction == UpRight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y == col - <span class="number">1</span>) &#123;</span><br><span class="line">                    x++;</span><br><span class="line">                    direction = DownLeft;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                    y++;</span><br><span class="line">                    direction = DownLeft;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    x--;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == row - <span class="number">1</span>) &#123;</span><br><span class="line">                    y++;</span><br><span class="line">                    direction = UpRight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">                    x++;</span><br><span class="line">                    direction = UpRight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    x++;</span><br><span class="line">                    y--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(matrix[row - <span class="number">1</span>][col - <span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 506. Relative Ranks</title>
      <link href="/2017/02/13/leetcode-506-relative-ranks/"/>
      <url>/2017/02/13/leetcode-506-relative-ranks/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given scores of <strong>N</strong> athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [5, 4, 3, 2, 1]</span><br><span class="line">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. </span><br><span class="line">For the left two athletes, you just need to output their relative ranks according to their scores.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>N is a positive integer and won’t exceed 10,000.</li><li>All the scores of athletes are guaranteed to be unique.</li></ol></blockquote><p>用排序+哈希表来建立得分与排名的对应关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; medals = &#123;<span class="string">"Gold Medal"</span>, <span class="string">"Silver Medal"</span>, <span class="string">"Bronze Medal"</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRelativeRanks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ranks;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortNums = nums;</span><br><span class="line">        sort(sortNums.begin(), sortNums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortNums.size(); i++) &#123;</span><br><span class="line">            ranks[sortNums[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> rank = ranks[i];</span><br><span class="line">            <span class="keyword">if</span> (rank &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                ans.push_back(medals[rank - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(to_string(rank));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 504. Base 7</title>
      <link href="/2017/02/13/leetcode-504-base-7/"/>
      <url>/2017/02/13/leetcode-504-base-7/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given an integer, return its base 7 string representation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 100</span><br><span class="line">Output: &quot;202&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -7</span><br><span class="line">Output: &quot;-10&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The input will be in range of [-1e7, 1e7].</p></blockquote><p>使用除法来进行进制转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign = num &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        num = <span class="built_in">abs</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.insert(ans.begin(), (num % <span class="number">7</span>) + <span class="string">'0'</span>);</span><br><span class="line">            num /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign &gt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"-"</span>) + ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 500. Keyboard Row</title>
      <link href="/2017/02/13/leetcode-500-keyboard-row/"/>
      <url>/2017/02/13/leetcode-500-keyboard-row/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a List of words, return the words that can be typed using letters of <strong>alphabet</strong> on only one row’s of American keyboard like the image below.</p><p><img src="https://leetcode.com/static/images/problemset/keyboard.png" alt="American keyboard"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>You may use one character in the keyboard more than once.</li><li>You may assume the input string will only contain letters of alphabet.</li></ol></blockquote><p>判断每个字母在键盘上位于哪一行，可以用Hash表来保存每个字母所对应的行，也可以每次都搜索一次，因为数据量都很小所以性能差距很小。</p><p>Hash表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; keymap = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> row = keymap[<span class="built_in">tolower</span>(str[<span class="number">0</span>]) - <span class="string">'a'</span>], i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (keymap[<span class="built_in">tolower</span>(str[i]) - <span class="string">'a'</span>] != row) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == str.length()) ans.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>搜索：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; keyboard = &#123;<span class="string">"qwertyuiop"</span>, <span class="string">"asdfghjkl"</span>, <span class="string">"zxcvbnm"</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> row = findRow(str[<span class="number">0</span>]), i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findRow(str[i]) != row) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == str.length()) ans.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRow</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyboard.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keyboard[i].find(c) != <span class="built_in">string</span>::npos) </span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 496. Next Greater Element I</title>
      <link href="/2017/02/13/leetcode-496-next-greater-element-i/"/>
      <url>/2017/02/13/leetcode-496-next-greater-element-i/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>You are given two arrays <strong>(without duplicates)</strong> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>’s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>'s elements in the corresponding places of <code>nums2</code>.</p><p>The Next Greater Number of a number <strong>x</strong> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">Output: [3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>All elements in <code>nums1</code> and <code>nums2</code> are unique.</li><li>The length of both <code>nums1</code> and <code>nums2</code> would not exceed 1000.</li></ol></blockquote><p>使用双重循环即可。先搜索数值，再向后搜索比它大的第一个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; findNums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> toFind : findNums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == toFind) &#123;</span><br><span class="line">                    <span class="keyword">int</span> j;</span><br><span class="line">                    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; nums.size() &amp;&amp; nums[j] &lt;= toFind; j++) ;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; nums.size()) ans.push_back(nums[j]);</span><br><span class="line">                    <span class="keyword">else</span> ans.push_back(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 492. Construct the Rectangle</title>
      <link href="/2017/02/04/leetcode-492-construct-the-rectangle/"/>
      <url>/2017/02/04/leetcode-492-construct-the-rectangle/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. The area of the rectangular web page you designed must equal to the given target area.</span><br><span class="line"></span><br><span class="line">2. The width W should not be larger than the length L, which means L &gt;&#x3D; W.</span><br><span class="line"></span><br><span class="line">3. The difference between length L and width W should be as small as possible.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>You need to output the length L and the width W of the web page you designed in sequence.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2, 2]</span><br><span class="line">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </span><br><span class="line">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The given area won’t exceed 10,000,000 and is a positive integer</li><li>The web page’s width and length you designed must be positive integers.</li></ol></blockquote><p>找到最接近的两个因数，使之乘积等于特定值。从给定的<code>area</code>的平方根向两边搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructRectangle</span><span class="params">(<span class="keyword">int</span> area)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">sqrt</span>(area);</span><br><span class="line">        <span class="keyword">if</span> (t * t == area) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = ans[<span class="number">1</span>] = t;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (area % t != <span class="number">0</span>) &#123;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = area / t;</span><br><span class="line">        ans[<span class="number">1</span>] = t;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 494. Target Sum</title>
      <link href="/2017/02/03/leetcode-494-target-sum/"/>
      <url>/2017/02/03/leetcode-494-target-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p><p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the given array is positive and will not exceed 20.</li><li>The sum of elements in the given array will not exceed 1000.</li><li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li></ol></blockquote><p>暴力的DFS可以AC，但是Runtime不理想.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        DFS(nums, <span class="number">0</span>, <span class="number">0</span>, S);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> path, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path + nums[i] == S) ans++;</span><br><span class="line">            <span class="keyword">if</span> (path - nums[i] == S) ans++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        DFS(nums, i + <span class="number">1</span>, path + nums[i], S);</span><br><span class="line">        DFS(nums, i + <span class="number">1</span>, path - nums[i], S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用DP是比较好的选择。<code>dp[i][j]</code>表示前<code>i+1</code>个元素中和为<code>j</code>的情况数，由于和可能为负，所以为了确保下标非负，所有的<code>j</code>减去所有元素的和<code>sum</code>后才是真正的和。</p><p>要注意在初始化时，第一个元素如果为0，那么和0所对应的下标<code>sum</code>应该初始化为2而不是1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) sum += i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[nums.size()][sum * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">if</span> (S &gt; sum || S &lt; -sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>] + sum]++;</span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>] + sum]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum * <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = j + nums[i];</span><br><span class="line">                    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= sum * <span class="number">2</span>) dp[i][index] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    index = j - nums[i];</span><br><span class="line">                    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= sum * <span class="number">2</span>) dp[i][index] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size() - <span class="number">1</span>][S + sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 495. Teemo Attacking</title>
      <link href="/2017/02/03/leetcode-495-teemo-attacking/"/>
      <url>/2017/02/03/leetcode-495-teemo-attacking/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking <strong>ascending</strong> time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition.</p><p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4], 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. </span><br><span class="line">This poisoned status will last 2 seconds until the end of time point 2. </span><br><span class="line">And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. </span><br><span class="line">So you finally need to output 4.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2], 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. </span><br><span class="line">This poisoned status will last 2 seconds until the end of time point 2. </span><br><span class="line">However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. </span><br><span class="line">Since the poisoned status won&#39;t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. </span><br><span class="line">So you finally need to output 3.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>You may assume the length of given time series array won’t exceed 10000.</li><li>You may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000.</li></ol></blockquote><p><em>提莫队长，正在送命！</em></p><p>题目比较简单，就是debuff状态时间不会叠加，每次击中目标后重新开始计时，要求返回总的debuff时间。只要每次判断与上一次攻击后的生效时间是否有重合，有的话就减去重合部分即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeSeries.empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        ans = duration;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timeSeries.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeSeries[i] &gt;= timeSeries[i - <span class="number">1</span>] + duration) &#123;</span><br><span class="line">                ans += duration;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (timeSeries[i] - timeSeries[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 501. Find Mode in Binary Search Tree</title>
      <link href="/2017/02/03/leetcode-501-find-mode-in-binary-search-tree/"/>
      <url>/2017/02/03/leetcode-501-find-mode-in-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a binary search tree (BST) with duplicates, find all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics)" target="_blank" rel="noopener">mode(s)</a> (the most frequently occurred element) in the given BST.</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>For example:Given BST <code>[1,null,2,2]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return <code>[2]</code>.</p><p><strong>Note:</strong> If a tree has more than one mode, you can return them in any order.</p><p><strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p></blockquote><p>使用Hash表可以快速解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; val;</span><br><span class="line">    <span class="keyword">int</span> maxOccur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.second == maxOccur) </span><br><span class="line">                ans.push_back(i.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> ;</span><br><span class="line">        inOrder(node-&gt;left);</span><br><span class="line">        maxOccur = max(maxOccur, ++val[node-&gt;val]);</span><br><span class="line">        inOrder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在要求不使用额外存储空间的情况下，因为这是一棵BST，所以中序遍历结果是一个有序序列，问题就转化为在一个有序序列中连续出现次数最多的元素有哪些。除了维护结果集以外，还要维护结果集中元素的出现次数，上一个元素的值和当前元素的出现次数。当前元素的出现次数超过结果集中元素的出现次数后就清空结果集，然后增加当前元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> lastElem = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> lastElemOccurTimes;</span><br><span class="line">    <span class="keyword">int</span> valInAnsOccurTimes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> ;</span><br><span class="line">        inOrder(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (lastElem == node-&gt;val) &#123;</span><br><span class="line">            lastElemOccurTimes++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lastElemOccurTimes = <span class="number">1</span>;</span><br><span class="line">            lastElem = node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lastElemOccurTimes == valInAnsOccurTimes) &#123;</span><br><span class="line">            ans.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lastElemOccurTimes &gt; valInAnsOccurTimes) &#123;</span><br><span class="line">            valInAnsOccurTimes = lastElemOccurTimes;</span><br><span class="line">            ans.clear();</span><br><span class="line">            ans.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        inOrder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 215. Kth Largest Element in an Array</title>
      <link href="/2017/01/21/leetcode-215-kth-largest-element-in-an-array/"/>
      <url>/2017/01/21/leetcode-215-kth-largest-element-in-an-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p><p>**Note: **You may assume k is always valid, 1 ≤ k ≤ array’s length.</p></blockquote><p>堆排序，我直接用STL了……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 排序 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 214. Shortest Palindrome</title>
      <link href="/2017/01/21/leetcode-214-shortest-palindrome/"/>
      <url>/2017/01/21/leetcode-214-shortest-palindrome/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><p>For example:</p><p>Given <code>&quot;aacecaaa&quot;</code>, return <code>&quot;aaacecaaa&quot;</code>.</p><p>Given <code>&quot;abcd&quot;</code>, return <code>&quot;dcbabcd&quot;</code>.</p></blockquote><p>这道题用直接的双重循环<strong>可能</strong>会超时，但是也不一定，比如我下面的代码就可以AC：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> max_r = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((max_r = palindromeBeside(s, i)) != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> t = s.substr(max_r);</span><br><span class="line">        reverse(t.begin(), t.end());</span><br><span class="line">        <span class="keyword">return</span> t + s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">palindromeBeside</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> axis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = axis, r = axis;</span><br><span class="line">        <span class="keyword">for</span> (; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length(); l--, r++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r]) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        l = axis - <span class="number">1</span>, r = axis;</span><br><span class="line">        <span class="keyword">for</span> (; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length(); l--, r++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r]) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这肯定不是一道Hard题的解法。这道题的本质在于寻找一个字符串<code>S</code>的最长回文前缀子串<code>k</code>，回文串的一个特征就是翻转之后保持不变，如果我们把<code>S</code>整个翻转之后接到<code>S</code>的后面得到的是以<code>k</code>开头，以<code>k</code>结尾的字符串。可以使用KMP算法中计算字符串自我覆盖情况的算法来进行计算，这个算法有点DP的意思，但是理解起来还是有点困难的，具体介绍可以Google关键字KMP。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> ts = s;</span><br><span class="line">        reverse(ts.begin(), ts.end());</span><br><span class="line">        ts = s + <span class="string">"|"</span> + ts;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(ts.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ts.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; ts[v[index]] != ts[i]) &#123;</span><br><span class="line">                index = v[index] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                v[i] = v[index] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ts = s.substr(v.back());</span><br><span class="line">        reverse(ts.begin(), ts.end());</span><br><span class="line">        <span class="keyword">return</span> ts + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 213. House Robber II</title>
      <link href="/2017/01/19/leetcode-213-house-robber-ii/"/>
      <url>/2017/01/19/leetcode-213-house-robber-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p><strong>Note:</strong> This is an extension of <a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">House Robber</a>.</p><p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p></blockquote><p>在<a href="http://xiadong.info/2016/11/leetcode-198-house-robber/" target="_blank" rel="noopener">House Robber</a>的简单DP基础上考虑首尾也是相邻的。我把第一个house是否rob分开来进行了两次DP，然后根据最后一个house有没有被抢来从中选择正确的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums.size() == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">robbed</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">v[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">robbed[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">v[<span class="number">1</span>] = v[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + v[i - <span class="number">2</span>] &gt; v[i - <span class="number">1</span>]) &#123;</span><br><span class="line">v[i] = nums[i] + v[i - <span class="number">2</span>];</span><br><span class="line">robbed[i] = <span class="literal">true</span>;</span><br><span class="line">robbed[i - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">robbed[i - <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v[i] = v[i - <span class="number">1</span>];</span><br><span class="line">robbed[i - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">robbed[i - <span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> lastRobbed = robbed.back();</span><br><span class="line"><span class="keyword">int</span> firstRobbedMax = v.back(), firstRobbedLastNotMax3 = v[v.size() - <span class="number">3</span>], firstRobbedLastNotMax2 = v[v.size() - <span class="number">2</span>];</span><br><span class="line">v[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">robbed[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">v[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">robbed[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + v[i - <span class="number">2</span>] &gt; v[i - <span class="number">1</span>]) &#123;</span><br><span class="line">v[i] = nums[i] + v[i - <span class="number">2</span>];</span><br><span class="line">robbed[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v[i] = v[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> firstNotRobbedMax = v.back();</span><br><span class="line"><span class="keyword">if</span> (firstRobbedMax &gt; firstNotRobbedMax &amp;&amp; !lastRobbed) <span class="keyword">return</span> firstRobbedMax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> max(firstNotRobbedMax, max(firstRobbedLastNotMax3, firstRobbedLastNotMax2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 212. Word Search II</title>
      <link href="/2017/01/19/leetcode-212-word-search-ii/"/>
      <url>/2017/01/19/leetcode-212-word-search-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p><p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p>For example,Given <strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board</strong> =</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],</span><br><span class="line">  [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],</span><br><span class="line">  [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],</span><br><span class="line">  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure><p>.</p><p><strong>Note:</strong>You may assume that all inputs are consist of lowercase letters <code>a-z</code>.</p></blockquote><p>用DFS来遍历表格，用前缀树来实现判断一个路径是否在目标字符串中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; children;</span><br><span class="line">    TrieNode(<span class="keyword">char</span> _v): isEnd(<span class="literal">false</span>), val(_v) &#123;</span><br><span class="line">        children = <span class="built_in">vector</span>&lt;TrieNode*&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    TrieNode* root = <span class="keyword">new</span> TrieNode(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; steps = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">            insertToTrie(word);</span><br><span class="line">        &#125;</span><br><span class="line">        row = board.size();</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        col = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(col == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> path;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                DFS(board, path, i, j, root-&gt;children[board[i][j] - <span class="string">'a'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> &amp;boardPath, <span class="keyword">int</span> r, <span class="keyword">int</span> c, TrieNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        visited[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> val = board[r][c];</span><br><span class="line">        boardPath.push_back(val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;isEnd) &#123;</span><br><span class="line">            ans.push_back(boardPath); </span><br><span class="line">            node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tr = r + steps[i][<span class="number">0</span>], tc = c + steps[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isValidPoint(board, tr, tc)) &#123;</span><br><span class="line">                TrieNode *next = node-&gt;children[board[tr][tc] - <span class="string">'a'</span>];</span><br><span class="line">                DFS(board, boardPath, tr, tc, next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        boardPath.pop_back();</span><br><span class="line">        visited[r][c] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidPoint</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= row || c &lt; <span class="number">0</span> || c &gt;= col || visited[r][c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertToTrie</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root, *prev;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> next = s[i++] - <span class="string">'a'</span>;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p-&gt;children[next];</span><br><span class="line">        &#125; <span class="keyword">while</span> (p &amp;&amp; i &lt; s.length());</span><br><span class="line">        <span class="keyword">if</span> (i &lt; s.length() || p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = prev;</span><br><span class="line">            <span class="keyword">for</span>(i--; i &lt; s.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> next = s[i] - <span class="string">'a'</span>;</span><br><span class="line">                p-&gt;children[next] = <span class="keyword">new</span> TrieNode(s[i]);</span><br><span class="line">                p = p-&gt;children[next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 前缀树(Trie) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 211. Add and Search Word - Data structure design</title>
      <link href="/2017/01/17/leetcode-211-add-and-search-word-data-structure-design/"/>
      <url>/2017/01/17/leetcode-211-add-and-search-word-data-structure-design/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Design a data structure that supports the following two operations:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong>You may assume that all words are consist of lowercase letters <code>a-z</code>.</p></blockquote><p>直接用前缀树来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> val;</span><br><span class="line"><span class="built_in">vector</span>&lt;TrieNode*&gt; children;</span><br><span class="line">TrieNode* parent;</span><br><span class="line"><span class="keyword">bool</span> wordEnd = <span class="literal">false</span>;</span><br><span class="line">TrieNode(<span class="keyword">char</span> v = <span class="number">0</span>, TrieNode *p = <span class="literal">nullptr</span>) : val(v), parent(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">TrieNode* root;</span><br><span class="line">Trie() &#123;</span><br><span class="line">root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inserts a word into the trie.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">insertToNode(word, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertToNode</span><span class="params">(<span class="built_in">string</span> word, TrieNode* node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word.empty()) &#123;</span><br><span class="line">node-&gt;wordEnd = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word[<span class="number">0</span>] == node-&gt;children[i]-&gt;val) &#123;</span><br><span class="line"><span class="keyword">return</span> insertToNode(word.substr(<span class="number">1</span>), node-&gt;children[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">TrieNode *p = <span class="keyword">new</span> TrieNode(word[<span class="number">0</span>], node);</span><br><span class="line">node-&gt;children.push_back(p);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word.size(); i++) &#123;</span><br><span class="line">TrieNode *tmp = <span class="keyword">new</span> TrieNode(word[i], p);</span><br><span class="line">p-&gt;children.push_back(tmp);</span><br><span class="line">p = tmp;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;wordEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word, TrieNode *node = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">TrieNode *p = (node ? node : root);</span><br><span class="line"><span class="keyword">if</span> (word.empty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;wordEnd)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; pos &lt; word.size(); pos++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word[pos] == <span class="string">'.'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;children.empty() &amp;&amp; word.size() &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;children.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (search(word.substr(pos + <span class="number">1</span>), p-&gt;children[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;children.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word[pos] == p-&gt;children[i]-&gt;val) &#123;</span><br><span class="line">p = p-&gt;children[i];</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos == word.size() &amp;&amp; p-&gt;wordEnd) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line"><span class="comment">// that starts with the given prefix.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">TrieNode *p = root;</span><br><span class="line"><span class="keyword">for</span> (; pos &lt; prefix.size(); pos++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;children.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (prefix[pos] == p-&gt;children[i]-&gt;val) &#123;</span><br><span class="line">p = p-&gt;children[i];</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Trie trie;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adds a word into the data structure.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">trie.insert(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line"><span class="comment">// contain the dot character '.' to represent any one letter.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> trie.search(word);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 前缀树(Trie) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 210. Course Schedule II</title>
      <link href="/2017/01/17/leetcode-210-course-schedule-ii/"/>
      <url>/2017/01/17/leetcode-210-course-schedule-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, return the ordering of courses you should take to finish all courses.</p><p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0]]</span><br></pre></td></tr></table></figure><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is <code>[0,1]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4, [[1,0],[2,0],[3,1],[3,2]]</span><br></pre></td></tr></table></figure><p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is<code>[0,2,1,3]</code>.</p><p><strong>Note:</strong>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="noopener">how a graph is represented</a>.</p></blockquote><p>要求返回一个图的拓扑排序结果，在有向图存在环路的时候返回空集。拓扑排序可以用点度和队列结合的办法，也可以用DFS的办法。因为输入数据是邻接表，对边的处理比较慢，所以我用DFS来实现拓扑排序，同时判断是否有环存在。</p><p>这个题有个条件就是节点编号是在<code>0</code>-<code>n-1</code>之间的，所以记录一个节点的状态可以用数组，没有查询的开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inPath;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; nextCourses(numCourses), preReq(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : prerequisites)&#123;</span><br><span class="line">            preReq[i.first].push_back(i.second);</span><br><span class="line">            nextCourses[i.second].push_back(i.first);</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(numCourses, <span class="number">0</span>);</span><br><span class="line">        inPath = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(numCourses, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; preReq[i].empty())&#123;</span><br><span class="line">                <span class="comment">// Begin node</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t, path;</span><br><span class="line">                <span class="keyword">if</span>(DFS(nextCourses, preReq, i, path, t))</span><br><span class="line">                    ans.insert(ans.end(), t.begin(), t.end());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() != numCourses)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;nextCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;preReq, <span class="keyword">int</span> node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inPath[node]) &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(visited[node]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : preReq[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        path.push_back(node);</span><br><span class="line">        ans.push_back(node);</span><br><span class="line">        inPath[node] = visited[node] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nextCourses[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!DFS(nextCourses, preReq, i, path, ans)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop_back();</span><br><span class="line">        inPath[node] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 488. Zuma Game</title>
      <link href="/2017/01/15/leetcode-488-zuma-game/"/>
      <url>/2017/01/15/leetcode-488-zuma-game/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Think about Zuma Game. You have a row of balls on the table, colored red®, yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.</p><p>Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.</p><p>Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line"></span><br><span class="line">Input: &quot;WRRBBW&quot;, &quot;RB&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: WRRBBW -&gt; WRR[R]BBW -&gt; WBBW -&gt; WBB[B]W -&gt; WW</span><br><span class="line"></span><br><span class="line">Input: &quot;WWRRBBWW&quot;, &quot;WRBRW&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: WWRRBBWW -&gt; WWRR[R]BBWW -&gt; WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; empty</span><br><span class="line"></span><br><span class="line">Input:&quot;G&quot;, &quot;GGGGG&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: G -&gt; G[G] -&gt; GG[G] -&gt; empty </span><br><span class="line"></span><br><span class="line">Input: &quot;RBYYBBRRB&quot;, &quot;YRBGB&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: RBYYBBRRB -&gt; RBYY[Y]BBRRB -&gt; RBBBRRB -&gt; RRRB -&gt; B -&gt; B[B] -&gt; BB[B] -&gt; empty </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.</li><li>The number of balls on the table won’t exceed 20, and the string represents these balls is called “board” in the input.</li><li>The number of balls in your hand won’t exceed 5, and the string represents these balls is called “hand” in the input.</li><li>Both input strings will be non-empty and only contain characters ‘R’,‘Y’,‘B’,‘G’,‘W’.</li></ol></blockquote><p>这次Contest中最难的题。Zuma游戏的规则，从<code>hand</code>中抽取ball插入到<code>board</code>中，有大于等于三个相同颜色的ball连着就可以消去，问最少几步可以消去，或者无法消去。</p><p>初看这道题我以为是图的连通性和最短路径问题（其实也差不多），然后发现构建图的过程中就已经完成了遍历可以得到结果了。使用回溯法，时间上可能效率不高，但好在方法比较容易想到。</p><p>对输入的<code>board</code>尝试消去每一个可能的位置，然后对每一个得到的结果递归地进行处理（DFS）。因为<code>board</code>长度不超过20，所以不会因为解空间太大而超时。</p><p>代码是Contest的时候写的，可能比较乱……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(<span class="built_in">string</span> board, <span class="built_in">string</span> hand)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findMinStepImpl(board, hand);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinStepImpl</span><span class="params">(<span class="built_in">string</span> board, <span class="built_in">string</span> hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minStep = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i] == board[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(findBall(board[i], hand) != <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">string</span> tb = board, th = hand;</span><br><span class="line">                    <span class="keyword">char</span> ball = board[i];</span><br><span class="line">                    removeBall(ball, th);</span><br><span class="line">                    tb.insert(tb.begin() + i, ball);</span><br><span class="line">                    removeThree(tb);</span><br><span class="line">                    <span class="keyword">int</span> ans = findMinStepImpl(tb, th);</span><br><span class="line">                    <span class="keyword">if</span>(ans != <span class="number">-1</span>) minStep = min(minStep, ans + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(minStep != INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> minStep;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(findBall(board[i], hand) != <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> tb = board, th = hand;</span><br><span class="line">                <span class="keyword">char</span> ball = board[i];</span><br><span class="line">                removeBall(ball, th);</span><br><span class="line">                tb.insert(tb.begin() + i, ball);</span><br><span class="line">                <span class="keyword">int</span> ans = findMinStepImpl(tb, th);</span><br><span class="line">                <span class="keyword">if</span>(ans != <span class="number">-1</span>) minStep = min(minStep, ans + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minStep != INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> minStep;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBall</span><span class="params">(<span class="keyword">char</span> ball, <span class="built_in">string</span> &amp;hand)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = find(hand.begin(), hand.end(), ball);</span><br><span class="line">        <span class="keyword">if</span>(iter == hand.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> iter - hand.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBall</span><span class="params">(<span class="keyword">char</span> ball, <span class="built_in">string</span> &amp;hand)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = find(hand.begin(), hand.end(), ball);</span><br><span class="line">        <span class="keyword">if</span>(iter != hand.end())&#123;</span><br><span class="line">            hand.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeThree</span><span class="params">(<span class="built_in">string</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i] == b[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span>(j = i; j &lt; b.size() &amp;&amp; b[j] == b[i]; j++);</span><br><span class="line">                <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    b.erase(i - <span class="number">1</span>, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> removeThree(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 487. Max Consecutive Ones II</title>
      <link href="/2017/01/15/leetcode-487-max-consecutive-ones-ii/"/>
      <url>/2017/01/15/leetcode-487-max-consecutive-ones-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,1,1,0]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Flip the first zero will get the the maximum number of consecutive 1s.</span><br><span class="line">    After flipping, the maximum number of consecutive 1s is 4.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>The input array will only contain <code>0</code> and <code>1</code>.</li><li>The length of input array is a positive integer and will not exceed 10,000</li></ul><p><strong>Follow up:</strong>What if the input numbers come in one by one as an <strong>infinite stream</strong>? In other words, you can’t store all numbers coming from the stream as it’s too large to hold in memory. Could you solve it efficiently?</p></blockquote><p>这道题是上一题的升级版。区别在于可以把最多一个0视为1，再求最长的连续1的个数。</p><p>我的解法也延续上一题的思路使用双指针，不过这次增加一个变量来记录跳过了多少个0。需要注意的是<code>...100</code>这种情况，左指针（指向子串开头的位置）不能只简单地跳过所有1之后再加1，而应该继续跳过连续的0，这可能导致左指针超过右指针，所以这时要更新右指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, zero = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(; p2 &lt; nums.size(); p2++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[p2] == <span class="number">0</span>) zero--;</span><br><span class="line">           <span class="keyword">if</span>(zero &lt; <span class="number">0</span>)&#123;</span><br><span class="line">               maxNum = max(maxNum, p2 - p1);</span><br><span class="line">               <span class="keyword">while</span>(p1 &lt; nums.size() &amp;&amp; nums[p1] != <span class="number">0</span>) p1++;</span><br><span class="line">               <span class="keyword">while</span>(p1 &lt; nums.size() &amp;&amp; nums[p1] != <span class="number">1</span>) &#123;</span><br><span class="line">                   p1++;</span><br><span class="line">                   <span class="keyword">if</span>(zero &lt; <span class="number">1</span>) zero++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(p2 &lt; p1) p2 = p1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       maxNum = max(maxNum, (<span class="keyword">int</span>)nums.size() - p1);</span><br><span class="line">       <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 485. Max Consecutive Ones</title>
      <link href="/2017/01/15/leetcode-485-max-consecutive-ones/"/>
      <url>/2017/01/15/leetcode-485-max-consecutive-ones/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>The input array will only contain <code>0</code> and <code>1</code>.</li><li>The length of input array is a positive integer and will not exceed 10,000</li></ul></blockquote><p>最长的连续1的个数。很简单，方法也很多。一开始在最后加一个0是为了方便结尾的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        nums.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beginIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span> &amp;&amp; beginIndex == <span class="number">-1</span>)&#123;</span><br><span class="line">                beginIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(beginIndex != <span class="number">-1</span>)&#123;</span><br><span class="line">                    maxNum = max(maxNum, i - beginIndex);</span><br><span class="line">                &#125;</span><br><span class="line">                beginIndex = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 390. Elimination Game</title>
      <link href="/2017/01/13/leetcode-390-elimination-game/"/>
      <url>/2017/01/13/leetcode-390-elimination-game/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>There is a list of sorted integers from 1 to <em>n</em>. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.</p><p>Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.</p><p>We keep repeating the steps again, alternating left to right and right to left, until a single number remains.</p><p>Find the last number that remains starting with a list of length <em>n</em>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">n &#x3D; 9,</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">2 4 6 8</span><br><span class="line">2 6</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">6</span><br></pre></td></tr></table></figure></blockquote><p>这道题我一开始认为会有一个公式来直接计算出最后一个剩下的数是多少，然后又尝试DP从n-1推出n，都没想出来，最后采用的是递归的方法。对于n来说，当n为偶数时，经过一次处理后剩下<code>n/2</code>个数；当为n奇数时，经过一次处理后剩下<code>(n-1)/2</code>个数，把剩下的数的个数作为下一次处理的输入（假设我们的每次处理返回的是数的下标而不是数的具体值），得到的结果为m，那么我们只要把下标m恢复为本次处理的下标即可。</p><p>那么如何回复呢？同样分奇偶进行分类，当n为奇数时，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Index: 0 1 2 3 4</span><br><span class="line">Value: 1 2 3 4 5</span><br><span class="line">Index: _ 0 _ 1 _</span><br><span class="line">Value: _ 2 _ 4 _</span><br></pre></td></tr></table></figure><p>无论处理方向正反得到的结果是一样的。可以看出这么一个映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m</span><br><span class="line">0 &#x3D;&gt; 1</span><br><span class="line">1 &#x3D;&gt; 3</span><br><span class="line">2 &#x3D;&gt; 5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以<code>m * 2 + 1</code>就是本次处理的结果中下标为m的数在本次处理之前的下标。</p><p>当m为奇数时有类似的规律，只不过要分处理正（从头到尾）反（从尾到头）方向来讨论。对于正向来说，仍然是<code>m * 2 + 1</code>，对于反向来说则是<code>m * 2</code>。</p><p>递归终止条件显然为<code>n==1</code>时返回0。每次递归时要对处理方向取反。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L2R = <span class="number">1</span>, R2L = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastRemainingImpl(n, L2R) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemainingImpl</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> direction)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> t = lastRemainingImpl(n % <span class="number">2</span> ? (n - <span class="number">1</span>) / <span class="number">2</span> : n / <span class="number">2</span>, -direction);</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> || direction == L2R)&#123;</span><br><span class="line">            <span class="keyword">return</span> t * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 482. License Key Formatting</title>
      <link href="/2017/01/13/leetcode-482-license-key-formatting/"/>
      <url>/2017/01/13/leetcode-482-license-key-formatting/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.</p><p>We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.</p><p>So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;2-4A0r7-4k&quot;, K &#x3D; 4</span><br><span class="line"></span><br><span class="line">Output: &quot;24A0-R74K&quot;</span><br><span class="line"></span><br><span class="line">Explanation: The string S has been split into two parts, each part has 4 characters.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;2-4A0r7-4k&quot;, K &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: &quot;24-A0R-74K&quot;</span><br><span class="line"></span><br><span class="line">Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of string S will not exceed 12,000, and K is a positive integer.</li><li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li><li>String S is non-empty.</li></ol></blockquote><p>题目说了很长，但是意思却很简单。就是把一个输入的字符串从后往前分割为K个一组，第一组可以不足K个。然后用“-”把它们连接起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">licenseKeyFormatting</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'-'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            str.push_back(<span class="built_in">toupper</span>(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans, tmp;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = str.length(); i &gt;= K; i -= K)&#123;</span><br><span class="line">            ans = str.substr(i - K, K) + <span class="string">"-"</span> + ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans = str.substr(<span class="number">0</span>, i) + <span class="string">"-"</span> + ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.pop_back(); <span class="comment">// Delete "-" in the end of ans.</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 476. Number Complement</title>
      <link href="/2017/01/13/leetcode-476-number-complement/"/>
      <url>/2017/01/13/leetcode-476-number-complement/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p><p><strong>Note:</strong></p><ol><li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li><li>You could assume no leading zero bit in the integer’s binary representation.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure></blockquote><p>就是简单的按位取反，不过不能把前导零给取反了，所以要先确定最高位所在的位置，取反后将更高位置零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> unum = num;</span><br><span class="line">        <span class="keyword">int</span> sigbit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(unum)&#123;</span><br><span class="line">            unum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            sigbit++;</span><br><span class="line">        &#125;</span><br><span class="line">        unum = ~num;</span><br><span class="line">        unum = unum &lt;&lt; (<span class="number">32</span> - sigbit) &gt;&gt; (<span class="number">32</span> - sigbit);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)unum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 481. Magical String</title>
      <link href="/2017/01/10/leetcode-481-magical-string/"/>
      <url>/2017/01/10/leetcode-481-magical-string/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>A magical string <strong>S</strong> consists of only ‘1’ and ‘2’ and obeys the following rules:</p><p>The string <strong>S</strong> is magical because concatenating the number of contiguous occurrences of characters ‘1’ and ‘2’ generates the string <strong>S</strong> itself.</p><p>The first few elements of string <strong>S</strong> is the following: <strong>S</strong> = “1221121221221121122……”</p><p>If we group the consecutive '1’s and '2’s in <strong>S</strong>, it will be:</p><p>1 22 11 2 1 22 1 22 11 2 11 22 …</p><p>and the occurrences of '1’s or '2’s in each group are:</p><p>1 22 1 1 2 1 2 2 1 2 2 …</p><p>You can see that the occurrence sequence above is the <strong>S</strong> itself.</p><p>Given an integer N as input, return the number of '1’s in the first N number in the magical string <strong>S</strong>.</p><p><strong>Note:</strong> N will not exceed 100,000.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first 6 elements of magical string S is &quot;12211&quot; and it contains three 1&#39;s, so return 3.</span><br></pre></td></tr></table></figure></blockquote><p>按照一个序列中的数值往这个序列的末尾增加元素，要求1与2是间隔的，不能超过两个相同的值在一起。按照题目给出的规律生成这个序列就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicalString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">1</span>, s[<span class="number">1</span>] = <span class="number">2</span>, s[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">3</span>, index2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = s[index1 - <span class="number">1</span>] == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[index2]; i++)&#123;</span><br><span class="line">                s[index1 + i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)&#123;</span><br><span class="line">                ans += s[index2];</span><br><span class="line">            &#125;</span><br><span class="line">            index1 += s[index2];</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index1 &gt; n &amp;&amp; s[index1 - <span class="number">1</span>] == <span class="number">1</span>) ans--; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 449. Serialize and Deserialize BST</title>
      <link href="/2017/01/10/leetcode-449-serialize-and-deserialize-bst/"/>
      <url>/2017/01/10/leetcode-449-serialize-and-deserialize-bst/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>The encoded string should be as compact as possible.</strong></p><p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p></blockquote><p>序列化一个二叉搜索树，有两个问题：</p><ol><li>如何序列化一个二叉搜索树的节点</li><li>如何序列化节点里的值</li></ol><p>因为二叉搜索树本身的有序性，所以按照先序遍历的顺序来保存节点就足够恢复BST的结构了。而对于节点里的值，最简单的方法是变为字符串，可是节点值的长度各不相同，这给区分不同的节点带来了麻烦，所以我用四个字节（char）来保存一个int，实际上就是计算机中的小端法存储。</p><p>对于节点的序列化与反序列化使用递归来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decodeInt</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = s[i + begin];</span><br><span class="line">            v |= ((t &amp; <span class="number">0xff</span>) &lt;&lt; (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encodeInt</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            s.push_back(v &amp; <span class="number">0xff</span>);</span><br><span class="line">            v &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encodeDFS(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encodeDFS</span><span class="params">(TreeNode *node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">        <span class="keyword">return</span> encodeInt(node-&gt;val) + encodeDFS(node-&gt;left) + encodeDFS(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;data&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> deserializeHelper(data, <span class="number">0</span>, data.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserializeHelper</span><span class="params">(<span class="built_in">string</span> &amp;data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> v = decodeInt(data, left);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;v&lt;&lt;endl;</span></span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">        <span class="keyword">int</span> mid = right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">4</span>; i &lt; right; i += <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = decodeInt(data, i);</span><br><span class="line">            <span class="keyword">if</span>(t &gt; v) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;left = deserializeHelper(data, left + <span class="number">4</span>, mid);</span><br><span class="line">        node-&gt;right = deserializeHelper(data, mid, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 445. Add Two Numbers II</title>
      <link href="/2017/01/10/leetcode-445-add-two-numbers-ii/"/>
      <url>/2017/01/10/leetcode-445-add-two-numbers-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Follow up:</strong>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure></blockquote><p>翻转链表后相加再翻转回来。至于Follow up，关键的问题在于加法要求最低位对齐，而单向链表又不能回溯，所以最直接的办法就是用两个数组或者栈保存每个节点的前一个节点……虽然我觉得这实在是有点多此一举，不过没有想到什么更好的办法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        l1 = reverseList(l1);</span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        <span class="function">ListNode <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *p = &amp;ret, *p1 = l1, *p2 = l2;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 || p2 || carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> s;</span><br><span class="line">            <span class="keyword">if</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">                s = p1-&gt;val + p2-&gt;val + carry;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p1)&#123;</span><br><span class="line">                s = p1-&gt;val + carry;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p2)&#123;</span><br><span class="line">                s = p2-&gt;val + carry;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s = carry;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            carry = s / <span class="number">10</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.next = reverseList(ret.next);</span><br><span class="line">        <span class="keyword">return</span> ret.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *l)</span></span>&#123;</span><br><span class="line">        ListNode *p1, *p2;</span><br><span class="line">        p1 = l; p2 = l-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p2)&#123;</span><br><span class="line">            ListNode *tmp = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        l-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 442. Find All Duplicates in an Array</title>
      <link href="/2017/01/09/leetcode-442-find-all-duplicates-in-an-array/"/>
      <url>/2017/01/09/leetcode-442-find-all-duplicates-in-an-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given an array of integers, 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.</p><p>Find all the elements that appear <strong>twice</strong> in this array.</p><p>Could you do it without extra space and in O(<em>n</em>) runtime?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure></blockquote><p>跟<a href="http://xiadong.info/2017/01/leetcode-448-find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">LeetCode 448. Find All Numbers Disappeared in an Array</a>类似，只不过这次是寻找出现过两次的数。我用0（输入数据中不会出现）来表示该数已经记录过来防止重复计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i] - <span class="number">1</span>] == <span class="number">0</span> || nums[i] == i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(nums[i]);</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 434. Number of Segments in a String</title>
      <link href="/2017/01/09/leetcode-434-number-of-segments-in-a-string/"/>
      <url>/2017/01/09/leetcode-434-number-of-segments-in-a-string/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p><p>Please note that the string does not contain any <strong>non-printable</strong> characters.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Hello, my name is John&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></blockquote><p>比较简单，注意处理连续的空格和结尾。还有有符号数与无符号数的隐式转换问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prevIndex = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prevIndex != i - <span class="number">1</span>)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">                prevIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prevIndex &lt; (<span class="keyword">int</span>)s.length() - <span class="number">1</span>) ans++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 448. Find All Numbers Disappeared in an Array</title>
      <link href="/2017/01/09/leetcode-448-find-all-numbers-disappeared-in-an-array/"/>
      <url>/2017/01/09/leetcode-448-find-all-numbers-disappeared-in-an-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given an array of integers where 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear twice and others appear once.</p><p>Find all the elements of [1, <em>n</em>] inclusive that do not appear in this array.</p><p>Could you do it without extra space and in O(<em>n</em>) runtime? You may assume the returned list does not count as extra space.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure></blockquote><p>寻找没有出现过的数字，因为数组中的元素满足1 ≤ a[i] ≤ <em>n</em>，所以可以利用下标来保存一个数是否出现过，把一个数放到它对应的下标处，然后再找出哪些下标与元素不对应就是没有出现过的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - <span class="number">1</span> != i) ans.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阳光之下依然是罪恶——扯扯《GTA5》</title>
      <link href="/2017/01/08/%E9%98%B3%E5%85%89%E4%B9%8B%E4%B8%8B%E4%BE%9D%E7%84%B6%E6%98%AF%E7%BD%AA%E6%81%B6-%E6%89%AF%E6%89%AF%E3%80%8Agta5%E3%80%8B/"/>
      <url>/2017/01/08/%E9%98%B3%E5%85%89%E4%B9%8B%E4%B8%8B%E4%BE%9D%E7%84%B6%E6%98%AF%E7%BD%AA%E6%81%B6-%E6%89%AF%E6%89%AF%E3%80%8Agta5%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>GTA5已经是好几年前发售的游戏了，奈何我电脑配置太低，再加上80G的大小让我望而却步。上个月Steam特价94软妹币，没忍住剁了手。54个小时通了主线剧情和大部分的支线，还有在游戏里瞎搞花了一些时间，所以主线剧情所需的时间大概在30~40小时左右。</p><p>要说我第一次玩GTA5还是一年半前，用老逼的电脑玩了一丁点。很多年以前……大概是初中的时候玩过《罪恶都市》还是《圣安地列斯》，不过那时什么都不懂，属于真正的瞎玩一通，甚至都没有剧情的概念，现在只记得卡在一个开遥控飞机的任务上再也没有过去过。这次通关GTA5之后想写点东西，就当是这几十个小时人生的总结吧。</p><p><strong>本文涉及剧透！</strong></p><h1 id="背景">背景</h1><p>GTA5的故事主要发生在洛圣都，NETA洛杉矶。游戏里的洛圣都真是不折不扣的罪恶都市，到处都散发着荒诞的气息。健忘症的警察、泛滥的枪支毒品、比黑帮还像黑帮的FIB和IAA、发生在电视直播上的爆炸和枪杀、大街上一言不合便拔枪开干……一切都构筑在赤裸裸的金钱、暴力与性的基础上。剧情中出现的人物似乎没有一个有正常的三观，这座城市似乎也不存在秩序，自私、贪婪、恃强凌弱也不像现实中那样遮遮掩掩，从这个角度来说，我觉得GTA中的暴力与罪恶恰恰是对现实中掩饰暴力与罪恶的讽刺。</p><p>从玩家，也就是三位主角的角度来看，这座城市的中上层简直是面目可憎。本来是秩序维护者的FIB和IAA都不是什么好东西，IAA为了拨款人为制造恐怖袭击，FIB出场的几个探员个个都不干净。有钱人想尽办法赚钱而毫无底线。同时下层则是黑帮火并，毒品交易，各种坑蒙拐骗。</p><p>游戏中的洛圣都绝大部时间都是阳光普照，然而在这阳光下的城市却弥漫着浓浓的罪恶气息。</p><h1 id="人物">人物</h1><p>GTA5的主角有三人，崔佛、麦克和富兰克林，我还是分开来说说吧。</p><p><strong>崔佛</strong>：老实说我还是挺喜欢这种真性情的人的，但可惜他是个疯子。也许说疯子不太准确，也有的人说他有时候控制不住自己的行为。在崔佛刚出场的时候就开始杀人，在后来的行动中又干出各种杀光别人帮派所有人的事情，麦克也总是说老崔只是喜欢杀人而已。但是如果仅仅这样我也并不讨厌他，因为他都是在你死我活的环境下杀人（除了第一个被打死的强尼），而且老崔莫名的有一些童真（当然更有可能是精神缺陷，他也说自己有童年阴影），比如他的个人载具保险杠那里的一只玩具熊，还有大结局（第三条路那个结局）之后遇到他妈妈痛哭流涕；而且他对朋友重情重义（后来我知道前提是他把你当朋友）。但是当我看到他杀了弗洛伊德（貌似没有死）和他女友黛伯拉的时候我就觉得老崔实在是太危害社会了，当老崔浑身是血的走出公寓以及特写给到窗户上的大量血迹时，我就觉得他们两个实在是遭了无妄之灾，一个被表弟的狐朋狗友把生活搞得一团糟（也有可能本来就一团糟），另一个只不过是想把一个看起来就不正常的人从自己家里赶出去而已结果不知道被装了几个袋子。当时我就知道结局要选择杀老崔还是杀麦克，所以我决定不能留老崔，他就像一个坏掉的定时炸弹一样，可能拿在手里就炸了。但是到最后真的选择的时候还是心软了，毕竟是一起抢过银行，怼过坦克，挨过枪子的交情，而且转念一想，三位主角在大街上碾死的围观群众个个都成百上千（都是我的锅，我不好好开车），老崔那次杀人让我印象深刻只不过是剧情中杀人而已，三位主角手上都沾满鲜血，没有理由单独除掉老崔。</p><p><strong>麦克</strong>：三位主角中我最同情麦克了。从一开始富兰克林潜入麦克的房子然后看到他老婆出轨，儿子废柴，女儿胸大无脑只想出名我就开始同情他了，这情况要是换我早就用人生重来枪了。麦克是最像一个文明人的人，换一句话说他是最虚伪的人。他一直想要的就是稳定的生活，可是当需要钱的时候他首先想到的还是抢劫。其实从GTA5的剧情中我看不出麦克为什么对这个从各方面都是bull shit的家庭有那么强的执念，大概我还是没法理解那种年龄的想法吧。</p><p><strong>富兰克林</strong>：我一直觉得富兰克林是一个推动剧情的人物，最终选择线路的时候也是富兰克林来做决定。他一开始只是个偷车的黑帮小混混，不太能看得出他做事的动机，大概是想做一番大事（THE BIG ONE！），感觉富兰克林这个人物塑造的不是很丰满。在救拉玛，救麦克的行动中可以看出他很重义气。</p><h1 id="剧情">剧情</h1><p>GTA5的剧情总的来说就是抢枪抢，杀杀杀……我在最后的选择中选了“第三条路”，一个HE，这个结局太好了，好的不真实。仿佛不费吹灰之力就干掉了所有的对头，一切的麻烦都烟消云散，基友冰释前嫌重归于好，抢来的黄金足够大家挥霍。然而理智告诉我这实在是不合逻辑，不是说选择既不杀麦克也不杀崔佛不合逻辑，而是选择“第三条路”之后这个“不费吹灰之力就干掉了所有的对头”不合逻辑，感觉与前面的剧情落差太大。我也看了另外两个结局，首先我觉得富兰克林不可能去杀麦克，感觉毫无理由，杀崔佛至少还有拆除定时炸弹目的。我觉得要是在现实中我大概会选杀崔佛，要不然指不定他又会搞什么麻烦，这种随机出现BUG的组件还是尽早清除掉为好。</p><p>支线任务我还没有做完，不过我对那两个追星的老年夫妇印象挺深的。病态的追寻名人，搜集名人的生活垃圾等等的Hentai行为甚至不惜进行绑架，没有追星经历的我还真是叹为观止。还有那个拿自己老婆当酬劳的房地产中介……一个大写的服，连老崔都表示佩服。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 209. Minimum Size Subarray Sum</title>
      <link href="/2017/01/02/leetcode-209-minimum-size-subarray-sum/"/>
      <url>/2017/01/02/leetcode-209-minimum-size-subarray-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p><p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p></blockquote><p>使用双指针。因为都是正数，所以子串的长度越长和越大。先增大右指针直到<code>[left,right]</code>中的元素的和&gt;=s，然后从中依次去掉开头的数，也就是left增大，直到和不再&gt;=s，更新最短长度。然后再次增大右指针进入下一个循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, minSum = <span class="number">0</span>, minLen = INT_MAX, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - left + <span class="number">1</span> &gt; minLen)&#123;</span><br><span class="line">                curSum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            curSum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum &gt;= s)&#123;</span><br><span class="line">                <span class="keyword">for</span>(; left &lt;= i &amp;&amp; curSum &gt;= s; left++)&#123;</span><br><span class="line">                    curSum -= nums[left];</span><br><span class="line">                &#125;</span><br><span class="line">                minLen = i - left + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen == INT_MAX ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 208. Implement Trie (Prefix Tree)</title>
      <link href="/2017/01/02/leetcode-208-implement-trie-prefix-tree/"/>
      <url>/2017/01/02/leetcode-208-implement-trie-prefix-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.</p><p><strong>Note:</strong>You may assume that all inputs are consist of lowercase letters <code>a-z</code>.</p></blockquote><p>实现前缀树。因为输入只有小写字母，所以直接使用26叉树，使用vector来实现支持任意分支数也可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; children;</span><br><span class="line">    <span class="keyword">bool</span> wordEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    TrieNode(<span class="keyword">char</span> v = <span class="number">0</span>) : val(v)&#123;</span><br><span class="line">        children = <span class="built_in">vector</span>&lt;TrieNode*&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        insertToNode(word, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertToNode</span><span class="params">(<span class="built_in">string</span> word, TrieNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.empty())&#123;</span><br><span class="line">            node-&gt;wordEnd = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">for</span>(pos = <span class="number">0</span>; pos &lt; word.size(); pos++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;children[word[pos] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                node = node-&gt;children[word[pos] - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pos == word.size()) &#123;</span><br><span class="line">            node-&gt;wordEnd = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; word.size(); i++)&#123;</span><br><span class="line">            TrieNode *tmp = <span class="keyword">new</span> TrieNode(word[i]);</span><br><span class="line">            node-&gt;children[word[i] - <span class="string">'a'</span>] = tmp;</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;wordEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(; pos &lt; word.size(); pos++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;children[word[pos] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p = p-&gt;children[word[pos] - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.size() &amp;&amp; p-&gt;wordEnd) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(; pos &lt; prefix.size(); pos++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;children[prefix[pos] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p = p-&gt;children[prefix[pos] - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == prefix.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie;</span></span><br><span class="line"><span class="comment">// trie.insert("somestring");</span></span><br><span class="line"><span class="comment">// trie.search("key");</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 前缀树(Trie) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 207. Course Schedule</title>
      <link href="/2017/01/02/leetcode-207-course-schedule/"/>
      <url>/2017/01/02/leetcode-207-course-schedule/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0]]</span><br></pre></td></tr></table></figure><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0],[0,1]]</span><br></pre></td></tr></table></figure><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p><p><strong>Note:</strong>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="noopener">how a graph is represented</a>.</p><p><strong>Hints:</strong></p><ul><li>This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li><li><a href="https://class.coursera.org/algo-003/lecture/52" target="_blank" rel="noopener">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li><li>Topological sort could also be done via <a href="http://en.wikipedia.org/wiki/Topological_sorting#Algorithms" target="_blank" rel="noopener">BFS</a>.</li></ul></blockquote><p>Hint中已经说的很明确了，就是判断一个图中有没有环。我用DFS来遍历每个节点，有两个出现环的情况：</p><ol><li>出现了路径中已经出现的节点</li><li>有的节点没有被遍历到过，说明它们没有起始的端点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">gg</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">vector&lt;int&gt; prerequested(numCourses, false), allVisited(numCourses, false);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</span><br><span class="line">gg[prerequisites[i].first].push_back(prerequisites[i].second);</span><br><span class="line">prerequested[prerequisites[i].second] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prerequestedNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!prerequested[i]) &#123;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">thisTimeVisited</span><span class="params">(numCourses, <span class="literal">false</span>)</span></span>;</span><br><span class="line">thisTimeVisited[i] = <span class="literal">true</span>;</span><br><span class="line">allVisited[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!DFS(gg, i, allVisited, thisTimeVisited))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">thisTimeVisited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">prerequestedNum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (prerequestedNum == numCourses) &#123;</span><br><span class="line"><span class="comment">//no start node</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!allVisited[i]) &#123;</span><br><span class="line"><span class="comment">//some nodes cannot be visited</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;gg, <span class="keyword">int</span> node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;allVisited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;thisTimeVisited)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextNodes = gg[node];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nextNodes.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (thisTimeVisited[nextNodes[i]]) &#123;</span><br><span class="line"><span class="comment">//find cycle</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">allVisited[nextNodes[i]] = <span class="literal">true</span>;</span><br><span class="line">thisTimeVisited[nextNodes[i]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!DFS(gg, nextNodes[i], allVisited, thisTimeVisited))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">thisTimeVisited[nextNodes[i]] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年，2017</title>
      <link href="/2016/12/31/%E6%96%B0%E5%B9%B4%EF%BC%8C2017/"/>
      <url>/2016/12/31/%E6%96%B0%E5%B9%B4%EF%BC%8C2017/</url>
      
        <content type="html"><![CDATA[<p>总是觉得时间飞逝却又总是抓不住时间，再有几十分钟就要进入2017年了。回头看这2016年，上半年轻松惬意，下半年紧张了不少。写这种总结文字总是觉得很矫情，权当是碎碎念，反正也没有什么人会看到┑(￣Д ￣)┍。</p><p>年初从一月份开始在家呆了近四个月，超长假期+很水的毕设=废人一个。要说干了啥……好像看完了《代码大全》，但是我觉得有点看早了，里面有的点能get到，有的点不明觉厉，总体感觉囫囵吞枣。三月底的时候趁着樱花季去日本转了两周，要说是穿越了国界反而更像是穿越了次元壁呢……大阪-奈良-京都-箱根-东京自由行下来感觉就是……以后还要去啊啊啊啊！！！对于动画厨来说简直逛不够啊！而且一个人旅行真的很舒服。</p><p>四月份回成都，五月份毕设结束，六月份本科毕业。四年的时光走到了尽头，相比于四年前的那个高中生成长了很多很多，人生的际遇总是那么不可思议，四年前的我怎么也想象不到毕业时的样子吧。</p><p>暑假在家，心血来潮准备从头刷LeetCode，也是为明年的面试做准备。这个大坑到现在我还没有填完T_T。暑假看了《Effective STL》，收获不小。</p><p>下半年来广州，只上两门课。CMU的课程真的让我觉得跟国内不同，一学期CSAPP从头讲到尾，配套9个Lab，而且是针对没有CS基础的同学，我至少有点基础，不会太费力，但是对其他专业背景的同学要求真的是很高。要说我觉得课程与国内最大的不同就是课后作业的重视程度，不仅数量大，而且难度也不小。</p><p>说到明年，希望我能顺利到达美国，能找到一个工作。这大概就是我的新年愿望了吧。</p><p>对了，马上就是我着任提督一周年的日子了，嘛，到时候专门写一篇吧:-)</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 477. Total Hamming Distance</title>
      <link href="/2016/12/27/leetcode-477-total-hamming-distance/"/>
      <url>/2016/12/27/leetcode-477-total-hamming-distance/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" rel="noopener">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 4, 14, 2</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line"></span><br><span class="line">Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just</span><br><span class="line">showing the four bits relevant in this case). So the answer will be:</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) &#x3D; 2 + 2 + 2 &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>Elements of the given array are in the range of <code>0</code>to <code>10^9</code></li><li>Length of the array will not exceed <code>10^4</code>.</li></ol></blockquote><p>跟 <em>461. Hamming Distance</em> 这道题类似，不过数量增加了。我们可以对int的每一位分别求HammingDistance再求和。n个二进制位中有i个0和j个1，那么它们两两组合成0与1的种类有i*j种。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                    num[<span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    num[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (num[<span class="number">0</span>] * num[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 461. Hamming Distance</title>
      <link href="/2016/12/27/leetcode-461-hamming-distance/"/>
      <url>/2016/12/27/leetcode-461-hamming-distance/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" rel="noopener">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p><p><strong>Note:</strong>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">The above arrows point to positions where the corresponding bits are different.</span><br></pre></td></tr></table></figure></blockquote><p>把两个数异或之后看结果有多少个1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(z &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(z &amp; <span class="number">1</span>) ans++;</span><br><span class="line">            z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 475. Heaters</title>
      <link href="/2016/12/19/leetcode-475-heaters/"/>
      <url>/2016/12/19/leetcode-475-heaters/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.</p><p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p><p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p><p><strong>Note:</strong></p><ol><li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li><li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li><li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li><li>All the heaters follow your radius standard and the warm radius will the same.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3],[2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4],[1,4]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</span><br></pre></td></tr></table></figure></blockquote><p>我使用二分搜索, 对每个房子搜索与它最近的heater, 维护一个最长的最短距离.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">        sort(heaters.begin(), heaters.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : houses)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = binSearch(heaters, i);</span><br><span class="line">            <span class="keyword">if</span>(index == heaters.size()) index--;</span><br><span class="line">            <span class="keyword">int</span> tmp = min(<span class="built_in">abs</span>(heaters[index] - i), <span class="built_in">abs</span>(index &lt; heaters.size() - <span class="number">1</span> ? heaters[index + <span class="number">1</span>] - i : INT_MAX));</span><br><span class="line">            tmp = min(tmp, <span class="built_in">abs</span>(index &gt; <span class="number">0</span> ? heaters[index - <span class="number">1</span>] - i : INT_MAX));</span><br><span class="line">            ans = max(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;heaters, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = heaters.size(), mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(heaters[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(heaters[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 468. Validate IP Address</title>
      <link href="/2016/12/19/leetcode-468-validate-ip-address/"/>
      <url>/2016/12/19/leetcode-468-validate-ip-address/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>In this problem, your job to write a function to check whether a input string is a valid IPv4 address or IPv6 address or neither.</p><p><strong>IPv4</strong> addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (&quot;.&quot;), e.g.,<code>172.16.254.1</code>;</p><p>Besides, you need to keep in mind that leading zeros in the IPv4 is illegal. For example, the address <code>172.16.254.01</code> is illegal.</p><p><strong>IPv6</strong> addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (&quot;:&quot;). For example, the address <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is a legal one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so <code>2001:db8:85a3:0:0:8A2E:0370:7334</code> is also a valid IPv6 address(Omit leading zeros and using upper cases).</p><p>However, we don’t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, <code>2001:0db8:85a3::8A2E:0370:7334</code> is an invalid IPv6 address.</p><p>Besides, you need to keep in mind that extra leading zeros in the IPv6 is also illegal. For example, the address <code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is also illegal.</p><p><strong>Note:</strong> You could assume there is no extra space in the test cases and there may some special characters in the input string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;172.16.254.1&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;IPv4&quot;</span><br><span class="line"></span><br><span class="line">Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;IPv6&quot;</span><br><span class="line"></span><br><span class="line">Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;256.256.256.256&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;Neither&quot;</span><br><span class="line"></span><br><span class="line">Explanation: This is neither a IPv4 address nor a IPv6 address.</span><br></pre></td></tr></table></figure></blockquote><p>判断合法的IP地址, 比较简单, 注意前导零就行.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(validIPv4(IP)) <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"IPv4"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(validIPv6(IP)) <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"IPv6"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"Neither"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validIPv4</span><span class="params">(<span class="built_in">string</span> IP)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            q = IP.find(<span class="string">'.'</span>, p);</span><br><span class="line">            <span class="keyword">if</span>(q == <span class="built_in">string</span>::npos &amp;&amp; i != <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">                q = IP.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> part = IP.substr(p, q - p);</span><br><span class="line">            <span class="keyword">if</span>(part.empty() || part.length() &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : part)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isDigit(c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> leadingZero = part[<span class="number">0</span>] == <span class="string">'0'</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(leadingZero &amp;&amp; part.length() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> t = stoi(part);</span><br><span class="line">            <span class="keyword">if</span>(t &gt; <span class="number">255</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = q + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validIPv6</span><span class="params">(<span class="built_in">string</span> IP)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            q = IP.find(<span class="string">':'</span>, p);</span><br><span class="line">            <span class="keyword">if</span>(q == <span class="built_in">string</span>::npos &amp;&amp; i != <span class="number">7</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">7</span>)&#123;</span><br><span class="line">                q = IP.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> part = IP.substr(p, q - p);</span><br><span class="line">            <span class="keyword">if</span>(part.empty() || part.length() &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : part)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isHex(c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = q + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHex</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDigit(c) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 206. Reverse Linked List</title>
      <link href="/2016/12/07/leetcode-206-reverse-linked-list/"/>
      <url>/2016/12/07/leetcode-206-reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Reverse a singly linked list.</p></blockquote><p>翻转一个单向链表, 就是从前往后依次翻转即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *p1 = head, *p2 = head-&gt;next, *p = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || !p2) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span>(p2 &amp;&amp; p1)&#123;</span><br><span class="line">            ListNode *t = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 205. Isomorphic Strings</title>
      <link href="/2016/12/07/leetcode-205-isomorphic-strings/"/>
      <url>/2016/12/07/leetcode-205-isomorphic-strings/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two strings <strong>s</strong> and <strong>t</strong>, determine if they are isomorphic.</p><p>Two strings are isomorphic if the characters in <strong>s</strong> can be replaced to get <strong>t</strong>.</p><p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p><p>For example,Given <code>&quot;egg&quot;</code>, <code>&quot;add&quot;</code>, return true.</p><p>Given <code>&quot;foo&quot;</code>, <code>&quot;bar&quot;</code>, return false.</p><p>Given <code>&quot;paper&quot;</code>, <code>&quot;title&quot;</code>, return true.</p><p><strong>Note:</strong>You may assume both <strong>s</strong> and <strong>t</strong> have the same length.</p></blockquote><p>依次建立替换的映射, 无法完成转换的条件有两个:</p><ol><li>s中两个不同的字符映射到了同一个字符. 用一个数组来记录每个字符是否被映射过, 出现重复时则返回false.</li><li>s中的两个相同字符映射到不同字符. 每次比较字符的映射是否相同.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        vector&lt;int&gt; s2t(128, -1), tCnt(128, 0);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> sc = s[i], tc = t[i];</span><br><span class="line">            <span class="keyword">if</span>(s2t[sc] == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tCnt[tc] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                s2t[sc] = tc;</span><br><span class="line">                tCnt[tc] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s2t[sc] != tc) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 204. Count Primes</title>
      <link href="/2016/12/06/leetcode-204-count-primes/"/>
      <url>/2016/12/06/leetcode-204-count-primes/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p><strong>Description:</strong></p><p>Count the number of prime numbers less than a non-negative number, <strong>n</strong>.</p></blockquote><p>使用筛法, 从小到大剔除每个遇到的素数的小于n的倍数, 直到$\sqrt n$, 每剔除一个就将素数个数减1. sum一开始减2是为了去掉1和n自身.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> sum = n - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; i * j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = i * j;</span><br><span class="line">    <span class="keyword">if</span>(!s[index]) &#123;</span><br><span class="line">        sum--;</span><br><span class="line">    s[index] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 203. Remove Linked List Elements</title>
      <link href="/2016/12/06/leetcode-203-remove-linked-list-elements/"/>
      <url>/2016/12/06/leetcode-203-remove-linked-list-elements/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p><p><strong>Example</strong><strong>Given:</strong> 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, <strong>val</strong> = 6<strong>Return:</strong> 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</p></blockquote><p>就是单纯的删除链表节点.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *p = <span class="keyword">new</span> ListNode(<span class="number">0</span>), *h = p;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 202. Happy Number</title>
      <link href="/2016/12/06/leetcode-202-happy-number/"/>
      <url>/2016/12/06/leetcode-202-happy-number/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p>**Example: **19 is a happy number</p><ul><li>12 + 92 = 82</li><li>82 + 22 = 68</li><li>62 + 82 = 100</li><li>12 + 02 + 02 = 1</li></ul></blockquote><p>最直观的解法可以使用hash表.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        s.insert(n);</span><br><span class="line">        <span class="keyword">int</span> t = n;</span><br><span class="line">        <span class="keyword">while</span>(t != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += ((t % <span class="number">10</span>) * (t % <span class="number">10</span>));</span><br><span class="line">                t /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = sum;</span><br><span class="line">            <span class="keyword">if</span>(s.count(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> s.insert(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是仔细想想, 输入数据最多为一个十位数, 每一位数字的平方最多为81, 因此中间过程所产生的数肯定落在<code>[1,810]</code>之间, 我们只要开一个较大的数组来保存某个数是否出现过就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">1000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> t = n;</span><br><span class="line">        <span class="keyword">while</span>(t != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += ((t % <span class="number">10</span>) * (t % <span class="number">10</span>));</span><br><span class="line">                t /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = sum;</span><br><span class="line">            <span class="keyword">if</span>(s[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> s[t] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 467. Unique Substrings in Wraparound String</title>
      <link href="/2016/12/05/leetcode-467-unique-substrings-in-wraparound-string/"/>
      <url>/2016/12/05/leetcode-467-unique-substrings-in-wraparound-string/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Consider the string <code>s</code> to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so <code>s</code> will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd…”.</p><p>Now we have another string <code>p</code>. Your job is to find out how many unique non-empty substrings of <code>p</code> are present in <code>s</code>. In particular, your input is the string <code>p</code> and you need to output the number of different non-empty substrings of <code>p</code> in the string <code>s</code>.</p><p><strong>Note:</strong> <code>p</code> consists of only lowercase English letters and the size of p might be over 10000.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a&quot;</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string s.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cac&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;zab&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s.</span><br></pre></td></tr></table></figure></blockquote><p>动态规划题目. <code>dp[i]</code>记录以<code>p[i]</code>为结尾的符合要求的子串的长度. 为了防止重复, 用另一个数组<code>tail</code>以字母为索引保存结果中以某个字母结尾的最长的子串的长度. 当<code>p[i]</code>与<code>p[i-1]</code>是连续的时候, <code>p[i]=p[i-1]</code>; 否则<code>p[i]=1</code>. 再检查<code>tail[p[i]-'a']</code>与<code>dp[i]</code>的大小关系, 若<code>tail[p[i]-'a']&gt;=dp[i]</code>, 说明<code>p[i]</code>结尾的所有子串都已经在结果中了; 否则更新<code>tail[p[i]-'a']=dp[i]</code>, 增加结果集中以<code>p[i]</code>这个字母结尾的子串的数量. 最后再对<code>tail</code>数组求和就得到结果. 时间复杂度O(n).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(p.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tail</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        tail[p[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((p[i - <span class="number">1</span>] != <span class="string">'z'</span> &amp;&amp; p[i] == p[i - <span class="number">1</span>] + <span class="number">1</span>) || (p[i - <span class="number">1</span>] == <span class="string">'z'</span> &amp;&amp; p[i] == <span class="string">'a'</span>))&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = p[i] - <span class="string">'a'</span>;</span><br><span class="line">            tail[index] = max(tail[index], dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : tail)&#123;</span><br><span class="line">            ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 201. Bitwise AND of Numbers Range</title>
      <link href="/2016/12/04/leetcode-201-bitwise-and-of-numbers-range/"/>
      <url>/2016/12/04/leetcode-201-bitwise-and-of-numbers-range/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p><p>For example, given the range [5, 7], you should return 4.</p></blockquote><p>位运算题目. 两个数m与n, 从最高位开始往低位看的话, 前面的许多位是相同的, 从某一位开始变得不同, 而这之后的所有位在结果中必然为0(因为中间肯定出现了0和1). 我们把m和n相减后得到的值就是这个阈值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minus = n - m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">if</span>(minus &gt; t)&#123;</span><br><span class="line">                re = re &amp; (~t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>((t &amp; m) &amp; (t &amp; n))&#123;</span><br><span class="line">                    re = re | t;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    re = re &amp; (~t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 200. Number of Islands</title>
      <link href="/2016/12/04/leetcode-200-number-of-islands/"/>
      <url>/2016/12/04/leetcode-200-number-of-islands/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a 2d grid map of <code>'1'</code>s (land) and <code>'0'</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br></pre></td></tr></table></figure><p>Answer: 1</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br></pre></td></tr></table></figure><p>Answer: 3</p></blockquote><p>使用BFS遍历即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> islandNum = <span class="number">0</span>;</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(grid[<span class="number">0</span>].size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    BFS(grid, i, j);</span><br><span class="line">                    ++islandNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islandNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;g, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; BFS;</span><br><span class="line">        BFS.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x, y));</span><br><span class="line">        <span class="keyword">while</span>(!BFS.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos = BFS.front();</span><br><span class="line">            <span class="keyword">int</span> curX = pos.first, curY = pos.second;</span><br><span class="line">            <span class="keyword">if</span>(curX - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; g[curX - <span class="number">1</span>][curY] == <span class="string">'1'</span> &amp;&amp; !visited[curX - <span class="number">1</span>][curY])&#123;</span><br><span class="line">                BFS.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(curX - <span class="number">1</span>, curY));</span><br><span class="line">                visited[curX - <span class="number">1</span>][curY] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curX + <span class="number">1</span> &lt; g.size() &amp;&amp; g[curX + <span class="number">1</span>][curY] == <span class="string">'1'</span> &amp;&amp; !visited[curX + <span class="number">1</span>][curY])&#123;</span><br><span class="line">                BFS.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(curX + <span class="number">1</span>, curY));</span><br><span class="line">                visited[curX + <span class="number">1</span>][curY] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curY - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; g[curX][curY - <span class="number">1</span>] == <span class="string">'1'</span> &amp;&amp; !visited[curX][curY - <span class="number">1</span>])&#123;</span><br><span class="line">                BFS.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(curX, curY - <span class="number">1</span>));</span><br><span class="line">                visited[curX][curY - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curY + <span class="number">1</span> &lt; g[<span class="number">0</span>].size() &amp;&amp; g[curX][curY + <span class="number">1</span>] == <span class="string">'1'</span> &amp;&amp; !visited[curX][curY + <span class="number">1</span>])&#123;</span><br><span class="line">                BFS.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(curX, curY + <span class="number">1</span>));</span><br><span class="line">                visited[curX][curY + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            BFS.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 199. Binary Tree Right Side View</title>
      <link href="/2016/12/04/leetcode-199-binary-tree-right-side-view/"/>
      <url>/2016/12/04/leetcode-199-binary-tree-right-side-view/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p><p>For example:Given the following binary tree,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>You should return <code>[1, 3, 4]</code>.</p></blockquote><p>我用DFS对二叉树进行遍历, 先遍历右节点再遍历左节点. 把每次遍历到的新的一层的第一个节点加入结果中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        DFS(root, ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode *node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level &gt; ans.size())&#123;</span><br><span class="line">            ans.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS(node-&gt;right, ans, level + <span class="number">1</span>);</span><br><span class="line">        DFS(node-&gt;left, ans, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 463. Island Perimeter</title>
      <link href="/2016/12/03/leetcode-463-island-perimeter/"/>
      <url>/2016/12/03/leetcode-463-island-perimeter/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Answer: 16</span><br><span class="line">Explanation: The perimeter is the 16 yellow stripes in the image below:</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/static/images/problemset/island.png" alt=""></p></blockquote><p>遍历整个二维数组, 对于每块陆地, 计算该块陆地与&quot;水域&quot;接触的边的数量, 这个数量范围为<code>[0,4]</code>, 岛屿的总周长等于每块陆地与水域接触的边的数量之和.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size(), col = grid[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    ans += getPerimeter(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size(), col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> || grid[x - <span class="number">1</span>][y] == <span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == row - <span class="number">1</span> || grid[x + <span class="number">1</span>][y] == <span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span> || grid[x][y - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y == col - <span class="number">1</span> || grid[x][y + <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 462. Minimum Moves to Equal Array Elements II</title>
      <link href="/2016/12/03/leetcode-462-minimum-moves-to-equal-array-elements-ii/"/>
      <url>/2016/12/03/leetcode-462-minimum-moves-to-equal-array-elements-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a <strong>non-empty</strong> integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p><p>You may assume the array’s length is at most 10,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only two moves are needed (remember each move increments or decrements one element):</span><br><span class="line"></span><br><span class="line">[1,2,3]  &#x3D;&gt;  [2,2,3]  &#x3D;&gt;  [2,2,2]</span><br></pre></td></tr></table></figure></blockquote><p>这道题我的首先思路是先找到最终每个元素所等于的值再计算需要的步数.</p><p>先考虑三个数$a_1 \ge a_2 \ge a_3$, 我们要找一个数$n$使得$|a_1-n|+|a_2-n|+|a_3-n|$最小. 比较容易想到$n$应该在区间$[a_1,a_3]$之间, 所以我们假设一个新的$n$, 满足$a_1 \ge a_2+n \ge a_3$, $a_2+n$就是我们要找的值. 这时我们要使$[a_1-(a_2+n)] + |n| + [(a_2 + n) - a_3]$最小.$$[a_1-(a_2+n)] + |n| + [(a_2 + n) - a_3] = a_1 - a_3 + |n|$$发现在$n=0$的时候才能取到最小值$a_1 - a_3$, 所以最终每个元素应有的值是原来所有元素的值的中位数.</p><p>以上是奇数的情况, 那么偶数的时候中位数有两个候选. 我们再假设$a_1 \ge a_2 \ge a_3 \ge a_4$, 当选择$a_2$作为最后的目标时, 总步数为$(a_1 - a_2) + (a_2 - a_3) + (a_2  - a_4) = a_1 - a_3 +a_2 - a_4$, 当选择$a_3$作为最后目标时, 总步数为$(a_1 - a_3) + (a_2 - a_3) + (a_3 - a_4) = a_1 - a_3 + a_2 - a_4$, 两种情况是相同, 因此我们只要随便选一个就可以了.</p><p>关于找到中位数, 不需要使用<code>sort</code>对所有数据进行排序, 可以使用<code>nth_element</code>来节省时间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> midIndex = nums.size() / <span class="number">2</span>;</span><br><span class="line">        nth_element(nums.begin(), nums.begin() + midIndex, nums.end());</span><br><span class="line">        <span class="keyword">int</span> mid = nums[midIndex];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(i - mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 198. House Robber</title>
      <link href="/2016/11/20/leetcode-198-house-robber/"/>
      <url>/2016/11/20/leetcode-198-house-robber/</url>
      
        <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p></blockquote><p>简单的动态规划问题. 相邻的房子不能同时入侵, 所以如果前一个房子入侵过了, 当前的房子就不能入侵.</p><p><code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp[nums.size()];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 191. Number of 1 Bits</title>
      <link href="/2016/11/20/leetcode-191-number-of-1-bits/"/>
      <url>/2016/11/20/leetcode-191-number-of-1-bits/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><p>For example, the 32-bit integer ’11’ has binary representation <code>00000000000000000000000000001011</code>, so the function should return 3.</p></blockquote><p>位运算.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">                ret++;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 190. Reverse Bits</title>
      <link href="/2016/11/20/leetcode-190-reverse-bits/"/>
      <url>/2016/11/20/leetcode-190-reverse-bits/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Reverse bits of a given 32 bits unsigned integer.</p><p>For example, given input 43261596 (represented in binary as <strong>00000010100101000001111010011100</strong>), return 964176192 (represented in binary as <strong>00111001011110000010100101000000</strong>).</p></blockquote><p>翻转一个32位整数的每一个位.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">            swapIntBit(n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapIntBit</span><span class="params">(<span class="keyword">uint32_t</span> &amp;n, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> b1 = n &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="keyword">uint32_t</span> b2 = n &amp; (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>) &gt;&gt; i);</span><br><span class="line">        n &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        n &amp;= ~(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>) &gt;&gt; i);</span><br><span class="line">        n |= b1 &lt;&lt; (<span class="number">31</span> - i * <span class="number">2</span>);</span><br><span class="line">        n |= b2 &gt;&gt; (<span class="number">31</span> - i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 189. Rotate Array</title>
      <link href="/2016/11/18/leetcode-189-rotate-array/"/>
      <url>/2016/11/18/leetcode-189-rotate-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p><p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>.</p></blockquote><p>循环右移, 没啥好说的…可以选择一起移动, 也可以选择一个元素一个元素移动; 前者时间复杂度低, 后者空间复杂度低.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.begin(), nums.begin() + (nums.size() - k))</span></span>;</span><br><span class="line">        nums.erase(nums.begin(), nums.begin() + (nums.size() - k));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : tmp)&#123;</span><br><span class="line">            nums.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 122. Best Time to Buy and Sell Stock II</title>
      <link href="/2016/11/18/leetcode-122-best-time-to-buy-and-sell-stock-ii-2/"/>
      <url>/2016/11/18/leetcode-122-best-time-to-buy-and-sell-stock-ii-2/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p></blockquote><p>这道题与<a href="http://xiadong.info/2016/09/leetcode-121-best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">上一题</a>相比不同点在于可以多次买入卖出股票但是不能同时持有多份股票, 所以整个的操作流程必须是&quot;买入-卖出-买入-卖出…-买入-卖出&quot;. 考虑一个简单的情况:</p><p><code>1,4,2,10</code></p><p>显然有两种策略, 分别的利润为<code>(4-1)+(10-2)=11</code>和<code>10-1=9</code>, 应选择第一种. 而另一种情况:</p><p><code>1,2,4,10</code></p><p>两种策略的利润为<code>(2-1)+(10-4)=8</code>和<code>10-1=9</code>, 此时应该选择第二种. 对于一般情况来说:</p><p><code>a1,a2,a3...,ap,...,aq,...,an</code></p><p>如果在a1买入ap卖出然后再aq买入an卖出的话, 利润为<code>(an-aq)+(ap-a1)</code>, 如果在a1买入an卖出的话, 利润为<code>an-a1</code>, 两者之差为<code>(an-a1)-[(an-aq)+(ap-a1)]=aq-ap</code>, 所以如果<code>ap&gt;aq</code>, 那么应该选择前者, 反之选择后者. 从编程策略上来说就应该是搜索一个从低价位开始的递增序列, 在不能再保持递增的时候就是应该卖出的时候.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; low) low = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(prices[i] &gt; prices[i + <span class="number">1</span>])&#123;</span><br><span class="line">                profit += (prices[i] - low);</span><br><span class="line">                low = prices[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prices.back() &gt; low) profit += (prices.back() - low);</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 456. 132 Pattern</title>
      <link href="/2016/11/17/leetcode-456-132-pattern/"/>
      <url>/2016/11/17/leetcode-456-132-pattern/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence a<strong>i</strong>, a<strong>j</strong>, a<strong>k</strong> such that <strong>i</strong> &lt; <strong>j</strong> &lt; <strong>k</strong> and a<strong>i</strong> &lt; a<strong>k</strong> &lt; a<strong>j</strong>. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p><p><strong>Note:</strong> n will be less than 15,000.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">Output: False</span><br><span class="line"></span><br><span class="line">Explanation: There is no 132 pattern in the sequence.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 1, 4, 2]</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [-1, 3, 2, 0]</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</span><br></pre></td></tr></table></figure></blockquote><p>这道题一开始我用了最直接的O(n^2)时间复杂度的解法, 后来仔细想了一下后才想出O(n)复杂度的解法.</p><p>主要思路是使用栈, 从后往前遍历nums. 假如我们遍历到了元素$a_k$, 那么在继续往前遍历的过程中, $a_k$有两种状态:</p><ol><li>等待找到一个比$a_k$大的元素$a_j$.</li><li>如果找到了$a_j$, 那么$a_k$就要等待找到一个比$a_k$小的元素$a_i$.</li></ol><p>问题在于$a_j$与$a_k$之间会有很多个其他元素, 这些元素一定比$a_k$小或相等, 因此当出现$a_j$的时候, $a_{j+1}\dots a_k$都会进入第二种状态, 对于$a_k$之后的元素则仍然处于第一种状态. 可以用一个栈来保存处于第一种状态的元素, 出现$a_j$时, 就弹出所有小于$a_j$的元素, 并把这些元素都压入另一个栈中.</p><p>仔细想一想, 每次从第一个栈中弹出的元素都一定是有序的, 越接近栈顶越小, 如果按照出栈的顺序压入第二个栈中, 就是越接近栈顶的元素越大, 当我们遍历到另一个元素$a_i$时, 只要它比第二个栈的栈顶元素小, 我们就可以确定函数返回true. 所以实际上我们并不需要第二个栈, 只要用一个变量来保存第一个栈中最后一个弹出的元素就可以了.</p><p>最后, 关于这个算法的复杂度. 首先遍历数组是O(n), 然后每一个数组中的元素都<strong>只有一次</strong>入栈和出栈的机会, 因此总的复杂度是O(n). 因为每个元素只能入栈一次, 所以我们可以一开始就设置栈的最大大小, 手动维护栈顶, 以避免栈大小动态增长过程中的开销.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">waitGreater</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxWaitSmaller = INT_MIN, top = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(top &lt; <span class="number">0</span> || nums[i] &lt; waitGreater[top])&#123;</span><br><span class="line">                waitGreater[++top] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; waitGreater[top])&#123;</span><br><span class="line">                <span class="keyword">while</span>(top &gt;= <span class="number">0</span> &amp;&amp; waitGreater[top] &lt; nums[i])&#123;</span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">                maxWaitSmaller = waitGreater[top + <span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                waitGreater[++top] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(maxWaitSmaller != INT_MIN &amp;&amp; nums[i] &lt; maxWaitSmaller) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 459. Repeated Substring Pattern</title>
      <link href="/2016/11/16/leetcode-459-repeated-substring-pattern/"/>
      <url>/2016/11/16/leetcode-459-repeated-substring-pattern/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: It&#39;s the substring &quot;ab&quot; twice.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">Output: False</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: It&#39;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)</span><br></pre></td></tr></table></figure></blockquote><p>这道题用最简单的遍历+回溯就可以AC</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= str.length() / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> sub = str.substr(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span>(check(str, sub)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span> &amp;sub)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() % sub.length() != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i += sub.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!strEqual(str, i, sub)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">strEqual</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> start, <span class="built_in">string</span> &amp;sub)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sub.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sub[i] != str[start + i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Runtime 92ms, 不是好解法, 看Discussion有许多人用KMP, 但是我不太懂KMP(加入学习列表), 而且感觉有点大材小. 所以选择了另一种办法: 主要思路就是把字符串循环左移(右移), 当正好移出了要找的子串的时候, 这个字符串应该是跟原字符串相等的. 我们可以只考虑移动字符串长度因子的长度, 因为其他长度都是不可能相等的. 这个解法的Runtime是29ms.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> nextStr = str;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len % i == <span class="number">0</span>)&#123;</span><br><span class="line">                nextStr = leftShift(str, i);</span><br><span class="line">                <span class="keyword">if</span>(nextStr == str) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">leftShift</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = str.substr(l);</span><br><span class="line">        ret += str.substr(<span class="number">0</span>, l);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 455. Assign Cookies</title>
      <link href="/2016/11/16/leetcode-455-assign-cookies/"/>
      <url>/2016/11/16/leetcode-455-assign-cookies/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>Note:</strong>You may assume the greed factor is always positive. You cannot assign more than one cookie to one child.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure></blockquote><p>排序之后使用贪心来满足尽量多的孩子.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> gi = <span class="number">0</span>, si = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(si &lt; s.size() &amp;&amp; gi &lt; g.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[gi] &lt;= s[si])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                si++;</span><br><span class="line">                gi++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                si++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 453. Minimum Moves to Equal Array Elements</title>
      <link href="/2016/11/07/leetcode-453-minimum-moves-to-equal-array-elements/"/>
      <url>/2016/11/07/leetcode-453-minimum-moves-to-equal-array-elements/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a <strong>non-empty</strong> integer array of size <em>n</em>, find the minimum number of moves required to make all array elements equal, where a move is incrementing <em>n</em> - 1 elements by 1.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only three moves are needed (remember each move increments two elements):</span><br><span class="line"></span><br><span class="line">[1,2,3]  &#x3D;&gt;  [2,3,3]  &#x3D;&gt;  [3,4,3]  &#x3D;&gt;  [4,4,4]</span><br></pre></td></tr></table></figure></blockquote><p>有很多种move的策略, 可以任意选择一种. 我的办法是:</p><ol><li>找到当前的最小值与最大值</li><li>增加除了该最大值以外的其他元素, 直到最小值与最大值相等</li><li>如果没有全部相等则回到第一步, 否则结束</li></ol><p>这样的话总的move次数应该为每个元素与最小元素之差的和.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, nMin = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            nMin = min(nMin, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            ans += (i - nMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 452. Minimum Number of Arrows to Burst Balloons</title>
      <link href="/2016/11/07/leetcode-452-minimum-number-of-arrows-to-burst-balloons/"/>
      <url>/2016/11/07/leetcode-452-minimum-number-of-arrows-to-burst-balloons/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p><p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons).</span><br></pre></td></tr></table></figure></blockquote><p>基本思路是每次尽可能多的刺破气球, 所以一开始从最左边的气球的右边缘发射一支箭, 否则最左边的气球就无法刺破了, 这样也能保证刺破尽可能多的气球.</p><p>但是问题在于如何判断哪个气球在&quot;最左边&quot;, 不能以左边缘来进行判断, 因为有这种情况: <code>(1,10),(2,5)</code>, 第一支箭应该从<code>x=5</code>发出而不是<code>x=10</code>, 所以排序时应该使用每个气球的右边缘来进行排序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(points.begin(), points.end(), [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, arrow = points[<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i].first &gt; arrow)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                arrow = points[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 447. Number of Boomerangs</title>
      <link href="/2016/11/07/leetcode-447-number-of-boomerangs/"/>
      <url>/2016/11/07/leetcode-447-number-of-boomerangs/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given <em>n</em> points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code>and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<strong>the order of the tuple matters</strong>).</p><p>Find the number of boomerangs. You may assume that <em>n</em> will be at most <strong>500</strong> and coordinates of points are all in the range <strong>[-10000, 10000]</strong>(inclusive).</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,0],[1,0],[2,0]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</span><br></pre></td></tr></table></figure></blockquote><p><s>这道题似乎还没有什么好解法, 现在Runtime1368ms都可以beats 100%的C++提交…</s></p><p>现在已经不是了, 1000多ms的Runtime算是比较慢啦, 但是我暂时还没有时间来搞这道题…</p><p>使用双重循环+哈希表. 如果认为unordered_map的查询复杂度是O(1), 总体复杂度是O(n^2).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; distance;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> d = getDistance(points[i], points[j]);</span><br><span class="line">                <span class="keyword">if</span>(distance.count(d))&#123;</span><br><span class="line">                    ans += <span class="number">2</span> * distance[d];</span><br><span class="line">                &#125;</span><br><span class="line">                distance[d]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getDistance</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p1, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)(p1.first - p2.first) * (<span class="keyword">long</span> <span class="keyword">long</span>)(p1.first - p2.first) </span><br><span class="line">             + (<span class="keyword">long</span> <span class="keyword">long</span>)(p1.second - p2.second) * (<span class="keyword">long</span> <span class="keyword">long</span>)(p1.second - p2.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 437. Path Sum III</title>
      <link href="/2016/11/05/leetcode-437-path-sum-iii/"/>
      <url>/2016/11/05/leetcode-437-path-sum-iii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure></blockquote><p>这道题用很直接的遍历方法就可以AC, 所以才会是Easy. 我还想了很久有没有O(n)或者O(nlogn)的办法…</p><p>对于每一棵子树, 都计算从根节点开始的路径和有没有等于sum的, 这一步用DFS遍历所有路径. 然后递归地处理左子树和右子树.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DFS(root, sum);</span><br><span class="line">        pathSum(root-&gt;left, sum);</span><br><span class="line">        pathSum(root-&gt;right, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode *node, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        target -= node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == target) ans++;</span><br><span class="line">        DFS(node-&gt;left, target);</span><br><span class="line">        DFS(node-&gt;right, target);</span><br><span class="line">        target += node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 421. Maximum XOR of Two Numbers in an Array</title>
      <link href="/2016/11/05/leetcode-421-maximum-xor-of-two-numbers-in-an-array/"/>
      <url>/2016/11/05/leetcode-421-maximum-xor-of-two-numbers-in-an-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a <strong>non-empty</strong> array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &lt; 231.</p><p>Find the maximum result of ai XOR aj, where 0 ≤ <em>i</em>, <em>j</em> &lt; <em>n</em>.</p><p>Could you do this in O(<em>n</em>) runtime?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 10, 5, 25, 2, 8]</span><br><span class="line"></span><br><span class="line">Output: 28</span><br><span class="line"></span><br><span class="line">Explanation: The maximum result is 5 ^ 25 &#x3D; 28.</span><br></pre></td></tr></table></figure></blockquote><p>这道题是使用递归的方法. 先找到出现不同的最高位, 然后按照该位是0还是1分为两类, 接下来处理下一位, 这时可以把数字分为4类, 分别以<code>00</code>, <code>01</code>, <code>10</code>和<code>11</code>开头, 最大的异或值会出现在<code>00</code>与<code>11</code>, <code>01</code>与<code>10</code>两种组合中, 递归地处理接下来的位数.</p><p>有可能出现<code>00</code>与<code>11</code>, <code>01</code>与<code>10</code>两种组合中每个组合都至少有一种分类是空的, 这个时候说明该位不可能为1, 只能为0, 可以用循环跳过这些位.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; one, zero;</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">for</span>(pos = <span class="number">31</span>; pos &gt;= <span class="number">0</span>; pos--)&#123;</span><br><span class="line">            <span class="comment">// 找到有不同的最高位</span></span><br><span class="line">            one.clear();</span><br><span class="line">            zero.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; pos)) one.push_back(i);</span><br><span class="line">                <span class="keyword">else</span> zero.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!one.empty() &amp;&amp; !zero.empty()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(one.empty() || zero.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; pos) + findXORHelper(zero, one, pos - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findXORHelper</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;zero, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;one, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; zeroZero, zeroOne, oneZero, oneOne;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(; pos &gt;= <span class="number">0</span>; pos--)&#123;</span><br><span class="line">            <span class="comment">// 跳过只能为0的位</span></span><br><span class="line">            zeroZero.clear();</span><br><span class="line">            zeroOne.clear();</span><br><span class="line">            oneZero.clear();</span><br><span class="line">            oneOne.clear();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : zero)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; pos)) zeroOne.push_back(i);</span><br><span class="line">                <span class="keyword">else</span> zeroZero.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : one)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; pos)) oneOne.push_back(i);</span><br><span class="line">                <span class="keyword">else</span> oneZero.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该位可以为1</span></span><br><span class="line">            <span class="keyword">if</span>(!((zeroZero.empty() || oneOne.empty()) &amp;&amp; (oneZero.empty() || zeroOne.empty()))) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有位数都处理完毕</span></span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; pos) + max(findXORHelper(zeroZero, oneOne, pos - <span class="number">1</span>), findXORHelper(oneZero, zeroOne, pos - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 187. Repeated DNA Sequences</title>
      <link href="/2016/11/04/leetcode-187-repeated-dna-sequences/"/>
      <url>/2016/11/04/leetcode-187-repeated-dna-sequences/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p><p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].</span><br></pre></td></tr></table></figure></blockquote><p>因为序列长度是固定的十位, 所以如果把A, C, G, T对应到1, 2, 3, 4的数字的话, 十位的字符串可以映射到一个整数. 然后就可以用hash表来记录是否出现过相同的字符串.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">10</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; tSet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.size() - <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> str = s.substr(i, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> t = strToInt(str);</span><br><span class="line">            <span class="keyword">if</span>(tSet.count(t))&#123;</span><br><span class="line">                <span class="keyword">if</span>(tSet[t] == <span class="number">1</span>) re.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            tSet[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            re *= <span class="number">5</span>;</span><br><span class="line">            re += charToNum(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">charToNum</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 419. Battleships in a Board</title>
      <link href="/2016/11/04/leetcode-419-battleships-in-a-board/"/>
      <url>/2016/11/04/leetcode-419-battleships-in-a-board/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an 2D board, count how many different battleships are in it. The battleships are represented with <code>'X'</code>s, empty slots are represented with <code>'.'</code>s. You may assume the following rules:</p><ul><li>You receive a valid board, made of only battleships or empty slots.</li><li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or<code>Nx1</code> (N rows, 1 column), where N can be of any size.</li><li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X..X</span><br><span class="line">...X</span><br><span class="line">...X</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>In the above board there are 2 battleships.</p><p><strong>Invalid Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...X</span><br><span class="line">XXXX</span><br><span class="line">...X</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p><p><strong>Follow up:</strong>Could you do it in <strong>one-pass</strong>, using only <strong>O(1) extra memory</strong> and <strong>without modifying</strong> the value of the board?</p></blockquote><p>这道题题目中举的invalid的例子是不会作为输入数据的, 所以不需要对它进行判断. 最直接的方法就是遍历数组, 然后~~找舰娘(雾)/老婆(大雾)~~在遇到一个X的时候计数器加1, 并把与它相邻接的所有X清除以防止重复计算.</p><p>但是Follow up中是要求不修改原数组的. 对于横向的战舰只要直接跳过就可以了, 因为一般都是按行=&gt;列的方式来遍历. 而对于纵向的战舰, 则要判断它上方是否有X, 如果有的话说明这艘战舰已经计算过了, 不应该重复计算.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.size();</span><br><span class="line">        <span class="keyword">if</span>(board.empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'X'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">'X'</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; col - <span class="number">1</span> &amp;&amp; board[i][j + <span class="number">1</span>] == <span class="string">'X'</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(; j &lt; col &amp;&amp; board[i][j] == <span class="string">'X'</span>; j++) board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 436. Find Right Interval</title>
      <link href="/2016/11/02/leetcode-436-find-right-interval/"/>
      <url>/2016/11/02/leetcode-436-find-right-interval/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i.</p><p>For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.</p><p><strong>Note:</strong></p><ol><li>You may assume the interval’s end point is always bigger than its start point.</li><li>You may assume none of these intervals have the same start point.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [1,2] ]</span><br><span class="line"></span><br><span class="line">Output: [-1]</span><br><span class="line"></span><br><span class="line">Explanation: There is only one interval in the collection, so it outputs -1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [3,4], [2,3], [1,2] ]</span><br><span class="line"></span><br><span class="line">Output: [-1, 0, 1]</span><br><span class="line"></span><br><span class="line">Explanation: There is no satisfied &quot;right&quot; interval for [3,4].</span><br><span class="line">For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;</span><br><span class="line">For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [1,4], [2,3], [3,4] ]</span><br><span class="line"></span><br><span class="line">Output: [-1, 2, -1]</span><br><span class="line"></span><br><span class="line">Explanation: There is no satisfied &quot;right&quot; interval for [1,4] and [3,4].</span><br><span class="line">For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point.</span><br></pre></td></tr></table></figure></blockquote><p>使用排序+二分搜索. 要注意记录排序之前每个interval的下标.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; maps(intervals.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            maps[i].first = intervals[i].start;</span><br><span class="line">            maps[i].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(maps.begin(), maps.end(), [&amp;](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(intervals.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> target = intervals[i].end;</span><br><span class="line">            ans[i] = binSearch(maps, <span class="number">0</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;m, <span class="keyword">int</span> begin, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = begin, right = m.size(), mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[mid].first == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> m[mid].second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m[mid].first &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者可以使用hash表.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            maps[intervals[i].start] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(intervals.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            ans[i] = maps.count(intervals[i].end) ? maps[intervals[i].end] : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 435. Non-overlapping Intervals</title>
      <link href="/2016/11/02/leetcode-435-non-overlapping-intervals/"/>
      <url>/2016/11/02/leetcode-435-non-overlapping-intervals/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p><p><strong>Note:</strong></p><ol><li>You may assume the interval’s end point is always bigger than its start point.</li><li>Intervals like [1,2] and [2,3] have borders “touching” but they don’t overlap each other.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.</span><br></pre></td></tr></table></figure></blockquote><p>先对区间按照左端点值, 右端点值的优先级从小到大排序, 然后从前到后依次处理. 对于前后两个区间a和b(它们并不一定相邻)来说, 有两种可能的情况:</p><ol><li>两个区间没有重叠. 这样的话b之后的区间也不可能与a有重叠, 不需要做处理.</li><li>两个区间有重叠. 这又分两种情况: 1. a完全&quot;盖住&quot;了b; 2. a没有完全&quot;盖住&quot;b. 对于前者, 应该移除的是a区间, 因为a比b要&quot;大&quot;, 之后的区间如果与b有重叠则一定与a有重叠, 但是与a有重叠不一定与b有重叠. 对于后者, 应该移除区间b, 因为与a有重叠则必然与b有重叠, 但是与b有重叠不一定与a有重叠.</li></ol><p>a应该始终保存上一个没有被移除的区间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(intervals.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [&amp;](Interval &amp;a, Interval &amp;b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.start == b.start)&#123;</span><br><span class="line">                <span class="keyword">return</span> a.end &lt; b.end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(overlap(intervals[p], intervals[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[i].end &lt; intervals[p].end)&#123;</span><br><span class="line">                    p = i;</span><br><span class="line">                &#125;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">overlap</span><span class="params">(Interval &amp;a, Interval &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(a.start &gt;= b.end || a.end &lt;= b.start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 179. Largest Number</title>
      <link href="/2016/11/01/leetcode-179-largest-number/"/>
      <url>/2016/11/01/leetcode-179-largest-number/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p><p>Note: The result may be very large, so you need to return a string instead of an integer.</p></blockquote><p>这是一个排序问题, 只要能判断两个数的先后顺序, 那就可以通过比较排序得到最后的有序序列. 对于两个int数据<code>a</code>, <code>b</code>, 把它们以<code>ab</code>和<code>ba</code>两种形式存储在<code>long long</code>中, 就可以通过直接的比较大小来判断顺序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end(), [=](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ab = func(a, b), ba = func(b, a);</span><br><span class="line">            <span class="keyword">return</span> ab &gt; ba;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">string</span> re;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            re += to_string(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> iter = re.begin();</span><br><span class="line">        <span class="keyword">for</span>(; iter != re.end() &amp;&amp; (*iter) == <span class="string">'0'</span>; iter++);</span><br><span class="line">        <span class="keyword">if</span>(iter == re.end()) <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">string</span>(iter, re.end());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> re = a;</span><br><span class="line">        <span class="keyword">int</span> t = b;</span><br><span class="line">        <span class="keyword">while</span>(t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            re *= <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 174. Dungeon Game</title>
      <link href="/2016/11/01/leetcode-174-dungeon-game/"/>
      <url>/2016/11/01/leetcode-174-dungeon-game/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0’s</em>) or contain magic orbs that increase the knight’s health (<em>positive</em> integers).</p><p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p><p><strong>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</strong></p><p>For example, given the dungeon below, the initial health of the knight must be at least <strong>7</strong> if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANgAAADXCAYAAAB4dp84AAAWXklEQVR4Xu2dL1xi29vF1y1MkaRFypC0SCJpuUwRwwxBKWIYLD+KEAaKEMQgFjCIhVvQIBZ9AxrEMkxhEokpmJiCBdKxHIrvB0FEBD37cIADLqLsvTl77fXdzx+Ye/95eHh4AF9UgAoMRIF/ngD7559/BvIBXJQKfFQF6rGLgH3U0+e+B64AARu4xPyAj6xAT8BYlj3boj11pi7U5b0Lo9MvXVNEGolGEjXSe+M/yvsETPCkGcG6C0ZdlOnCCPYOcDSSMiMJ3lsTO5wRTPBoCRgBE7EMARNRCwABI2AiliFgImoRsJ5q8eJRdvGwBmMNJnjlNIYTMAKmyjidk2gkZUbSROwJWIQpouAhEjACJmIZAiaiFlMh1mB9+oU1GGswQQuxBntLMEYwQTsxRWSKKGIZAiaiFlNEpoh9+oUpIlNEQQsxRWSKqMoyTIVEZGPqrMwvjGCMYCJctcYSMAKmyjidk2gkZUbSROwJWIRNDsFDJGAETMQyBExELXYR2UXs0y+swViDCVqIXUR2EVVZhqmQiGxMnZX5hRGMEUyEK3YRBf1CwAQFU+XGCZzECMYIpomtaSRlRtJE7AlYhF1EwUMkYARMxDIETEQttunZpu/TL8OtwaQyiqU73GMKs+Z5mIzvPb2EYjaH6pwNS6YaSoUSJKMZFnP7RBmV4i3uaoDB+Al3xQrMtiWYP723trL3dRnB6jre3qE2NQvzvAnvyqhsq0KjdKOLDrRoF25EEUxGOXuEQOAMt62nmcNqNAq/zYReLFRyEWzuA+FUEFZDHuEvHvz+mkQ6aGnOkVHO7MMTuoL07w4SkUWUdjdwMhtFwmvRxHi6MVJTt0oujoDvBH+edJxbxV7UD7tJoxtFIWZ60EUvWowesEoWQUcA+eU9JLbtMNdKyMQ8CN0sIJqOwTbT5VSlAuJuD27d54h/MwFyJ2DPcNXq6+7YH6OWXErB47rBcioBlwZhTA9Gaqkj5RF2evDb2tjvbDWHmMeHq7ko0jEbusmokBfhYSPXRUdajBwwuRiHx5eH7TAB93zjppULETg2f2E5mYbf8vr2rWT9cAQ/IZqOYKnunBeAzaHajFz42oD2+QIv49LjwNHnBM6D1r6j2MiN1H565RyOj7MwuvxYe7w8JOTDdngK6zhNedGUVhgWNRNGrouOtBg5YK8PUEYptQnngRHb6QTWTJ0jysh4HQgZorh+uplbgCVwaL1EIHQFw2oUcb+tDa7GOuULNxwxEw4zESz1WaCM3Eg93C9LFdwVbhALHKC0lkTKr01KrBQ2Pekyai10B1glH4fPcwJpNYFUtyhTD/92D263zpF0mRv1VhOwK+NnTFX/4h7A9OohToNLr1KjRnT8ja+n5/D2ea3ryUitg5SLiDs3cHJX/8sCtpJxuC193iRKyWqO040uOtBiqIBV8pe4KUqtz5y2foN9/unwZZRzRwj4zlD+dxuJ8Bpab71IhS7hcezCsHeNuL1ZWTwBVgMWvkfxP+MxfEclLO+lELG/DIGPdZjzANOHPxHrM4SNykhv6yihXKqiJpVweRTASXEZ0fNI91pWEBylw0ely+vnG70WQwRMRjHuwsbJ39ZnWrfTSDzmgBKKF2H49n9h6useYvVmR6/GV+kCbuf+S0CagN0sNgt6uYiUbwMH+UXsnEfxrX2xchPQ6DXiXTsoSm00qv9E9Fs6vnz2en3r2jiBWYPLRLkqo9Ll7ScclRZDBKyXADKKqQA2DvKwbsWx57a+3fGqZOFdCaC2k0ai3kFsSxHb2/Ry6QI+5z7yCz9wmnC1iny5eIzNjf8wl8ggbO0vddLPTQ1I+TCcngLWT1NtzaIYnJsXsCQyiPS513ECTE9ajBwwuZiCZ+MAfz5/xQ93e2fPANOiHdbO/rJcxLFrA2fWtu+8XrXpH6lD+TIA5+5vzH5P4NjbWLvegVwJ3GMnncATnyLmeUswtetoMq+SQ9jpw9X8Dxxu22CSCriIhXB2t4rEeRBD5Gv0//MHHWkxYsBkFI83sXH0/BXz8wNN4Wsyg/CrNr2MQtyJzezyc/u5K2D1lcrIBJ0I3RixeniK4NIn5MNOeEr/w3lire9fdOgpgtV3KxVS2A8e4OaxwQEYFlaxE/bC/uLXLZrg/OYietBFL1qMGDB1h91oVFzAmkzB2+V7sp6rSvVbPoja9jkifdZf9c/Qg5Fe71WGVK5CMhhhmukvBVZ3OnrSZfRajCVgj1+iRlwI3vtxGlH+K4XypQfOs0Ukk25NvnjVJ2BqsdBuHnXpruWIfouo8mArOUR8JzDtHLaK+jdXkvKIeeKY3tbueyEaSZmRVJ7wxE0bL8B0ID8BI2AiNiRgImrptgYT3MQAhvPiUXbxDPffgw3goAe9JI2kzEiDPodxWZ8RTPCkCBgBE7EMARNRiyliT7V48Si7eJgivgMcjaTMSIL31sQOZwQTPFoCRsBELEPARNRiisgUsU+/MEVkiihoocZwRnZlkZ2AETACpkoBAqaJbLyplRlJE7EnYBHWYIKHSMAImIhlCJiIWqw12OTo0y+swViDCVqITY63BGMEE7QTU0SmiCKWIWAiajFFZIrYp1+YIjJFFLQQU0SmiKosw1RIRDamzsr8wgjGCCbCVWssASNgqozTOYlGUmYkTcSegEXY5BA8RAJGwEQsQ8BE1GIXkV3EPv3CGow1mKCF2EVkF1GVZZgKicjG1FmZXxjBGMFEuGIXUdAvBExQMFVunMBJjGB9RLAJ9AO3RAWGrsDDwwO6RrChPwk/kApMoAIEbAIPlVvSjwI9Aau/wRfb0SLtaPqlu1/Y5GCTQxUbbHL00eRgBHsWj0ZSZiRVlE7gJP5USvBQCRgBE7EMARNRi79F7KkWLx5lFw9rMNZgglcOmz8izR8CRsAImCoFGME0kY2pkDIjaSL2BCzCGkzwEAkYAROxDAETUYtNDjY5+vQLazDWYIIWYpODTQ5VlmEqJCIbU2dlfmEEYwQT4ao1loARMFXG6ZxEIykzkiZiT8AibHIIHiIBI2AiliFgImqxi8guYp9+YQ3GGkzQQuwisouoyjJMhURkY+qszC+MYIxgIlyxiyjoFwImKJgqN07gJEYwRjBNbE0jKTOSJmJPwCLsIgoeIgEjYCKWIWAiarFNzzZ9n35hDcYaTNBCbNOzTa/KMkyFRGRj6qzML4xgjGAiXLFNL+gXAiYomCo3TuAkRrBxj2CyhHJV6tiFAdOmGXwaomH1ZCSpmEfJuACLqUMBuYLi7V/cYxqf58yYGYJAetKlboee2gzRK/WPGpsuopQLwu67Qe2FQMtI/IzAahyeanoxkly6RNC1i6o/jeM1U0uA+t93Pbu4qTb/9Pkr9uLbsHdCqLFketGlvq1e2mi8ZUXLjQlgMkrHm3Aez2I74oK5dSNPYc46jyHy9epGUqSypoNklPMXiPkP8OseWNhuA0wu4cLjxD62kIiuY6GWx5HXhzPTHtJxO54x1PSBHhfTB2BvaKP9lhWtOCaAVZD1ryBQ28N13I4ZRVsbzKBRG6mc8cMR+oXP/y4Dv25gbANMLqWw6TyA+fAakaWGSpWsHyuBe+ykE/g2QMJGrUt9r29pMxg3vL/qeAAmFxF3buDEuIxlYwnFigHmpTW4v3+DZci0jdpIlUIGf2DFovkWwS8+VNsAq6fRX3wl/DhPwtUM83IxDtfGFazJNIKWwRVjo9bl8TJ5Q5v3URjMiPEArJKBdyWE39OLWP1ug7lWwNXRFW4XtnCacGN+cL55pboejPT4UFIO/g7AKhkvVkK1F9GqHtU8zgOYEj8RGWCxqhtdemgzGHzeX1V3gFXyl7gpPncLp63fYDdLKORLgNna6phVcmE4fTewJTIID9A4nRIOy0hddZhvqza7AZb1YiVAwLpdPu+jMJgROgNMRjHuwsbJ39ZurdtpJNq6ZK03yhl4HCFgJ43EIIuLDt2HA5gCHboAJuXDsHtusdWRIjo3rrD4AVLE1lF10WYw+Ly/qs4A6/7AUj4Ct/cPbMkkvM18UC7E4dw8g/Uwg/DS8PqIwwHs/YPrekuXL+Fx7GIqeo2YrVGcli89cOwasHcdh32A9apudGGKqMA8nUMqWQQdAWStW4j6l2GSCrjYD+FM/o7ksReW4fGlk3Z09xoMKCPjdyJ0u4ydiBuWWh7/BfeRs0ZxHrENtPtKwLr7eiwi2GOHKJ/CfvgAv+4aGzEsrGMnvAX785diKsgVn6IbI/VKgyo5xEMBnOQbX8lPWbcQ23PDOsDoVf8c3ejCCCZu6ucZMirlKmoGI0wzQwxbbY+sKyO9IaVUKUPC8HQaF136cZ+auWMTwdRsbhBzaCRlqdAgtB/HNQmY4KkRMAImYhkCJqKW3moNwWcf5HBePMouHv57sHdcSCMpM9IgYR6ntRnBBE+LgBEwEcsQMBG1mCL2VIsXj7KLhykiU0TBK6cxnIARMFXG6ZxEIykzkiZiT8AiTBEFD5GAETARyxAwEbWYCrEG69MvrMFYgwlaiDXYW4IxggnaiSkiU0QRyxAwEbWYIjJF7NMvTBGZIgpaiCkiU0RVlmEqJCIbU2dlfmEEYwQT4ao1loARMFXG6ZxEIykzkiZiT8AibHIIHiIBI2AiliFgImqxi8guYp9+YQ3GGkzQQuwisouoyjJMhURkY+qszC+MYIxgIlyxiyjoFwImKJgqN07gJEYwRjBNbE0jKTOSJmJPwCLsIgoeIgEjYCKWIWAiarFNzzZ9n35hDcYaTNBCbNOzTa/KMkyFRGRj6qzML10jmIjQHEsFqEB3BR4eHkDA6A4qMCAFCNiAhOWyVKCuQE/A6m/wxWJepJinX7r7hV1EdhFVscEmRx9NDkawZ/FoJGVGUkXpBE7iF82Ch0rACJiIZQiYiFr8JUdPtXjxKLt4WIOxBhO8ctj8EWn+EDACRsBUKcAIpolsTIWUGUkTsSdgEdZggodIwAiYiGUImIhabHKwydGnX1iDsQYTtBCbHGxyqLIMUyER2Zg6K/MLIxgjmAhXrbEEjICpMk7nJBpJmZE0EXsCFmGTQ/AQCRgBE7EMARNRi11EdhH79AtrMNZgghZiF5FdRFWWYSokIhtTZ2V+YQRjBBPhil1EQb8QMEHBVLlxAicxgjGCaWJrGkmZkTQRewIWYRdR8BAJGAETsQwBE1GLbXq26fv0C2sw1mCCFmKbnm16VZZhKiQiG1NnZX5hBGMEE+GKbXpBvxAwQcFUuXECJzGCjVkEk4p5lIwLsJg+vXxyuYLi7V/cYxqf58yY6Xh70N4dmZGkMoq3d6hNzcI8b4Kxc6OTrossoVyVOnZtwLRpBr0tIKGYzaE6Z8OSqYZSoYRXK0zPwvy0hlRCNleG2bYEs0a+0mUXUS5dIujaRdWfxvGaqSVq/e+7nl3cVJt/+vwVe/Ft2DshHCBlowCskosj4DvBn6d9za1iL+pv7fsj6CLlgrD7blB7cbbLSPyMwPrqtmkMquQi2NwHwqkgrIYCYo5NnD15p32dhXVEI1uwmSRkghs4mY0i4bW8vsRU+EpngMko5y8Q8x/g1z2wsN0GmFzChceJfWwhEV3HQi2PI68PZ6Y9pON2PGOoQgWBKUMHTMoj7PTgt3UPiR07Zqs5xDw+XM1FkY7ZMPMhdJFROt6E83gW2xFXW3SZwpx1vjsIUgFxtwe37nPEv5kAuQnY3B5Otxvw1Go1SMUL7IfOUFqOIh2xwVhKweO6wXIqAZcGYUxXgJUzfjhCv/D532Xg1w2MbYDJpRQ2nQcwH14jsjTTuKGyfqwE7rGTTqCu4TBeQwesnMPxcRZGlx9rjwcuIR+2w1NYx2nKC/PdR9Clgqx/BYHaHq7jdjRO/+1X3RuO4CdE0xE82uUJMGsCPyPWNigl5Pxf4PuzimQ6CMunMi49Dhx9TuA82D7uvU8cgxqsUsjgD6xYNN8i+MWHahtg9RThi6+EH+fJ1s0iF+NwbVzBmkwjaNEoaX5Hx6ED1vY8slTBXeEGscABSmtJpPwW4CPoIhcRd27gxLiMZWMJxYoB5qU1uL9/g6UrbWVkvA6EDFFc16N8XcNegMllXHgc2Je+P15Y85+A8oUbjpgJh5kIlnqkn0px01UEaz20lIO/A7BKxouVUO1FtKpHNY/zAKbET0R6JeJKlVA4bmSAPZnsrv6gC9hKxuG2GPEhdKlk4F0J4ff0Ila/22CuFXB1dIXbhS2cJtyPULx41dNquwe3W+dIusyNJsgTYFOr2Fozw1D/W62KUv4K//e7CuuPcxw2x8qFCBybv/H19BzeV4srNEpz2PgAlvViJfCBAYOEcqmKmlTC5VEAJ8VlRM8jWPgzWbpU8pe4KT73+qat32A3SyjkS4DZ2uoqV3JhOH03sCUyCHderuVLeBy7MOxdI25vhrgnwKqAwfCIFwzGaZjMFix+Xcf6N0sr9Xy6uKcPfyLWZwgbG8CkfBh2zy22OlJE58YVFj9Iivh0dzZS4xOYD38i/Ck2QbrIKMZd2Dj52woT1u00Em2d5NYb5Qw8jhCwk0aiswAvXcDt3McLQHrWYF0i0hOg0WvEbUoqvt5RbWwAQ3PTU9FrxJqbLl964Ng1YO86jqeLSiyAi48edopYv1icngLWT1NwN9MVuRCDc/MClkQGkdns4209ybpI+Qjc3j+wJZOtlE0uxOHcPIP1MINwZ5SpZOFdCaDWDp8AYHLxGJsb/2GuW3QUtMz4AIYyMn4nQrfL2Im4Yanl8V9wHzlrFOeRZiEruHk1w4cNGCo5hJ0+XM3/wOG2DSapgItYCGd3q0icB2E1fgBdKlkEHQFkrVuI+pcbGuyHcCZ/R/LYC0tnI0Iu4ti1gTNrEumg5WUN9qqL+NoFWnanxwiwx28OEQ8FcJJvfN04Zd1CbM8Na39RXIizoQNWb8wXUtgPHuDmscEBGBZWsRP2wm5uOusD6FLJp7AfPsCvlgbr2Alvwd71uyoZhbgTm9nlVmewd5u+8/jrX4M44Sn9D+eJtb5/0aFPwN6xvFQpQ4IRppk+e6hCaDUGjwKwxifLkMpVSIbe+558XWRUylXU3tCgVac+dpgvYE2m4BX5CkeqZwxB1LbPEemz/urmF/7Y9x3oRgeYittgiFP0p4uEfMSF4L0fpwIlRL2ud54tIpns0v5XoedYRjAV+9Rsiv6MpNnW+lpIl7pUcoj4TmDaOWw1iN7cpJRHzBPH9HbjO0YtXgRMUEVdGklwD4MYTl26q0rABN1GIykzkqCsEzucgAkeLQEjYCKWIWAiao20iyj4oEMezotH2cXDLiK7iKrQJGAETJVxOifRSMqMpInYE7AIU0TBQyRgBEzEMgRMRC3WYD3V4sWj7OJhDcYaTPDKaQwnYARMlXFYgymTjYARMGVOYQRTpRMBI2CqjMMIpkw2AkbAlDmFEUyVTgSMgKkyDiOYMtkIGAFT5hRGMFU6ETACpso4jGDKZCNgBEyZUxjBVOlEwAiYKuMwgimTjYARMGVOYQRTpRMBI2CqjMMIpkw2AkbAlDmFEUyVTgSMgKkyDiOYMtkIGAFT5hRGMFU6ETACpso4jGDKZCNgBEyZUxjBVOlEwAiYKuMwgimTjYD1AZgyiTmKClCBtxR4eHhA1/9kAGWjAlSgfwUIWP8acgUq0FOBF4BRJypABbRX4P8ByPremdZWpuYAAAAASUVORK5CYII=" alt="img"></p><p><strong>Notes:</strong></p><ul><li>The knight’s health has no upper bound.</li><li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li></ul></blockquote><p>使用二分搜索+DP. 单纯的二维DP是不行的, 因为这道题要求从起点到终点的路径中每个格子的值都不能小于1. 有可能出现终点时生命值大于0但是每一条路径实际上都无法抵达.</p><p>但是我们可以使用DP来判断一个特定初始生命值的knight能否救到princess. 然后在外层使用二分搜索来找到最小的初始生命值. 虽然可以用<code>0~INT_MAX</code>作为搜索范围, 但是先找出初始生命值为0时每一条路径中出现的最小的生命值可以大大缩小这个范围, 实际上如果初始生命值为0时, 所有的格子中生命值都是大于1的, 可以直接返回1; 否则搜索范围的最大值就是最小生命值的绝对值加1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dungeon.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dungeon[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = minInPath(dungeon);</span><br><span class="line"><span class="keyword">if</span>(tmp &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = -tmp + <span class="number">1</span>, mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> h = canArrive(dungeon, mid);</span><br><span class="line"><span class="keyword">if</span>(h == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">1</span>) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line">mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mid ? mid : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canArrive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> row = dungeon.size(), col = dungeon[<span class="number">0</span>].size();</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>))</span></span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = target + dungeon[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; col; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[<span class="number">0</span>][i - <span class="number">1</span>] &gt; <span class="number">0</span>) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + dungeon[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][<span class="number">0</span>] &gt; <span class="number">0</span>) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + dungeon[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &gt; <span class="number">0</span> || dp[i][j - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + dungeon[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minInPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = dungeon.size(), col = dungeon[<span class="number">0</span>].size(), minInPath = INT_MAX;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>))</span></span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = dungeon[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">minInPath = min(minInPath, dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; col; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + dungeon[<span class="number">0</span>][i];</span><br><span class="line">minInPath = min(minInPath, dp[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + dungeon[i][<span class="number">0</span>];</span><br><span class="line">minInPath = min(minInPath, dp[i][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + dungeon[i][j];</span><br><span class="line">minInPath = min(minInPath, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minInPath;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 173. Binary Search Tree Iterator</title>
      <link href="/2016/10/31/leetcode-173-binary-search-tree-iterator/"/>
      <url>/2016/10/31/leetcode-173-binary-search-tree-iterator/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p><p>Calling <code>next()</code> will return the next smallest number in the BST.</p><p>**Note: **<code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</p></blockquote><p>二叉树的非递归中序遍历, 只不过不是放在循环中, 而是通过next来触发每一步的进行.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line">    TreeNode *BST, *curNode;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        BST = root;</span><br><span class="line">        mostLeft(root);</span><br><span class="line">        curNode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">mostLeft</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span>(node) &#123;</span><br><span class="line">            path.push_back(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.empty() &amp;&amp; !curNode) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//curNode = path.back();</span></span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(!curNode)&#123;</span><br><span class="line">            ans = path.back()-&gt;val;</span><br><span class="line">            curNode = path.back()-&gt;right;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mostLeft(curNode);</span><br><span class="line">            ans = path.back()-&gt;val;</span><br><span class="line">            curNode = path.back()-&gt;right;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 441. Arranging Coins</title>
      <link href="/2016/10/31/leetcode-441-arranging-coins/"/>
      <url>/2016/10/31/leetcode-441-arranging-coins/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>You have a total of <em>n</em> coins that you want to form in a staircase shape, where every <em>k</em>-th row must have exactly <em>k</em> coins.</p><p>Given <em>n</em>, find the total number of <strong>full</strong> staircase rows that can be formed.</p><p><em>n</em> is a non-negative integer and fits within the range of a 32-bit signed integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 5</span><br><span class="line"></span><br><span class="line">The coins can form the following rows:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤</span><br><span class="line"></span><br><span class="line">Because the 3rd row is incomplete, we return 2.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 8</span><br><span class="line"></span><br><span class="line">The coins can form the following rows:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤ ¤</span><br><span class="line">¤ ¤</span><br><span class="line"></span><br><span class="line">Because the 4th row is incomplete, we return 3.</span><br></pre></td></tr></table></figure></blockquote><p>等差数列的问题, 前m行共有$$\frac{m(m+1)}{2}$$个硬币, 共有n个硬币, 那么应该找出最大的m满足$$\frac{m(m+1)}{2} \le n \rightarrow m^2+m-2n \le 0$$因为m是正整数, 所以$$m \le \frac{-1+\sqrt{1+8n}}{2}$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">sqrt</span>((<span class="keyword">long</span> <span class="keyword">long</span>)n * <span class="number">8</span> + <span class="number">1</span>) - <span class="number">1.0</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 438. Find All Anagrams in a String</title>
      <link href="/2016/10/30/leetcode-438-find-all-anagrams-in-a-string/"/>
      <url>/2016/10/30/leetcode-438-find-all-anagrams-in-a-string/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.</p><p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p><p>The order of output does not matter.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index &#x3D; 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure></blockquote><p>使用哈希表和双指针, 可以在<code>O(n)</code>的时间复杂度内完成.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">letters</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(s.empty() || p.empty() || s.length() &lt; p.length()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : p)&#123;</span><br><span class="line">            letters[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = letters;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; p.length(); j++)&#123;</span><br><span class="line">            tmp[s[j] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= s.length())&#123;</span><br><span class="line">            <span class="keyword">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> k : tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k != <span class="number">0</span>)&#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(match) ans.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(j == s.length()) <span class="keyword">break</span>;</span><br><span class="line">            tmp[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            tmp[s[j] - <span class="string">'a'</span>]--;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 414. Third Maximum Number</title>
      <link href="/2016/10/29/leetcode-414-third-maximum-number/"/>
      <url>/2016/10/29/leetcode-414-third-maximum-number/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a <strong>non-empty</strong> array of integers, return the <strong>third</strong> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: The third maximum is 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: The third maximum does not exist, so the maximum (2) is returned instead.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: Note that the third maximum here means the third maximum distinct number.</span><br><span class="line">Both numbers with value 2 are both considered as second maximum.</span><br></pre></td></tr></table></figure></blockquote><p>只要求保存前三个最大的数(不重复), 所以可以在遍历过程中维护已经遍历过的元素中最大的三个值. 由于有可能不重复的数值不足三个, 所以还要记录已经保存的最大元素的个数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max1, max2, max3;</span><br><span class="line">        max1 = max2 = max3 = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i == max1 &amp;&amp; num &gt; <span class="number">0</span>) || </span><br><span class="line">               (i == max2 &amp;&amp; num &gt; <span class="number">1</span>) || </span><br><span class="line">               (i == max3 &amp;&amp; num &gt; <span class="number">2</span>)) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span> || i &gt; max1)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span> || i &gt; max2)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">2</span> || i &gt; max3)&#123;</span><br><span class="line">                max3 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            num = min(num + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">3</span>) <span class="keyword">return</span> max3;</span><br><span class="line">        <span class="keyword">return</span> max1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 413. Arithmetic Slices</title>
      <link href="/2016/10/29/leetcode-413-arithmetic-slices/"/>
      <url>/2016/10/29/leetcode-413-arithmetic-slices/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p><p>For example, these are arithmetic sequence:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure><p>The following sequence is not arithmetic.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure><p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p><p>A slice (P, Q) of array A is called arithmetic if the sequence:A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p><p>The function should return the number of arithmetic slices in the array A.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</span><br></pre></td></tr></table></figure></blockquote><p>这道题我首先用双指针找到所有的尽量长的连续等差数列. 对于每个数列, 假设长度为n, 那么它所包含的所有可能长度的等差数列(长度&gt;=3)有$1+2+3+\dots+(n-2)=(n-2)(n-1)/2=(n^2-3n+2)/2$个.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q &lt; A.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[p + <span class="number">1</span>] - A[p] != A[q] - A[p + <span class="number">1</span>]) &#123;</span><br><span class="line">                p++, q++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> diff = A[p + <span class="number">1</span>] - A[p];</span><br><span class="line">            <span class="keyword">while</span>(q + <span class="number">1</span> &lt; A.size() &amp;&amp; A[q + <span class="number">1</span>] - A[q] == diff) q++;</span><br><span class="line">            <span class="keyword">int</span> seqLength = q - p + <span class="number">1</span>;</span><br><span class="line">            ans += (seqLength * seqLength - <span class="number">3</span> * seqLength + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">            p = q;</span><br><span class="line">            q = p + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 412. Fizz Buzz</title>
      <link href="/2016/10/29/leetcode-412-fizz-buzz/"/>
      <url>/2016/10/29/leetcode-412-fizz-buzz/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Write a program that outputs the string representation of numbers from 1 to <em>n</em>.</p><p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 15,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>直接判断数字是不是3或5的倍数就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">3</span> &amp;&amp; i % <span class="number">5</span>)&#123;</span><br><span class="line">                s = to_string(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    s += <span class="string">"Fizz"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    s += <span class="string">"Buzz"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 172. Factorial Trailing Zeroes</title>
      <link href="/2016/10/20/leetcode-172-factorial-trailing-zeroes/"/>
      <url>/2016/10/20/leetcode-172-factorial-trailing-zeroes/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an integer <em>n</em>, return the number of trailing zeroes in <em>n</em>!.</p><p>**Note: **Your solution should be in logarithmic time complexity.</p></blockquote><p>统计结果中因子5的个数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ret += n / <span class="number">5</span>; <span class="comment">// 实际是计算比n小的最大的5的整数倍</span></span><br><span class="line">            n /= <span class="number">5</span>; <span class="comment">// 实际是计算比n小的最大的5的整数倍除以5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 171. Excel Sheet Column Number</title>
      <link href="/2016/10/20/leetcode-171-excel-sheet-column-number/"/>
      <url>/2016/10/20/leetcode-171-excel-sheet-column-number/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Related to question <a href="https://leetcode.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">Excel Sheet Column Title</a></p><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br></pre></td></tr></table></figure></blockquote><p>二十六进制的转换.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ans *= <span class="number">26</span>;</span><br><span class="line">            ans += s[i] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 169. Majority Element</title>
      <link href="/2016/10/17/leetcode-169-majority-element/"/>
      <url>/2016/10/17/leetcode-169-majority-element/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p></blockquote><p>这道题方法很多, 排序, 哈希表, 位运算等等都可以.</p><p>排序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位运算:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &amp; (<span class="number">1</span> &lt;&lt; i)) bits[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bits[i] &gt; n / <span class="number">2</span>)&#123;</span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希表:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(++m[i] &gt; n) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一种O(n)的算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                n = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n == i)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; nums.size() / <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 168. Excel Sheet Column Title</title>
      <link href="/2016/10/17/leetcode-168-excel-sheet-column-title/"/>
      <url>/2016/10/17/leetcode-168-excel-sheet-column-title/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br></pre></td></tr></table></figure></blockquote><p>按照26进制来处理, 不过由于是从1而不是0开始的, 所以要对Z单独处理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">26</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ret.push_back(<span class="string">'Z'</span>);</span><br><span class="line">                n = n / <span class="number">26</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.push_back((n % <span class="number">26</span>) + <span class="string">'A'</span> - <span class="number">1</span>);</span><br><span class="line">                n /= <span class="number">26</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ret.begin(), ret.end());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 167. Two Sum II - Input array is sorted</title>
      <link href="/2016/10/17/leetcode-167-two-sum-ii-input-array-is-sorted/"/>
      <url>/2016/10/17/leetcode-167-two-sum-ii-input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution.</p><p><strong>Input:</strong> numbers={2, 7, 11, 15}, target=9<strong>Output:</strong> index1=1, index2=2</p></blockquote><p>输入数据是有序的反而更简单了, 两个指针从两端开始向中间移动就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[l] + numbers[r] &gt; target)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[l] + numbers[r] &lt; target)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = l + <span class="number">1</span>;</span><br><span class="line">                ans[<span class="number">1</span>] = r + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 424. Longest Repeating Character Replacement</title>
      <link href="/2016/10/16/leetcode-424-longest-repeating-character-replacement/"/>
      <url>/2016/10/16/leetcode-424-longest-repeating-character-replacement/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most <em>k</em> times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p><p><strong>Note:</strong>Both the string’s length and <em>k</em> will not exceed 104.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;ABAB&quot;, k &#x3D; 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;AABABBA&quot;, k &#x3D; 1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.</span><br><span class="line">The substring &quot;BBBB&quot; has the longest repeating letters, which is 4.</span><br></pre></td></tr></table></figure></blockquote><p>这道题我采用双指针的方法. p指向最长连续重复字符的结尾, q指向开头. 首先看一个例子: 字符串<code>&quot;ABBBAAABBAAB&quot;</code>, k=2, 先查找<code>A</code>. 用r记录已经替换了多少个字母.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;0, q&#x3D;0, r&#x3D;0</span><br></pre></td></tr></table></figure><p>一开始p和q都指向开头, 第一个字符为<code>A</code>, 因此不用替换, 此时长度为1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;1, q&#x3D;0, r&#x3D;1</span><br></pre></td></tr></table></figure><p>第二个字符需要替换, r变为1, 此时长度为2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;2, q&#x3D;0, r&#x3D;2</span><br></pre></td></tr></table></figure><p>第三个字符也要替换, r变为2, 长度为3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;3, q&#x3D;2, r&#x3D;2</span><br></pre></td></tr></table></figure><p>第四个字符仍然需要替换, 但是所有的替换次数已经用完, 因此q要向前移, 直到跳过第一个不是<code>A</code>的字符.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;4, q&#x3D;2, r&#x3D;2</span><br></pre></td></tr></table></figure><p>第五个字符不需要替换, q不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;5, q&#x3D;2, r&#x3D;2</span><br><span class="line"></span><br><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;6, q&#x3D;2, r&#x3D;2</span><br><span class="line"></span><br><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;7, q&#x3D;3, r&#x3D;2</span><br></pre></td></tr></table></figure><p>p=7的时候, 又指向了<code>B</code>, 此时q也指向<code>B</code>, 因此只要q前移一格.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;8, q&#x3D;4, r&#x3D;2</span><br><span class="line"></span><br><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;9, q&#x3D;4, r&#x3D;2</span><br><span class="line"></span><br><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;10, q&#x3D;4, r&#x3D;2</span><br><span class="line"></span><br><span class="line">ABBBAAABBAAB</span><br><span class="line">p&#x3D;11, q&#x3D;8, r&#x3D;2</span><br></pre></td></tr></table></figure><p>最后一个字符不是<code>A</code>, 因此q要前移, 先跳过三个<code>A</code>, 再继续跳过一个<code>B</code>以腾出一个替换次数.</p><p>最长连续重复字符的长度为<code>max(p-q+1)</code>, 而因为输入只有26个大写字母, 因此对每一个出现的字母计算一次最长长度就可以得到总的最长长度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">letters</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            letters[c - <span class="string">'A'</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!letters[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p, q = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(p = <span class="number">0</span>; p &lt; s.length(); p++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[p] == i + <span class="string">'A'</span>)&#123;</span><br><span class="line">                    maxLen = max(maxLen, p - q + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(r &lt; k)&#123;</span><br><span class="line">                        maxLen = max(maxLen, p - q + <span class="number">1</span>);</span><br><span class="line">                        r++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">while</span>(s[q] == i + <span class="string">'A'</span>) q++;</span><br><span class="line">                        q++;</span><br><span class="line">                        maxLen = max(maxLen, p - q + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 423. Reconstruct Original Digits from English</title>
      <link href="/2016/10/16/leetcode-423-reconstruct-original-digits-from-english/"/>
      <url>/2016/10/16/leetcode-423-reconstruct-original-digits-from-english/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a <strong>non-empty</strong> string containing an out-of-order English representation of digits <code>0-9</code>, output the digits in ascending order.</p><p><strong>Note:</strong></p><ol><li>Input contains only lowercase English letters.</li><li>Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as “abc” or “zerone” are not permitted.</li><li>Input length is less than 50,000.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;owoztneoer&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;012&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;fviefuro&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;45&quot;</span><br></pre></td></tr></table></figure></blockquote><p>这道题关键在于找出所有的数字, 至于顺序问题采用排序或者先用数组保存最后再拼接都可以.</p><p>先遍历一次输入字符串, 记录每个字母的出现次数, 然后用贪心法逐个找出每个单词的出现次数, 只要组成这个单词的所有字母的剩余个数都不为0, 那么就可以组成这个单词. 但是如果采用<code>0-9</code>的顺序来依次搜索单词的话, <code>one</code>这个单词中的<code>o</code>, <code>n</code>和<code>e</code>可能都不是<code>one</code>中的, 可能是从其他单词中&quot;拿来的&quot;, 这就会导致结果错误. 所以要以特定的顺序来遍历<code>0-9</code>. 如果一个单词中有&quot;独特的&quot;字母, 也就是只在这个单词中出现的字母, 那么它就不可能从其他的单词中&quot;拿来&quot;组成这个单词的所有字母, <code>zero</code>中的<code>z</code>, <code>two</code>中的<code>w</code>, <code>four</code>中的<code>u</code>, <code>six</code>中的<code>x</code>, <code>eight</code>中的<code>g</code>都是唯一的, 因此要把它们放在前面来搜索, 在剩下的单词中继续寻找&quot;唯一的&quot;字母. 这样就可以得到一个<code>0-9</code>的序列, 比如<code>0246875319</code>, 按照这个顺序来搜索单词就可以得到正确答案.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digits = &#123;<span class="string">"zero"</span>, <span class="string">"two"</span>, <span class="string">"four"</span>, <span class="string">"six"</span>, <span class="string">"eight"</span>, <span class="string">"seven"</span>, <span class="string">"five"</span>, <span class="string">"three"</span>, <span class="string">"one"</span>, <span class="string">"nine"</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> digitStr = <span class="string">"0246875319"</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">originalDigits</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">letters</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            letters[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ansVector</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">bool</span> cont = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; digits[i].length(); j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(letters[digits[i][j] - <span class="string">'a'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                        cont = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!cont) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; digits[i].length(); j++)&#123;</span><br><span class="line">                    letters[digits[i][j] - <span class="string">'a'</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">                ansVector[digitStr[i] - <span class="string">'0'</span>].push_back(digitStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ansVector)&#123;</span><br><span class="line">            ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 166. Fraction to Recurring Decimal</title>
      <link href="/2016/10/13/leetcode-166-fraction-to-recurring-decimal/"/>
      <url>/2016/10/13/leetcode-166-fraction-to-recurring-decimal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p><p>If the fractional part is repeating, enclose the repeating part in parentheses.</p><p>For example,</p><ul><li>Given numerator = 1, denominator = 2, return “0.5”.</li><li>Given numerator = 2, denominator = 1, return “2”.</li><li>Given numerator = 2, denominator = 3, return “0.(6)”.</li></ul></blockquote><p>模拟手算除法, 难度不大但是非常繁琐.</p><p>对于循环小数使用一个hash表来保存出现过的余数的值和它所得的结果在结果字符串中的位置, 当出现重复的余数时就可以确定是循环小数.</p><p>还要注意int型的溢出问题.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">bool</span> sign = (numerator ^ denominator) &amp; <span class="number">0x80000000</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; remainders;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lldenominator = denominator;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> llnumerator = numerator;</span><br><span class="line">lldenominator = <span class="built_in">abs</span>(lldenominator);</span><br><span class="line">llnumerator = <span class="built_in">abs</span>(llnumerator);</span><br><span class="line"><span class="built_in">string</span> dStr = to_string(lldenominator), nStr = to_string(llnumerator);</span><br><span class="line"><span class="keyword">int</span> nLen = nStr.length(), dLen = dStr.length();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tmpn = nStr[<span class="number">0</span>] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">int</span> ni = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> hasDot = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> a = tmpn / lldenominator;</span><br><span class="line"><span class="keyword">if</span>(!(a == <span class="number">0</span> &amp;&amp; !hasDot)) ans.push_back(a + <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; !ans.empty()) ans.push_back(<span class="string">'0'</span>);</span><br><span class="line">tmpn = tmpn % lldenominator;</span><br><span class="line"><span class="keyword">if</span> (!tmpn &amp;&amp; ni == nLen) <span class="keyword">break</span>;</span><br><span class="line">tmpn *= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (ni == nLen &amp;&amp; !hasDot) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans.empty()) ans += <span class="string">"0."</span>;</span><br><span class="line"><span class="keyword">else</span> ans += <span class="string">"."</span>;</span><br><span class="line">hasDot = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ni &lt; nLen) &#123;</span><br><span class="line">tmpn += nStr[ni++] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!hasDot) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (remainders.count(tmpn)) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> remainders[tmpn] = ans.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmpn) &#123;</span><br><span class="line"><span class="keyword">int</span> index = remainders[tmpn];</span><br><span class="line">ans.insert(ans.begin() + index, <span class="string">'('</span>);</span><br><span class="line">ans.push_back(<span class="string">')'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sign) ans = <span class="string">"-"</span> + ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 165. Compare Version Numbers</title>
      <link href="/2016/10/13/leetcode-165-compare-version-numbers/"/>
      <url>/2016/10/13/leetcode-165-compare-version-numbers/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Compare two version numbers <em>version1</em> and <em>version2</em>.If <em>version1</em> &gt; <em>version2</em> return 1, if <em>version1</em> &lt; <em>version2</em> return -1, otherwise return 0.</p><p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.The <code>.</code> character does not represent a decimal point and is used to separate number sequences.For instance, <code>2.5</code> is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p><p>Here is an example of version numbers ordering:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</span><br></pre></td></tr></table></figure></blockquote><p>使用<code>.</code>把字符串分割为数组, 然后再依次比较大小.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = versionVector(version1), v2 = versionVector(version2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size() &amp;&amp; i &lt; v2.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[i] &gt; v2[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v1[i] &lt; v2[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v1.size() &gt; v2.size())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = v2.size(); i &lt; v1.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v1.size() &lt; v2.size())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = v1.size(); i &lt; v2.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v2[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">versionVector</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; version;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(next = s.find(<span class="string">'.'</span>, pos))&#123;</span><br><span class="line">            version.push_back(stoi(s.substr(pos, next - pos)));</span><br><span class="line">            <span class="keyword">if</span>(next == <span class="built_in">string</span>::npos) <span class="keyword">break</span>;</span><br><span class="line">            pos = next + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> version;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 164. Maximum Gap</title>
      <link href="/2016/10/12/leetcode-164-maximum-gap/"/>
      <url>/2016/10/12/leetcode-164-maximum-gap/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p><p>Try to solve it in linear time/space.</p><p>Return 0 if the array contains less than 2 elements.</p><p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p></blockquote><p>这道题就是一个排序问题, 但是要求O(n)时间复杂度, 可用的办法有桶排序(<a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">bucket sort</a>)和基数排序(<a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">radix sort</a>), 但是虽然说这两种算法有近似O(n)的复杂度, 但是它们并不一定真的比快排之类的算法快, 因为虽然快排, 堆排的时间复杂度是O(nlogn), 但即使n达到2<sup>32</sup>, logn也只有32而已, 实际中要排序的数据达到这个数量级时我觉得应该考虑外部排序了, 因为很可能数据已经无法完全装入内存了. 而桶排序和基数排序的O(n)算法系数也并不小, 所以这道题直接用快排或者STL的sort函数也是能过的.</p><p>更进一步来说, 基于比较的排序算法时间复杂度下界是O(nlogn), 而能到达O(n)复杂度的算法是非比较的排序算法(计数排序, 基数排序, 桶排序).(<a href="http://blog.csdn.net/zouliping123/article/details/8934856" target="_blank" rel="noopener">http://blog.csdn.net/zouliping123/article/details/8934856</a>)</p><p>桶排序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_item = nums[<span class="number">0</span>], min_item = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">            max_item = max(max_item, nums[i]);</span><br><span class="line">            min_item = min(min_item, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bucket_gap = ( max_item - min_item ) / length &gt;= <span class="number">1</span> ? ( max_item - min_item ) / length : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bucket_size = ( max_item - min_item ) / bucket_gap + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">bucket</span><span class="params">(bucket_size)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            bucket[(nums[i] - min_item) / bucket_gap].push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_gap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket_size; i++)&#123;</span><br><span class="line">            sort(bucket[i].begin(), bucket[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lastNoneEmptyIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!bucket[i].empty() &amp;&amp; i != <span class="number">0</span> &amp;&amp; lastNoneEmptyIndex != <span class="number">-1</span>)&#123;</span><br><span class="line">                max_gap =max(max_gap, bucket[i][<span class="number">0</span>] - bucket[lastNoneEmptyIndex].back());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!bucket[i].empty())&#123;</span><br><span class="line">                lastNoneEmptyIndex = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; bucket[i].size() &amp;&amp; max_gap &lt; bucket_gap; j++)&#123;</span><br><span class="line">                    max_gap = max(max_gap, bucket[i][j] - bucket[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_gap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基数排序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_gap = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">radix</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(length)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                radix[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : nums)&#123;</span><br><span class="line">                radix[(j / r) % <span class="number">10</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                radix[j] += radix[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = (nums[j] / r) % <span class="number">10</span>;</span><br><span class="line">                tmp[--radix[k]] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            r *= <span class="number">10</span>;</span><br><span class="line">            nums = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            max_gap = max(max_gap, nums[i + <span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_gap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 162. Find Peak Element</title>
      <link href="/2016/10/12/leetcode-162-find-peak-element/"/>
      <url>/2016/10/12/leetcode-162-find-peak-element/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p><p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p><p>**Note:**Your solution should be in logarithmic complexity.</p></blockquote><p>二分搜索，每次比较找到的nums[mid]与邻居的大小来决定向哪边搜索,注意对于边界的处理,下标不能越界.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.size(), mid, len = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid == nums.size() - <span class="number">1</span>) <span class="keyword">return</span> nums[len - <span class="number">2</span>] &gt; nums[len - <span class="number">1</span>] ? len - <span class="number">2</span> : len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid + <span class="number">1</span>] &gt; nums[mid])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 160. Intersection of Two Linked Lists</title>
      <link href="/2016/10/12/leetcode-160-intersection-of-two-linked-lists/"/>
      <url>/2016/10/12/leetcode-160-intersection-of-two-linked-lists/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>begin to intersect at node c1.</p><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul></blockquote><p>这是一道我遇到过的面试题. 解题方法就是先遍历得到两个链表的长度, 然后再跳过较长的链表的前面几个节点, 直到两个链表剩下的部分长度相等, 再同步移动指针来找到相交的节点.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode *pa = headA, *pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pb)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pa = headA, pb = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA - lenB; i++) pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(lenA &lt; lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB - lenA; i++) pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pa == pb &amp;&amp; pa != <span class="literal">nullptr</span>) <span class="keyword">return</span> pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 155. Min Stack</title>
      <link href="/2016/10/11/leetcode-155-min-stack/"/>
      <url>/2016/10/11/leetcode-155-min-stack/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure></blockquote><p>实现一个栈的同时能在常数时间内取得栈内的最小值. 使用两个栈即可, 一个栈用来保存元素, 另一个栈用来保存对应元素时栈内的最小值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(x);</span><br><span class="line">        <span class="keyword">if</span>(min.empty() || min.back() &gt; x) min.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> min.push_back(min.back());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        min.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 154. Find Minimum in Rotated Sorted Array II</title>
      <link href="/2016/10/11/leetcode-154-find-minimum-in-rotated-sorted-array-ii/"/>
      <url>/2016/10/11/leetcode-154-find-minimum-in-rotated-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p></blockquote><p>与上一题类似, 但是有重复元素, 所以要用遍历的方法跳过这些元素.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>, mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[right]) right--;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">            mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 153. Find Minimum in Rotated Sorted Array</title>
      <link href="/2016/10/11/leetcode-153-find-minimum-in-rotated-sorted-array/"/>
      <url>/2016/10/11/leetcode-153-find-minimum-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p></blockquote><p>这道题虽然使用线性遍历的方法也能过, 但是是可以使用二分搜索的.</p><p>一个经过了循环左移的有序数组相当于被分成了两部分, 我们要找的是这两部分的分界点, 判断一个点是在哪一部分是看它与两端的元素的大小关系, 如果比两端的元素大, 那么它是在左半部分; 如果比两端的元素小, 那么它是在右半部分; 如果它比左端元素小比右边元素大, 那么从左端到右端整体是有序的, 在这种情况下最左端元素就是最小值; 不可能出现比左端元素大而比右端元素小的情况.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>, mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[left] &amp;&amp; nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= nums[left] &amp;&amp; nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 152. Maximum Product Subarray</title>
      <link href="/2016/10/10/leetcode-152-maximum-product-subarray/"/>
      <url>/2016/10/10/leetcode-152-maximum-product-subarray/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array <code>[2,3,-2,4]</code>,the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p></blockquote><p>DP问题, 主要问题在于数组中可能会出现负数, 所以要在维护最大值的同时维护一个最小值, 因为如果一个元素为负, 那么最小值也有可能变为最大值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPrevP = nums[<span class="number">0</span>], minPrevP = nums[<span class="number">0</span>], maxP = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxCurP = max(maxPrevP * nums[i], max(nums[i], minPrevP * nums[i]));</span><br><span class="line">            <span class="keyword">int</span> minCurP = min(maxPrevP * nums[i], min(nums[i], minPrevP * nums[i]));</span><br><span class="line">            <span class="keyword">if</span>(maxP &lt; maxCurP) maxP = maxCurP;</span><br><span class="line">            maxPrevP = maxCurP, minPrevP = minCurP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 151. Reverse Words in a String</title>
      <link href="/2016/10/10/leetcode-151-reverse-words-in-a-string/"/>
      <url>/2016/10/10/leetcode-151-reverse-words-in-a-string/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an input string, reverse the string word by word.</p><p>For example,Given s = “<code>the sky is blue</code>”,return “<code>blue is sky the</code>”.</p><p><strong>Clarification:</strong></p><ul><li>What constitutes a word?A sequence of non-space characters constitutes a word.</li><li>Could the input string contain leading or trailing spaces?Yes. However, your reversed string should not contain leading or trailing spaces.</li><li>How about multiple spaces between two words?Reduce them to a single space in the reversed string.</li></ul></blockquote><p>翻转一个字符串中的单词, 先翻转整个字符串然后再把每一个单词都翻转一次即可. 但是要考虑输入字符串前后的空格和单词间多余空格.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        trimString(s);</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; s.size() &amp;&amp; s[j] != <span class="string">' '</span>; j++);</span><br><span class="line">            reverse(s.begin() + i, s.begin() + j);</span><br><span class="line">            <span class="keyword">if</span>(j == s.size())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(j + <span class="number">1</span> &lt; s.size() &amp;&amp; s[j + <span class="number">1</span>] == <span class="string">' '</span>) s.erase(j + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trimString</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s.front() == <span class="string">' '</span>) s.erase(s.begin());</span><br><span class="line">        <span class="keyword">while</span>(s.back() == <span class="string">' '</span>) s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 417. Pacific Atlantic Water Flow</title>
      <link href="/2016/10/10/leetcode-417-pacific-atlantic-water-flow/"/>
      <url>/2016/10/10/leetcode-417-pacific-atlantic-water-flow/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</p><p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p><p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p><p><strong>Note:</strong></p><ol><li>The order of returned grid coordinates does not matter.</li><li>Both <em>m</em> and <em>n</em> are less than 150.</li></ol><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given the following 5x5 matrix:</span><br><span class="line"></span><br><span class="line">  Pacific ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * Atlantic</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</span><br></pre></td></tr></table></figure></blockquote><p>比较直接的搜索题, 用BFS或者DFS分别找出所有与Pacific连接的位置和与Atlantic连接的位置, 然后求它们的交集.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> col, row;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        row = matrix.size(), col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; pacificVisited(row, vector&lt;int&gt;(col, 0)), atlanticVisited(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; pacific, atlantic;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)&#123;</span><br><span class="line">            BFS(matrix, <span class="number">0</span>, i, pacificVisited, pacific);</span><br><span class="line">            BFS(matrix, row - <span class="number">1</span>, i, atlanticVisited, atlantic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            BFS(matrix, i, <span class="number">0</span>, pacificVisited, pacific);</span><br><span class="line">            BFS(matrix, i, col - <span class="number">1</span>, atlanticVisited, atlantic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : pacific)&#123;</span><br><span class="line">            <span class="keyword">if</span>(atlantic.count(i))</span><br><span class="line">                ans.push_back(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i &gt;&gt; <span class="number">32</span>, i &amp; <span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;visited, <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;ocean)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x, y));</span><br><span class="line">        ocean.insert((<span class="keyword">long</span> <span class="keyword">long</span>)x &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span> <span class="keyword">long</span>)y);</span><br><span class="line">        visited[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = q.front();</span><br><span class="line">            <span class="keyword">if</span>(p.first &gt; <span class="number">0</span> &amp;&amp; !visited[p.first - <span class="number">1</span>][p.second] &amp;&amp; matrix[p.first][p.second] &lt;= matrix[p.first - <span class="number">1</span>][p.second])&#123;</span><br><span class="line">                visited[p.first - <span class="number">1</span>][p.second] = <span class="number">1</span>;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nextP = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(p.first - <span class="number">1</span>, p.second);</span><br><span class="line">                ocean.insert((<span class="keyword">long</span> <span class="keyword">long</span>)nextP.first &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span> <span class="keyword">long</span>)nextP.second);</span><br><span class="line">                q.push(nextP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.first &lt; row - <span class="number">1</span> &amp;&amp; !visited[p.first + <span class="number">1</span>][p.second] &amp;&amp; matrix[p.first][p.second] &lt;= matrix[p.first + <span class="number">1</span>][p.second])&#123;</span><br><span class="line">                visited[p.first + <span class="number">1</span>][p.second] = <span class="number">1</span>;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nextP = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(p.first + <span class="number">1</span>, p.second);</span><br><span class="line">                ocean.insert((<span class="keyword">long</span> <span class="keyword">long</span>)nextP.first &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span> <span class="keyword">long</span>)nextP.second);</span><br><span class="line">                q.push(nextP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.second &gt; <span class="number">0</span> &amp;&amp; !visited[p.first][p.second - <span class="number">1</span>] &amp;&amp; matrix[p.first][p.second] &lt;= matrix[p.first][p.second - <span class="number">1</span>])&#123;</span><br><span class="line">                visited[p.first][p.second - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nextP = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(p.first, p.second - <span class="number">1</span>);</span><br><span class="line">                ocean.insert((<span class="keyword">long</span> <span class="keyword">long</span>)nextP.first &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span> <span class="keyword">long</span>)nextP.second);</span><br><span class="line">                q.push(nextP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.second &lt; col - <span class="number">1</span> &amp;&amp; !visited[p.first][p.second + <span class="number">1</span>] &amp;&amp; matrix[p.first][p.second] &lt;= matrix[p.first][p.second + <span class="number">1</span>])&#123;</span><br><span class="line">                visited[p.first][p.second + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nextP = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(p.first, p.second + <span class="number">1</span>);</span><br><span class="line">                ocean.insert((<span class="keyword">long</span> <span class="keyword">long</span>)nextP.first &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span> <span class="keyword">long</span>)nextP.second);</span><br><span class="line">                q.push(nextP);</span><br><span class="line">            &#125;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 416. Partition Equal Subset Sum</title>
      <link href="/2016/10/09/leetcode-416-partition-equal-subset-sum/"/>
      <url>/2016/10/09/leetcode-416-partition-equal-subset-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Note:</strong>Both the array size and each of the array element will not exceed 100.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Explanation: The array cannot be partitioned into equal sum subsets.</span><br></pre></td></tr></table></figure></blockquote><p>动态规划问题, 比较容易看出如果用<code>dp[i][j]</code>表示前i+1个数字能否找出和为j的子集的话, <code>dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i]]</code>. 但是用二维数组来进行dp的话, 数组的列数是不知道的, 我一开始用hash表来存储行, 但是运行速度很慢, 后来注意到总的元素数目最多只有100个, 每个最多只有100, 而我们要找的目标是和的一半, 也就是最多5000, 完全可以把数组的列数设置为和的一半, 然后从下往上dp.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        vector&lt;int&gt; dp(sum + 1), tmpDp(sum + 1);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[nums[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            tmpDp = dp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmpDp[j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> t = j + nums[i];</span><br><span class="line">                <span class="keyword">if</span>(t == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &lt; sum) dp[t] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 415. Add Strings</title>
      <link href="/2016/10/09/leetcode-415-add-strings/"/>
      <url>/2016/10/09/leetcode-415-add-strings/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two non-negative numbers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p><p><strong>Note:</strong></p><ol><li>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li><li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li><li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li><li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li></ol></blockquote><p>简单的模拟加法.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num2.length() &gt; num1.length()) swap(num1, num2);</span><br><span class="line">        <span class="keyword">int</span> maxLen = num1.length(), minLen = num2.length(), inc = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(maxLen, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; minLen; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> a = num1[maxLen - i - <span class="number">1</span>] - <span class="string">'0'</span>, b = num2[minLen - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">char</span> r = a + b + inc;</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                inc = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                inc = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[maxLen - i - <span class="number">1</span>] = r % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; maxLen)&#123;</span><br><span class="line">            <span class="keyword">for</span>(; i &lt; maxLen; i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> r = num1[maxLen - i - <span class="number">1</span>] - <span class="string">'0'</span> + inc;</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                    inc = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    inc = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[maxLen - i - <span class="number">1</span>] = r % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inc)&#123;</span><br><span class="line">            ans.insert(ans.begin(), <span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 150. Evaluate Reverse Polish Notation</title>
      <link href="/2016/10/08/leetcode-150-evaluate-reverse-polish-notation/"/>
      <url>/2016/10/08/leetcode-150-evaluate-reverse-polish-notation/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="noopener">Reverse Polish Notation</a>.</p><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p><p>Some examples:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9</span><br><span class="line">[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;] -&gt; (4 + (13 &#x2F; 5)) -&gt; 6</span><br></pre></td></tr></table></figure></blockquote><p><em>逆波兰表达式</em>的意思就是运算符后缀, 这种方式就是为栈设计的. 当读入数字的时候就将其入栈, 读入运算符的时候就将栈顶的两个元素取出运算后再压入栈.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> s = tokens[i];</span><br><span class="line">            <span class="keyword">if</span>(s.size() == <span class="number">1</span> &amp;&amp; (s == <span class="string">"+"</span> || s == <span class="string">"-"</span> || s == <span class="string">"*"</span> || s == <span class="string">"/"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> a = nums.back();</span><br><span class="line">                nums.pop_back();</span><br><span class="line">                <span class="keyword">int</span> b = nums.back();</span><br><span class="line">                nums.pop_back();</span><br><span class="line">                <span class="keyword">int</span> re;</span><br><span class="line">                <span class="keyword">switch</span>(s[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                        re = a + b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                        re = b - a;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                        re = b * a;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                        re = b / a;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nums.push_back(re);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums.push_back(stoi(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 149. Max Points on a Line</title>
      <link href="/2016/10/08/leetcode-149-max-points-on-a-line/"/>
      <url>/2016/10/08/leetcode-149-max-points-on-a-line/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given <em>n</em> points on a 2D plane, find the maximum number of points that lie on the same straight line.</p></blockquote><p>寻找一个平面上最多有多少个点共线. 首先应该复杂度应该是O(n<sup>2</sup>)的, 因为要判断每一个点与其他点的关系(或者说判断是否在之前的点所连成的线上). 对每一个点, 计算与其他点的连线的斜率, 找出出现次数最多的斜率, 它的出现次数就是共线的点的个数(但是这里没有包括改点自己, 再加上重复点的问题, 所以最后要加上该点自己的出现次数). 使用一个hash表来保存斜率的出现次数即可.</p><p>还要注意对于连线斜率为无穷大的点来说(横坐标相同), 要单独处理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * struct Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> points.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; slope;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">1</span>, mmax = <span class="number">0</span>, infiniteSlope = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(points[i].x == points[j].x)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(points[i].y == points[j].y)&#123;</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        mmax = max(mmax, ++infiniteSlope);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">double</span> k = (<span class="keyword">double</span>)(points[i].y - points[j].y) / (points[i].x - points[j].x);</span><br><span class="line">                    mmax = max(mmax, ++slope[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxNum = max(maxNum, mmax + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 148. Sort List</title>
      <link href="/2016/10/07/leetcode-148-sort-list/"/>
      <url>/2016/10/07/leetcode-148-sort-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p></blockquote><p>不使用额外空间对单向链表进行排序, 要求时间复杂度为O(nlogn). 可以使用归并排序, 使用快慢指针把链表分为两部分, 分别进行递归地归并排序后再合并为一个链表.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &gt; head-&gt;next-&gt;val)&#123;</span><br><span class="line">                head-&gt;next-&gt;next = head;</span><br><span class="line">                ListNode *t = head-&gt;next;</span><br><span class="line">                head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *right = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        head = sortList(head);</span><br><span class="line">        right = sortList(right);</span><br><span class="line">        <span class="keyword">return</span> merge(head, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *left, ListNode *right)</span></span>&#123;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), *p1 = left, *p2 = right, *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; !p1)&#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &amp;&amp; !p2)&#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;S</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 147. Insertion Sort List</title>
      <link href="/2016/10/07/leetcode-147-insertion-sort-list/"/>
      <url>/2016/10/07/leetcode-147-insertion-sort-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Sort a linked list using insertion sort.</p></blockquote><p>使用插入排序对一个链表进行排序. 对于原来链表中的每一个节点搜索在新链表中应该插入的位置.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insertion(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">insertion</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *h = <span class="keyword">new</span> ListNode(head-&gt;val), *p = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            ListNode *tp = h, *prev = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">while</span>(tp &amp;&amp; tp-&gt;val &lt; p-&gt;val) &#123;</span><br><span class="line">                prev = tp;</span><br><span class="line">                tp = tp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prev)&#123;</span><br><span class="line">                ListNode *newNode = <span class="keyword">new</span> ListNode(p-&gt;val);</span><br><span class="line">                newNode-&gt;next = prev-&gt;next;</span><br><span class="line">                prev-&gt;next = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode *newHead = <span class="keyword">new</span> ListNode(p-&gt;val);</span><br><span class="line">                newHead-&gt;next = h;</span><br><span class="line">                h = newHead;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 146. LRU Cache</title>
      <link href="/2016/10/06/leetcode-146-lru-cache/"/>
      <url>/2016/10/06/leetcode-146-lru-cache/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p></blockquote><p>实现一个LRU数据结构, 就是说在元素容量到达上限时要删除最长时间没有访问的元素. 要注意<code>set</code>和<code>get</code>都属于访问了元素.</p><p>主要问题在于如何保存所有访问元素的顺序并且能够高效地进行查找和删除. 我一开始想的方法是使用两个map, 分别保存<code>上一次使用时间=&gt;key</code>和<code>key=&gt;上一次使用时间</code>两个映射. 其中第一个map需要有序而第二个不需要, 所以第二个可以采用unordered_map. 第一个map用于保存每一个key的上一次访问时间并且按照访问时间从远到近排序. 但是这个办法虽然可以AC但是效率不高, 而且并不实用. 因为访问时间的表示范围毕竟是有限的, 实际中的访问次数是完全有可能超过它的取值范围的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; lastTimeAndKey;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; keyAndLastTime;</span><br><span class="line">    <span class="keyword">int</span> capacity, useTime;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        useTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.count(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastUseTime = keyAndLastTime[key];</span><br><span class="line">            keyAndLastTime[key] = useTime;</span><br><span class="line">            lastTimeAndKey.erase(lastUseTime);</span><br><span class="line">            lastTimeAndKey[useTime] = key;</span><br><span class="line">            useTime++;</span><br><span class="line">            <span class="keyword">return</span> data[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.count(key))&#123;</span><br><span class="line">            <span class="keyword">int</span> lastUseTime = keyAndLastTime[key];</span><br><span class="line">            keyAndLastTime[key] = useTime;</span><br><span class="line">            lastTimeAndKey.erase(lastUseTime);</span><br><span class="line">            lastTimeAndKey[useTime] = key;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.size() &lt; capacity)&#123;</span><br><span class="line">            lastTimeAndKey[useTime] = key;</span><br><span class="line">            keyAndLastTime[key] = useTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> eraseKey = lastTimeAndKey.begin()-&gt;second;</span><br><span class="line">            keyAndLastTime.erase(eraseKey);</span><br><span class="line">            lastTimeAndKey.erase(lastTimeAndKey.begin());</span><br><span class="line">            data.erase(eraseKey);</span><br><span class="line">            lastTimeAndKey[useTime] = key;</span><br><span class="line">            keyAndLastTime[key] = useTime;</span><br><span class="line">        &#125;</span><br><span class="line">        useTime++;</span><br><span class="line">        data[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以后来我采用一个双向链表作为队列, 然后使用一个unordered_map来维护<code>key=&gt;链表节点指针(迭代器)</code>的映射, 而链表中保存相应的key值. 当要更新队列时, 就通过key来找到节点, 删除节点并在最后增加节点, 更新key对应的迭代器. 当要删除队列中的第一个元素时, 可以通过头结点保存的key值同时删除data中的数据和<code>key=&gt;链表节点指针(迭代器)</code>中的数据. 这样的话每次<code>set</code>和<code>get</code>的处理时间都是常数的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; keyToPointer;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.count(key)) &#123;</span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = keyToPointer[key];</span><br><span class="line">            q.erase(iter);</span><br><span class="line">            q.push_back(key);</span><br><span class="line">            keyToPointer[key] = --q.end();</span><br><span class="line">            <span class="keyword">return</span> data[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.count(key))&#123;</span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = keyToPointer[key];</span><br><span class="line">            q.erase(iter);</span><br><span class="line">            q.push_back(key);</span><br><span class="line">            keyToPointer[key] = --q.end();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.size() &lt; capacity)&#123;</span><br><span class="line">            q.push_back(key);</span><br><span class="line">            keyToPointer[key] = --q.end();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> keyToErase = q.front();</span><br><span class="line">            data.erase(keyToErase);</span><br><span class="line">            keyToPointer.erase(keyToErase);</span><br><span class="line">            q.pop_front();</span><br><span class="line">            q.push_back(key);</span><br><span class="line">            keyToPointer[key] = --q.end();</span><br><span class="line">        &#125;</span><br><span class="line">        data[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 145. Binary Tree Postorder Traversal</title>
      <link href="/2016/10/06/leetcode-145-binary-tree-postorder-traversal/"/>
      <url>/2016/10/06/leetcode-145-binary-tree-postorder-traversal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p><p>For example:Given binary tree <code>{1,#,2,3}</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return <code>[3,2,1]</code>.</p><p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p></blockquote><p>非递归后序遍历.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span> = &#123;root&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            TreeNode* n = <span class="built_in">stack</span>.back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            ans.push_back(n-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;left) <span class="built_in">stack</span>.push_back(n-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;right) <span class="built_in">stack</span>.push_back(n-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 410. Split Array Largest Sum</title>
      <link href="/2016/10/05/leetcode-410-split-array-largest-sum/"/>
      <url>/2016/10/05/leetcode-410-split-array-largest-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array which consists of non-negative integers and an integer <em>m</em>, you can split the array into <em>m</em> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <em>m</em> subarrays.</p><p><strong>Note:</strong>Given <em>m</em> satisfies the following constraint: 1 ≤ m ≤ length(nums) ≤ 14,000.</p><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">There are four ways to split nums into two subarrays.</span><br><span class="line">The best way is to split it into [7,2,5] and [10,8],</span><br><span class="line">where the largest sum among the two subarrays is only 18.</span><br></pre></td></tr></table></figure></blockquote><p>这道题我是采用二分搜索的方法解的. 虽然要想到对整个int型范围进行二分搜索还是不太容易, 但是只要想到这一点, 问题就基本解决了, 剩下的就可以通过贪心来判断数组能不能被分成m个并且保证最大的和不超过一个给定的值. 二分搜索上界是INT_MAX, 而下界是数组中的最大值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxElement = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            maxElement = max(maxElement, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = maxElement, right = INT_MAX, mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(canSplit(nums, mid, m))&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canSplit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">long</span> <span class="keyword">long</span> target, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> splitArrs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() &amp;&amp; splitArrs &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + nums[i] &gt; target)&#123;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">                splitArrs++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum + nums[i] == target)&#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                splitArrs++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) splitArrs++;</span><br><span class="line">        <span class="keyword">return</span> splitArrs &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 144. Binary Tree Preorder Traversal</title>
      <link href="/2016/10/05/leetcode-144-binary-tree-preorder-traversal/"/>
      <url>/2016/10/05/leetcode-144-binary-tree-preorder-traversal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p>For example:Given binary tree <code>{1,#,2,3}</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return <code>[1,2,3]</code>.</p><p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p></blockquote><p>二叉树非递归前序遍历. 需要背下来的代码了…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; path;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node || !path.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                ret.push_back(node-&gt;val);</span><br><span class="line">                path.push_back(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                node = path.back();</span><br><span class="line">                path.pop_back();</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 143. Reorder List</title>
      <link href="/2016/10/05/leetcode-143-reorder-list/"/>
      <url>/2016/10/05/leetcode-143-reorder-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>Ln</em>-1→<em>L</em>n,reorder it to: <em>L</em>0→<em>Ln</em>→<em>L</em>1→<em>Ln</em>-1→<em>L</em>2→<em>Ln</em>-2→…</p><p>You must do this in-place without altering the nodes’ values.</p><p>For example,Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p></blockquote><p>这道题如果不用辅助空间的话分成三步: 1. 分割链表; 2. 颠倒第二个链表; 3. 合并链表. 其中分割链表通过快慢指针来找到链表的中间节点.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *low = head, *preLow = <span class="literal">nullptr</span>;;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            preLow = low;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        preLow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *h1 = head, *h2 = low;</span><br><span class="line">        h2 = reverseList(h2);</span><br><span class="line">        <span class="keyword">while</span>(h1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!h1-&gt;next)&#123;</span><br><span class="line">                h1-&gt;next = h2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode *h2next = h2-&gt;next;</span><br><span class="line">                h2-&gt;next = h1-&gt;next;</span><br><span class="line">                h1-&gt;next = h2;</span><br><span class="line">                h1 = h1-&gt;next-&gt;next;</span><br><span class="line">                h2 = h2next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *p1 = <span class="literal">nullptr</span>, *p2;</span><br><span class="line">        p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2)&#123;</span><br><span class="line">            ListNode *next = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 409. Longest Palindrome</title>
      <link href="/2016/10/04/leetcode-409-longest-palindrome/"/>
      <url>/2016/10/04/leetcode-409-longest-palindrome/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p><p>This is case sensitive, for example <code>&quot;Aa&quot;</code> is not considered a palindrome here.</p><p><strong>Note:</strong>Assume the length of given string will not exceed 1,010.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure></blockquote><p>给出一个字符数组, 问从中取出字符拼成的回文串最长是多少. 这道题比较简单, 回文串中的字符都是成对出现的, 因此如果一个字母的数量超过了2, 那么它就一定可以放在回文串中, 数量则是必须是偶数奇数的话则减1. 最后看是否还有剩下的字母, 如果有就可以选一个放在中间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">letters</span><span class="params">(<span class="number">52</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="string">'a'</span> &amp;&amp; i &lt;= <span class="string">'z'</span>)&#123;</span><br><span class="line">                letters[i - <span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                letters[i - <span class="string">'A'</span> + <span class="number">26</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : letters)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans += i % <span class="number">2</span> ? i - <span class="number">1</span> : i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; s.length()) ans++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写了个舰C肝度计算器</title>
      <link href="/2016/10/03/%E5%86%99%E4%BA%86%E4%B8%AA%E8%88%B0c%E8%82%9D%E5%BA%A6%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2016/10/03/%E5%86%99%E4%BA%86%E4%B8%AA%E8%88%B0c%E8%82%9D%E5%BA%A6%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>今天突然想看看自己算不算肝, 但是却没怎么找到在线的计算器, 于是就扒拉了几个公式写了个在线计算器. 纯属娱乐.</p><p><a href="https://blog.xiadong.info/KanColleHairDensity/KanColleHairDensity.html">https://blog.xiadong.info/KanColleHairDensity/KanColleHairDensity.html</a></p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> ACG </tag>
            
            <tag> 舰C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 142. Linked List Cycle II</title>
      <link href="/2016/10/02/leetcode-142-linked-list-cycle-ii/"/>
      <url>/2016/10/02/leetcode-142-linked-list-cycle-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:Can you solve it without using extra space?</p></blockquote><p>同样是使用双指针, 不过要比上一题更进一步. 假设链表有环, 环的长度为m, 去掉环的长度为n(这些节点都一定在环之前),  相遇时快慢指针走过的长度为k和2k. 那么慢指针在环上走过的距离为<code>k-n</code>, 快指针为<code>2k-n</code>, 因为它们指向同一个节点, 所以它们的差<code>k</code>一定是m的整数倍. 因此慢指针只要再走n个节点就会回到进入环的那个节点(<code>k-n+n=k</code>).</p><p>虽然我们并不知道m和n的值, 但n是环之前的节点数量, 只要再让一个指针从头结点开始与慢指针同步向前, 当他们相遇时就正好走过了n个节点, 而他们指向的节点就是进入环的节点.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *p1 = head-&gt;next, *p2 = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p2-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == p2)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p1 == head) <span class="keyword">return</span> p1;</span><br><span class="line">                    p1 = p1-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 141. Linked List Cycle</title>
      <link href="/2016/10/02/leetcode-141-linked-list-cycle/"/>
      <url>/2016/10/02/leetcode-141-linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:Can you solve it without using extra space?</p></blockquote><p>经典题, 使用快慢指针.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *p1 = head, *p2 = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == p2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!p2-&gt;next)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p2 = p2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 140. Word Break II</title>
      <link href="/2016/10/02/leetcode-140-word-break-ii/"/>
      <url>/2016/10/02/leetcode-140-word-break-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string <em>s</em> and a dictionary of words <em>dict</em>, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word.</p><p>Return all such possible sentences.</p><p>For example, given<em>s</em> = <code>&quot;catsanddog&quot;</code>,<em>dict</em> = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code>.</p><p>A solution is <code>[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]</code>.</p></blockquote><p>这道题是上一题的升级版. 这道题的主要问题在于在特定情况下解空间很大, 呈指数增长但是最后却无法到达字符串结尾, 这种情况下会超时. 所以可以先用类似上一道题的办法来先确定以第i-1个字符为结尾的子串是否能被分割, 保存在dp[i]中. 这一步之后就可以知道有没有解. 然后再通过从后向前DFS的方法搜索每一个解. 之所以不采用从前向后是因为从前向后搜索的话有可能在最后一步无法正好到达结尾, 而从后往前可以保证这一点.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> sLen, maxWordLen;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        sLen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : wordDict)&#123;</span><br><span class="line">            maxWordLen = max(maxWordLen, (<span class="keyword">int</span>)i.length());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(sLen + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; i - j &lt;= maxWordLen; j--)&#123;</span><br><span class="line">                <span class="built_in">string</span> str = s.substr(j, i - j);</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.count(str))&#123;</span><br><span class="line">                    dp[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!dp[sLen]) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        DFS(dp, path, sLen, s, wordDict);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="keyword">int</span> index, <span class="built_in">string</span> &amp;s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line">            <span class="keyword">int</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i = path.rbegin(); i != path.rend(); i++)&#123;</span><br><span class="line">                str += s.substr(lastIndex, (*i) - lastIndex);</span><br><span class="line">                str += <span class="string">" "</span>;</span><br><span class="line">                lastIndex = *i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!str.empty())str.pop_back();</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(index);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = index - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; index - j &lt;= maxWordLen; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.count(s.substr(j, index - j)))&#123;</span><br><span class="line">                DFS(dp, path, j, s, wordDict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 139. Word Break</title>
      <link href="/2016/09/29/leetcode-139-word-break/"/>
      <url>/2016/09/29/leetcode-139-word-break/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string <em>s</em> and a dictionary of words <em>dict</em>, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p><p>For example, given<em>s</em> = <code>&quot;leetcode&quot;</code>,<em>dict</em> = <code>[&quot;leet&quot;, &quot;code&quot;]</code>.</p><p>Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.</p></blockquote><p>使用DP, 从前到后遍历字符串, 记录下可以分割的坐标(也就是从开头到该坐标的子串是可以被分割的). 对于每增加一个字母, 判断每个被记录的坐标到该字母所组成的子串是否在dict中, 如果在, 那么这个坐标也是可以分割的. 最后判断所记录的坐标的最后一个是不是字符串的结尾.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trueIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j = trueIndex.rbegin(); j != trueIndex.rend(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(wordDict.count(s.substr(*j + <span class="number">1</span>, i - *j)))&#123;</span><br><span class="line">                    trueIndex.push_back(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((trueIndex.empty() || trueIndex.back() != i) &amp;&amp; wordDict.count(s.substr(<span class="number">0</span>, i + <span class="number">1</span>))) trueIndex.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !trueIndex.empty() &amp;&amp; trueIndex.back() == (s.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 138. Copy List with Random Pointer</title>
      <link href="/2016/09/29/leetcode-138-copy-list-with-random-pointer/"/>
      <url>/2016/09/29/leetcode-138-copy-list-with-random-pointer/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p></blockquote><p>这是一个单纯的哈希表问题, 不知道为什么归类为hard. 首先遍历一次链表进行拷贝, 同时建立原链表节点到新链表节点的映射关系, 再遍历一次新链表更新random的值即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;RandomListNode*, RandomListNode*&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode *p = head, *newHead = <span class="keyword">new</span> RandomListNode(head-&gt;label), *np = newHead;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">                np-&gt;next = <span class="keyword">new</span> RandomListNode(p-&gt;next-&gt;label);</span><br><span class="line">            np-&gt;random = p-&gt;random;</span><br><span class="line">            m[p] = np;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            np = np-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = newHead;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;random)&#123;</span><br><span class="line">                p-&gt;random = m[p-&gt;random];</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 137. Single Number II</title>
      <link href="/2016/09/29/leetcode-137-single-number-ii/"/>
      <url>/2016/09/29/leetcode-137-single-number-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array of integers, every element appears <em>three</em> times except for one. Find that single one.</p><p><strong>Note:</strong>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p></blockquote><p>最简单的方法是使用哈希表. 但是要不使用额外空间就要用位运算的方法, 思路是除了要找的元素外, 每个数字都重复了三次, 所以32-bit整数中的每一位出现1的总次数是3的倍数, 找出出现次数不是3的倍数的位, 就是要找的数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> useBit(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">useMap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用哈希表的方法</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(++m[nums[i]] == <span class="number">3</span>) m.erase(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.begin()-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">useBit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用位运算的方法</span></span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &amp; b) n++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">3</span>) re |= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 407. Trapping Rain Water II</title>
      <link href="/2016/09/28/leetcode-407-trapping-rain-water-ii/"/>
      <url>/2016/09/28/leetcode-407-trapping-rain-water-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.</p><p><strong>Note:</strong>Both <em>m</em> and <em>n</em> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the following 3x6 height map:</span><br><span class="line">[</span><br><span class="line">  [1,4,3,1,3,2],</span><br><span class="line">  [3,2,1,3,2,4],</span><br><span class="line">  [2,3,3,2,3,1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return 4.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/static/images/problemset/rainwater_empty.png" alt="img">The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.</p><p><img src="https://leetcode.com/static/images/problemset/rainwater_fill.png" alt="img">After the rain, water are trapped between the blocks. The total volume of water trapped is 4.</p></blockquote><p>这道题对于时间复杂度要求比较高, 轻易就会超时. 我的解法Runtime也不是很短, 有100多ms, 所以权当参考吧.</p><p>首先简单的对三维空间进行BFS是绝对超时, 因为最多有110*110*20000个坐标. 我一开始是使用分层进行BFS的办法, 确定每一层中不能装水的位置有多少. 之所以是搜索哪些不能装水而不是哪些能装水是因为搜索与边缘连通的位置只要从四条边开始搜索, 而搜索不与边缘连通的位置要从每个非边缘位置搜索, 数量要多得多.</p><p>有两种坐标是不能装水的:</p><ol><li>与边缘连通的</li><li>该位置的高度比层数高的</li></ol><p>拿总的面积减去不能装水的面积就是有水的面积, 把每一层的面积加起来就是最终的装水的体积. 但是这个办法是超时了, 我总结的超时原因是对每一层都从边缘开始BFS, 实际上并不需要每次都从最初始的情况开始BFS, 而可以在上一层的基础上进行BFS.</p><p>当层数为level的时候, 我们要检查的是<code>height==level-1</code>的坐标, 因为<code>height&gt;=level</code>的坐标不能装水, 而<code>height&lt;level-1</code>的坐标在之前的level已经计算过了, 那么对于所有的<code>height==level-1</code>的坐标有两种情况: 能存水和不能存水. 而区分条件是是否与边缘连通, 在知道上一层每个坐标与边缘连通情况(一个二维数组)的时候, 只要判断四周的坐标是否与边缘连通即可(因为已经不能存水的位置随着高度增加永远不能存水), 如果出现了一个<code>height==level-1</code>的坐标与边缘连通的情况, 那么就从这个点开始BFS, 能到达的坐标都是不能存水的.</p><p>在这种方法中, 二维平面上的每个点只有一次被BFS遍历到的机会, 大大降低了时间复杂度.</p><p>关于二维坐标表示: 二维坐标可以用pair来表示, 但是处理一个对象总没有用int来的快, 这道题由于长宽最大只有110, 所以完全可以把x,y坐标保存在一个int型中, 前16位保存x, 后16位保存y. <code>int xy=x&lt;&lt;16|y</code>, <code>int x = xy&gt;&gt;16, y=xy&amp;0xff</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m, n, area;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        m = heightMap.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = heightMap[<span class="number">0</span>].size();</span><br><span class="line">        area = n * m; <span class="comment">// 每一层的总面积</span></span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq; <span class="comment">// 保存所有的高度</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; hm; <span class="comment">// 保存每一个高度对应的所有坐标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                pq.push(heightMap[i][j]);</span><br><span class="line">                hm[heightMap[i][j]].push_back(xy2int(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以下处理最底层, 生成初始的visited数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> edgeArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[<span class="number">0</span>][i]) edgeArea += BFS(heightMap, <span class="number">0</span>, i, pq.top() + <span class="number">1</span>, visited);</span><br><span class="line">            <span class="keyword">if</span>(!visited[m - <span class="number">1</span>][i]) edgeArea += BFS(heightMap, m - <span class="number">1</span>, i, pq.top() + <span class="number">1</span>, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][<span class="number">0</span>]) edgeArea += BFS(heightMap, i, <span class="number">0</span>, pq.top() + <span class="number">1</span>, visited);</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][n - <span class="number">1</span>]) edgeArea += BFS(heightMap, i, n - <span class="number">1</span>, pq.top() + <span class="number">1</span>, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以下先得到下一层的高度, 然后用高度差乘本层的装水面积得到两层之间总得装水体积</span></span><br><span class="line">        <span class="comment">// 下面的循环中对每一层都做这样的处理</span></span><br><span class="line">        <span class="keyword">int</span> t = pq.top();</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty() &amp;&amp; pq.top() == t) pq.pop(); </span><br><span class="line">        <span class="keyword">if</span>(!pq.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> higherArea = pq.size();</span><br><span class="line">            <span class="comment">// higherArea表示的是高度比当前层高的格子数</span></span><br><span class="line">            <span class="comment">// edgeArea是与边缘连通的格子数</span></span><br><span class="line">            <span class="comment">// pq.top() - t得到高度差</span></span><br><span class="line">            ans += (area - higherArea - edgeArea) * (pq.top() - t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理上层</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> level = pq.top() + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;h = hm[level - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : h)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i &gt;&gt; <span class="number">16</span>, y = i &amp; <span class="number">0xff</span>;</span><br><span class="line">                <span class="keyword">if</span>(!visited[x][y] &amp;&amp; (besideEdge(x, y, visited) || onEdge(x, y)))&#123;</span><br><span class="line">                    <span class="comment">// 没有被标记与边缘连通但是四周有与边缘连通的坐标或者自己就在边上</span></span><br><span class="line">                    edgeArea += BFS(heightMap, x, y, level, visited);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!pq.empty() &amp;&amp; pq.top() == level - <span class="number">1</span>) pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(pq.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> higherArea = pq.size();</span><br><span class="line">            ans += (area - higherArea - edgeArea) * (pq.top() - level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">xy2int</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;&lt; <span class="number">16</span> | y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">besideEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断四周是否被标记为与边缘连通</span></span><br><span class="line">        <span class="keyword">return</span> ((x &gt; <span class="number">0</span> &amp;&amp; visited[x - <span class="number">1</span>][y]) || </span><br><span class="line">           (x &lt; m - <span class="number">1</span> &amp;&amp; visited[x + <span class="number">1</span>][y]) || </span><br><span class="line">           (y &gt; <span class="number">0</span> &amp;&amp; visited[x][y - <span class="number">1</span>]) ||</span><br><span class="line">           (y &lt; n - <span class="number">1</span> &amp;&amp; visited[x][y + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heightMap, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(heightMap[i][j] &gt;= k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(xy2int(i, j));</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curi = q.front() &gt;&gt; <span class="number">16</span>, curj = q.front() &amp; <span class="number">0xff</span>;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span>(curi &gt; <span class="number">0</span> &amp;&amp; !visited[curi - <span class="number">1</span>][curj] &amp;&amp; heightMap[curi - <span class="number">1</span>][curj] &lt; k)&#123;</span><br><span class="line">                q.push(xy2int(curi - <span class="number">1</span>, curj));</span><br><span class="line">                visited[curi - <span class="number">1</span>][curj] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curi &lt; m - <span class="number">1</span> &amp;&amp; !visited[curi + <span class="number">1</span>][curj] &amp;&amp; heightMap[curi + <span class="number">1</span>][curj] &lt; k)&#123;</span><br><span class="line">                q.push(xy2int(curi + <span class="number">1</span>, curj));</span><br><span class="line">                visited[curi + <span class="number">1</span>][curj] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curj &gt; <span class="number">0</span> &amp;&amp; !visited[curi][curj - <span class="number">1</span>] &amp;&amp; heightMap[curi][curj - <span class="number">1</span>] &lt; k)&#123;</span><br><span class="line">                q.push(xy2int(curi, curj - <span class="number">1</span>));</span><br><span class="line">                visited[curi][curj - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curj &lt; n - <span class="number">1</span> &amp;&amp; !visited[curi][curj + <span class="number">1</span>] &amp;&amp; heightMap[curi][curj + <span class="number">1</span>] &lt; k)&#123;</span><br><span class="line">                q.push(xy2int(curi, curj + <span class="number">1</span>));</span><br><span class="line">                visited[curi][curj + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">onEdge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 136. Single Number</title>
      <link href="/2016/09/28/leetcode-136-single-number/"/>
      <url>/2016/09/28/leetcode-136-single-number/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p></blockquote><p>使用异或.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            ans ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 135. Candy</title>
      <link href="/2016/09/28/leetcode-135-candy/"/>
      <url>/2016/09/28/leetcode-135-candy/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p><p>You are giving candies to these children subjected to the following requirements:</p><ul><li>Each child must have at least one candy.</li><li>Children with a higher rating get more candies than their neighbors.</li></ul><p>What is the minimum candies you must give?</p></blockquote><p>分糖果的问题, 有两条规则:</p><ul><li>每个孩子必须至少有一个糖果.</li><li>如果rating比相邻的孩子高, 那么也必须有更多的糖果. 也就是说<strong>相等的rating是没有要求的, 跟小于一样</strong>.</li></ul><p>我所采用的思路是一种类似双指针的方法:</p><ol><li>扫描一遍ratings, 找到所有<strong>小于等于相邻元素的元素</strong>的rating, 这些rating是可以直接设为1的.</li><li>在上一步的到的数组中每两个相邻的rating中间找到rating的最大值</li><li>比较这个最大值与相邻的两个最小rating的距离, 使用等差数列来算出所需要的总rating值.</li></ol><p>对于最后一步为什么可以使用等差数列, 因为对于两个candy值为1的孩子中间的孩子, 按照索引顺序的话他们各自的candy值是先增后减的趋势, 为了保证总得candy最小每次增加或减少1是唯一方法, 是两个等差数列. 但是由于最大rating的孩子与两边candy为1的孩子的距离不同, 这两个数列也不同. 比如对于以下的ratings</p><p><code>[6,8,9,10,2,1]</code></p><p>对应的最小candy值应为:</p><p><code>[1,2,3,4,2,1]</code></p><p>左边数列是一个从左边的candy为1的孩子到rating最大的孩子共4个, 而右边则是到2就结束了. 把输入数据颠倒一下:</p><p><code>[1,2,10,9,8,6]</code></p><p>对应的结果应为:</p><p><code>[1,2,4,3,2,1]</code></p><p>数列的形式也颠倒了, 所以要根据rating最大的孩子到左右两边的距离来分别求和.</p><p>还有一些其他问题:</p><ol><li>关于最左边与最右边的值, 因为他们只有一边有邻居, 所以不能像中间的节点一样计算. 我的方法是在前后各插入一个INT_MIN, 这样就可以把两端节点当作中间节点来处理了. 最后再从结果中减去.</li><li>rating的最大值有多个. 这种情况只有一种可能, 就是两个连续的最大rating值(从我的方法来说, 其他情况都是不可能的), 由于相等的两个值没有大小要求, 因此也应该分别计算.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; oneIndex;</span><br><span class="line">        oneIndex.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ratings[<span class="number">0</span>] &lt;= ratings[<span class="number">1</span>]) oneIndex.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &lt;= ratings[i - <span class="number">1</span>] &amp;&amp; ratings[i] &lt;= ratings[i + <span class="number">1</span>]) </span><br><span class="line">                oneIndex.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ratings[n - <span class="number">1</span>] &lt;= ratings[n - <span class="number">2</span>]) oneIndex.push_back(n - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        oneIndex.push_back(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = oneIndex.size() - <span class="number">2</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; oneIndex.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; oneIndex.size() - <span class="number">1</span> &amp;&amp; oneIndex[i + <span class="number">1</span>] == oneIndex[i] + <span class="number">1</span>) i++; <span class="comment">// 跳过连续的相等值</span></span><br><span class="line">            <span class="keyword">if</span>(i == oneIndex.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> left = oneIndex[i], right = oneIndex[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> maxRating = INT_MIN, maxIndex;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = left + <span class="number">1</span>; j &lt; right; j++)&#123; <span class="comment">// 找出最大rating值</span></span><br><span class="line">                <span class="keyword">if</span>(ratings[j] &gt;= maxRating)&#123;</span><br><span class="line">                    maxRating = ratings[j];</span><br><span class="line">                    maxIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((ratings[maxIndex - <span class="number">1</span>] == ratings[maxIndex] &amp;&amp; maxIndex - <span class="number">1</span> != left))&#123;</span><br><span class="line">                <span class="comment">// 有两个最大rating值</span></span><br><span class="line">                ans += (<span class="number">2</span> + maxIndex - left) * (maxIndex - left - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                ans += (right - maxIndex) * (<span class="number">3</span> + right - maxIndex) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right - maxIndex &lt; maxIndex - left)&#123;</span><br><span class="line">                <span class="comment">// 距左边较远</span></span><br><span class="line">                ans += (<span class="number">3</span> + maxIndex - left) * (maxIndex - left) / <span class="number">2</span>;</span><br><span class="line">                ans += (right - maxIndex - <span class="number">1</span>) * (<span class="number">2</span> + right - maxIndex) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 距右边较远</span></span><br><span class="line">                ans += (<span class="number">2</span> + maxIndex - left) * (maxIndex - left - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                ans += (right - maxIndex) * (<span class="number">3</span> + right - maxIndex) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 406. Queue Reconstruction by Height</title>
      <link href="/2016/09/26/leetcode-406-queue-reconstruction-by-height/"/>
      <url>/2016/09/26/leetcode-406-queue-reconstruction-by-height/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers <code>(h, k)</code>, where <code>h</code> is the height of the person and <code>k</code> is the number of people in front of this person who have a height greater than or equal to <code>h</code>. Write an algorithm to reconstruct the queue.</p><p><strong>Note:</strong>The number of people is less than 1,100.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure></blockquote><p>输入数据中的k表示这个人之前有几个大于等于自己的h的人. 比较容易想到对于h最小的人来说, 他的k值就是他在最终队列中的位置, 因为排在他前面的所有人都是大于等于他的h的. 如果去掉h最小的人, 此时h次小的人就成为了最小的, 他在队列中的位置就是从开头数起, 跳过已经确定位置的h更小的人的第k个位置. 这样不断重复就可以确定最终的序列.</p><p>但是<em>从开头数起, 跳过已经确定位置的h更小的人的第k个位置</em>是需要遍历数组的, 效率不高, 所以我用一个deque来保存还没有被占用的位置, 当一个位置确定之后就从其中删除, 这样对于之后的人来说, 用k作为索引从deque中取得的位置就是最终的位置. 但是这会造成一个问题, 就是h相同的人如果排在前面的已经确定了位置, 那么排在后面的人会由于已经删除一个位置而偏后一位, 解决方法是排序的时候就把h相同的人中k较大的排在前面.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), [&amp;](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.first == b.first)&#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> sz = people.size();</span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; ans(sz);</span><br><span class="line">        <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indexes</span><span class="params">(sz)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) indexes[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = people[i].second;</span><br><span class="line">            ans[indexes[index]] = people[i];</span><br><span class="line">            indexes.erase(indexes.begin() + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 405. Convert a Number to Hexadecimal</title>
      <link href="/2016/09/26/leetcode-405-convert-a-number-to-hexadecimal/"/>
      <url>/2016/09/26/leetcode-405-convert-a-number-to-hexadecimal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">two’s complement</a> method is used.</p><p><strong>Note:</strong></p><ol><li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li><li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>'0'</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li><li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li><li>You <strong>must not use any method provided by the library</strong> which converts/formats the number to hex directly.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;1a&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure></blockquote><p>由于传入的数据是int型, 所以其实负数就已经是用补码来表示了. 因此只要每次取四位二进制位出来然后把它们转换为16进制即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num;</span><br><span class="line">        <span class="built_in">string</span> hex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            hex.push_back(toCharHex(n &amp; <span class="number">0xf</span>));</span><br><span class="line">            n &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(hex.size() &gt; <span class="number">1</span> &amp;&amp; hex.back() == <span class="string">'0'</span>) hex.pop_back();</span><br><span class="line">        reverse(hex.begin(), hex.end());</span><br><span class="line">        <span class="keyword">return</span> hex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">toCharHex</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num + <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num - <span class="number">10</span> + <span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 404. Sum of Left Leaves</title>
      <link href="/2016/09/26/leetcode-404-sum-of-left-leaves/"/>
      <url>/2016/09/26/leetcode-404-sum-of-left-leaves/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Find the sum of all left leaves in a given binary tree.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</span><br></pre></td></tr></table></figure></blockquote><p>用DFS找出所有左叶子节点再求和即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        DFS(root, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode *node, <span class="keyword">bool</span> left)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; left)&#123;</span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DFS(node-&gt;left, <span class="literal">true</span>);</span><br><span class="line">        DFS(node-&gt;right, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 134. Gas Station</title>
      <link href="/2016/09/25/leetcode-134-gas-station/"/>
      <url>/2016/09/25/leetcode-134-gas-station/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p><p><strong>Note:</strong>The solution is guaranteed to be unique.</p></blockquote><p>环路上分布着n个加油站, 输入数据是每个加油站可以加多少油和到下一个加油站耗费多少油, 要求找出能不能走完这个环.</p><p>首先要证明一个情况: 如果从a点出发无法抵达c点(c之前的一点可以到达), 那么从a到c之间的任何一点b出发都是无法到达c点的. 这是因为从a出发到b的时候最坏的情况是正好没有油, 所以从b点继续的时候油是&gt;=在b点加的油的, 而如果一开始就从b出发, 油就等于在b加的油, 是不可能比从a出发开的远的.</p><p>因此可以在O(n)的时间复杂度内解决. 从第一个点开始, 搜索能到达的最远的点, 如果不能走完一圈, 那么这之间的点就不用再试了, 可以直接从最远点的下一个点开始尝试.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newStart, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(impl(gas, cost, i, newStart))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(newStart &gt;= gas.size())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i = newStart;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">impl</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cost, <span class="keyword">int</span> start, <span class="keyword">int</span> &amp;newStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; start + gas.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = i % gas.size();</span><br><span class="line">            carGas += gas[index];</span><br><span class="line">            carGas -= cost[index];</span><br><span class="line">            <span class="keyword">if</span>(carGas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                newStart = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 133. Clone Graph</title>
      <link href="/2016/09/25/leetcode-133-clone-graph/"/>
      <url>/2016/09/25/leetcode-133-clone-graph/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.</p><p>**OJ’s undirected graph serialization:**Nodes are labeled uniquely.We use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.First node is labeled as <code>0</code>. Connect node <code>0</code> to both nodes <code>1</code> and <code>2</code>.Second node is labeled as <code>1</code>. Connect node <code>1</code> to node <code>2</code>.Third node is labeled as <code>2</code>. Connect node <code>2</code> to node <code>2</code> (itself), thus forming a self-cycle.Visually, the graph looks like the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> &#x2F;   \</span><br><span class="line">0 --- 2</span><br><span class="line">     &#x2F; \</span><br><span class="line">     \_&#x2F;</span><br></pre></td></tr></table></figure></blockquote><p>使用DFS或者BFS来进行复制就可以了. 有一个要注意的问题就是在新的图中, 连接到已经遍历过的节点的边也要连接到新的图中的节点, 所以不仅要记录原图中节点有没有访问过, 也要记录对应的新的图中的节点. 由于输入数据中节点是用编号来区分的, 因此我用一个map来把节点编号与节点指针对应起来记录访问过的节点, 这样就可以同时记录新的图的节点与原图访问过的节点了(原图用节点编号, 新的图用节点指针).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> node;</span><br><span class="line">        UndirectedGraphNode *re = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</span><br><span class="line">        <span class="built_in">queue</span>&lt;UndirectedGraphNode*&gt; BFS, reBFS;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, UndirectedGraphNode*&gt; visited;</span><br><span class="line">        BFS.push(node);</span><br><span class="line">        reBFS.push(re);</span><br><span class="line">        visited[re-&gt;label] = re;</span><br><span class="line">        <span class="keyword">while</span>(!BFS.empty())&#123;</span><br><span class="line">            UndirectedGraphNode *p = BFS.front(), *r = reBFS.front();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;neighbors.size(); i++)&#123;</span><br><span class="line">                UndirectedGraphNode *next = p-&gt;neighbors[i];</span><br><span class="line">                <span class="keyword">if</span>(visited.count(next-&gt;label))&#123;</span><br><span class="line">                    r-&gt;neighbors.push_back(visited[next-&gt;label]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    UndirectedGraphNode *reNext = <span class="keyword">new</span> UndirectedGraphNode(next-&gt;label);</span><br><span class="line">                    r-&gt;neighbors.push_back(reNext);</span><br><span class="line">                    BFS.push(next);</span><br><span class="line">                    reBFS.push(reNext);</span><br><span class="line">                    visited[reNext-&gt;label] = reNext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            BFS.pop();</span><br><span class="line">            reBFS.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 132. Palindrome Partitioning II</title>
      <link href="/2016/09/24/leetcode-132-palindrome-partitioning-ii/"/>
      <url>/2016/09/24/leetcode-132-palindrome-partitioning-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p><p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>,Return <code>1</code> since the palindrome partitioning <code>[&quot;aa&quot;,&quot;b&quot;]</code> could be produced using 1 cut.</p></blockquote><p>这道题可以用两次DP来解, 第一个二维数组<code>palindrome[i][j]</code>表示s从i到j的子串是不是回文串, 第二个数组<code>dp[i]</code>保存从0到i的子串有几种分割方法. 对于<code>dp[i]</code>来说, 它有几种分割方法取决于以<code>s[i]</code>为结尾的回文串有多少个. 由于使用普通的遍历比较方法来判断所有的回文串是一个三重循环, 而用DP+从中间向两边比较的方法可以用双重循环解决. 所以总的复杂度是O(n<sup>2</sup>).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">palindrome</span><span class="params">(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            palindrome[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>]) palindrome[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        palindrome[len - <span class="number">1</span>][len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l &lt; len; l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[i + l]) palindrome[i][i + l] = palindrome[i + <span class="number">1</span>][i + l - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(palindrome[<span class="number">0</span>][i - <span class="number">1</span>]) dp[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> minCut = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; minCut &gt; <span class="number">1</span>; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(palindrome[j][i - <span class="number">1</span>])&#123;</span><br><span class="line">                        minCut = min(minCut, dp[j] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = minCut;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实可以把第二个循环的内容也放到第一个循环中去. 为了按行列的顺序来访问数组, 我把<code>palindrome[i][j]</code>的含义改为从j到i的字串是否为回文串.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">palindrome</span><span class="params">(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            palindrome[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>]) palindrome[i + <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        palindrome[len - <span class="number">1</span>][len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = palindrome[<span class="number">1</span>][<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minCut = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(palindrome[i][i - <span class="number">1</span>])&#123;</span><br><span class="line">                minCut = min(dp[i - <span class="number">2</span>] + <span class="number">1</span>, minCut);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == s[i]) palindrome[i][j] = palindrome[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; palindrome[i][j])&#123;</span><br><span class="line">                    minCut = min(minCut, dp[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = palindrome[i][<span class="number">0</span>] ? <span class="number">0</span> : minCut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 131. Palindrome Partitioning</title>
      <link href="/2016/09/23/leetcode-131-palindrome-partitioning/"/>
      <url>/2016/09/23/leetcode-131-palindrome-partitioning/</url>
      
        <content type="html"><![CDATA[<p>问题描述:</p><blockquote><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of <em>s</em>.</p><p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>,Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>使用回溯法遍历每一种可能的情况.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">        partitionImpl(s, <span class="number">0</span>, s.size(), path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partitionImpl</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end &lt;= start)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(s, start, end))&#123;</span><br><span class="line">            path.push_back(s.substr(start, end - start));</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome(s, start, i)) <span class="keyword">continue</span>;</span><br><span class="line">            path.push_back(s.substr(start, i - start));</span><br><span class="line">            partitionImpl(s, i, end, path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end - start &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (end - start) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start + i] != s[end - i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 130. Surrounded Regions</title>
      <link href="/2016/09/23/leetcode-130-surrounded-regions/"/>
      <url>/2016/09/23/leetcode-130-surrounded-regions/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a 2D board containing <code>'X'</code> and <code>'O'</code> (the <strong>letter</strong> O), capture all regions surrounded by <code>'X'</code>.</p><p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>After running your function, the board should be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure></blockquote><p>这道题可以使用并查集或者BFS的方法. 基本思想都是把没有接触边缘的元素归为一类, 然后设置为X. 我使用BFS的方法, 由于查找所有没有接触边缘的区块要遍历整个二维数组, 而查找与边缘有接触的区块只要遍历四条边, 所以我选择找出与边缘有接触的O组成的区块, 把它们使用另一种符号标记(比如T), 然后再遍历整个数组, 把O变为X, T变为O即可得到最终的结果.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty() || board[<span class="number">0</span>].empty()) <span class="keyword">return</span>;</span><br><span class="line">        row = board.size();</span><br><span class="line">        col = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">'O'</span>) BFS(board, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">'O'</span>) BFS(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(board[i][col - <span class="number">1</span>] == <span class="string">'O'</span>) BFS(board, i, col - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row - <span class="number">1</span>][i] == <span class="string">'O'</span>) BFS(board, row - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'T'</span>) board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x, y));</span><br><span class="line">        b[x][y] = <span class="string">'T'</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cx = q.front().first, cy = q.front().second;</span><br><span class="line">            <span class="keyword">if</span>(cx &gt; <span class="number">0</span> &amp;&amp; b[cx - <span class="number">1</span>][cy] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                b[cx - <span class="number">1</span>][cy] = <span class="string">'T'</span>;</span><br><span class="line">                q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(cx - <span class="number">1</span>, cy));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cy &gt; <span class="number">0</span> &amp;&amp; b[cx][cy - <span class="number">1</span>] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                b[cx][cy - <span class="number">1</span>] = <span class="string">'T'</span>;</span><br><span class="line">                q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(cx, cy - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cx &lt; row - <span class="number">1</span> &amp;&amp; b[cx + <span class="number">1</span>][cy] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                b[cx + <span class="number">1</span>][cy] = <span class="string">'T'</span>;</span><br><span class="line">                q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(cx + <span class="number">1</span>, cy));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cy &lt; col - <span class="number">1</span> &amp;&amp; b[cx][cy + <span class="number">1</span>] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                b[cx][cy + <span class="number">1</span>] = <span class="string">'T'</span>;</span><br><span class="line">                q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(cx, cy + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 129. Sum Root to Leaf Numbers</title>
      <link href="/2016/09/22/leetcode-129-sum-root-to-leaf-numbers/"/>
      <url>/2016/09/22/leetcode-129-sum-root-to-leaf-numbers/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p><p>Find the total sum of all root-to-leaf numbers.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.</p><p>Return the sum = 12 + 13 = <code>25</code>.</p></blockquote><p>简单的DFS获取所有从根节点到叶子节点的路径的问题.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums;</span><br><span class="line">        <span class="built_in">string</span> path;</span><br><span class="line">        getPath(root, path, sums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sums.size(); i++)&#123;</span><br><span class="line">            sum += sums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode* root, <span class="built_in">string</span> &amp;path, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            path.push_back(root-&gt;val + <span class="string">'0'</span>);</span><br><span class="line">            sums.push_back(stoi(path));</span><br><span class="line">            path.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(root-&gt;val + <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            getPath(root-&gt;left, path, sums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            getPath(root-&gt;right, path, sums);</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 128. Longest Consecutive Sequence</title>
      <link href="/2016/09/22/leetcode-128-longest-consecutive-sequence/"/>
      <url>/2016/09/22/leetcode-128-longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>For example,Given <code>[100, 4, 200, 1, 3, 2]</code>,The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.</p><p>Your algorithm should run in O(<em>n</em>) complexity.</p></blockquote><p>从一个无序的数组中找出最长的连续数字序列. 每读入一个数字, 就要判断能否加入到一个已经存在的区间中去, 而如何在常数时间内判断能否加入到某个区间中就是主要的问题. 我的方法是使用两个map, key的值分别为区间的开始和结束, 这样就可以在常数时间内确定能否加入到已经存在的区间的开头或结尾. 当一个值既能插入到某个区间的开头, 也能插入到某个区间的结尾时, 这两个区间就可以合并. 但是这个解法的效率并不是很高.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; SE, ES; <span class="comment">//SE = start&lt;-&gt;end, ES = end&lt;-&gt;start</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; included; <span class="comment">// 保存区间中已经包含的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(included.count(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">bool</span> SEext = SE.count(nums[i] + <span class="number">1</span>), ESext = ES.count(nums[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(SEext &amp;&amp; ESext)&#123;</span><br><span class="line">                <span class="keyword">int</span> newStart = ES[nums[i] - <span class="number">1</span>], newEnd = SE[nums[i] + <span class="number">1</span>];</span><br><span class="line">                SE.erase(nums[i] + <span class="number">1</span>);</span><br><span class="line">                ES.erase(nums[i] - <span class="number">1</span>);</span><br><span class="line">                SE[newStart] = newEnd;</span><br><span class="line">                ES[newEnd] = newStart;</span><br><span class="line">                maxLen = max(maxLen, newEnd - newStart + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(SEext)&#123;</span><br><span class="line">                SE[nums[i]] = SE[nums[i] + <span class="number">1</span>];</span><br><span class="line">                SE.erase(nums[i] + <span class="number">1</span>);</span><br><span class="line">                ES[SE[nums[i]]] = nums[i];</span><br><span class="line">                maxLen = max(maxLen, SE[nums[i]] - nums[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ESext)&#123;</span><br><span class="line">                ES[nums[i]] = ES[nums[i] - <span class="number">1</span>];</span><br><span class="line">                ES.erase(nums[i] - <span class="number">1</span>);</span><br><span class="line">                SE[ES[nums[i]]] = nums[i];</span><br><span class="line">                maxLen = max(maxLen, nums[i] - ES[nums[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                SE[nums[i]] = nums[i];</span><br><span class="line">                ES[nums[i]] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            included.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 126. Word Ladder II</title>
      <link href="/2016/09/20/leetcode-126-word-ladder-ii/"/>
      <url>/2016/09/20/leetcode-126-word-ladder-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to<em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each intermediate word must exist in the word list</li></ol><p>For example,</p><p>Given:<em>beginWord</em> = <code>&quot;hit&quot;</code><em>endWord</em> = <code>&quot;cog&quot;</code><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code></p><p>Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li></ul></blockquote><p>这道题使用BFS的问题在于BFS无法保存路径, 所以可以用对于路径的BFS, 也就是在队列中保存的是路径而不是节点. 这样的代码虽然可以AC, 但是非常慢…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">findLadders</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;wordList)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; BFS;</span><br><span class="line">BFS.push(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(&#123; beginWord &#125;));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line"><span class="keyword">int</span> curLevel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!BFS.empty()) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; lastPath = BFS.front();</span><br><span class="line"><span class="keyword">if</span> (lastPath.size() &gt; curLevel) &#123; <span class="comment">// 每一层遍历过的节点必须在进入下一层时才能删除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : visited) &#123;</span><br><span class="line">wordList.erase(i);</span><br><span class="line">&#125;</span><br><span class="line">visited.clear();</span><br><span class="line">curLevel = lastPath.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ans.empty() &amp;&amp; lastPath.size() &gt; ans[<span class="number">0</span>].size()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lastPath.back() == endWord) &#123;</span><br><span class="line">ans.push_back(lastPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">string</span> &amp;c = lastPath.back();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length(); i++) &#123;</span><br><span class="line"><span class="built_in">string</span> tmp = c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</span><br><span class="line">tmp[i] = j;</span><br><span class="line"><span class="keyword">if</span> (tmp == c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == endWord || wordList.count(tmp)) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; newPath = lastPath;</span><br><span class="line">newPath.push_back(tmp);</span><br><span class="line">BFS.push(newPath);</span><br><span class="line">visited.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BFS.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 127. Word Ladder</title>
      <link href="/2016/09/20/leetcode-127-word-ladder/"/>
      <url>/2016/09/20/leetcode-127-word-ladder/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from<em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each intermediate word must exist in the word list</li></ol><p>For example,</p><p>Given:<em>beginWord</em> = <code>&quot;hit&quot;</code><em>endWord</em> = <code>&quot;cog&quot;</code><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code></p><p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,return its length <code>5</code>.</p><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li></ul></blockquote><p>使用广度优先搜索, 判断是否连接是通过穷举一个单词的所有可能变化来完成的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; BFS;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; length;</span><br><span class="line">BFS.push(beginWord);</span><br><span class="line">length.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> maxLen = INT_MIN;</span><br><span class="line"><span class="keyword">while</span> (!BFS.empty()) &#123;</span><br><span class="line"><span class="built_in">string</span> &amp;c = BFS.front();</span><br><span class="line"><span class="keyword">int</span> l = length.front();</span><br><span class="line"><span class="keyword">if</span> (maxLen &lt; l) maxLen = l;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c == endWord) <span class="keyword">return</span> maxLen;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length(); i++)&#123;</span><br><span class="line">    <span class="built_in">string</span> tmp = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++)&#123;</span><br><span class="line">        tmp[i] = j;</span><br><span class="line">        <span class="keyword">if</span>(wordList.count(tmp))&#123;</span><br><span class="line">            BFS.push(tmp);</span><br><span class="line">            length.push(l + <span class="number">1</span>);</span><br><span class="line">            wordList.erase(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFS.pop();</span><br><span class="line">length.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 403. Frog Jump</title>
      <link href="/2016/09/19/leetcode-403-frog-jump/"/>
      <url>/2016/09/19/leetcode-403-frog-jump/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p><p>Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</p><p>If the frog’s last jump was <em>k</em> units, then its next jump must be either <em>k</em> - 1, <em>k</em>, or <em>k</em> + 1 units. Note that the frog can only jump in the forward direction.</p><p><strong>Note:</strong></p><ul><li>The number of stones is ≥ 2 and is &lt; 1,100.</li><li>Each stone’s position will be a non-negative integer &lt; 231.</li><li>The first stone’s position is always 0.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[0,1,3,5,6,8,12,17]</span><br><span class="line"></span><br><span class="line">There are a total of 8 stones.</span><br><span class="line">The first stone at the 0th unit, second stone at the 1st unit,</span><br><span class="line">third stone at the 3rd unit, and so on...</span><br><span class="line">The last stone at the 17th unit.</span><br><span class="line"></span><br><span class="line">Return true. The frog can jump to the last stone by jumping </span><br><span class="line">1 unit to the 2nd stone, then 2 units to the 3rd stone, then </span><br><span class="line">2 units to the 4th stone, then 3 units to the 6th stone, </span><br><span class="line">4 units to the 7th stone, and 5 units to the 8th stone.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,1,2,3,4,8,9,11]</span><br><span class="line"></span><br><span class="line">Return false. There is no way to jump to the last stone as </span><br><span class="line">the gap between the 5th and 6th stone is too large.</span><br></pre></td></tr></table></figure></blockquote><p>虽然tag里说这是个DP题, 但是我觉得更像个图论题. 每个stone是一个node, 根据能否到达来判断有没有边相连, 最终要判断第一个节点与最后一个节点是否连通.</p><p>那么既然是这样, 就有DFS和BFS两派了. 用BFS的话要记录抵达每个node的上一跳可能有多远, 同时要记录一个node有没有访问过, 所以比较复杂.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; visited;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[stones[i]] = <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            visited[stones[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!dp.count(<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(stones.size() == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        visited[<span class="number">0</span>] = visited[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; BFS;</span><br><span class="line">        BFS.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!BFS.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> stn = BFS.front();</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; &amp;v = dp[stn];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dp.count(stn + j))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!visited[stn + j]) &#123;</span><br><span class="line">                            visited[stn + j] = <span class="number">1</span>;</span><br><span class="line">                            BFS.push(stn + j);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(stn + j == stones.back() &amp;&amp; visited[stn + j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        dp[stn + j].insert(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            BFS.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个解法的Runtime有近500ms. DFS就不用保存维护这些数据. 在目前的测试数据上DFS只需要6ms.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canCrossImpl(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCrossImpl</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> index, <span class="keyword">int</span> lastStep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; stones.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stones[i] - stones[index] &lt; lastStep - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(stones[i] - stones[index] &gt; lastStep + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(canCrossImpl(stones, i, stones[i] - stones[index])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == stones.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Update: LeetCode已经更新了测试数据</strong>, 所以像上面那样单纯的DFS已经会超时了, 要使用一些DP的方法. 用一个二维数组来保存第i个节点的前一步为s步时能否到达. 因为步数s和节点编号i都未知且可能很大, 所以用unordered_map来实现二维数组.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt;&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canCrossImpl(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCrossImpl</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> index, <span class="keyword">int</span> lastStep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.count(index) &amp;&amp; m[index].count(lastStep))&#123;</span><br><span class="line">            <span class="keyword">return</span> m[index][lastStep];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; stones.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stones[i] - stones[index] &lt; lastStep - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(stones[i] - stones[index] &gt; lastStep + <span class="number">1</span>) &#123;</span><br><span class="line">                m[index][lastStep] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(canCrossImpl(stones, i, stones[i] - stones[index])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == stones.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于节点最多有1099个, 在步长每次都+1的情况下步数是一个从1开始的公差为1的等差数列, 所以虽然stone的编号是&lt;2<sup>31</sup>的, 但是大于0+1+2+…+1099=604450的stone是肯定抵达不了的. 而604450占20个二进制位, 一个32位数剩下的12位正好可以存储步数, 所以上面的二维数组可以变为一维.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canCrossImpl(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCrossImpl</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> index, <span class="keyword">int</span> lastStep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="number">604450</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> mi = index &lt;&lt; <span class="number">12</span> | lastStep;</span><br><span class="line">        <span class="keyword">if</span>(m.count(mi))&#123;</span><br><span class="line">            <span class="keyword">return</span> m[mi];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; stones.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stones[i] - stones[index] &lt; lastStep - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(stones[i] - stones[index] &gt; lastStep + <span class="number">1</span>) &#123;</span><br><span class="line">                m[mi] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(canCrossImpl(stones, i, stones[i] - stones[index])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == stones.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 402. Remove K Digits</title>
      <link href="/2016/09/19/leetcode-402-remove-k-digits/"/>
      <url>/2016/09/19/leetcode-402-remove-k-digits/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a non-negative integer <em>num</em> represented as a string, remove <em>k</em> digits from the number so that the new number is the smallest possible.</p><p><strong>Note:</strong></p><ul><li>The length of <em>num</em> is less than 10002 and will be ≥ <em>k</em>.</li><li>The given <em>num</em> does not contain any leading zero.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">Output: &quot;1219&quot;</span><br><span class="line">Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">Output: &quot;200&quot;</span><br><span class="line">Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: Remove all the digits from the number and it is left with nothing which is 0.</span><br></pre></td></tr></table></figure></blockquote><p>这道题的主要思想就是&quot;如果遇到了一个较小的值, 那么就把已得到的字符串中尾部所有比它大的值删除, 再把它放入末尾; 如果比末尾元素大, 那么就把它直接添加到末尾&quot;. 这是一个栈的问题, 但是除了主要的思路以外还有另一个问题: 最终栈的大小必须是<code>num.size()-k</code>, 所以在添加和删除时必须要考虑栈的大小.</p><p>在元素比栈顶元素大的情况下还要增加一个条件: 栈的大小还没有达到<code>num.size()-k</code>.</p><p>而元素比栈顶元素小的情况下, 在弹出栈顶元素时要求num中剩下的元素数量&gt;=栈的目标大小-栈目前的大小, 这样才能保证栈能被填满.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> target = num.size() - k, size = num.size(), i;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        ans.push_back(num[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; k + ans.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &gt; ans.back() &amp;&amp; ans.size() &lt; target) ans.push_back(num[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!ans.empty() &amp;&amp; ans.back() &gt; num[i] &amp;&amp; size - i - <span class="number">1</span> &gt;= target - ans.size()) ans.pop_back();</span><br><span class="line">                <span class="keyword">if</span>(ans.size() &lt; target) ans.push_back(num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; ans.size() &lt; target; i++)&#123;</span><br><span class="line">            ans.push_back(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; ans[i] == <span class="string">'0'</span>; i++);</span><br><span class="line">        <span class="keyword">if</span>(ans.empty() || i == ans.size()) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> ans.substr(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 401. Binary Watch</title>
      <link href="/2016/09/18/leetcode-401-binary-watch/"/>
      <url>/2016/09/18/leetcode-401-binary-watch/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p><p>Each LED represents a zero or one, with the least significant bit on the right.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt=""></p><p>For example, the above binary watch reads “3:25”.</p><p>Given a non-negative integer <em>n</em> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>The order of output does not matter.</li><li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li><li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li></ul></blockquote><p>由于数据量相当的小, 所以这道题最简单粗暴的方法就是把每种小时和分钟的可能都列出来, 正常一点的思路就是从n个数中选择k个不同的数出来, 对于这道题来说还要加上一个对于是否是合法地时间数据的判断.</p><p>我对于小时采用写出所有可能的办法, 对于分钟采用正常的方法. 至于为啥分钟不写, 大概是因为手算有点烦= =.</p><p>这道题我还遇到了[无符号数-有符号数=无符号数]的坑, 就是第64行的<code>i &lt;= v.size() - n</code>, 在n&gt;6的情况下是会溢出的. 所以要么把n移到不等式的左边, 要么在第8行就规避n&gt;6的情况.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hourNum = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minuteNum = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; hours, minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num - <span class="number">6</span>; i &lt;= num; i++)&#123;</span><br><span class="line">            possibleHour(i);</span><br><span class="line">            possibleMinute(num - i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : hours)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j : minutes)&#123;</span><br><span class="line">                    ans.push_back(i + <span class="string">":"</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">possibleHour</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        hours.clear();</span><br><span class="line">        <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                hours = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(&#123;<span class="string">"0"</span>&#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                hours = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"4"</span>, <span class="string">"8"</span>&#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                hours = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(&#123;<span class="string">"3"</span>, <span class="string">"5"</span>, <span class="string">"9"</span>, <span class="string">"6"</span>, <span class="string">"10"</span>&#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                hours = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(&#123;<span class="string">"7"</span>, <span class="string">"11"</span>&#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                hours = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">possibleMinute</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        minutes.clear();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            minutes.push_back(<span class="string">"00"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        selectNFromVector(minuteNum, <span class="number">0</span>, n, path, ret);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                sum += ret[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">60</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> str = to_string(sum);</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; <span class="number">10</span>) str.insert(str.begin(), <span class="string">'0'</span>);</span><br><span class="line">                minutes.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selectNFromVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> start, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ret)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= v.size() - n; i++)&#123;</span><br><span class="line">            path.push_back(v[i]);</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">                ret.push_back(path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            selectNFromVector(v, i + <span class="number">1</span>, n - <span class="number">1</span>, path, ret);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 400. Nth Digit</title>
      <link href="/2016/09/18/leetcode-400-nth-digit/"/>
      <url>/2016/09/18/leetcode-400-nth-digit/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Find the <em>n</em>th digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …</p><p><strong>Note:</strong><em>n</em> is positive and will fit within the range of a 32-bit signed integer (<em>n</em> &lt; 231).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.</span><br></pre></td></tr></table></figure></blockquote><p>LeetCode现在每周的比赛都要出四道新题, 像我这种一边做老题一边追新题还要上课(自己选的统计学习, 跪着也要上完)的人来说还真是有点觉得追不上.</p><p>这道题算是比较简单, 就是算出1位数有多少个阿拉伯数字, 2位数有多少阿拉伯数字, 3位数有多少个阿拉伯数字…n位数有9×10^(n-1)×n个阿拉伯数字, 然后对于输入的n, 我们就可以通过前面得到的数据确定它有多少位, 进而确定是哪个数, 最终确定要找的数字.</p><p>1位数到n位数共有多少个数字可以先计算出来写在程序中,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;; i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">9</span> * (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>, i) * (i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">        sum += t;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">':'</span>&lt;&lt;t&lt;&lt;<span class="string">" sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:9 sum:9</span><br><span class="line">1:180 sum:189</span><br><span class="line">2:2700 sum:2889</span><br><span class="line">3:36000 sum:38889</span><br><span class="line">4:450000 sum:488889</span><br><span class="line">5:5400000 sum:5888889</span><br><span class="line">6:63000000 sum:68888889</span><br><span class="line">7:720000000 sum:788888889</span><br></pre></td></tr></table></figure><p>这个结果还是挺有规律的. 接下来就是解题的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">189</span>, <span class="number">2889</span>, <span class="number">38889</span>, <span class="number">488889</span>, <span class="number">5888889</span>, <span class="number">68888889</span>, <span class="number">788888889</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">9</span> &amp;&amp; arr[index] &lt; n; index++); <span class="comment">// 确定位数</span></span><br><span class="line">        <span class="keyword">int</span> t = (n - arr[index - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = (t / index) + (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, index - <span class="number">1</span>); <span class="comment">// 确定数</span></span><br><span class="line">        <span class="keyword">int</span> p = index - (t % index) - <span class="number">1</span>; <span class="comment">// 确定第几位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++)&#123; <span class="comment">// 找出该位</span></span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num % <span class="number">10</span>; <span class="comment">// 个位为我们要找的数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 125. Valid Palindrome</title>
      <link href="/2016/09/17/leetcode-125-valid-palindrome/"/>
      <url>/2016/09/17/leetcode-125-valid-palindrome/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>For example,<code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<code>&quot;race a car&quot;</code> is <em>not</em> a palindrome.</p><p><strong>Note:</strong>Have you consider that the string might be empty? This is a good question to ask during an interview.</p><p>For the purpose of this problem, we define empty string as valid palindrome.</p></blockquote><p>双指针从两端向中间遍历即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(s[i]))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isValid(s[j]))&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] &gt;= <span class="string">'A'</span> &amp;&amp; s[i] &lt;= <span class="string">'Z'</span>) s[i] -= (<span class="string">'A'</span> - <span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[j] &gt;= <span class="string">'A'</span> &amp;&amp; s[j] &lt;= <span class="string">'Z'</span>) s[j] -= (<span class="string">'A'</span> - <span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) || (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) || (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 124. Binary Tree Maximum Path Sum</title>
      <link href="/2016/09/17/leetcode-124-binary-tree-maximum-path-sum/"/>
      <url>/2016/09/17/leetcode-124-binary-tree-maximum-path-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.</p><p>For example:Given the below binary tree,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Return <code>6</code>.</p></blockquote><p>这道题我一开始是先用DFS来搜索出所有节点到根节点的路径, 然后再用双重循环来计算出每对节点的路径和. 如果有n个节点的话, 这个方法的时间复杂度是O(n<sup>2</sup>), 所以超时了.</p><p>后来发现了递归的方法. 对于一个二叉树的根节点来说, 这棵树中的最长路径和要么经过它, 要么经过它的后代, 所以我们就可以算出经过根节点的最长路径和是多少, 然后对每一个节点都计算一遍就可以找出最长的路径和.</p><p>在递归过程中, 除了维护一个最终的最长路径和以外, 我们还要知道每个节点的左右子树到该节点的最长路径和(注意, 这里的路径必须有一端是该节点)才能找出经过该节点的最长路径和.</p><p>同时还要注意路径和与0的大小关系, 如果到某节点的路径和小于0, 那么就不应该把这部分路径包含进去.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxPath = INT_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        DFS(root);</span><br><span class="line">        <span class="keyword">return</span> maxPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPath = DFS(root-&gt;left), rightPath = DFS(root-&gt;right);</span><br><span class="line">        <span class="comment">// 经过root节点的路径的四种情况, 选择最大的.</span></span><br><span class="line">        maxPath = max(maxPath, (leftPath + rightPath + root-&gt;val));</span><br><span class="line">        maxPath = max(maxPath, root-&gt;val);</span><br><span class="line">        maxPath = max(maxPath, root-&gt;val + leftPath);</span><br><span class="line">        maxPath = max(maxPath, root-&gt;val + rightPath);</span><br><span class="line">        <span class="comment">// 如果左右子树都小于0, 那么应该只返回root节点的值</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + max(<span class="number">0</span>, max(leftPath, rightPath));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 123. Best Time to Buy and Sell Stock III</title>
      <link href="/2016/09/15/leetcode-123-best-time-to-buy-and-sell-stock-iii/"/>
      <url>/2016/09/15/leetcode-123-best-time-to-buy-and-sell-stock-iii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:</strong>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p></blockquote><p>这道题可以用一种我也不知道算不算动态规划的方法来解. 首先我们可以进行零次, 一次或者两次买入卖出操作, 零次或一次是之前的题目, 比较容易解决. 问题在于两次交易, 由于不能同时持有多个stock, 所以两次交易必须是前后发生的, 那么就可以用两个数组来分别记录[0,i]中获得能获得的最大收益和[i+1, n]中能获得的最大收益, 通过遍历i就可以得到前后两次交易的最大收益.</p><p>第一个数组通过遍历一次prices得到, 而第二个数组通过反向遍历一次prices得到.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; profit1(n, 0), profit2(n, 0);</span><br><span class="line">        <span class="keyword">int</span> lowest = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            lowest = min(lowest, prices[i]);</span><br><span class="line">            profit1[i] = max(profit1[i - <span class="number">1</span>], prices[i] - lowest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> highest = prices.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            highest = max(highest, prices[i]);</span><br><span class="line">            profit2[i] = max(profit2[i + <span class="number">1</span>], highest - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxProfit = profit1.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxProfit = max(maxProfit, profit1[i] + profit2[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而最后两个循环可以合并为一个.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; profit1(n, 0), profit2(n, 0);</span><br><span class="line">        <span class="keyword">int</span> lowest = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            lowest = min(lowest, prices[i]);</span><br><span class="line">            profit1[i] = max(profit1[i - <span class="number">1</span>], prices[i] - lowest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> highest = prices.back(), maxProfit = profit1.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            highest = max(highest, prices[i]);</span><br><span class="line">            profit2[i] = max(profit2[i + <span class="number">1</span>], highest - prices[i]);</span><br><span class="line">            maxProfit = max(maxProfit, profit1[i] + profit2[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 399. Evaluate Division</title>
      <link href="/2016/09/14/leetcode-399-evaluate-division/"/>
      <url>/2016/09/14/leetcode-399-evaluate-division/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.</p><p><strong>Example:</strong>Given <code>a / b = 2.0, b / c = 3.0.</code> queries are: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .</code> return <code>[6.0, 0.5, -1.0, 1.0, -1.0 ].</code></p><p>The input is:</p><figure class="highlight plain"><figcaption><span>string>> equations, vector<double>& values, vector<pair<string, string>> queries ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">, where &#96;equations.size() &#x3D;&#x3D; values.size()&#96;, and the values are positive. This represents the equations. Return &#96;vector&#96;.</span><br><span class="line"></span><br><span class="line">According to the example above:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>equations = [ [“a”, “b”], [“b”, “c”] ],values = [2.0, 3.0],queries = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</span><br><span class="line"></span><br><span class="line">这道题一看起来没啥思路, 但是看到tags里的Graph就一下子豁然开朗了. 其实每一个除法就是定义了有向图的一条边(实际上是来回两条)以及这条边的权值. 这样一来每一个查询就是判断给定的两个节点是否连通, 并且计算出路径上每条边的权值的乘积.</span><br><span class="line"></span><br><span class="line">首先构建邻接矩阵或邻接表, 然后对每个查询使用DFS或者BFS来搜索是否有两点之间的通路, 并且计算乘积.</span><br><span class="line"></span><br><span class="line">在计算过程中, 如果两个点是间接相连的, 实际上我们就可以直接在两点之间增加一条边, 权值为连接通路的权值乘积. 这样的话在剩下的查询中BFS中就可能更快地抵达目标节点.</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line">   &#x2F;&#x2F; 由于对于string的比较等操作很费时, 所以用一个map把string与int对应起来.</span><br><span class="line">   unordered_map&lt;string, int&gt; nodes; </span><br><span class="line">public:</span><br><span class="line">   vector&lt;double&gt; calcEquation(vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries) &#123;</span><br><span class="line">       for(int i &#x3D; 0; i &lt; equations.size(); i++)&#123;</span><br><span class="line">           &#x2F;&#x2F; 给每一个string分配一个下标</span><br><span class="line">           &#x2F;&#x2F; 注意这里有个隐藏bug, 假如map&#x2F;unordered_map对象m中不包含a, </span><br><span class="line">           &#x2F;&#x2F; 那么在使用m[a]时实际上是已经创建一个a的key和对应的value, 导致size加1</span><br><span class="line">           &#x2F;&#x2F; 所以如果我们想让第n个加入的元素的value为n-1的话, </span><br><span class="line">           &#x2F;&#x2F; 需要赋值m.size() - 1而不是m.size()</span><br><span class="line">           if(!nodes.count(equations[i].first))&#123;</span><br><span class="line">               nodes[equations[i].first] &#x3D; nodes.size() - 1;</span><br><span class="line">           &#125;</span><br><span class="line">           if(!nodes.count(equations[i].second))&#123;</span><br><span class="line">               nodes[equations[i].second] &#x3D; nodes.size() - 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       vector&lt;vector&lt;double&gt;&gt; g(nodes.size(), vector&lt;double&gt;(nodes.size(), -1.0));</span><br><span class="line">       for(int i &#x3D; 0; i &lt; equations.size(); i++)&#123;</span><br><span class="line">           &#x2F;&#x2F; 构建邻接矩阵</span><br><span class="line">           g[getNode(equations[i].first)][getNode(equations[i].second)] &#x3D; values[i];</span><br><span class="line">           g[getNode(equations[i].second)][getNode(equations[i].first)] &#x3D; 1 &#x2F; values[i];</span><br><span class="line">       &#125;</span><br><span class="line">       vector&lt;double&gt; ret(queries.size());</span><br><span class="line">       for(int i &#x3D; 0; i &lt; queries.size(); i++)&#123;</span><br><span class="line">           string a &#x3D; queries[i].first, b &#x3D; queries[i].second;</span><br><span class="line">           if(!nodes.count(a) || !nodes.count(b))&#123;</span><br><span class="line">               &#x2F;&#x2F; 如果出现了不存在的节点</span><br><span class="line">               ret[i] &#x3D; -1.0;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               &#x2F;&#x2F; 使用BFS来搜索路径</span><br><span class="line">               ret[i] &#x3D; BFS(g, getNode(a), getNode(b));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   int getNode(string s)&#123;</span><br><span class="line">       return nodes[s];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   double BFS(vector&lt;vector&lt;double&gt;&gt; &amp;g, int a, int b)&#123;</span><br><span class="line">       &#x2F;&#x2F; 如果是同一个节点就直接返回</span><br><span class="line">       if(a &#x3D;&#x3D; b) return 1.0;</span><br><span class="line">       int n &#x3D; g.size();</span><br><span class="line">       vector&lt;int&gt; visited(n, 0); &#x2F;&#x2F; 用于保存是否访问过节点</span><br><span class="line">       queue&lt;int&gt; q; &#x2F;&#x2F; BFS队列, 保存节点下标</span><br><span class="line">       queue&lt;double&gt; v; &#x2F;&#x2F; 用于保存从a到BFS队列中相应的节点的路径乘积</span><br><span class="line">       q.push(a);</span><br><span class="line">       visited[a] &#x3D; 1;</span><br><span class="line">       v.push(1.0);</span><br><span class="line">       while(!q.empty())&#123;</span><br><span class="line">           int node &#x3D; q.front();</span><br><span class="line">           double value &#x3D; v.front();</span><br><span class="line">           for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">               if(visited[i] || g[node][i] &#x3D;&#x3D; -1.0) continue; &#x2F;&#x2F; 节点i已经访问过或者没有边到达i</span><br><span class="line">               visited[i] &#x3D; 1;</span><br><span class="line">               q.push(i);</span><br><span class="line">               double len &#x3D; value * g[node][i]; &#x2F;&#x2F; 从a到i的路径权值乘积</span><br><span class="line">               &#x2F;&#x2F; 添加新的边</span><br><span class="line">               g[a][i] &#x3D; len;</span><br><span class="line">               g[i][a] &#x3D; 1 &#x2F; len;</span><br><span class="line">               if(i &#x3D;&#x3D; b)&#123; &#x2F;&#x2F; 抵达b点</span><br><span class="line">                   return len;</span><br><span class="line">               &#125;</span><br><span class="line">               v.push(len);</span><br><span class="line">           &#125;</span><br><span class="line">           q.pop();</span><br><span class="line">           v.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       return -1.0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 图 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 398. Random Pick Index</title>
      <link href="/2016/09/14/leetcode-398-random-pick-index/"/>
      <url>/2016/09/14/leetcode-398-random-pick-index/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.</p><p><strong>Note:</strong>The array size can be very large. Solution that uses too much extra space will not pass the judge.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int[] nums &#x3D; new int[] &#123;1,2,3,3,3&#125;;</span><br><span class="line">Solution solution &#x3D; new Solution(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br><span class="line">solution.pick(3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pick(1) should return 0. Since in the array only nums[0] is equal to 1.</span><br><span class="line">solution.pick(1);</span><br></pre></td></tr></table></figure></blockquote><p>这道题的内存要求相当严, 对我来说比较容易想到的方法都超内存了. 最后还是看tag才知道要用一种叫作<em>reservoir sampling 水塘抽样</em>(<a href="https://en.wikipedia.org/wiki/Reservoir_sampling" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reservoir_sampling</a>)的算法来做.</p><p>这个算法可以用于从n个数据(n很大且未知)中随机抽取k个样本, 具体思路如下(下标从0开始):</p><ol><li>首先取取数组a前k个元素放入结果r中</li><li>对于第i个元素(n&gt;i&gt;=k), 取一个随机数j(0&lt;=j&lt;i), 如果j&lt;k, 那么就把r[j]换成a[i].</li></ol><p>至于等概率的具体证明可以看wiki. 具体到这道题, 就是k=1的情况, 我们只需要在r中保存一个元素, 并且同时记录已经遍历到第几个target即可…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        n = nums;</span><br><span class="line">        srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> retIndex, totalTarget = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n[i] != target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(totalTarget == <span class="number">1</span>)&#123;</span><br><span class="line">                retIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(rand() % totalTarget == <span class="number">0</span>)&#123;</span><br><span class="line">                    retIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            totalTarget++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pick(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 397. Integer Replacement</title>
      <link href="/2016/09/12/leetcode-397-integer-replacement/"/>
      <url>/2016/09/12/leetcode-397-integer-replacement/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a positive integer <em>n</em> and you can do operations as follow:</p><ol><li>If <em>n</em> is even, replace <em>n</em> with <code>n/2</code>.</li><li>If <em>n</em> is odd, you can replace <em>n</em> with either <code>n + 1</code> or <code>n - 1</code>.</li></ol><p>What is the minimum number of replacements needed for <em>n</em> to become 1?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">8 -&gt; 4 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</span><br><span class="line">or</span><br><span class="line">7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure></blockquote><p>我一开始想用动态规划, 但是这个题的测试数据有INT_MAX这么大, 根本开不了这么大的数组, 所以不行. 说明这道题有一些小窍门. 仔细想想, n为偶数是直接除以2没有什么问题, 问题在于奇数时有两种情况, <code>(n+1)/2</code>与<code>(n-1)/2</code>恰好是相邻的两个数, 一个奇数一个偶数, 对于其中的偶数还是直接除以2, 但是奇数就要多一步加1或减1, 所以在选择加1还是减1时应该选择的是除以2后还是偶数的那一个.</p><p>这道题因为数据是指数下降的, 所以最多迭代几十次, 递归与循环的性能差距不大, 用递归更好理解一点.</p><p>当n等于INT_MAX时, 再加1会导致溢出, 所以下次递归选择次数相同的INT_MAX-1.</p><p>还有一个问题在于n等于3时的情况, <code>(n+1)</code>与<code>(n-1)/2</code>分别是4和2, 按照先前的规则应该选择4, 但实际上应该选择2, 我对于这种情况单独处理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">4</span> || n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> integerReplacement(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == INT_MAX) <span class="keyword">return</span> integerReplacement(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integerReplacement(((n - <span class="number">1</span>) / <span class="number">2</span>) % <span class="number">2</span> ? (n + <span class="number">1</span>) : (n - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 396. Rotate Function</title>
      <link href="/2016/09/12/leetcode-396-rotate-function/"/>
      <url>/2016/09/12/leetcode-396-rotate-function/</url>
      
        <content type="html"><![CDATA[<p>问题描述:</p><blockquote><p>Given an array of integers <code>A</code> and let <em>n</em> to be its length.</p><p>Assume <code>Bk</code> to be an array obtained by rotating the array <code>A</code> <em>k</em> positions clock-wise, we define a “rotation function” <code>F</code> on <code>A</code> as follow:</p><p><code>F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]</code>.</p><p>Calculate the maximum value of <code>F(0), F(1), ..., F(n-1)</code>.</p><p><strong>Note:</strong><em>n</em> is guaranteed to be less than 105.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [4, 3, 2, 6]</span><br><span class="line"></span><br><span class="line">F(0) &#x3D; (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) &#x3D; 0 + 3 + 4 + 18 &#x3D; 25</span><br><span class="line">F(1) &#x3D; (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) &#x3D; 0 + 4 + 6 + 6 &#x3D; 16</span><br><span class="line">F(2) &#x3D; (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) &#x3D; 0 + 6 + 8 + 9 &#x3D; 23</span><br><span class="line">F(3) &#x3D; (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) &#x3D; 0 + 2 + 12 + 12 &#x3D; 26</span><br><span class="line"></span><br><span class="line">So the maximum value of F(0), F(1), F(2), F(3) is F(3) &#x3D; 26.</span><br></pre></td></tr></table></figure></blockquote><p>按照题目要求的步骤来计算一个数组的每个元素与下标乘积的和, 然后每次循环右移一位, 找出所有的和中的最大值. 不需要在每次右移后都计算一次数组的和, 只要把上一次得到的结果减去最后一项<code>(n-1) * Bk[n-1]</code>再加上所有元素的和(不乘下标)再减去<code>Bk[n-1]</code>即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, stepSum = <span class="number">0</span>, maxSum = INT_MIN, n = A.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            stepSum += (i * A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxSum = stepSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            stepSum = stepSum - A[n - i] * (n - <span class="number">1</span>) + sum - A[n - i];</span><br><span class="line">            maxSum = max(maxSum, stepSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 122. Best Time to Buy and Sell Stock II</title>
      <link href="/2016/09/11/leetcode-122-best-time-to-buy-and-sell-stock-ii/"/>
      <url>/2016/09/11/leetcode-122-best-time-to-buy-and-sell-stock-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p></blockquote><p>这道题与<a href="http://xiadong.info/2016/09/leetcode-121-best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">上一题</a>相比不同点在于可以多次买入卖出股票但是不能同时持有多份股票, 所以整个的操作流程必须是&quot;买入-卖出-买入-卖出…-买入-卖出&quot;. 考虑一个简单的情况:</p><p><code>1,4,2,10</code></p><p>显然有两种策略, 分别的利润为<code>(4-1)+(10-2)=11</code>和<code>10-1=9</code>, 应选择第一种. 而另一种情况:</p><p><code>1,2,4,10</code></p><p>两种策略的利润为<code>(2-1)+(10-4)=8</code>和<code>10-1=9</code>, 此时应该选择第二种. 对于一般情况来说:</p><p><code>a1,a2,a3...,ap,...,aq,...,an</code></p><p>如果在a1买入ap卖出然后再aq买入an卖出的话, 利润为<code>(an-aq)+(ap-a1)</code>, 如果在a1买入an卖出的话, 利润为<code>an-a1</code>, 两者之差为<code>(an-a1)-[(an-aq)+(ap-a1)]=aq-ap</code>, 所以如果<code>ap&gt;aq</code>, 那么应该选择前者, 反之选择后者. 从编程策略上来说就应该是搜索一个从低价位开始的递增序列, 在不能再保持递增的时候就是应该卖出的时候.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; low) low = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(prices[i] &gt; prices[i + <span class="number">1</span>])&#123;</span><br><span class="line">                profit += (prices[i] - low);</span><br><span class="line">                low = prices[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prices.back() &gt; low) profit += (prices.back() - low);</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 121. Best Time to Buy and Sell Stock</title>
      <link href="/2016/09/11/leetcode-121-best-time-to-buy-and-sell-stock/"/>
      <url>/2016/09/11/leetcode-121-best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 1, 5, 3, 6, 4]</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">max. difference &#x3D; 6-1 &#x3D; 5 (not 7-1 &#x3D; 6, as selling price needs to be larger than buying price)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 6, 4, 3, 1]</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure></blockquote><p>这道题我一开始看错了题意. 它的意思是只允许一次买入卖出操作或者没有操作, 所以只要找到相差最大的两个价格并且低价在高价之前就可以了. 从前往后遍历一次数组, 记录到目前为止的最低价格, 然后再记录一个差额的最大值就可以了. 时间复杂度O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lowest = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lowest &gt; prices[i])&#123;</span><br><span class="line">                lowest = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                profit = max(profit, prices[i] - lowest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 120. Triangle</title>
      <link href="/2016/09/11/leetcode-120-triangle/"/>
      <url>/2016/09/11/leetcode-120-triangle/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [2],</span><br><span class="line">   [3,4],</span><br><span class="line">  [6,5,7],</span><br><span class="line"> [4,1,8,3]</span><br><span class="line">&gt;]</span><br></pre></td></tr></table></figure><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p><p>Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p></blockquote><p>比较简单的动态规划题, 每次需要的数据就是上一行到达每个位置的最小路径和. 只要比较左上方与右上方的两个和然后选择较小的一个就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lastRow, rowSum;</span><br><span class="line">        lastRow = triangle[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangle.size(); i++)&#123;</span><br><span class="line">            rowSum.resize(triangle[i].size());</span><br><span class="line">            rowSum[<span class="number">0</span>] = lastRow[<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; triangle[i].size() - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                rowSum[j] = min(lastRow[j - <span class="number">1</span>], lastRow[j]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            rowSum.back() = lastRow.back() + triangle[i].back();</span><br><span class="line">            lastRow = rowSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastRow.size(); i++)&#123;</span><br><span class="line">            ret = min(lastRow[i], ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 119. Pascal&#39;s Triangle II</title>
      <link href="/2016/09/09/leetcode-119-pascals-triangle-ii/"/>
      <url>/2016/09/09/leetcode-119-pascals-triangle-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an index <em>k</em>, return the <em>k</em>th row of the Pascal’s triangle.</p><p>For example, given <em>k</em> = 3,Return <code>[1,3,3,1]</code>.</p><p><strong>Note:</strong>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p></blockquote><p>与<a href="http://xiadong.info/2016/09/leetcode-118-pascals-triangle/" target="_blank" rel="noopener">上一题</a>类似, 只不过现在是要求某一行的结果. 每计算一行只需要上一行的数据, 所以只需要保存一行.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; last = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">            ret.clear();</span><br><span class="line">            ret.push_back(last[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">auto</span> j = last.begin() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j != last.end(); j++)&#123;</span><br><span class="line">                ret.push_back(*j + *(j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(*(j - <span class="number">1</span>));</span><br><span class="line">            last = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 118. Pascal&#39;s Triangle</title>
      <link href="/2016/09/09/leetcode-118-pascals-triangle/"/>
      <url>/2016/09/09/leetcode-118-pascals-triangle/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p><p>For example, given <em>numRows</em> = 5,Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>Pascal三角形就是每一行除了开头和结尾的数是1, 其他数都等于它的左上方与右上方的数之和.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">result</span><span class="params">(numRows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || j == i) result[i].push_back(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    result[i].push_back(result[i - <span class="number">1</span>][j - <span class="number">1</span>] + result[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 117. Populating Next Right Pointers in Each Node II</title>
      <link href="/2016/09/09/leetcode-117-populating-next-right-pointers-in-each-node-ii/"/>
      <url>/2016/09/09/leetcode-117-populating-next-right-pointers-in-each-node-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Follow up for problem “<em>Populating Next Right Pointers in Each Node</em>”.</p><p>What if the given tree could be any binary tree? Would your previous solution still work?</p><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li></ul><p>For example,Given the following binary tree,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2    3</span><br><span class="line"> &#x2F; \    \</span><br><span class="line">4   5    7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>After calling your function, the tree should look like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> &#x2F; \    \</span><br><span class="line">4-&gt; 5 -&gt; 7 -&gt; NULL</span><br></pre></td></tr></table></figure></blockquote><p>这个问题仍然沿用<a href="http://xiadong.info/2016/09/leetcode-116-populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">上一题</a>的思路, 先对一个节点是父节点的左节点还是右节点分类. 然后再细分接下来的情况.</p><ul><li>一个节点是父节点的左孩子:<ul><li>如果父节点有右孩子, 那么next就是右孩子</li><li>如果父节点没有右孩子并且next为null, 那么该节点的next也为null</li><li>如果父节点next不为null, 那么遍历父节点接下来的每一个next节点, 直到找到一个节点有孩子节点, 这个孩子节点是该节点的next. 如果找不到, 该节点的next节点为null</li></ul></li><li>一个节点是父节点的右孩子<ul><li>父节点的next为null, 则该节点的next为null</li><li>如果父节点next不为null, 那么遍历父节点接下来的每一个next节点, 直到找到一个节点有孩子节点, 这个孩子节点是该节点的next. 如果找不到, 该节点的next节点为null</li></ul></li></ul><p>由于对于每一层节点都是从左往右遍历的, 所以每一个父节点的所有后续next节点在处理孩子节点的时候都必须固定下来, 所以要采取从上到下, 从右到左的顺序来遍历二叉树.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root, TreeLinkNode *parent = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == parent-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(parent-&gt;right) root-&gt;next = parent-&gt;right;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!parent-&gt;next)&#123;</span><br><span class="line">                    root-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    TreeLinkNode* t = parent-&gt;next;</span><br><span class="line">                    <span class="keyword">while</span>(t &amp;&amp; !(t-&gt;left || t-&gt;right)) t = t-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span>(!t) root-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">else</span> root-&gt;next = (t-&gt;left ? t-&gt;left : t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root == parent-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!parent-&gt;next)&#123;</span><br><span class="line">                    root-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    TreeLinkNode* t = parent-&gt;next;</span><br><span class="line">                    <span class="keyword">while</span>(t &amp;&amp; !(t-&gt;left || t-&gt;right)) t = t-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span>(!t) root-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">else</span> root-&gt;next = (t-&gt;left ? t-&gt;left : t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;right, root);</span><br><span class="line">        connect(root-&gt;left, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 116. Populating Next Right Pointers in Each Node</title>
      <link href="/2016/09/09/leetcode-116-populating-next-right-pointers-in-each-node/"/>
      <url>/2016/09/09/leetcode-116-populating-next-right-pointers-in-each-node/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li></ul><p>For example,Given the following perfect binary tree,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2    3</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">4  5  6  7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>After calling your function, the tree should look like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">4-&gt;5-&gt;6-&gt;7 -&gt; NULL</span><br></pre></td></tr></table></figure></blockquote><p>给一颗完全二叉树的每一个节点确定它同层中的下一个节点. 规则比较简单:</p><ul><li>如果一个节点是父节点的左孩子, 那么它的next就是父节点的右孩子</li><li>如果一个节点是父节点的右孩子, 那么分两种情况:<ul><li>父节点的next为null, 则该节点的next为null</li><li>父节点的next不为null, 则该节点的next为父节点next节点的左孩子</li></ul></li></ul><p>为了知道一个节点的父节点, 在函数参数中要同时把节点的父节点传入.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root, TreeLinkNode *parent = <span class="literal">NULL</span>)</span> </span>&#123; <span class="comment">// 与题目提供的函数原型略有不同S</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == parent-&gt;left)&#123;</span><br><span class="line">                root-&gt;next = parent-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root == parent-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(parent-&gt;next != <span class="literal">NULL</span>)root-&gt;next = parent-&gt;next-&gt;left;</span><br><span class="line">                <span class="keyword">else</span> root-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;left, root);</span><br><span class="line">        connect(root-&gt;right, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 115. Distinct Subsequences</title>
      <link href="/2016/09/08/leetcode-115-distinct-subsequences/"/>
      <url>/2016/09/08/leetcode-115-distinct-subsequences/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>T</strong> in <strong>S</strong>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p>Here is an example:<strong>S</strong> = <code>&quot;rabbbit&quot;</code>, <strong>T</strong> = <code>&quot;rabbit&quot;</code></p><p>Return <code>3</code>.</p></blockquote><p>这道题第一反应是动态规划, 使用<code>dp[i][j]</code>表示从<code>s[0]</code>到<code>s[i]</code>(含, 以下用<code>s[0:i]</code>表示)这个字符串中包含多少个<code>t[0:j]</code>字符串. 但是递推公式不太好想, 所以我先把例子中给出的<code>&quot;rabbbit&quot;</code>和<code>&quot;rabbit&quot;</code>的dp数组写出来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  r a b b i t</span><br><span class="line">r 1 0 0 0 0 0</span><br><span class="line">a 1 1 0 0 0 0</span><br><span class="line">b 1 1 1 0 0 0</span><br><span class="line">b 1 1 2 1 0 0</span><br><span class="line">b 1 1 3 3 0 0</span><br><span class="line">i 1 1 3 3 3 0</span><br><span class="line">t 1 1 3 3 3 3</span><br></pre></td></tr></table></figure><p>通过观察这个数组我们可以发现, 递推公式可能为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (s[i] == t[j]) ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] : dp[i - <span class="number">1</span>][j]</span><br></pre></td></tr></table></figure><p>那么为什么会是这个公式呢? 首先, 如果<code>s[i]</code>与<code>t[j]</code>不相等, 那么说明没有增加新的子串, 所以<code>s[0:i]</code>中包含的<code>t[0:j]</code>数量与<code>s[0:i-1]</code>相同. 而如果<code>s[i] == t[j]</code>, 那么说明增加了新的子串, 就要在<code>s[0:i-1]</code>中包含<code>t[0:j]</code>的基础上加上<code>s[0:i-1]</code>中包含<code>t[0:j-1]</code>的数量.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(t.length(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(s.empty() || t.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == t[<span class="number">0</span>]) dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123; <span class="comment">//初始化第一列</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == t[<span class="number">0</span>]) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t.length(); j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt; s.length(); i++)&#123; <span class="comment">// s的长度一定大于等于t的长度</span></span><br><span class="line">                <span class="keyword">if</span>(s[i] == t[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length() - <span class="number">1</span>][t.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上的代码的运行效率有问题, 大家都知道受到Cache命中的影响, 遍历二维数组时, 按行列比按列行的效率更高, 所以把行列代表的含义交换一下, 得到按行列遍历的数组. 同时进行一些剪枝和dp初始化的优化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s的长度应该大于等于t长度</span></span><br><span class="line">        <span class="keyword">if</span>(s.empty() || t.empty() || s.length() &lt; t.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[t.length()][s.length()];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == t[<span class="number">0</span>]) dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录t中是否有s中不存在的元素</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        chars[s[<span class="number">0</span>]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == t[<span class="number">0</span>]) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">            chars[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="comment">// 如果t中含有s中不存在的元素则直接返回0</span></span><br><span class="line">            <span class="keyword">if</span>(--chars[t[i]] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == t[i]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t.length() - <span class="number">1</span>][s.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 114. Flatten Binary Tree to Linked List</title>
      <link href="/2016/09/08/leetcode-114-flatten-binary-tree-to-linked-list/"/>
      <url>/2016/09/08/leetcode-114-flatten-binary-tree-to-linked-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example,Given</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The flattened tree should look like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure></blockquote><p>题目中其实并没有说清楚怎么flatten的, 但是观察给的例子后可以发现是把一个节点的左子树插到右子树之前, 原来的右子树放到左子树的最右端叶子节点的右子树位置.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">                TreeNode *right = p-&gt;right;</span><br><span class="line">                p-&gt;right = p-&gt;left;</span><br><span class="line">                p-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                leftNode(p)-&gt;right = right;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">leftNode</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;right)&#123;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 113. Path Sum II</title>
      <link href="/2016/09/07/leetcode-113-path-sum-ii/"/>
      <url>/2016/09/07/leetcode-113-path-sum-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>For example:</p><p>Given the below binary tree and</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum &#x3D; 22</span><br></pre></td></tr></table></figure><p>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>与<a href="http://xiadong.info/2016/09/leetcode-112-path-sum/" target="_blank" rel="noopener">上一题</a>类似, 只不过在DFS的过程中维护一个路径path, 保存从根节点到当前节点的值, 抵达叶子节点并且path中元素的和与sum相等时就把它加到结果中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        DFS(root, <span class="number">0</span>, sum, path);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode *node, <span class="keyword">int</span> n, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n + node-&gt;val == sum)&#123;</span><br><span class="line">                ret.push_back(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!node-&gt;left &amp;&amp; node-&gt;right)&#123;</span><br><span class="line">            DFS(node-&gt;right, node-&gt;val + n, sum, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left &amp;&amp; !node-&gt;right)&#123;</span><br><span class="line">            DFS(node-&gt;left, node-&gt;val + n, sum, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            DFS(node-&gt;left, node-&gt;val + n, sum, path);</span><br><span class="line">            DFS(node-&gt;right, node-&gt;val + n, sum, path);</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 112. Path Sum</title>
      <link href="/2016/09/07/leetcode-112-path-sum/"/>
      <url>/2016/09/07/leetcode-112-path-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>For example:</p><p>Given the below binary tree and</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum &#x3D; 22</span><br></pre></td></tr></table></figure><p>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p></blockquote><p>深度优先搜索就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DFS(root, <span class="number">0</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(TreeNode *node, <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n + node-&gt;val == sum)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; node-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> DFS(node-&gt;right, node-&gt;val + n, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left &amp;&amp; !node-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> DFS(node-&gt;left, node-&gt;val + n, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left &amp;&amp; node-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> DFS(node-&gt;left, node-&gt;val + n, sum) || DFS(node-&gt;right, node-&gt;val + n, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 111. Minimum Depth of Binary Tree</title>
      <link href="/2016/09/07/leetcode-111-minimum-depth-of-binary-tree/"/>
      <url>/2016/09/07/leetcode-111-minimum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p></blockquote><p>DFS/BFS都可以, 但是我觉得大概BFS会快一点, 因为在最坏的情况下DFS需要遍历完所有节点才能知道最短的高度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; BFS;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; depth;</span><br><span class="line">        BFS.push(root);</span><br><span class="line">        depth.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!BFS.empty())&#123;</span><br><span class="line">            TreeNode *p = BFS.front();</span><br><span class="line">            <span class="keyword">int</span> d = depth.front();</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">                BFS.push(p-&gt;left);</span><br><span class="line">                depth.push(d + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">                BFS.push(p-&gt;right);</span><br><span class="line">                depth.push(d + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BFS.pop();</span><br><span class="line">            depth.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 110. Balanced Binary Tree</title>
      <link href="/2016/09/06/leetcode-110-balanced-binary-tree/"/>
      <url>/2016/09/06/leetcode-110-balanced-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p></blockquote><p>题目中二叉树平衡的定义为: 每个节点的左右子树的高度相差都不超过1. 因此可以用递归的方式依次遍历每个节点同时计算每个节点左右子树的高度. 用一个bool变量来保存是否出现了不平衡的节点.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> re = <span class="literal">true</span>;</span><br><span class="line">        height(root, re);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode *node, <span class="keyword">bool</span> &amp;re)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = height(node-&gt;left, re), rightHeight = height(node-&gt;right, re);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) re = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 395. Longest Substring with At Least K Repeating Characters</title>
      <link href="/2016/09/06/leetcode-395-longest-substring-with-at-least-k-repeating-characters/"/>
      <url>/2016/09/06/leetcode-395-longest-substring-with-at-least-k-repeating-characters/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Find the length of the longest substring <strong>T</strong> of a given string (consists of lowercase letters only) such that every character in <strong>T</strong> appears no less than <em>k</em> times.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aaabb&quot;, k &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;ababbc&quot;, k &#x3D; 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure></blockquote><p>第一眼看到这道题我是想用动态规划的, 可是凭我的弱鸡DP功底做不出来. 第二眼我又想用双指针, 可是又觉得有超时的危险(暴力双循环必然超时, 我写的双指针复杂度降低不多). 所以我最后采用了分治+递归的方法.</p><p>总体思想如下</p><ol><li>先遍历一遍字符串, 记录每个字符的出现次数, 在这一步中同时记录出现大于等于k次的字母个数, 如果根本就没有大于等于k次的字母, 那么可以直接返回0.</li><li>通过出现次数不足k次的字母来把字符串分割成多个子串, 因为在原字符串中出现次数不足k次的字母必然不会出现在结果串中.</li><li>递归的处理每个子串. 递归结束条件为字符串长度不足k.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longestSubstringImpl(s, k, <span class="number">0</span>, s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstringImpl</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end - start &lt; k) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">letters</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> biggerThanK = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end; i++)&#123; <span class="comment">// 记录每个字母出现的次数</span></span><br><span class="line">            <span class="keyword">if</span>(++letters[s[i] - <span class="string">'a'</span>] &gt;= k) biggerThanK++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(biggerThanK == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有出现达到k次的字母</span></span><br><span class="line">        <span class="keyword">int</span> l = start, r = l, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; end)&#123;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; end &amp;&amp; letters[s[r] - <span class="string">'a'</span>] &gt;= k)&#123; <span class="comment">// 跳过出现次数达到k次的字母</span></span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r == l)&#123; <span class="comment">// r == l说明第一个字母就没有到达k次, 所以处理下一个字母</span></span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(r == end &amp;&amp; l == start)&#123;</span><br><span class="line">                <span class="comment">// 这里比较重要, 如果不单独处理整个字符串都符合</span></span><br><span class="line">                <span class="comment">// 要求的情况的话, 就会出现无穷递归.</span></span><br><span class="line">                maxLen = max(maxLen, r - l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 递归处理子串</span></span><br><span class="line">                maxLen = max(maxLen, longestSubstringImpl(s, k, l, r));</span><br><span class="line">                l = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 394. Decode String</title>
      <link href="/2016/09/05/leetcode-394-decode-string/"/>
      <url>/2016/09/05/leetcode-394-decode-string/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an encoded string, return it’s decoded string.</p><p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em>is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or<code>2[4]</code>.</p><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</span><br><span class="line">s &#x3D; &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</span><br><span class="line">s &#x3D; &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure></blockquote><p>对一个字符串进行解码, 该字符串的编码规则是这样的<code>重复次数[重复内容]</code>, 由于有可能出现嵌套, 所以我使用递归来处理这个字符串.</p><p>对于括号匹配来说, 使用栈来确定与相应左括号匹配的右括号. 要注意可能会出现不重复的串, 这时要直接把它加到返回串的后面而不处理重复次数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">s = str;</span><br><span class="line"><span class="keyword">return</span> decodeStringImpl(<span class="number">0</span>, s.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeStringImpl</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> ret;</span><br><span class="line"><span class="keyword">int</span> index = start;</span><br><span class="line"><span class="keyword">while</span>(index &lt; end &amp;&amp; !isDigit(s[index]) &amp;&amp; s[index] != <span class="string">']'</span>)&#123;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line">ret += s.substr(start, index - start);</span><br><span class="line"><span class="keyword">while</span> (index &lt; end) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!isDigit(s[index]))&#123;</span><br><span class="line">        <span class="keyword">int</span> j = index;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; end &amp;&amp; !isDigit(s[j])) j++;</span><br><span class="line">        ret += s.substr(index, j - index);</span><br><span class="line">        index = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftBracket = getInt(index);</span><br><span class="line">    <span class="keyword">int</span> repeat = stoi(s.substr(index, leftBracket - index));</span><br><span class="line">    <span class="keyword">int</span> rightBracket = findRightBracket(leftBracket);</span><br><span class="line">    <span class="built_in">string</span> s = decodeStringImpl(leftBracket + <span class="number">1</span>, rightBracket);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeat; i++) &#123;</span><br><span class="line">    ret += s;</span><br><span class="line">    &#125;</span><br><span class="line">    index = rightBracket + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRightBracket</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">st.push_back(index);</span><br><span class="line"><span class="keyword">int</span> i = index;</span><br><span class="line"><span class="keyword">while</span> (!st.empty() &amp;&amp; i &lt; s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'['</span>) st.push_back(i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) st.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (index &lt; s.length() &amp;&amp; isDigit(s[index])) &#123;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 393. UTF-8 Validation</title>
      <link href="/2016/09/05/leetcode-393-utf-8-validation/"/>
      <url>/2016/09/05/leetcode-393-utf-8-validation/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:</p><ol><li>For 1-byte character, the first bit is a 0, followed by its unicode code.</li><li>For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.</li></ol><p>This is how the UTF-8 encoding would work:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Char. number range  |        UTF-8 octet sequence</span><br><span class="line">   (hexadecimal)    |              (binary)</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Given an array of integers representing the data, return whether it is a valid utf-8 encoding.</p><p><strong>Note:</strong>The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.</span><br><span class="line"></span><br><span class="line">Return true.</span><br><span class="line">It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.</span><br><span class="line"></span><br><span class="line">Return false.</span><br><span class="line">The first 3 bits are all one&#39;s and the 4th bit is 0 means it is a 3-bytes character.</span><br><span class="line">The next byte is a continuation byte which starts with 10 and that&#39;s correct.</span><br><span class="line">But the second continuation byte does not start with 10, so it is invalid.</span><br></pre></td></tr></table></figure></blockquote><p>这道题使用位运算就可以了, 前几天刚刚做完18600的第一个datalab, 位运算还是挺easy的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; data.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &amp; <span class="number">0x80</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> oneLen = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((<span class="number">0x80</span> &gt;&gt; oneLen) &amp; data[i])&#123;</span><br><span class="line">                    oneLen++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(oneLen &lt;= <span class="number">1</span> || oneLen &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; oneLen; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((data[i + j] &amp; <span class="number">0xc0</span>) != <span class="number">0x80</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i = i + j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 392. Is Subsequence</title>
      <link href="/2016/09/05/leetcode-392-is-subsequence/"/>
      <url>/2016/09/05/leetcode-392-is-subsequence/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string <strong>s</strong> and a string <strong>t</strong>, check if <strong>s</strong> is subsequence of <strong>t</strong>.</p><p>You may assume that there is only lower case English letters in both <strong>s</strong> and <strong>t</strong>. <strong>t</strong> is potentially a very long (length ~= 500,000) string, and <strong>s</strong> is a short string (&lt;=100).</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p><p><strong>Example 1:</strong><strong>s</strong> = <code>&quot;abc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p><p>Return <code>true</code>.</p><p><strong>Example 2:</strong><strong>s</strong> = <code>&quot;axc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p><p>Return <code>false</code>.</p></blockquote><p>双指针, O(n)时间复杂度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length(), tLen = t.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span> &amp;&amp; tLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> sp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tLen; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sp] == t[i]) sp++;</span><br><span class="line">            <span class="keyword">if</span>(sp == sLen) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 109. Convert Sorted List to Binary Search Tree</title>
      <link href="/2016/09/04/leetcode-109-convert-sorted-list-to-binary-search-tree/"/>
      <url>/2016/09/04/leetcode-109-convert-sorted-list-to-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p></blockquote><p>最简单的方法就是遍历一次链表, 把每个节点的值放入一个数组中, 然后就变成了<a href="http://xiadong.info/2016/09/leetcode-108-convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">上一题</a>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            nums.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, nums.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildBST</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        node-&gt;left = buildBST(nums, left, mid);</span><br><span class="line">        node-&gt;right = buildBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不使用辅助空间, 就要实现一个根据节点距头结点的距离来获取节点的函数. 这样的话每次访问节点都要遍历一部分链表.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildBST(head, len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildBST</span><span class="params">(ListNode *head, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">        ListNode *n = getNode(head, mid);</span><br><span class="line">        </span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(n-&gt;val);</span><br><span class="line">        node-&gt;left = buildBST(head, mid);</span><br><span class="line">        node-&gt;right = buildBST(n-&gt;next, len - mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">getNode</span><span class="params">(ListNode *head, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = index;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2016/09/04/leetcode-108-convert-sorted-array-to-binary-search-tree/"/>
      <url>/2016/09/04/leetcode-108-convert-sorted-array-to-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述;</p><blockquote><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p></blockquote><p>根据有序数组来构建一颗平衡二叉搜索树. 比较直观的方法就是选择给定数组的中间位置的元素作为根节点的值, 然后把左边和右边的元素分别递归地生成左右子树, 这样可以保证高度平衡.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBSTImpl(num, <span class="number">0</span>, num.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBSTImpl</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end &lt;= start)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(num[mid]);</span><br><span class="line">        </span><br><span class="line">        root-&gt;left = sortedArrayToBSTImpl(num, start, mid);</span><br><span class="line">        root-&gt;right = sortedArrayToBSTImpl(num, mid + <span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 107. Binary Tree Level Order Traversal II</title>
      <link href="/2016/09/01/leetcode-107-binary-tree-level-order-traversal-ii/"/>
      <url>/2016/09/01/leetcode-107-binary-tree-level-order-traversal-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return its bottom-up level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>先层次遍历, 然后将得到的二维数组颠倒顺序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ret;</span><br><span class="line">        BFS(root);</span><br><span class="line">        reverse(ret.begin(), ret.end());</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; levelQueue;</span><br><span class="line">    </span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line">    levelQueue.push(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!nodeQueue.empty())&#123;</span><br><span class="line">        TreeNode *node = nodeQueue.front();</span><br><span class="line">        <span class="keyword">int</span> nodeLevel = levelQueue.front();</span><br><span class="line">        nodeQueue.pop();</span><br><span class="line">        levelQueue.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nodeLevel &gt;= ret.size())&#123;</span><br><span class="line">            ret.resize(nodeLevel + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret[nodeLevel].push_back(node-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">            nodeQueue.push(node-&gt;left);</span><br><span class="line">            levelQueue.push(nodeLevel + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">            nodeQueue.push(node-&gt;right);</span><br><span class="line">            levelQueue.push(nodeLevel + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link href="/2016/09/01/leetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal/"/>
      <url>/2016/09/01/leetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p><strong>Note:</strong>You may assume that duplicates do not exist in the tree.</p></blockquote><p>与上一题<a href="http://xiadong.info/2016/09/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</a>非常相似, 只不过先序序列变成了后序序列, 实质上并没有什么变化, 仍然使用相同的方法.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTreeImpl(inorder, <span class="number">0</span>, inorder.size(), postorder, <span class="number">0</span>, postorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeImpl</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart == inEnd || postStart == postEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postEnd - <span class="number">1</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> leftLen, rightLen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt; inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                leftLen = i - inStart;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rightLen = (inEnd - inStart - leftLen - <span class="number">1</span>);</span><br><span class="line">        root-&gt;left = buildTreeImpl(inorder, inStart, inStart + leftLen, postorder, postStart, postStart + leftLen);</span><br><span class="line">        root-&gt;right = buildTreeImpl(inorder, inStart + leftLen + <span class="number">1</span>, inEnd, postorder, postStart + leftLen, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2016/09/01/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/"/>
      <url>/2016/09/01/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p><strong>Note:</strong>You may assume that duplicates do not exist in the tree.</p></blockquote><p>通过中序遍历序列和先序遍历序列来还原一颗二叉树. 由于题目指出可以假设树中不存在重复元素, 所以在先序序列的第一个元素就是根节点的值, 然后再中序序列中找到这个值就可以把中序序列划分为左子树的中序序列和右子树的中序序列, 并且得到左右子树的节点数量, 根据节点数量就可以把先序序列划分开来. 然后就可以通过递归来分别构建左右子树.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> buildBinaryTree(preorder, <span class="number">0</span>, preorder.size(), inorder, <span class="number">0</span>, inorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preLeft &gt;= preRight || inLeft &gt;= inRight) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">        <span class="keyword">int</span> rootPosInOrder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inLeft; i &lt; inRight; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == node-&gt;val)&#123;</span><br><span class="line">                rootPosInOrder = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftNum = rootPosInOrder - inLeft, rightNum = inRight - rootPosInOrder - <span class="number">1</span>;</span><br><span class="line">        node-&gt;left = buildBinaryTree(preorder, preLeft + <span class="number">1</span>, preLeft + <span class="number">1</span> + leftNum, inorder, inLeft, inLeft + leftNum);</span><br><span class="line">        node-&gt;right = buildBinaryTree(preorder, preLeft + <span class="number">1</span> + leftNum, preRight, inorder, inLeft + leftNum + <span class="number">1</span>, inRight);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hyper-V为Linux扩大分区</title>
      <link href="/2016/09/01/%E5%9C%A8hyper-v%E4%B8%BAlinux%E6%89%A9%E5%A4%A7%E5%88%86%E5%8C%BA/"/>
      <url>/2016/09/01/%E5%9C%A8hyper-v%E4%B8%BAlinux%E6%89%A9%E5%A4%A7%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题来源">问题来源</h1><p>我在Hyper-V里安装的虚拟机一开始只分配了10G的虚拟硬盘, 今天编译RISC-V Toolchain的时候硬盘空间耗尽了(顺带吐槽一下编译的时候下载源代码再次被网速折磨), 所以就要扩大虚拟磁盘的空间.</p><h1 id="hyper-v中的设置">Hyper-V中的设置</h1><p>首先就是在Hyper-V中的磁盘编辑中修改虚拟磁盘的大小. 这一步没有任何问题, 下一步是修改分区表.</p><h1 id="修改分区表">修改分区表</h1><p>在Linux中要修改一个分区的大小, 必须要把它<code>umount</code>, 但是我要扩展的是整个系统分区, 所以需要用Linux的系统安装光盘启动. 然后运行gparted程序来修改分区大小.</p><h1 id="回到linux中的设置">回到Linux中的设置</h1><p>到了上一步还是不行, 因为我要扩展的是一个逻辑分区 <em>logical volume</em>, 需要在原来的系统中扩展逻辑分区和启用新的分区空间才可以.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lvresize -l 100%VG [your device]</span></span><br></pre></td></tr></table></figure><p><code>100%VG</code>的意思是使用全部空闲空间. 然后启用空间.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> resize2fs [your device]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> 工具 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 104. Maximum Depth of Binary Tree</title>
      <link href="/2016/08/31/leetcode-104-maximum-depth-of-binary-tree/"/>
      <url>/2016/08/31/leetcode-104-maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p></blockquote><p>递归递归递.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_depth = <span class="number">1</span>, right_depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            left_depth = maxDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            right_depth = maxDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> left_depth &gt; right_depth ? left_depth : right_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/2016/08/31/leetcode-103-binary-tree-zigzag-level-order-traversal/"/>
      <url>/2016/08/31/leetcode-103-binary-tree-zigzag-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return its zigzag level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>这道题与上一题<a href="http://xiadong.info/2016/08/leetcode-102-binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>非常相似, 只需要在BFS之后汇总的时候以正反方向间隔的形式放入level中即可. 我是全部正向放入之后再对偶数行颠倒来完成的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals, level;</span><br><span class="line">        generateMap(root, vals, level);</span><br><span class="line">        <span class="keyword">int</span> maxLevel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level.size(); i++) <span class="keyword">if</span>(maxLevel &lt; level[i]) maxLevel = level[i];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">re</span><span class="params">(maxLevel + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.size(); i++)&#123;</span><br><span class="line">            re[level[i]].push_back(vals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxLevel; i += <span class="number">2</span>)&#123;</span><br><span class="line">            reverse(re[i].begin(), re[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateMap</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;level)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; levels;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        levels.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            TreeNode* p = nodes.front();</span><br><span class="line">            <span class="keyword">int</span> l = levels.front();</span><br><span class="line">            vals.push_back(p-&gt;val);</span><br><span class="line">            level.push_back(l);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">                nodes.push(p-&gt;left);</span><br><span class="line">                levels.push(l + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">                nodes.push(p-&gt;right);</span><br><span class="line">                levels.push(l + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            nodes.pop();</span><br><span class="line">            levels.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 102. Binary Tree Level Order Traversal</title>
      <link href="/2016/08/31/leetcode-102-binary-tree-level-order-traversal/"/>
      <url>/2016/08/31/leetcode-102-binary-tree-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return its level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>我的方法是使用广度优先搜索遍历每一个节点并计算出每一个节点的level值, 然后再遍历一次节点把节点放到相应的level中去. 时间和空间复杂度都是O(n).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于BFS的队列, qLevel用于保存BFS中相应节点的level</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; BFS;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qLevel;</span><br><span class="line">        <span class="comment">// 把遍历到的每一个节点都放到vector中保存, 用于最后汇总</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        </span><br><span class="line">        BFS.push(root);</span><br><span class="line">        qLevel.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLevel = <span class="number">0</span>;</span><br><span class="line">        nodes.push_back(root);</span><br><span class="line">        level.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!BFS.empty())&#123;</span><br><span class="line">            TreeNode* node = BFS.front();</span><br><span class="line">            <span class="keyword">int</span> currentLevel = qLevel.front();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                BFS.push(node-&gt;left);</span><br><span class="line">                qLevel.push(currentLevel + <span class="number">1</span>);</span><br><span class="line">                nodes.push_back(node-&gt;left);</span><br><span class="line">                level.push_back(currentLevel + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                BFS.push(node-&gt;right);</span><br><span class="line">                qLevel.push(currentLevel + <span class="number">1</span>);</span><br><span class="line">                nodes.push_back(node-&gt;right);</span><br><span class="line">                level.push_back(currentLevel + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currentLevel + <span class="number">1</span> &gt; maxLevel) maxLevel = currentLevel + <span class="number">1</span>;</span><br><span class="line">            BFS.pop();</span><br><span class="line">            qLevel.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次遍历节点并放到相应的level中去</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">re</span><span class="params">(maxLevel)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++)&#123;</span><br><span class="line">            re[level[i]].push_back(nodes[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 101. Symmetric Tree</title>
      <link href="/2016/08/30/leetcode-101-symmetric-tree/"/>
      <url>/2016/08/30/leetcode-101-symmetric-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong>Bonus points if you could solve it both recursively and iteratively.</p></blockquote><p>最直观的方法就是先把二叉树翻转, 然后再判断两棵二叉树是否相同.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copyTree</span><span class="params">(TreeNode* root, TreeNode *copy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            copy-&gt;left = <span class="keyword">new</span> TreeNode(root-&gt;left-&gt;val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            copy-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        copyTree(root-&gt;left, copy-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            copy-&gt;right = <span class="keyword">new</span> TreeNode(root-&gt;right-&gt;val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            copy-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        copyTree(root-&gt;right, copy-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseTree</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode *tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        reverseTree(root-&gt;left);</span><br><span class="line">        reverseTree(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sameTree</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> sameTree(root1-&gt;left, root2-&gt;left) &amp;&amp; sameTree(root1-&gt;right, root2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        TreeNode *mirrorRoot = <span class="keyword">new</span> TreeNode(root-&gt;val);</span><br><span class="line">        copyTree(root, mirrorRoot);</span><br><span class="line">        reverseTree(mirrorRoot);</span><br><span class="line">        <span class="keyword">return</span> sameTree(root, mirrorRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>非递归的方法就是使用迭代而不是递归来分别从<strong>不同的方向</strong>遍历左右子树, <strong>注意</strong>, 不能用先序遍历或者后序遍历, 比如这组数据<code>[1,2,2,null,3,null,3]</code>使用先序遍历它的左右子树是互为镜像的.</p><p>另外说一句, 直到这里我才去看非递归遍历二叉树的标准方法, 我以前都是用另一个栈来保存节点状态…很有力地证明了我的数据结构课听得很水= =.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* left, TreeNode *right)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; leftPath, rightPath;</span><br><span class="line">        <span class="keyword">while</span>((!leftPath.empty() || left != <span class="literal">nullptr</span>) &amp;&amp; (!rightPath.empty() || right != <span class="literal">nullptr</span>))&#123;</span><br><span class="line">            TreeNode *curLeftNode = <span class="literal">nullptr</span>, *curRightNode = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                leftPath.push(left);</span><br><span class="line">                left = left-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = leftPath.top();</span><br><span class="line">                curLeftNode = left;</span><br><span class="line">                leftPath.pop();</span><br><span class="line">                left = left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                rightPath.push(right);</span><br><span class="line">                right = right-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = rightPath.top();</span><br><span class="line">                curRightNode = right;</span><br><span class="line">                rightPath.pop();</span><br><span class="line">                right = right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((curLeftNode &amp;&amp; curRightNode &amp;&amp; curLeftNode-&gt;val != curRightNode-&gt;val) || (!(curLeftNode &amp;&amp; curRightNode) &amp;&amp; !(curLeftNode == <span class="literal">nullptr</span> &amp;&amp; curRightNode == <span class="literal">nullptr</span>))) &#123;</span><br><span class="line">                <span class="comment">// 这个布尔表达式的意思是当前的左右节点都不为null并且值不等, 或者其中有且只有</span></span><br><span class="line">                <span class="comment">// 一个null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftPath.empty() &amp;&amp; left == <span class="literal">nullptr</span> &amp;&amp; rightPath.empty() &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>附上标准的非递归遍历方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderIter</span><span class="params">(struct node *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;struct node *&gt; s;  </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">" "</span>; <span class="comment">//访问结点并入栈  </span></span><br><span class="line">            s.push(root);                </span><br><span class="line">            root = root-&gt;left;         <span class="comment">//访问左子树  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            root = s.top();            <span class="comment">//回溯至父亲结点  </span></span><br><span class="line">            s.pop();  </span><br><span class="line">            root = root-&gt;right;        <span class="comment">//访问右子树  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderIter</span><span class="params">(struct node *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;struct node *&gt; s;  </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !s.empty()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            s.push(root);  </span><br><span class="line">            root = root-&gt;left;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            root = s.top();  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">" "</span>;  <span class="comment">//访问完左子树后才访问根结点  </span></span><br><span class="line">            s.pop();  </span><br><span class="line">            root = root-&gt;right;        <span class="comment">//访问右子树  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderIter</span><span class="params">(struct node *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;struct node*&gt; s, output;  </span><br><span class="line">    s.push(root);  </span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">curr</span> = <span class="title">s</span>.<span class="title">top</span>();</span>  </span><br><span class="line">        output.push(curr);  </span><br><span class="line">        s.pop();  </span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;left)  </span><br><span class="line">            s.push(curr-&gt;left);  </span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;right)  </span><br><span class="line">            s.push(curr-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (!output.empty()) &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; output.top()-&gt;data &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">        output.pop();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 391. Perfect Rectangle</title>
      <link href="/2016/08/30/leetcode-391-perfect-rectangle/"/>
      <url>/2016/08/30/leetcode-391-perfect-rectangle/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given N axis-aligned rectangles where N &gt; 0, determine if they all together form an exact cover of a rectangular region.</p><p>Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).</p><p><img src="https://leetcode.com/static/images/problemset/rectangle_perfect.gif" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rectangles &#x3D; [</span><br><span class="line">  [1,1,3,3],</span><br><span class="line">  [3,1,4,2],</span><br><span class="line">  [3,2,4,4],</span><br><span class="line">  [1,3,2,4],</span><br><span class="line">  [2,3,3,4]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return true. All 5 rectangles together form an exact cover of a rectangular region.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/static/images/problemset/rectangle_separated.gif" alt="img"></p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rectangles &#x3D; [</span><br><span class="line">  [1,1,2,3],</span><br><span class="line">  [1,3,2,4],</span><br><span class="line">  [3,1,4,2],</span><br><span class="line">  [3,2,4,4]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return false. Because there is a gap between the two rectangular regions.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/static/images/problemset/rectangle_hole.gif" alt="img"></p><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rectangles &#x3D; [</span><br><span class="line">  [1,1,3,3],</span><br><span class="line">  [3,1,4,2],</span><br><span class="line">  [1,3,2,4],</span><br><span class="line">  [3,2,4,4]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return false. Because there is a gap in the top center.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/static/images/problemset/rectangle_intersect.gif" alt="img"></p><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rectangles &#x3D; [</span><br><span class="line">  [1,1,3,3],</span><br><span class="line">  [3,1,4,2],</span><br><span class="line">  [1,3,2,4],</span><br><span class="line">  [2,2,4,4]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Return false. Because two of the rectangles overlap with each other.</span><br></pre></td></tr></table></figure></blockquote><p>一开始我对于这道题的思路是这样的:</p><ul><li>第一步, 遍历所有小的矩形计算它们的面积之和并且计算出最终应该拼成的大矩形的端点位置(左下角和右上角), 如果面积之和与大矩形的面积不相等, 那么就肯定不可能拼成.</li><li>第二步, 判断小矩形之间是不是有重叠.</li></ul><p>问题在于第二步, 判断矩形是否有重叠比较容易, 但是两两比较要求O(n<sup>2</sup>)的时间复杂度, 超时了.</p><p>如果不对小矩形两两判断是否有重叠而使用累积的办法看某个小矩形与之前所有小矩形拼成的多边形是否有重合的话, 实现起来相当复杂, 所以应该有更好的方法.</p><p>在Discuss中看到了一个相当妙的办法<a href="https://discuss.leetcode.com/topic/56081/easy-understanding-o-n-python-solution" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/56081/easy-understanding-o-n-python-solution</a>, 基本思想就是如果最终能拼成大矩形, 那么除了大矩形的四个顶点只出现一次外, 其他的每个小矩形的顶点只能出现两次或者四次. 所以就可以用一个map来记录小矩形的每个顶点出现的次数, 然后再遍历这个map判断其中的顶点是不是都满足条件. 时间复杂度(O(nlogn + n)).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleCover</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rectangles.size(), areaSum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">finalRect</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; corners;</span><br><span class="line">        finalRect[<span class="number">0</span>] = finalRect[<span class="number">1</span>] = INT_MAX, finalRect[<span class="number">2</span>] = finalRect[<span class="number">3</span>] = INT_MIN;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">areas</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            areas[i] = (rectangles[i][<span class="number">2</span>] - rectangles[i][<span class="number">0</span>]) * (rectangles[i][<span class="number">3</span>] - rectangles[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; corner = &#123;&#123;rectangles[i][<span class="number">0</span>], rectangles[i][<span class="number">1</span>]&#125;, &#123;rectangles[i][<span class="number">2</span>], rectangles[i][<span class="number">3</span>]&#125;, &#123;rectangles[i][<span class="number">0</span>], rectangles[i][<span class="number">3</span>]&#125;, &#123;rectangles[i][<span class="number">2</span>], rectangles[i][<span class="number">1</span>]&#125;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(corners.count(corner[j]))&#123;</span><br><span class="line">                    corners[corner[j]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    corners[corner[j]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            finalRect[<span class="number">0</span>] = min(finalRect[<span class="number">0</span>], rectangles[i][<span class="number">0</span>]);</span><br><span class="line">            finalRect[<span class="number">1</span>] = min(finalRect[<span class="number">1</span>], rectangles[i][<span class="number">1</span>]);</span><br><span class="line">            finalRect[<span class="number">2</span>] = max(finalRect[<span class="number">2</span>], rectangles[i][<span class="number">2</span>]);</span><br><span class="line">            finalRect[<span class="number">3</span>] = max(finalRect[<span class="number">3</span>], rectangles[i][<span class="number">3</span>]);</span><br><span class="line">            areaSum += areas[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> finalArea = (finalRect[<span class="number">2</span>] - finalRect[<span class="number">0</span>]) * (finalRect[<span class="number">3</span>] - finalRect[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(areaSum != finalArea) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = corners.begin(); i != corners.end(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((i-&gt;first.first == finalRect[<span class="number">0</span>] &amp;&amp; i-&gt;first.second == finalRect[<span class="number">1</span>]) || (i-&gt;first.first == finalRect[<span class="number">2</span>] &amp;&amp; i-&gt;first.second == finalRect[<span class="number">3</span>]) || (i-&gt;first.first == finalRect[<span class="number">0</span>] &amp;&amp; i-&gt;first.second == finalRect[<span class="number">3</span>]) || (i-&gt;first.first == finalRect[<span class="number">2</span>] &amp;&amp; i-&gt;first.second == finalRect[<span class="number">1</span>])))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-&gt;second != <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-&gt;second == <span class="number">2</span> || i-&gt;second == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 389. Find the Difference</title>
      <link href="/2016/08/29/leetcode-389-find-the-difference/"/>
      <url>/2016/08/29/leetcode-389-find-the-difference/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two strings <strong>s</strong> and <strong>t</strong> which consist of only lowercase letters.</p><p>String <strong>t</strong> is generated by random shuffling string <strong>s</strong> and then add one more letter at a random position.</p><p>Find the letter that was added in <strong>t</strong>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;abcd&quot;</span><br><span class="line">t &#x3D; &quot;abcde&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; is the letter that was added.</span><br></pre></td></tr></table></figure></blockquote><p>使用哈希表来记录每个字母出现的次数, 多出现的字符就是增加的字符.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            nums[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--nums[t[i] - <span class="string">'a'</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以使用异或. 由于s与t除了一个元素以外其他都相同, 所以使用0分别于s与t的每个元素异或, 得到的就是多余的那一个字符.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ch ^= s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            ch ^= t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 100. Same Tree</title>
      <link href="/2016/08/28/leetcode-100-same-tree/"/>
      <url>/2016/08/28/leetcode-100-same-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two binary trees, write a function to check if they are equal or not.</p><p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p></blockquote><p>很简单, 使用递归来判断每个节点是否相等.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) || (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 99. Recover Binary Search Tree</title>
      <link href="/2016/08/28/leetcode-99-recover-binary-search-tree/"/>
      <url>/2016/08/28/leetcode-99-recover-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Two elements of a binary search tree (BST) are swapped by mistake.</p><p>Recover the tree without changing its structure.</p><p>Note:A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p></blockquote><p>使用O(n)辅助空间的方法就是使用中序遍历从BST中获得一个有序递增的序列, 但是其中有两个元素的位置交换了. 被交换的元素的特征就是前一个元素大于后一个元素, 找到这样两个元素再把它们交换回来即可, 如果只找到了一个这样的元素, 说明是相邻的两个元素交换了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; seq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mistakeNodes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i]-&gt;val &gt; seq[i + <span class="number">1</span>]-&gt;val)&#123;</span><br><span class="line">                mistakeNodes.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mistakeNodes.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            swap(seq[mistakeNodes[<span class="number">0</span>]]-&gt;val, seq[mistakeNodes[<span class="number">0</span>] + <span class="number">1</span>]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            swap(seq[mistakeNodes[<span class="number">0</span>]]-&gt;val, seq[mistakeNodes[<span class="number">1</span>] + <span class="number">1</span>]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        seq.push_back(root);</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而把这一思路推广到不使用辅助空间, 很容易就可以发现我们并不需要一个完整的序列, 只需要相邻两个值的大小关系, 所以我们只要在遍历过程中维持两个节点值即可. 另外由于我们没有完整的序列, 所以在mistakeNodes中要同时保存前一个元素比后一个元素大的这两个元素, 因为对于被交换的较小值来说, 它在后一个元素的位置, 而对于较大值来说, 它位于前一个元素的位置. 当然也可以通过判断mistakeNodes中是否已经有元素来避免同时保存.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; mistakeNodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; tmpNodes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        tmpNodes.resize(<span class="number">2</span>);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">if</span>(mistakeNodes.size() == <span class="number">2</span>)&#123;</span><br><span class="line">            swap(mistakeNodes[<span class="number">0</span>]-&gt;val, mistakeNodes[<span class="number">1</span>]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            swap(mistakeNodes[<span class="number">0</span>]-&gt;val, mistakeNodes[<span class="number">3</span>]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || mistakeNodes.size() == <span class="number">4</span>) <span class="keyword">return</span> ;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        tmpNodes[<span class="number">0</span>] = tmpNodes[<span class="number">1</span>];</span><br><span class="line">        tmpNodes[<span class="number">1</span>] = root;</span><br><span class="line">        <span class="keyword">if</span>(tmpNodes[<span class="number">0</span>] &amp;&amp; tmpNodes[<span class="number">0</span>]-&gt;val &gt; tmpNodes[<span class="number">1</span>]-&gt;val)&#123;</span><br><span class="line">            mistakeNodes.push_back(tmpNodes[<span class="number">0</span>]);</span><br><span class="line">            mistakeNodes.push_back(tmpNodes[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 98. Validate Binary Search Tree</title>
      <link href="/2016/08/28/leetcode-98-validate-binary-search-tree/"/>
      <url>/2016/08/28/leetcode-98-validate-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,1,3]</span><br></pre></td></tr></table></figure><p>, return true.</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure><p>, return false.</p></blockquote><p>验证一个二叉搜索树是否合法, 使用递归的方法来依次遍历左右子树.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; BSTMax(root-&gt;left) &gt;= root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; BSTMin(root-&gt;right) &lt;= root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BSTMax</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BSTMax(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BSTMin</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BSTMin(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 97. Interleaving String</title>
      <link href="/2016/08/24/leetcode-97-interleaving-string/"/>
      <url>/2016/08/24/leetcode-97-interleaving-string/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p><p>For example,Given:<em>s1</em> = <code>&quot;aabcc&quot;</code>,<em>s2</em> = <code>&quot;dbbca&quot;</code>,</p><p>When <em>s3</em> = <code>&quot;aadbbcbcac&quot;</code>, return true.When <em>s3</em> = <code>&quot;aadbbbaccc&quot;</code>, return false.</p></blockquote><p>使用动态规划, <code>dp[i][j]</code>代表s1的前i个字符与s2的前j个字符是否能组成s3的前i+j个字符.</p><p>显然<code>dp[0][0]</code>能组成空字符串, 所以<code>dp[0][0]</code>为真. 而对于<code>i=0</code>和<code>j=0</code>的情况来说, 直接比较s1的前i个字符或s2的前j个字符与s3是否相同就可以了.</p><p>接下来的<code>dp[i][j]</code>分为两种情况:</p><ol><li><code>s3[i+j-1]</code>的字符与<code>s1[i-1]</code>相同, 代表<code>s3[i+j-1]</code>的字符可以从s1中取得. 此时<code>dp[i][j]</code>为真则要求<code>dp[i-1][j]</code>为真.</li><li><code>s3[i+j-1]</code>的字符与<code>s2[j-1]</code>相同, 代表<code>s3[i+j-1]</code>的字符可以从s2中取得. 此时<code>dp[i][j]</code>为真则要求<code>dp[i][j-1]</code>为真.</li></ol><p>递推方程为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; (dp[i - 1][j] &amp;&amp; s3[i + j - 1] &#x3D;&#x3D; s1[i - 1]) || (dp[i][j - 1] &amp;&amp; s3[i + j - 1] &#x3D;&#x3D; s2[j - 1])</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() + s2.length() != s3.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s2.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i - <span class="number">1</span>][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s2.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[<span class="number">0</span>][i - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s2[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((dp[i - <span class="number">1</span>][j] &amp;&amp; s3[i + j - <span class="number">1</span>] == s1[i - <span class="number">1</span>]) || (dp[i][j - <span class="number">1</span>] &amp;&amp; s3[i + j - <span class="number">1</span>] == s2[j - <span class="number">1</span>])) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.size()][s2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 96. Unique Binary Search Trees</title>
      <link href="/2016/08/24/leetcode-96-unique-binary-search-trees/"/>
      <url>/2016/08/24/leetcode-96-unique-binary-search-trees/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>?</p><p>For example,Given <em>n</em> = 3, there are a total of 5 unique BST’s.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> &#x2F;     &#x2F;       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure></blockquote><p>采用递归+动态规划来解决.</p><p>首先一颗n个节点的BST, 假设它的根节点值为r(1&lt;=r&lt;=n), 那么它的不同形态数量等于所有左子树的形态数量(r-1个节点)×所有右子树的形态数量(n-r个节点), 而因为一颗BST的形态数量只与节点数量有关而与节点的具体值无关, 所以可以用一个数组来记录已经计算过数量的n来减少计算.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> numsTrees(n, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numsTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num += ((nums[i - <span class="number">1</span>] == <span class="number">-1</span> ? numsTrees(i - <span class="number">1</span>, nums) : nums[i - <span class="number">1</span>]) * (nums[n - i] == <span class="number">-1</span> ? numsTrees(n - i, nums) : nums[n - i]));</span><br><span class="line">        &#125;</span><br><span class="line">        nums[n] = num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 95. Unique Binary Search Trees II</title>
      <link href="/2016/08/24/leetcode-95-unique-binary-search-trees-ii/"/>
      <url>/2016/08/24/leetcode-95-unique-binary-search-trees-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an integer <em>n</em>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>.</p><p>For example,Given <em>n</em> = 3, your program should return all 5 unique BST’s shown below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> &#x2F;     &#x2F;       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure></blockquote><p>返回由1-n组成的所有可能的二叉搜索树. 先来复习一下二叉搜索树BST的定义:</p><ol><li>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol><p>根据定义, 很容易想到通过递归的方法来产生所有可能的BST, 对于[1,n]n个节点, 从中取一个值1&lt;=r&lt;=n, 则属于[1, r)的值在左子树, 属于(r,n]的值在右子树, 再分别调用递归函数生成相应的左右子树.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildBST(<span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">buildBST</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> re;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> leftVector = buildBST(left, i);</span><br><span class="line">            <span class="keyword">auto</span> rightVector = buildBST(i + <span class="number">1</span>, right);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; leftVector.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rightVector.empty())&#123;</span><br><span class="line">                    TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    node-&gt;left = leftVector[j];</span><br><span class="line">                    node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    re.push_back(node);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; rightVector.size(); k++)&#123;</span><br><span class="line">                        TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        node-&gt;left = leftVector[j];</span><br><span class="line">                        node-&gt;right = rightVector[k];</span><br><span class="line">                        re.push_back(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftVector.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(rightVector.empty())&#123;</span><br><span class="line">                    TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                    node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    re.push_back(node);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; rightVector.size(); k++)&#123;</span><br><span class="line">                        TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                        node-&gt;right = rightVector[k];</span><br><span class="line">                        re.push_back(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 388. Longest Absolute File Path</title>
      <link href="/2016/08/23/leetcode-388-longest-absolute-file-path/"/>
      <url>/2016/08/23/leetcode-388-longest-absolute-file-path/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Suppose we abstract our file system by a string in the following manner:</p><p>The string “dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext” represents:</p><p>dirsubdir1subdir2file.extThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.</p><p>The string “dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext” represents:</p><p>dirsubdir1file1.extsubsubdir1subdir2subsubdir2file2.extThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.</p><p>We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is “dir/subdir2/subsubdir2/file2.ext”, and its length is 32 (not including the double quotes).</p><p>Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.</p><p>Note:The name of a file contains at least a . and an extension.The name of a directory or sub-directory will not contain a …Time complexity required: O(n) where n is the size of the input string.</p><p>Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.</p></blockquote><p>虽然题目描述非常的长, 但是实际的难度并不大. 目录结构是一个树形结构, 使用栈可以模拟深度优先搜索, 遍历根目录到每一个叶子节点的路径, 从中找出总长度最长的一条路径. 每个节点通过<code>\n</code>分割, 而每个节点前的<code>\t</code>的个数就是该节点所的层次.</p><p>要注意输入字符串中<code>\n</code>和<code>\t</code>都只是<strong>一个字符</strong>而不是两个字符.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLongestPath</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathLevel; <span class="comment">// 记录path中节点的层次</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path; <span class="comment">// 记录路径</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, nextPos = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            nextPos = input.find(<span class="string">"\n"</span>, pos);</span><br><span class="line">            <span class="built_in">string</span> node = input.substr(pos, nextPos - pos); <span class="comment">// 获取当前节点的字符串</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> level = getLevel(node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!pathLevel.empty() &amp;&amp; pathLevel.back() &gt;= level)&#123; <span class="comment">// 路径退回到当前节点的上一层</span></span><br><span class="line">                pathLevel.pop_back();</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            path.push_back(node);</span><br><span class="line">            pathLevel.push_back(level);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(isFile(node))&#123;</span><br><span class="line">                maxLen = max(maxLen, getTotalLen(path) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nextPos == <span class="built_in">string</span>::npos) <span class="keyword">break</span>;</span><br><span class="line">            pos = nextPos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFile</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123; <span class="comment">// 判断是不是file</span></span><br><span class="line">        <span class="keyword">int</span> index = s.find(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="built_in">string</span>::npos || index == s.length() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTotalLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span>&#123; <span class="comment">// 根据path计算总长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : v)&#123;</span><br><span class="line">            len += s.length();</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLevel</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123; <span class="comment">// 计算字符串头部\t的个数</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'\t'</span> )&#123;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.substr(level); <span class="comment">// 清除头部的\t</span></span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 94. Binary Tree Inorder Traversal</title>
      <link href="/2016/08/22/leetcode-94-binary-tree-inorder-traversal/"/>
      <url>/2016/08/22/leetcode-94-binary-tree-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><p>For example:Given binary tree <code>[1,null,2,3]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return <code>[1,3,2]</code>.</p><p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p></blockquote><p>返回一个树的中序遍历序列, 既然题目要求不用递归用迭代, 那么就可以使用栈来模拟递归. 因为使用栈来模拟无法直到栈顶的节点的左子树有没有访问过, 所以还要同时记录每个节点的状态. 我用-1表示未访问左子树, 0表示已访问左子树未访问右子树, 1表示左右子树都已经访问过.</p><p>一开始我用vector来作为栈使用, 运行时间4ms, 查看discuss后换用deque运行时间变为0ms. vector在分配的内存不够的情况下的扩充操作真的开销很大.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; path;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; nodeState;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        </span><br><span class="line">        path.push_back(root);</span><br><span class="line">        nodeState.push_back(<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        TreeNode *node;</span><br><span class="line">        <span class="keyword">while</span>(!path.empty())&#123;</span><br><span class="line">            node = path.back();</span><br><span class="line">            <span class="keyword">if</span>(nodeState.back() == <span class="number">1</span>)&#123;</span><br><span class="line">                path.pop_back();</span><br><span class="line">                nodeState.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left &amp;&amp; nodeState.back() == <span class="number">-1</span>)&#123;</span><br><span class="line">                nodeState.back() = <span class="number">0</span>;</span><br><span class="line">                path.push_back(node-&gt;left);</span><br><span class="line">                nodeState.push_back(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!node-&gt;left &amp;&amp; nodeState.back() == <span class="number">-1</span>)&#123;</span><br><span class="line">                nodeState.back() = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;right &amp;&amp; nodeState.back() == <span class="number">0</span>)&#123;</span><br><span class="line">                ret.push_back(node-&gt;val);</span><br><span class="line">                nodeState.back() = <span class="number">1</span>;</span><br><span class="line">                path.push_back(node-&gt;right);</span><br><span class="line">                nodeState.push_back(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret.push_back(node-&gt;val);</span><br><span class="line">                nodeState.back() = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装YCM中遇到的问题</title>
      <link href="/2016/08/22/%E5%AE%89%E8%A3%85ycm%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2016/08/22/%E5%AE%89%E8%A3%85ycm%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>说到VIM的代码补全, YouCompleteMe算是一个非常有名的插件了, 只不过由于它提供的功能已经大大超过了一个文本编辑器的功能, 所以安装起来相当复杂. 在这里记录自己在安装过程中遇到的问题, 安装步骤参考官方手册: <a href="http://valloric.github.io/YouCompleteMe/" target="_blank" rel="noopener">http://valloric.github.io/YouCompleteMe/</a></p><p>操作系统Ubuntu 14.04</p><h4 id="youcompleteme-unavailable-requires-vim-compiled-with-python-2-6-or-3-3-support">YouCompleteMe unavailable: requires Vim compiled with Python (2.6+ or 3.3+) support</h4><p>当前的VIM版本不支持Python脚本, 我通过安装<a href="http://packages.ubuntu.com/Trusty/editors/vim-nox" target="_blank" rel="noopener">vim-nox</a>解决.</p><h4 id="编译ycm-core-library时提示-stdexcept-file-not-found">编译<code>ycm_core</code> library时提示’stdexcept’ file not found</h4><p>通过<code>sudo apt-get install clang</code>安装clang.</p><h4 id="运行时提示-the-ycmd-server-shut-down-restart-with-ycmrestartserver-ycm-core-library-compiled-for-python-2-but-loaded-in-python-3-set-the-g-ycm-server-python-interpreter-option-to-a-python-2-interpreter-path">运行时提示: The ycmd server SHUT DOWN (restart with ‘:YcmRestartServer’). YCM core library compiled for Python 2 but loaded in Python 3. Set the ‘g:ycm_server_python_interpreter’ option to a Python 2 interpreter path.</h4><p>在vimrc中加入<code>let g:ycm_server_python_interpreter='/usr/bin/python'</code>来指定python2.x的程序路径.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Linux </tag>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 93. Restore IP Addresses</title>
      <link href="/2016/08/21/leetcode-93-restore-ip-addresses/"/>
      <url>/2016/08/21/leetcode-93-restore-ip-addresses/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p><p>For example:Given <code>&quot;25525511135&quot;</code>,</p><p>return <code>[&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code>. (Order does not matter)</p></blockquote><p>返回从一个字符串中可以得到多少个合法的IP地址, 使用回溯法遍历所有可能的组合. 由于最多只能有四个数字组成IP地址, 所以可以用四重循环来实现.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">12</span> || s.length() &lt; <span class="number">4</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="built_in">string</span> a, b, c, d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> &amp;&amp; i &lt;= s.size() - <span class="number">3</span>; i++)&#123;</span><br><span class="line">            a = s.substr(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span>(!checkValid(a)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span> &amp;&amp; i + j &lt;= s.size() - <span class="number">2</span>; j++)&#123;</span><br><span class="line">                b = s.substr(i, j);</span><br><span class="line">                <span class="keyword">if</span>(!checkValid(b)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">3</span> &amp;&amp; i + j + k &lt;= s.size() - <span class="number">1</span>; k++)&#123;</span><br><span class="line">                    c = s.substr(i + j, k);</span><br><span class="line">                    <span class="keyword">if</span>(!checkValid(c)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">3</span> &amp;&amp; i + j + k + l &lt;= s.size(); l++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i + j + k + l != s.size())</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        d = s.substr(i + j + k, l);</span><br><span class="line">                        <span class="keyword">if</span>(checkValid(d))&#123;</span><br><span class="line">                            <span class="built_in">string</span> t;</span><br><span class="line">                            t = a + <span class="string">"."</span> + b + <span class="string">"."</span> + c + <span class="string">"."</span> + d;</span><br><span class="line">                            re.push_back(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValid</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; s.size() != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::stoi(s);</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">255</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 92. Reverse Linked List II</title>
      <link href="/2016/08/21/leetcode-92-reverse-linked-list-ii/"/>
      <url>/2016/08/21/leetcode-92-reverse-linked-list-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p><p>For example:Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p><p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p><p><strong>Note:</strong>Given <em>m</em>, <em>n</em> satisfy the following condition:1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p></blockquote><p>在只遍历一次并且不使用额外存储空间的情况下反转单向链表中第m个节点到第n个节点中的节点. 这道题目要求只遍历一次并且不使用额外空间, 那么就要用两个指针来记录当前节点与前一节点, 对于m与n之间的节点, 将当前节点指向前一节点. 第m-1个节点和第n+1个节点在最后处理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *start, *end, *p = head, *prev = <span class="literal">nullptr</span>, *startPrev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123; <span class="comment">// 查找翻转开始的节点</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                start = p;</span><br><span class="line">                startPrev = prev;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = start;</span><br><span class="line">        ListNode *pp = p-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i != n)&#123; <span class="comment">// 翻转节点</span></span><br><span class="line">            ListNode *tmp = pp-&gt;next;</span><br><span class="line">            pp-&gt;next = p;</span><br><span class="line">            p = pp;</span><br><span class="line">            pp = tmp;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        start-&gt;next = pp; <span class="comment">// 翻转后的头结点</span></span><br><span class="line">        <span class="keyword">if</span>(startPrev)&#123; <span class="comment">// 判断是不是从第一个节点开始翻转</span></span><br><span class="line">            startPrev-&gt;next = p;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 91. Decode Ways</title>
      <link href="/2016/08/20/leetcode-91-decode-ways/"/>
      <url>/2016/08/20/leetcode-91-decode-ways/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Given an encoded message containing digits, determine the total number of ways to decode it.</p><p>For example,Given encoded message <code>&quot;12&quot;</code>, it could be decoded as <code>&quot;AB&quot;</code> (1 2) or <code>&quot;L&quot;</code> (12).</p><p>The number of ways decoding <code>&quot;12&quot;</code> is 2.</p></blockquote><p>动态规划, 最后一个字母可以是一位数字或者两位数字. 在最后一位不是0时可以是一位数字, 在倒数第二位为1, 或倒数第二位为2且最后一位小于等于6时可以为两位数字, 解码的不同方法数量为这两种情况之和.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> one;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">'0'</span>)</span><br><span class="line">                one = num[<span class="number">0</span>] + num[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                one = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i - <span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                two = num[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i - <span class="number">1</span>] == <span class="string">'2'</span> &amp;&amp; s[i] &lt;= <span class="string">'6'</span>)&#123;</span><br><span class="line">                two = num[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            num[<span class="number">0</span>] = one;</span><br><span class="line">            num[<span class="number">1</span>] = two;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[<span class="number">0</span>] + num[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 90. Subsets II</title>
      <link href="/2016/08/19/leetcode-90-subsets-ii/"/>
      <url>/2016/08/19/leetcode-90-subsets-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets.</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>For example,If <strong>nums</strong> = <code>[1,2,2]</code>, a solution is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>返回一个包含重复元素的集合的所有子集, 要求不能重复. 获得子集的思路都是使用回溯法, 如果不考虑重复问题, 那么整个的实现过程可以分为两步:</p><ol><li>实现从nums中获得n个元素的所有情况函数, 使用递归, 即先取一个元素, 然后从之后的数组中再取n-1个元素.</li><li>从nums中取得1个到nums.size()个元素</li></ol><p>对于去除重复的情况, 在选择元素的时候跳过之后的与该元素相等的元素就可以避免重复, 为此, 要先对nums排序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        ret.push_back(path);</span><br><span class="line">        len = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;</span><br><span class="line">            subsetWithN(nums, <span class="number">0</span>, i, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 从nums中从start开始取得n个元素并放入ret中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subsetWithN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            ret.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= len - n; i++)&#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            subsetWithN(nums, i + <span class="number">1</span>, n - <span class="number">1</span>, path); <span class="comment">// 递归调用</span></span><br><span class="line">            path.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(i + <span class="number">1</span> &lt;= len - n &amp;&amp; nums[i] == nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 89. Gray Code</title>
      <link href="/2016/08/19/leetcode-89-gray-code/"/>
      <url>/2016/08/19/leetcode-89-gray-code/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p><p>Given a non-negative integer <em>n</em> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p><p>For example, given <em>n</em> = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong>For a given <em>n</em>, a gray code sequence is not uniquely defined.</p><p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p><p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p></blockquote><p>计算Gray code, 两个数的二进制表示只有一位不同, 则这两个数为gray code. 这个题有多个可能的解, 但是LeetCode只判断一种正确解, 就是每次变换尽可能低位的二进制位.</p><p>变换一个数中的某一位可以通过位运算实现, 所以主要问题就在如何判断一个数是否已经出现, 我使用<code>unordered_set</code>来保存已经选出来的gray code. 因为测试数据只有12组, 所以也可以使用一个2^12 + 1大小的数组来保存数字有没有出现过.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; codes;</span><br><span class="line">        codes.insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpBits = bits ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span>(codes.count(tmpBits))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                codes.insert(tmpBits);</span><br><span class="line">                ret.push_back(tmpBits);</span><br><span class="line">                bits = tmpBits;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 88. Merge Sorted Array</title>
      <link href="/2016/08/19/leetcode-88-merge-sorted-array/"/>
      <url>/2016/08/19/leetcode-88-merge-sorted-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p><strong>Note:</strong>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p></blockquote><p>合并两个有序数组, 合并的结果放在第一个数组中, 数组长度通过函数参数给出, 所以不能使用<code>size()</code>成员函数来获得数组长度.</p><p>使用另一个数组nums3来保存原来nums1的元素, 然后再逐个比较nums2和nums3中的元素大小, 放入nums1中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums3;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            nums3.push_back(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nums2.empty() || !nums3.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2.empty())&#123;</span><br><span class="line">                nums1[p--] = nums3.back();</span><br><span class="line">                nums3.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums3.empty())&#123;</span><br><span class="line">                nums1[p--] = nums2.back();</span><br><span class="line">                nums2.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums2.back() &gt; nums3.back())&#123;</span><br><span class="line">                nums1[p--] = nums2.back();</span><br><span class="line">                nums2.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[p--] = nums3.back();</span><br><span class="line">                nums3.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 87. Scramble String</title>
      <link href="/2016/08/18/leetcode-87-scramble-string/"/>
      <url>/2016/08/18/leetcode-87-scramble-string/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p><p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    great</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  gr    eat</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">g   r  e   at</span><br><span class="line">           &#x2F; \</span><br><span class="line">          a   t</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    rgeat</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  rg    eat</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">r   g  e   at</span><br><span class="line">           &#x2F; \</span><br><span class="line">          a   t</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    rgtae</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  rg    tae</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">r   g  ta  e</span><br><span class="line">       &#x2F; \</span><br><span class="line">      t   a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p></blockquote><p>看完这道题, 首先想到的是使用递归, 但是思维惯性让我觉得递归可能超时, 所以按照tag中的动态规划方法来做, 我是使用了三维数组来进行动态规划, 有四重循环, 所以可能还有优化空间. <code>dp[i][j][k]</code>表示s1[i]和s2[j]开始的长度为k的子串是不是scramble的, 最后要返回的结果是<code>dp[0][0][s1.length()]</code>, 所以i和j要从大到小遍历.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s1.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(len, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len + <span class="number">1</span>, <span class="number">0</span>)))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i] == s2[j])&#123;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; i + k &lt;= len &amp;&amp; j + k &lt;= len; k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; k &amp;&amp; !dp[i][j][k]; r++)&#123;</span><br><span class="line">                        dp[i][j][k] = (dp[i][j][r] &amp;&amp; dp[i + r][j + r][k - r]) || (dp[i][j + k - r][r] &amp;&amp; dp[i + r][j][k - r]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这个方法速度并不是很理想, 比较快的方法反而是递归+剪枝, 在递归前先判断字符串中字母数量是不是相同, 如果不相同则可以直接返回false.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isScrambleImpl(s1, s2, <span class="number">0</span>, <span class="number">0</span>, s1.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScrambleImpl</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2, <span class="keyword">int</span> start1, <span class="keyword">int</span> start2, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">charTimes</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start1; i &lt; start1 + len; i++)&#123;</span><br><span class="line">            charTimes[s1[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag  = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start2; i &lt; start2 + len; i++)&#123;</span><br><span class="line">            charTimes[s2[i] - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(charTimes[s2[i] - <span class="string">'a'</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; len == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 只有一个字母并且相同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((isScrambleImpl(s1, s2, start1, start2, i) &amp;&amp; isScrambleImpl(s1, s2, start1 + i, start2 + i, len - i))</span><br><span class="line">                || (isScrambleImpl(s1, s2, start1, start2 + len - i, i) &amp;&amp; isScrambleImpl(s1, s2, start1 + i, start2, len - i)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 86. Partition List</title>
      <link href="/2016/08/17/leetcode-86-partition-list/"/>
      <url>/2016/08/17/leetcode-86-partition-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>For example,Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p></blockquote><p>使用两个临时的链表分别保存小于x和大于等于x的值, 最后再把它们连接到一起.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *less = <span class="keyword">new</span> ListNode(<span class="number">0</span>), *greater = <span class="keyword">new</span> ListNode(<span class="number">0</span>), *p1 = less, *p2 = greater, *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val &lt; x)&#123;</span><br><span class="line">                p1-&gt;next = <span class="keyword">new</span> ListNode(p-&gt;val);</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p2-&gt;next = <span class="keyword">new</span> ListNode(p-&gt;val);</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1-&gt;next = greater-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> less-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 85. Maximal Rectangle</title>
      <link href="/2016/08/17/leetcode-85-maximal-rectangle/"/>
      <url>/2016/08/17/leetcode-85-maximal-rectangle/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>For example, given the following matrix:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Return 6.</p></blockquote><p>本来我想直接用动态规划, 但是做起来非常麻烦. 然后想起了上一道题<a href="http://xiadong.info/2016/08/leetcode-84-largest-rectangle-in-histogram/" target="_blank" rel="noopener">Largest Rectangle in Histogram</a>是本题解决的步骤之一, 先用动态规划法计算出matrix中每个元素的高(就是该元素和该元素之上的1的个数), 然后以行为单位计算最大的矩形面积.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size(), col;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">heights</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            heights[<span class="number">0</span>][j] = (matrix[<span class="number">0</span>][j] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                heights[i][j] = (matrix[i][j] == <span class="string">'1'</span> ? heights[i - <span class="number">1</span>][j] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            maxArea = max(maxArea, largestRectangleArea(heights[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || heights[i] &gt; heights[s.back()])&#123;</span><br><span class="line">                s.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.empty() &amp;&amp; heights[s.back()] &gt;= heights[i])&#123;</span><br><span class="line">                    <span class="keyword">int</span> h = heights[s.back()];</span><br><span class="line">                    s.pop_back();</span><br><span class="line">                    <span class="keyword">int</span> w = s.empty() ? i : i - s.back() - <span class="number">1</span>;</span><br><span class="line">                    ret = max(ret, w * h);</span><br><span class="line">                &#125;</span><br><span class="line">                s.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 385. Mini Parser</title>
      <link href="/2016/08/16/leetcode-385-mini-parser/"/>
      <url>/2016/08/16/leetcode-385-mini-parser/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><p><strong>Note:</strong> You may assume that the string is well-formed:</p><ul><li>String is non-empty.</li><li>String does not contain white spaces.</li><li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given s &#x3D; &quot;324&quot;,</span><br><span class="line"></span><br><span class="line">You should return a NestedInteger object which contains a single integer 324.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given s &#x3D; &quot;[123,[456,[789]]]&quot;,</span><br><span class="line"></span><br><span class="line">Return a NestedInteger object containing a nested list with 2 elements:</span><br><span class="line"></span><br><span class="line">1. An integer containing value 123.</span><br><span class="line">2. A nested list containing two elements:</span><br><span class="line">    i.  An integer containing value 456.</span><br><span class="line">    ii. A nested list with one element:</span><br><span class="line">         a. An integer containing value 789.</span><br></pre></td></tr></table></figure></blockquote><p>题目要求把一个合法的字符串转换为对应的嵌套的数据格式, 一开始我想使用递归, 但是在处理嵌套的问题上遇到了麻烦, 所以改为使用栈来做.</p><p>把每一层嵌套视为栈的一个元素, 每遇到一个<code>[</code>就入栈一个新的NestedInteger, 然后遇到数字就把它加入到栈顶的NestedInteger中去, 遇到<code>]</code>就把栈顶的元素弹出, 加入到新的栈顶中, 如果弹出栈顶后栈为空说明处理结束.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;NestedInteger&gt; nestedIntSt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                NestedInteger tmp;</span><br><span class="line">                nestedIntSt.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">                NestedInteger tmp = nestedIntSt.back();</span><br><span class="line">                nestedIntSt.pop_back();</span><br><span class="line">                <span class="keyword">if</span>(!nestedIntSt.empty()) nestedIntSt.back().add(tmp);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] == <span class="string">'-'</span> || isDigit(s[i])) &amp;&amp; !nestedIntSt.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> start = i, end = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(isDigit(s[end]))&#123;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                nestedIntSt.back().add(stoi(s.substr(start, end - start)));</span><br><span class="line">                i = end - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NestedInteger(stoi(s)); <span class="comment">// 如果循环中没有返回, 说明字符串中只包含一个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 84. Largest Rectangle in Histogram</title>
      <link href="/2016/08/15/leetcode-84-largest-rectangle-in-histogram/"/>
      <url>/2016/08/15/leetcode-84-largest-rectangle-in-histogram/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram.png" alt="img"></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram_area.png" alt="img"></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p>For example,Given heights = <code>[2,1,5,6,2,3]</code>,return <code>10</code>.</p></blockquote><p>这道题目使用栈来解决, 方法是每读入一个高度就判断该高度左边有哪些高度所组成的矩形到此为止, 最终得到的是一个单调递增的序列.</p><p>这篇解答写的比较详细: <a href="http://www.cnblogs.com/boring09/p/4231906.html" target="_blank" rel="noopener">http://www.cnblogs.com/boring09/p/4231906.html</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || heights[i] &gt; heights[s.back()])&#123;</span><br><span class="line">                s.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.empty() &amp;&amp; heights[s.back()] &gt;= heights[i])&#123;</span><br><span class="line">                    <span class="keyword">int</span> h = heights[s.back()];</span><br><span class="line">                    s.pop_back();</span><br><span class="line">                    <span class="keyword">int</span> w = s.empty() ? i : i - s.back() - <span class="number">1</span>;</span><br><span class="line">                    ret = max(ret, w * h);</span><br><span class="line">                &#125;</span><br><span class="line">                s.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 83. Remove Duplicates from Sorted List</title>
      <link href="/2016/08/14/leetcode-83-remove-duplicates-from-sorted-list/"/>
      <url>/2016/08/14/leetcode-83-remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p>For example,Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p></blockquote><p>删除连表中的重复元素, 比较简单. 要注意不能造成内存泄漏.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *node = head, *true_next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node-&gt;next != <span class="literal">NULL</span> &amp;&amp; node-&gt;next-&gt;val == node-&gt;val)&#123;</span><br><span class="line">                ListNode *toDel = node-&gt;next;</span><br><span class="line">                node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> toDel;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 82. Remove Duplicates from Sorted List II</title>
      <link href="/2016/08/14/leetcode-82-remove-duplicates-from-sorted-list-ii/"/>
      <url>/2016/08/14/leetcode-82-remove-duplicates-from-sorted-list-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p><p>For example,Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p></blockquote><p>删除一个有序序列中的所有出现重复的元素. 与去除重复元素相比, 问题在于头节点的问题, 在这个问题中头结点可能会发生变化, 因此先创建一个临时头结点指向真正的头结点. 出现初伏元素的时候就把所有相同的元素删除.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p1, *p2 = head;</span><br><span class="line">        ListNode *re = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        re-&gt;next = head;</span><br><span class="line">        p1 = re;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2-&gt;next != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;val == p2-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">int</span> dup_val = p2-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(p2 != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;val == dup_val)&#123;</span><br><span class="line">                    ListNode *toDel = p2;</span><br><span class="line">                    p2 = p2-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> toDel;</span><br><span class="line">                &#125;</span><br><span class="line">                p1-&gt;next = p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p1 = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 81. Search in Rotated Sorted Array II</title>
      <link href="/2016/08/14/leetcode-81-search-in-rotated-sorted-array-ii/"/>
      <url>/2016/08/14/leetcode-81-search-in-rotated-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Follow up for “Search in Rotated Sorted Array”:What if <em>duplicates</em> are allowed?</p><p>Would this affect the run-time complexity? How and why?</p><p>Write a function to determine if a given target is in the array.</p></blockquote><p>仍然使用二分搜索, 数组中可能出现重复元素并没有什么影响.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">                mid = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> binSearch(nums, <span class="number">0</span>, mid, target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binSearch(nums, mid, nums.size(), target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">binSearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 80. Remove Duplicates from Sorted Array II</title>
      <link href="/2016/08/13/leetcode-80-remove-duplicates-from-sorted-array-ii/"/>
      <url>/2016/08/13/leetcode-80-remove-duplicates-from-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Follow up for “Remove Duplicates”:What if duplicates are allowed at most <em>twice</em>?</p><p>For example,Given sorted array <em>nums</em> = <code>[1,1,1,2,2,3]</code>,</p><p>Your function should return length = <code>5</code>, with the first five elements of <em>nums</em> being <code>1</code>, <code>1</code>, <code>2</code>, <code>2</code> and <code>3</code>. It doesn’t matter what you leave beyond the new length.</p></blockquote><p>O(n)空间复杂度, O(n)时间复杂度的方法是使用另一个数组来保存去除超过两个重复元素之后的结果.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> tp = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;nums[<span class="number">0</span>], nums[<span class="number">1</span>]&#125;;</span><br><span class="line">        t.resize(nums.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> np = <span class="number">2</span>; np &lt; nums.size(); np++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[tp] &lt; nums[np] || (t[tp] == nums[np] &amp;&amp; t[tp - <span class="number">1</span>] &lt; nums[np]))&#123;</span><br><span class="line">                t[++tp] = (nums[np]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, t);</span><br><span class="line">        <span class="keyword">return</span> tp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而不使用辅助空间则是直接删除vector中对应位置的元素, 虽然这会使vector中之后的元素都前移一位, 但是在实际的测试中这种方法还快一点, 上一种方法是20ms, 而这种是16ms…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> val = nums[<span class="number">0</span>], dup = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                val = nums[i];</span><br><span class="line">                dup = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dup == <span class="number">2</span>)&#123;</span><br><span class="line">                nums.erase(nums.begin() + i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dup++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 79. Word Search</title>
      <link href="/2016/08/13/leetcode-79-word-search/"/>
      <url>/2016/08/13/leetcode-79-word-search/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>For example,Given <strong>board</strong> =</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>word = <code>&quot;ABCCED&quot;</code>, -&gt; returns <code>true</code>,word = <code>&quot;SEE&quot;</code>, -&gt; returns <code>true</code>,word = <code>&quot;ABCB&quot;</code>, -&gt; returns <code>false</code>.</p></blockquote><p>一个搜索问题, 使用回溯+递归, 先遍历二维数组, 找到目标字符串的开头字母, 然后向上下左右四个方向搜索下一个字母, 同时标记该位置已访问, 直到找到整个字符串为止.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(board[<span class="number">0</span>].empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = board.size(), col = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> str_p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word[str_p] &amp;&amp; existNext(board, i, j, word, str_p + <span class="number">1</span>, flag, row, col))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">existNext</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> p, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;flag, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        flag[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> re = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == word.size())&#123;</span><br><span class="line">            flag[r][c] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; flag[r - <span class="number">1</span>][c] == <span class="number">0</span> &amp;&amp; board[r - <span class="number">1</span>][c] == word[p])&#123;</span><br><span class="line">            re = existNext(board, r - <span class="number">1</span>, c, word, p + <span class="number">1</span>, flag, row, col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!re &amp;&amp; c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; flag[r][c - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; board[r][c - <span class="number">1</span>] == word[p])&#123;</span><br><span class="line">            re = existNext(board, r, c - <span class="number">1</span>, word, p + <span class="number">1</span>, flag, row, col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!re &amp;&amp; r + <span class="number">1</span> &lt; row &amp;&amp; flag[r + <span class="number">1</span>][c] == <span class="number">0</span> &amp;&amp; board[r + <span class="number">1</span>][c] == word[p])&#123;</span><br><span class="line">            re = existNext(board, r + <span class="number">1</span>, c, word, p + <span class="number">1</span>, flag, row, col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!re &amp;&amp; c + <span class="number">1</span> &lt; col &amp;&amp; flag[r][c + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; board[r][c + <span class="number">1</span>] == word[p])&#123;</span><br><span class="line">            re = existNext(board, r, c + <span class="number">1</span>, word, p + <span class="number">1</span>, flag, row, col);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 78. Subsets</title>
      <link href="/2016/08/13/leetcode-78-subsets/"/>
      <url>/2016/08/13/leetcode-78-subsets/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a set of distinct integers, <em>nums</em>, return all possible subsets.</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>For example,If <strong>nums</strong> = <code>[1,2,3]</code>, a solution is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>取得一个数组的所有子集, 这道题可以直接使用上一道题<a href="http://xiadong.info/2016/08/leetcode-77-combinations/" target="_blank" rel="noopener">LeetCode 77. Combinations</a>的方法, 上一题是从[1,n]中取得k个数, 只要把它们当作下标, 然后n从1遍历到nums.size()即可, 然后再插入一个空集.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kElement;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ret</span><span class="params">(<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++)&#123;</span><br><span class="line">            kElement.clear();</span><br><span class="line">            combine(nums.size(), i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kElement.size(); i++)&#123;</span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(kElement[i].size())</span></span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; kElement[i].size(); j++)&#123;</span><br><span class="line">                    t[j] = nums[kElement[i][j] - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                ret.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        getKElement(n, k, <span class="number">1</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getKElement</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">                v.push_back(i);</span><br><span class="line">                kElement.push_back(v);</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n - k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">            getKElement(n, k - <span class="number">1</span>, i + <span class="number">1</span>, v);</span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 77. Combinations</title>
      <link href="/2016/08/12/leetcode-77-combinations/"/>
      <url>/2016/08/12/leetcode-77-combinations/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p><p>For example,If <em>n</em> = 4 and <em>k</em> = 2, a solution is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>从[1,n]中选出k个数, 这道题只要求组合, 不要求排列, 因此用递归可以比较容易的解决.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kElement;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        getKElement(n, k, <span class="number">1</span>, v);</span><br><span class="line">        <span class="keyword">return</span> kElement;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getKElement</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">                v.push_back(i);</span><br><span class="line">                kElement.push_back(v);</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n - k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">            getKElement(n, k - <span class="number">1</span>, i + <span class="number">1</span>, v);</span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 76. Minimum Window Substring</title>
      <link href="/2016/08/12/leetcode-76-minimum-window-substring/"/>
      <url>/2016/08/12/leetcode-76-minimum-window-substring/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>For example,<strong>S</strong> = <code>&quot;ADOBECODEBANC&quot;</code><strong>T</strong> = <code>&quot;ABC&quot;</code></p><p>Minimum window is <code>&quot;BANC&quot;</code>.</p><p><strong>Note:</strong>If there is no such window in S that covers all characters in T, return the empty string <code>&quot;&quot;</code>.</p><p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p></blockquote><p>这道题叫做<em>MInimum Window Substring</em>, 很容易想到使用滑动窗口. 使用一个ASCII码做索引的数组来保存每个字符出现的次数, 然后先找到以S的第一个字符为开头的满足条件的子串, 然后跳过子串的前部字符直到子串不满足条件, 此时得到的便是第一个最小值. 显然一个子串如果包含T中的所有元素并且尽量短, 那么它的两端字符肯定都在T中(因为如果不在, 那么删掉它们可得到更短的子串),</p><p>从刚才得到的第一个子串开始, 去掉开头的字符, 把子串向后延伸, 直到再次出现该字符为止, 然后不断去掉开头的字符, 直到子串尽可能短, 便可以得到下一个子串. 窗口以&quot;伸-缩-伸-缩…&quot;的方式前进, 算法是线性的(不考虑判断是否符合条件). 记录整个过程中最短的子串开始位置与长度.</p><p>另一个重要问题是如何判断一个子串是否符合条件, 即是否包含T中的所有字符. 最直接的方法是循环比较每个字符出现的次数(子串首尾移动时同时更新子串中字符的出现次数), 这样的话复杂度大约为<code>O(CHAR_MAX*s.length())</code>. 一般来说CHAR_MAX = 127, 这个系数还是比较大的.</p><p>因为除了第一个子串外, 后续的子串都以前一个子串为基础变化而来, 子串开头的下标start在前进时子串始终是处于符合要求的状态, 当不符合要求时start才停下, 所以每当start扫过一个字符, 就把它在子串中的出现次数减1, 然后只比较该字符与T中该字符的出现次数, 当小于时则子串不符合要求. 对于子串结尾end, 则只要找到上一个符合条件的子串的第一个元素就可以了.</p><p>说起来还是比较混乱, 其实代码写起来也比较混乱, 双指针start与end的++, --操作很多, 很容易出错…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tFlag = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(CHAR_MAX + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t.empty() || s.empty() || s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">tFlag[t[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(CHAR_MAX + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = start;</span><br><span class="line"><span class="keyword">int</span> minLen = INT_MAX, minStart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; end &lt;= s.length() &amp;&amp; !matchEnd(flag, s[end - <span class="number">1</span>]); end++) &#123;</span><br><span class="line">flag[s[end]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (end &gt; s.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (matchStart(flag, s[start - <span class="number">1</span>])) &#123;</span><br><span class="line">flag[s[start]]--;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">start--;</span><br><span class="line">flag[s[start]]++;</span><br><span class="line"></span><br><span class="line">minLen = end - start;</span><br><span class="line">minStart = start;</span><br><span class="line">end--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">char</span> ch = s[start];</span><br><span class="line">flag[ch]--;</span><br><span class="line"></span><br><span class="line">end++;</span><br><span class="line"><span class="keyword">while</span> (end &lt; s.length() &amp;&amp; s[end] != ch) &#123;</span><br><span class="line">flag[s[end]]++;</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (end == s.length()) <span class="keyword">break</span>;</span><br><span class="line">flag[ch]++;</span><br><span class="line"></span><br><span class="line">start++;</span><br><span class="line"><span class="keyword">while</span> (matchStart(flag, s[start - <span class="number">1</span>])) &#123;</span><br><span class="line">flag[s[start]]--;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">start--;</span><br><span class="line">flag[s[start]]++;</span><br><span class="line"><span class="keyword">if</span> (minLen &gt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">minLen = end - start + <span class="number">1</span>;</span><br><span class="line">minStart = start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (minLen == INT_MAX) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="keyword">return</span> s.substr(minStart, minLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchEnd</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flag, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[index] &lt; tFlag[index])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CHAR_MAX + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag[i] &lt; tFlag[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchStart</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flag, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> flag[index] &gt;= tFlag[index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 384. Shuffle an Array</title>
      <link href="/2016/08/12/leetcode-384-shuffle-an-array/"/>
      <url>/2016/08/12/leetcode-384-shuffle-an-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Shuffle a set of numbers without duplicates.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Init an array with set 1, 2, and 3.</span><br><span class="line">int[] nums &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">Solution solution &#x3D; new Solution(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.</span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Resets the array back to its original configuration [1,2,3].</span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Returns the random shuffling of array [1,2,3].</span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure></blockquote><p>实现一个洗牌类, 实际的要求是生成1到n个不重复的随机数, 范围在[1,n]之间.</p><p>其实我不太明白为什么要有一个reset方法, 因为这种随机的排列中这个一开始的原始序列并没有什么特殊性, 也不会影响下一次调用shuffle时的概率.</p><p>在LeetCode的Discuss中有貌似题目作者的回复<a href="https://discuss.leetcode.com/topic/53984/reset-makes-no-sense/2" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/53984/reset-makes-no-sense/2</a>:</p><blockquote><p>The reason I designed it that way is to increase the likelihood that when <code>shuffle</code> is called it is shuffling based on the original array, not the previously shuffled array. This will increase the chance of detecting bugs in the main algorithm in <code>shuffle</code>.</p></blockquote><p>关于生成随机排列, 我的方法是下标从低到高一次确定每个位置的函数, 假设下标范围为[0,n), 当前下标为i, 那么从[i,n)中取得一个随机数r, 交换下标i与r中的元素, 然后i增加1.</p><p>运行时间300多ms. 这个算法实际上叫做<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle?oldformat=true" target="_blank" rel="noopener">Fisher–Yates shuffle</a>, Knuth在<em>TAOCP</em>中也介绍过.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; orignalNums, ret;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        ret = orignalNums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ret = orignalNums; <span class="comment">// 这条语句其实没什么影响</span></span><br><span class="line">        <span class="keyword">return</span> orignalNums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = rand() % (ret.size() - i);</span><br><span class="line">            swap(ret[i], ret[i + index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 75. Sort Colors</title>
      <link href="/2016/08/11/leetcode-75-sort-colors/"/>
      <url>/2016/08/11/leetcode-75-sort-colors/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array with <em>n</em> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p><strong>Note:</strong>You are not suppose to use the library’s sort function for this problem.</p><p><strong>Follow up:</strong>A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</p><p>Could you come up with an one-pass algorithm using only constant space?</p></blockquote><p>由于数组中元素的值只有三种, 所以可以先遍历一遍数组, 分别记录下三种值的出现次数, 然后再按照值的大小和数量填充到数组中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> colorNum[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            colorNum[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colorNum[i]; j++)&#123;</span><br><span class="line">                nums[k++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于Follow up中的单次遍历, 可以使用两个指针分别指向red(0)和blue(2)的结尾和开头位置, 然后遍历中间的元素, 通过交换把对应的值放到相应的位置.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> redIndex = <span class="number">0</span>, blueIndex = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[redIndex] == <span class="number">0</span>) redIndex++;</span><br><span class="line">        <span class="keyword">while</span>(nums[blueIndex] == <span class="number">2</span>) blueIndex--;</span><br><span class="line">        <span class="keyword">int</span> i = redIndex;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= blueIndex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums[redIndex++], nums[i]);</span><br><span class="line">                i = max(redIndex, i); <span class="comment">// 由于i有可能落后于redIndex, 所以要选择一个较大的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums[blueIndex--], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 383. Ransom Note</title>
      <link href="/2016/08/11/leetcode-383-ransom-note/"/>
      <url>/2016/08/11/leetcode-383-ransom-note/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p><p>Each letter in the magazine string can only be used once in your ransom note.</p><p><strong>Note:</strong>You may assume that both strings contain only lowercase letters.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure></blockquote><p>Ransom note的意思是勒索信或者绑架信, 题目要求判断是不是所有绑架信上的字母都可以用magazines中的字母拼出来. 使用的方法是类似hash表, 不过hash值就是字母在字母表中的位置.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i++)&#123;</span><br><span class="line">            flag[magazine[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[ransomNote[i] - <span class="string">'a'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                flag[ransomNote[i] - <span class="string">'a'</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 74. Search a 2D Matrix</title>
      <link href="/2016/08/10/leetcode-74-search-a-2d-matrix/"/>
      <url>/2016/08/10/leetcode-74-search-a-2d-matrix/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><p>For example,</p><p>Consider the following matrix:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>对矩阵应用两次二分搜索, 第一次确定元素所在行, 第二次在行内确定元素.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = getRow(matrix, target) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][<span class="number">0</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getTarget(matrix, target, row);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n, mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] == target)</span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[row].size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n, mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 73. Set Matrix Zeroes</title>
      <link href="/2016/08/10/leetcode-73-set-matrix-zeroes/"/>
      <url>/2016/08/10/leetcode-73-set-matrix-zeroes/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a <em>m</em> x <em>n</em> matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p><p>**Follow up:**Did you use extra space?A straight forward solution using O(<em>mn</em>) space is probably a bad idea.A simple improvement uses O(<em>m + n</em>) space, but still not the best solution.Could you devise a constant space solution?</p></blockquote><p>这道题主要的要求在于空间复杂度, O(mn)的复杂度就是使用另一个m×n的矩阵来保存结果. O(m+n)的复杂度则是用两个数组分别保存要设置为0的行数和列数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        vector&lt;int&gt; rowFlag(m, 1), colFlag(n, 1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    rowFlag[i] = <span class="number">0</span>;</span><br><span class="line">                    colFlag[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!rowFlag[i])&#123;</span><br><span class="line">                setZeroRow(matrix, i, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!colFlag[i])&#123;</span><br><span class="line">                setZeroCol(matrix, i, m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroRow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            matrix[row][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroCol</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> col, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            matrix[i][col] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而不使用额外空间的方法不是那么直观, 我的方法是先找到一个为0的位置(r,c), 然后使用它所在的行和列来保存要置为0的行数和列数, 最后再把该行和该列置为0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>, y = <span class="number">-1</span>, m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 以下找到第一个0所在的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y != <span class="number">-1</span>)&#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span> &amp;&amp; y == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 因为之前的位置不存在0, 所以可以从x开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[x][j] = <span class="number">0</span>;</span><br><span class="line">                    matrix[i][y] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == x)</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过x, 要在最后处理</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[i][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                setZeroRow(matrix, i, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == y)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][i] == <span class="number">0</span>)&#123;</span><br><span class="line">                setZeroCol(matrix, i, m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setZeroRow(matrix, x, n);</span><br><span class="line">        setZeroCol(matrix, y, m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroRow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            matrix[row][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroCol</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> col, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            matrix[i][col] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 382. Linked List Random Node</title>
      <link href="/2016/08/10/leetcode-382-linked-list-random-node/"/>
      <url>/2016/08/10/leetcode-382-linked-list-random-node/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p><p><strong>Follow up:</strong>What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Init a singly linked list [1,2,3].</span><br><span class="line">ListNode head &#x3D; new ListNode(1);</span><br><span class="line">head.next &#x3D; new ListNode(2);</span><br><span class="line">head.next.next &#x3D; new ListNode(3);</span><br><span class="line">Solution solution &#x3D; new Solution(head);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom() should return either 1, 2, or 3 randomly. Each element &gt;should have equal probability of returning.</span><br><span class="line">solution.getRandom();</span><br></pre></td></tr></table></figure></blockquote><p>要求设计一个类, 根据一个未知长度的单链表进行构造, 每次调用<code>getRandom</code>成员函数时返回一个随机节点.</p><p>O(n)空间复杂度, O(1)时间复杂度的方法就是用一个顺序容器保存所有节点的指针, 然后每次调用<code>getRandom</code>都根据下标来访问.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; nodes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. */</span></span><br><span class="line">    Solution(ListNode* head) &#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            nodes.push_back(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random node's value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = rand() % nodes.size();</span><br><span class="line">        <span class="keyword">return</span> nodes[r]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(head);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>对于题目中的Follow up部分, 要使用O(1)空间复杂度, O(n)时间复杂度. 在类中只保存链表头结点和当前访问节点, 每次生成的随机数是下一个节点与当前节点的距离.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    ListNode *head, *mp;</span><br><span class="line">    <span class="keyword">int</span> listLen;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. */</span></span><br><span class="line">    Solution(ListNode* h) &#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = h;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mp = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        listLen = <span class="number">0</span>;</span><br><span class="line">        ListNode *p = h;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            listLen++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random node's value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = rand() % listLen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            mp = mp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(mp == <span class="literal">nullptr</span>) mp = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(head);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 72. Edit Distance</title>
      <link href="/2016/08/09/leetcode-72-edit-distance/"/>
      <url>/2016/08/09/leetcode-72-edit-distance/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p><p>You have the following 3 operations permitted on a word:</p><p>a) Insert a characterb) Delete a characterc) Replace a character</p></blockquote><p>题目要求计算两个单词(word1, word2)的&quot;距离&quot;, 就是说最少经过多少步可以从word1变幻到word2. 可以使用的操作有三种:</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><p>这道题目使用动态规划来解决.</p><p>数组<code>dp[i][j]</code>表示<code>word1[0:i-1]</code>(包括i-1)与<code>word2[0:j-1]</code>之间的距离.</p><p>根据最后一次操作的类型分为三类:</p><ol><li>word1插入字符, 此时<code>dp[i][j] = dp[i][j - 1] + 1</code>, 因为这是在<code>word1[0:i-1]=&gt;word2[0:j-2]</code>需要<code>dp[i][j - 1]</code>的基础上, word2最后又增加了一个字符, 因此<code>word1[0:i-1]=&gt;word2[0:j-2]</code>之后再增加一步插入字符的操作(也可以看作word2=&gt;word1最后多删除了一个字符)</li><li>word2插入字符, 此时<code>dp[i][j] = dp[i - 1][j] + 1</code>, 因为这是在<code>word2[0:j-1]=&gt;word1[0:i-2]</code>需要<code>dp[i - 1][j]</code>的基础上, word1最后又增加了一个字符, 因此<code>word2[0:j-1]=&gt;word1[0:i-2]</code>之后再增加一步插入字符的操作(也可以看作word1=&gt;word2最后多删除了一个字符)</li><li>替换操作, 如果<code>word1[i - 1] == word2[j - 1]</code>, 那么<code>dp[i][j] = dp[i - 1][j - 1]</code>, 否则<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li></ol><p>因此递推方程为</p><p><code>dp[i][j] = min(dp[i-1][j-1] + (word1[i-1] == word2[j-1] ? 0 : 1), dp[i][j - 1] + 1, dp[i - 1][j] + 1)</code></p><p>初始条件为<code>dp[i][0] = i; dp[0][j] = j;</code>(全部为插入操作)</p><pre><code>class Solution {public:    int minDistance(string word1, string word2) {        int len1 = word1.length(), len2 = word2.length();        int arr[len1 + 1][len2 + 1];        arr[0][0] = 0;        for(int i = 1; i &lt;= len2; i++){            arr[0][i] = i;        }        for(int i = 1; i &lt;= len1; i++){            arr[i][0] = i;        }        for(int i = 1; i &lt;= len1; i++){            for(int j = 1; j &lt;= len2; j++){                int tmp1 = arr[i - 1][j] + 1, tmp2 = arr[i][j - 1] + 1, tmp3;                if(word1[i - 1] == word2[j - 1]) tmp3 = arr[i - 1][j - 1];                else tmp3 = arr[i - 1][j - 1] + 1;                arr[i][j] = min(tmp1, min(tmp2, tmp3));            }        }        return arr[len1][len2];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 71. Simplify Path</title>
      <link href="/2016/08/09/leetcode-71-simplify-path/"/>
      <url>/2016/08/09/leetcode-71-simplify-path/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an absolute path for a file (Unix-style), simplify it.For example,<strong>path</strong> = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><strong>path</strong> = <code>&quot;/a/./b/../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code><strong>Corner Cases:</strong></p><ul><li>Did you consider the case where <strong>path</strong> = <code>&quot;/../&quot;</code>?In this case, you should return <code>&quot;/&quot;</code>.</li><li>Another corner case is the path might contain multiple slashes <code>'/'</code> together, such as <code>&quot;/home//foo/&quot;</code>.In this case, you should ignore redundant slashes and return <code>&quot;/home/foo&quot;</code>.</li></ul></blockquote><p>题目要求简化一个路径, 要做到两点:</p><ol><li>去掉无效的<code>/</code>, 比如连续的<code>/</code>和结尾的<code>/</code></li><li>把<code>.</code>和<code>..</code>这种相对路径转换为绝对路径</li></ol><p>先使用栈保存<code>/</code>分割的每个节点, 在处理过程中分为三种情况:</p><ol><li>节点为<code>.</code>: 不做任何处理</li><li>节点为<code>..</code>: 若栈不为空则弹出栈顶元素</li><li>否则将节点入栈</li></ol><p>最后把栈变为字符串输出.</p><pre><code>class Solution {public:    string simplifyPath(string path) {        vector&lt;string&gt; pathStack = splitPath(path);        return getFinPath(pathStack);    }    string getFinPath(vector&lt;string&gt; &amp;finStack){        string re = &quot;&quot;;        for(int i = 0 ; i &lt; finStack.size(); i++){            re += &quot;/&quot;;            re += finStack[i];        }        if(re == &quot;&quot;)            re = &quot;/&quot;;        return re;    }    vector&lt;string&gt; splitPath(string path){        vector&lt;string&gt; re;        for(int i = 0; i &lt; path.size(); i++){            if(path[i] != '/'){                int end = getEnd(path, i);                string node = string(path.begin() + i, path.begin() + end);                if(node == string(&quot;.&quot;)){                    // do nothing                }                else if(node == string(&quot;..&quot;)){                    if(!re.empty()) re.pop_back();                }                else{                    re.push_back(node);                }                i = end;            }        }        return re;    }    int getEnd(string path, int start){        int i = start;        for(; i &lt; path.size() &amp;&amp; path[i] != '/'; i++);        return i;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 70. Climbing Stairs</title>
      <link href="/2016/08/09/leetcode-70-climbing-stairs/"/>
      <url>/2016/08/09/leetcode-70-climbing-stairs/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p></blockquote><p>斐波那契数列, 到达第n层的路径数量等于到达第n - 1层的路径数量加到达第n - 2层的路径数量.</p><pre><code>class Solution {public:    int climbStairs(int n) {        if(n == 1)return 1;        if(n == 2)return 2;        int a = 1, b = 2, t;        for(int i = 2; i &lt; n; i++){            t = b;            b = a + b;            a = t;        }        return b;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 69. Sqrt(x)</title>
      <link href="/2016/08/08/leetcode-69-sqrtx/"/>
      <url>/2016/08/08/leetcode-69-sqrtx/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Implement <code>int sqrt(int x)</code>.</p><p>Compute and return the square root of x.</p></blockquote><p>实现整数的开平方运算, 使用二分搜索, 也就是方程求根的二分法来计算. 因为计算结果为整数, 所以最后如果没有平方根的准确值, 要把最后的结果减1.</p><pre><code>class Solution {public:    int mySqrt(int x) {        if(x == 1) return 1;        long long left = 1, right = x, mid = (left + right) / 2;        while(left &lt; right){            long long m = mid * mid;            if(m &gt; x)                 right = mid;            else if(m &lt; x)                left = mid + 1;            else                 return mid;            mid = (left + right) / 2;        }        return left - 1;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 68. Text Justification</title>
      <link href="/2016/08/08/leetcode-68-text-justification/"/>
      <url>/2016/08/08/leetcode-68-text-justification/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.</p><p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ’ ’ when necessary so that each line has exactly L characters.</p><p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p><p>For the last line of text, it should be left justified and no extra space is inserted between words.</p><p>For example,</p><p>words: <code>[&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</code></p><p>L: <code>16</code>.</p><p>Return the formatted lines as:</p><pre><code>[   &quot;This    is    an&quot;,   &quot;example  of text&quot;,   &quot;justification.  &quot;]</code></pre><p>Note: Each word is guaranteed not to exceed L in length.</p></blockquote><p>细节比较多, 难度倒也不是很大, 但是这种题在面试的时候我觉得更难, 因为考虑许多情况, 人肉调试还是比较困难的.</p><pre><code>class Solution {public:    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) {        vector&lt;string&gt; ret;        if(maxWidth == 0) { // 因为每个单词长度都不会超过maxWidth, 所以可以直接返回            ret.push_back(string(&quot;&quot;));            return ret;        }        // start保存每行单词的起始下标, end表示结束下标, 单词的下标范围为[start, end)        // lenInLine保存每一行的长度        int start = 0, end = 0, lenInLine = 0;        while (start &lt; words.size()) {            // 计算这一行能放多少个单词, 把第一个单词放进去, +1是因为后面还有一个空格            lenInLine = words[start].length() + 1;             end = start + 1;             while (end &lt; words.size() &amp;&amp; lenInLine &lt; maxWidth) {                lenInLine += words[end++].length();                lenInLine += 1; // 计算空格            }            if(lenInLine - 1 &gt; maxWidth){ // 去掉尾部空格后如果还是大于maxWidth, 那么应该少放一个单词                end--;            }            if (end == words.size()) { // 根据题目, 最后一行要单独处理, 使用左对齐而不是两端对齐                string line = words[start];                for (int i = start + 1; i &lt; end; i++) {                    line += &quot; &quot;;                    line += words[i];                }                line.insert(line.end(), maxWidth - line.length(), ' ');                ret.push_back(line);            }            else {                createLine(words, start, end, ret, maxWidth); // 创建行            }            start = end;        }        return ret;    }    void createLine(vector&lt;string&gt; &amp;words, int start, int end, vector&lt;string&gt; &amp;ret, int maxWidth) {        string line;        int wordCnt = end - start, spacePerInterval = 0, spaceCnt = maxWidth;        if (wordCnt == 0) return; // end == start, 没有单词        for (int i = start; i &lt; end; i++) { // 计算总空格数            spaceCnt -= words[i].length();        }        // 如果spaceCnt不能平均分配, 那么左边的一个或多个间隔就要增加一个空格        // moreSpaceLen保存左边的多少个间隔需要多的空格        int moreSpaceLen = spaceCnt % (wordCnt - 1 ? wordCnt - 1 : 1);        spacePerInterval = spaceCnt / (wordCnt - 1 ? wordCnt - 1 : 1);        line += words[start];        if(wordCnt == 1){            // 因为下面的循环从start + 1开始, 所以如果行内只有一个单词,            // 就要在其之后填充空格直到长度达到maxWidth            line.insert(line.end(), maxWidth - line.length(), ' ');        }        else{            for (int i = start + 1; i &lt; end; i++) {                if (i &lt;= start + moreSpaceLen) {                    line.insert(line.end(), spacePerInterval + 1, ' ');                }                else {                    line.insert(line.end(), spacePerInterval, ' ');                }                line += words[i];            }        }        ret.push_back(line);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 67. Add Binary</title>
      <link href="/2016/08/08/leetcode-67-add-binary/"/>
      <url>/2016/08/08/leetcode-67-add-binary/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two binary strings, return their sum (also a binary string).</p><p>For example,</p><p>a = <code>&quot;11&quot;</code></p><p>b = <code>&quot;1&quot;</code></p><p>Return <code>&quot;100&quot;</code>.</p></blockquote><p>模拟加法计算, 只不过是使用二进制格式.</p><pre><code>class Solution {public:    string addBinary(string a, string b) {        if(a.length() &lt; b.length()) swap(a, b);        int pa = a.length() - 1, pb = b.length() - 1, jw = 0;        while(pb &gt;= 0){            a[pa] = a[pa] - '0' + b[pb] - '0' + jw + '0';            if(a[pa] &gt;= '2'){                a[pa] = a[pa] % '2' + '0';                jw = 1;            }            else{                jw = 0;            }            pa--, pb--;        }        while(pa &gt;= 0){            a[pa] = a[pa] + jw;            if(a[pa] &gt;= '2'){                a[pa] = a[pa] % '2' + '0';                jw = 1;            }            else{                jw = 0;            }            pa--;        }        if(jw){            a.insert(a.begin(), '1');        }        return a;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 66. Plus One</title>
      <link href="/2016/08/07/leetcode-66-plus-one/"/>
      <url>/2016/08/07/leetcode-66-plus-one/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a non-negative number represented as an array of digits, plus one to the number.</p><p>The digits are stored such that the most significant digit is at the head of the list.</p></blockquote><p>数组模拟计算, 由于只加1, 所以比较简单.</p><pre><code>class Solution {public:    vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) {        vector&lt;int&gt; ret = digits;        int jw = 1;        for(int i = ret.size() - 1; i &gt;= 0 &amp;&amp; jw; i--){            ret[i]++;            if(ret[i] == 10){                jw = 1;                ret[i] = 0;            }            else{                jw = 0;            }        }        if(jw){            ret.insert(ret.begin(), 1);        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 65. Valid Number</title>
      <link href="/2016/08/06/leetcode-65-valid-number/"/>
      <url>/2016/08/06/leetcode-65-valid-number/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Validate if a given string is numeric.</p><p>Some examples:</p><p><code>&quot;0&quot;</code> =&gt; <code>true</code></p><p><code>&quot; 0.1 &quot;</code> =&gt; <code>true</code></p><p><code>&quot;abc&quot;</code> =&gt; <code>false</code></p><p><code>&quot;1 a&quot;</code> =&gt; <code>false</code></p><p><code>&quot;2e10&quot;</code> =&gt; <code>true</code></p><p>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p></blockquote><p>判断一个输入字符串是否是数字, 这道题的要求并不是很明确, 一下子很难想的全面, 并且也不容易跟出题人想到一块去. 实际上主要有以下几点:</p><ul><li>字符串前后可以有空格, 但是数字中间不能出现空格</li><li>允许出现的字符有<code>+</code>, <code>-</code>, <code>.</code>, <code>e</code>和阿拉伯数字</li><li>数字可以以<code>.</code>开头或结尾</li><li>e后面的指数部分只能是整数</li></ul><pre><code>class Solution {public:    bool isNumber(string s) {        delSpace(s);        for(int i = 0; i &lt; s.length(); i++){ // 检查除e, ., 和数字以外的字符            if((s[i] &lt; '0' || s[i] &gt; '9')  &amp;&amp; s[i] != 'e' &amp;&amp; s[i] != '.' &amp;&amp; s[i] != '-' &amp;&amp; s[i] != '+') return false;        }        int eCnt = 0;        for(int i = 0; i &lt; s.length(); i++){ // 计算e的个数            if(s[i] == 'e') eCnt++;        }        //printf(&quot;%d\n&quot;, eCnt);        if(eCnt &gt; 1) return false; // e多于1个则返回false        if(eCnt == 1){            // 如果有e出现, 前后都有不含e的数字            int i;            for(i = 0; s[i] != 'e'; i++);            // e的前面可以是小数, 但是后面不可以            if(!isNumberWithoutE(s.substr(0, i)) || !isNumberWithoutEAndDot(s.substr(i + 1, s.length() - i - 1))){                return false;            }            else return true;        }        else{            // 如果没有e            return isNumberWithoutE(s);        }    }        bool isNumberWithoutE(string s){ // 判断是不是不包含e的数字        if(s.empty()) return false;        if(s.length() == 1 &amp;&amp; (s[0] == '.' || s[0] == '-' || s[0] == '+')) return false; // 只有符号或小数点        int dashPos = -1, dotCnt = 0, plusSignPos = -1;        for(int i = 0; i &lt; s.length(); i++){ // 查找是否有不位于开头的正负号            if(s[i] == '-') dashPos = i;            else if(s[i] == '+') plusSignPos = i;        }        if(dashPos &gt; 0 || plusSignPos &gt; 0) return false;        if(s[0] == '+' || s[0] == '-'){ // 清除开头的正负号            s.erase(s.begin(), s.begin() + 1);        }        if(s.length() == 1 &amp;&amp; s[0] == '.') return false; // 如果去掉符号后只有小数点了, 那么不是数字        for(int i = 0; i &lt; s.length(); i++){ // 计算小数点的数量            if(s[i] == '.') dotCnt++;        }        if(dotCnt &gt; 1) return false;        else return true;    }        bool isNumberWithoutEAndDot(string s){ //判断是不是不包含e的整数        if(s.empty()) return false;        if(s.length() == 1 &amp;&amp; (s[0] == '.' || s[0] == '-' || s[0] == '+')) return false;        int dashPos = -1, plusSignPos = -1;        for(int i = 0; i &lt; s.length(); i++){ // 查找是否有不位于开头的正负号            if(s[i] == '-') dashPos = i;            else if(s[i] == '+') plusSignPos = i;            else if(s[i] == '.') return false; // 如果有小数点则返回false        }        if(dashPos &gt; 0 || plusSignPos &gt; 0) return false;        else return true;    }        void delSpace(string &amp;s){ //删除前后空格        int i;        for(i = 0; i &lt; s.size() &amp;&amp; s[i] == ' '; i++);        s.erase(s.begin(), s.begin() + i);        for(i = 0; i &lt; s.size() &amp;&amp; s[s.size() - i - 1] == ' '; i++);        s.erase(s.end() - i, s.end());    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 64. Minimum Path Sum</title>
      <link href="/2016/08/06/leetcode-64-minimum-path-sum/"/>
      <url>/2016/08/06/leetcode-64-minimum-path-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.</p></blockquote><p>动态规划问题, 到达每个格子的最小的路径和等于到达左边左边格子的路径和与到达上面的格子的路径和中的较小值加上当前格子的值.</p><pre><code>class Solution {public:    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) {        int height = grid.size(), width = grid[0].size();                for(int i = 1; i &lt; height; i++)            grid[i][0] += grid[i - 1][0];        for(int i = 1; i &lt; width; i++)            grid[0][i] += grid[0][i - 1];                    for(int i = 1; i &lt; height; i++){            for(int j = 1; j &lt; width; j++){                grid[i][j] += (grid[i - 1][j] &lt; grid[i][j - 1] ? grid[i - 1][j] : grid[i][j - 1]);            }        }                return grid[height - 1][width - 1];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 63. Unique Paths II</title>
      <link href="/2016/08/05/leetcode-63-unique-paths-ii/"/>
      <url>/2016/08/05/leetcode-63-unique-paths-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>Follow up for “Unique Paths”:</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p><p>For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.</p><pre><code>[  [0,0,0],  [0,1,0],  [0,0,0]]</code></pre><p>The total number of unique paths is 2.</p><p>Note: m and n will be at most 100.</p></blockquote><p>紧跟着上一题<a href="http://xiadong.info/2016/08/leetcode-62-unique-paths/" target="_blank" rel="noopener">Unique Paths</a>, 这一题增加了条件, 在地图上会出现障碍物(用1表示), 障碍物不能出现在路线上. 仍然采用上一题的动态规划法, 只不过多了一条:</p><ul><li>所有障碍物的位置到达的路线数量都为0</li></ul><pre><code>class Solution {public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {        int m = obstacleGrid.size();        if(m == 0)            return 0;        int n = obstacleGrid[0].size();        vector&lt;vector&lt;int&gt;&gt; arr(m, vector&lt;int&gt;(n, 0));        int i, j;        for(i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] != 1; i++)            arr[i][0] = 1;        for(i = 0; i &lt; n &amp;&amp; obstacleGrid[0][i] != 1; i++)            arr[0][i] = 1;        for(i = 1; i &lt; m; i++){            for(j = 1; j &lt; n; j++){                if(obstacleGrid[i][j])                    continue;                                    arr[i][j] = arr[i - 1][j] + arr[i][j - 1];            }        }                return arr[m - 1][n - 1];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 62. Unique Paths</title>
      <link href="/2016/08/05/leetcode-62-unique-paths/"/>
      <url>/2016/08/05/leetcode-62-unique-paths/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><p><img src="http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png" alt=""></p><p>Above is a 3 x 7 grid. How many possible unique paths are there?</p><p>Note: m and n will be at most 100.</p></blockquote><p>经典的动态规划题目, 由于每一个格子只能从上面的格子和左面的格子到达, 所以到达每个格子的路线数量等于到达上面格子的路线数量+到达左面格子的路线数量.</p><pre><code>class Solution {public:    int uniquePaths(int m, int n) {        int arr[m][n];        int i, j;        for(i = 0; i &lt; m; i++)            arr[i][0] = 1;        for(i = 0; i &lt; n; i++)            arr[0][i] = 1;        for(i = 1; i &lt; m; i++){            for(j = 1; j &lt; n; j++){                arr[i][j] = arr[i - 1][j] + arr[i][j - 1];            }        }                return arr[m - 1][n - 1];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 61. Rotate List</title>
      <link href="/2016/08/05/leetcode-61-rotate-list/"/>
      <url>/2016/08/05/leetcode-61-rotate-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p><p>For example:</p><p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</p><p>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p></blockquote><p>最简单的方法是把所有节点指针保存在一个数组中, 设总长度为<code>len</code>, 然后找到第<code>len - k</code>个节点为新链表的头结点, 它之前的节点是新链表的尾节点. 把原链表的尾节点指向头结点即可. 要注意<code>k</code>可能会大于<code>len</code>, 所以可以先把<code>k</code>对<code>len</code>取余.</p><pre><code>/*** Definition for singly-linked list.* struct ListNode {*     int val;*     ListNode *next;*     ListNode(int x) : val(x), next(NULL) {}* };*/class Solution {public:    ListNode* rotateRight(ListNode* head, int k) {        if(!head)            return head;        vector&lt;ListNode*&gt; l;        ListNode* p = head, *reHead;        while(p){            l.push_back(p);            p = p-&gt;next;        }                k = k % l.size();        if(k == 0)            return head;        auto iter = l.end() - k;        (*(iter - 1))-&gt;next = NULL;        (*(l.end() - 1))-&gt;next = *(l.begin());        return *iter;    }};</code></pre><p>不使用额外空间的方法需要多遍历几次链表:</p><pre><code>class Solution {public:    ListNode* rotateRight(ListNode* head, int k) {        if(!head)            return head;        int len = 0;        ListNode *p = head, *newHead = nullptr, *tail = nullptr, *newTail = nullptr;        while(p){            len++;            if(!p-&gt;next)                tail = p;            p = p-&gt;next;        }        k = k % len;        if(!k) return head;        newHead = head;        for(int i = 0; i &lt; len - k; i++){            newTail = newHead;            newHead = newHead-&gt;next;        }        newTail-&gt;next = nullptr;        tail-&gt;next = head;        return newHead;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 60. Permutation Sequence</title>
      <link href="/2016/08/04/leetcode-60-permutation-sequence/"/>
      <url>/2016/08/04/leetcode-60-permutation-sequence/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p><p>By listing and labeling all of the permutations in order,We get the following sequence (ie, for n = 3):</p><ol><li>“123”</li><li>“132”</li><li>“213”</li><li>“231”</li><li>“312”</li><li>“321”</li></ol><p>Given n and k, return the kth permutation sequence.</p><p>Note: Given n will be between 1 and 9 inclusive.</p></blockquote><p>返回[1,n]n个数字的全排列按照字典序排序后的第k个排列, n在[1,9]的范围内.</p><p>通过观察题目给出的<code>n = 3</code>的全排列可以看出, 以1, 2, 3开头的排列各有两个. n的全排列有<code>n!</code>种, 而以[1,n]中某个数字开头的排列种数有<code>(n - 1)!</code>种, 所以第k个排列的第一个数为<code>(k - 1) / (n - 1)! + 1</code>. 将k更新为<code>k % (n - 1)!</code>, 把第一个已经确定的数从数字集合中去掉(该集合应有序), 就可以以类似递归的方法确定整个序列.</p><p>实际上每一次确定数字在集合数组中的下标比直接确定数字要更加有效. 而且由于n在1到9之间, 因此可以先把<code>n!</code>计算出来放到数组中.</p><pre><code>class Solution {public:    vector&lt;int&gt; arr = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};    string getPermutation(int n, int k) {        int kk = k - 1;        vector&lt;int&gt; nums;        for(int i = 1; i &lt;= n; i++){            nums.push_back(i); //nums[i]的值实际是i + 1        }        string ret;        for(int i = 0; i &lt; n; i++){            if(i == n - 1){                ret.push_back(nums[0] + '0'); //i = n - 1时下方会出现除零错误                break;            }            int t = kk / arr[n - 1 - i];            ret.push_back(nums[t] + '0'); //因为nums[i] = i + 1, 所以不需要再加1            nums.erase(nums.begin() + t); //把已经确定的元素删除            kk = kk % arr[n - i - 1];        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 59. Spiral Matrix II</title>
      <link href="/2016/08/04/leetcode-59-spiral-matrix-ii/"/>
      <url>/2016/08/04/leetcode-59-spiral-matrix-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p><p>For example,Given n = 3,</p><p>You should return the following matrix:</p><pre><code>[  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ]]</code></pre></blockquote><p>螺旋输出序列. 首先用一个循环, 在循环体内填充一圈数字, 直到所有位置填满.</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) {        vector&lt;vector&lt;int&gt; &gt; ret(n, vector&lt;int&gt;(n, 0));        if(n == 0)return ret;        int a = 1;        for(int i = n; i &gt; 0; i-=2){ // 圈数应为n/2            if(i == 1 &amp;&amp; n % 2 == 1){ // 当n为奇数时, 最内圈只有一个元素                ret[(n - i) / 2][(n - i) / 2] = a++;                break;            }            for(int j = (n - i) / 2; j &lt; n - (n - i) / 2 - 1; j++) // 填充上边的行                ret[(n - i) / 2][j] = a++;            for(int j = (n - i) / 2; j &lt; n - (n - i) / 2 - 1; j++) // 填充右边的列                ret[j][n - (n - i) / 2 - 1] = a++;            for(int j = n - (n - i) / 2 - 1; j &gt; (n - i) / 2; j--) // 填充下边的行                ret[n - (n - i) / 2 - 1][j] = a++;            for(int j = n - (n - i) / 2 - 1; j &gt; (n - i) / 2; j--) // 填充左边的列                ret[j][(n - i) / 2] = a++;        }                return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 58. Length of Last Word</title>
      <link href="/2016/08/04/leetcode-58-length-of-last-word/"/>
      <url>/2016/08/04/leetcode-58-length-of-last-word/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string s consists of upper/lower-case alphabets and empty space characters ’ ', return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p>Note: A word is defined as a character sequence consists of non-space characters only.</p><p>For example,Given s = “Hello World”,return 5.</p></blockquote><p>找出一个字符串中最后一个单词的长度, 没有什么好说的, 从后往前搜索.</p><pre><code>class Solution {public:    int lengthOfLastWord(string s) {        int end = s.size();        if(end == 0)            return 0;        for(; end &gt;= 1 &amp;&amp; s[end - 1] == ' '; end--); // 跳过结尾的空格        int i;        for(i = end - 1; i &gt;= 0 &amp;&amp; s[i] != ' '; i--);        return end - i - 1;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 57. Insert Interval</title>
      <link href="/2016/08/03/leetcode-57-insert-interval/"/>
      <url>/2016/08/03/leetcode-57-insert-interval/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p>Example 1:</p><p>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p><p>Example 2:</p><p>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p><p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p></blockquote><p>向一个已经按照start排好序的区间数组中插入新区间, 问题分为两个部分:</p><ol><li>找到插入位置</li><li>确定区间是否需要合并, 如何合并</li></ol><p>用语言来说还是不太好说清楚, 还是看注释吧.</p><pre><code>/*** Definition for an interval.* struct Interval {*     int start;*     int end;*     Interval() : start(0), end(0) {}*     Interval(int s, int e) : start(s), end(e) {}* };*/class Solution {public:    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) {        vector&lt;Interval&gt; ret;        if(intervals.empty()){ // 如果intervals为空就返回只包含newInterval的数组            ret.push_back(newInterval);            return ret;        }        int i;        // 以下循环用于跳过所有end小于newInterval.start, 也就是所有小于newInterval并且        // 与newInterval没有交集的区间        for(i = 0; i &lt; intervals.size() &amp;&amp; intervals[i].end &lt; newInterval.start; i++);        // 如果i == intervals.size(), 说明所有元素都小于newInterval, 把它插入到最后即可        if(i == intervals.size()){            intervals.push_back(newInterval);            return intervals;        }        int j = i;        // 将要插入的新区间        Interval t;        // 此时j = i, intervals[j]是end &gt;= newInterval.start的第一个元素,但它们的start        // 关系还不确定, 因此要插入的start值是intervals[j].start和newInterval.start中较        // 小的一个        t.start = min(intervals[j].start, newInterval.start);        // 寻找start &gt; newInterval.end的元素, 该元素之前的元素是要与newInterval合并的区间        for(; j &lt; intervals.size() &amp;&amp; intervals[j].start &lt;= newInterval.end; j++);        // 如果j == intervals.size()说明i之后的所有区间都要与newInterval合并,        // 所以t.end是newInterval.end和intervals.back().end中较大的值.        // 然后删除intervals中i之后的元素(包括i, 因为i也与newInterval有交集),        // 最后插入t        if(j == intervals.size()){            t.end = max(newInterval.end, intervals.back().end);            intervals.erase(intervals.begin() + i, intervals.end());            intervals.push_back(t);            return intervals;        }        // 否则intervals[j - 1]是start &lt;= newInterval.end的最后一个元素, 也就是与newInterval        // 有交集的最后一个元素, t.end的值是newInterval.end和intervals[j - 1].end中较大的.        // 从intervals中移除下标在[i, j-1]范围内的元素, 在i位置插入新区间t.        else{            t.end = max(newInterval.end, intervals[j - 1].end);            intervals.erase(intervals.begin() + i, intervals.begin() + j);            intervals.insert(intervals.begin() + i, t);        }        return intervals;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 56. Merge Intervals</title>
      <link href="/2016/08/03/leetcode-56-merge-intervals/"/>
      <url>/2016/08/03/leetcode-56-merge-intervals/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a collection of intervals, merge all overlapping intervals.</p><p>For example,</p><p>Given <code>[1,3],[2,6],[8,10],[15,18]</code>,</p><p>return <code>[1,6],[8,10],[15,18]</code>.</p></blockquote><p>合并(闭)区间, 区间以对象的形式给出. 首先将输入的区间数组按照<code>start</code>从小到大排序, 然后先取第一个元素放入结果集中, 从第二个元素开始遍历. 取当前区间为<code>cur</code>, 结果集中的最后一个元素为<code>pre</code>. 如果<code>cur.start &gt; pre.end</code>, 说明<code>cur</code>与<code>pre</code>并无交集, 由于有序, 所以<code>cur</code>以后的区间与<code>pre</code>也都没有交集, 所以可以将<code>cur</code>放入结果集中. 如果<code>cur.start &lt;= pre.end</code>, 说明有交集, 由于必然存在<code>cur.start &gt;= pre.start</code>, 所以新区间的<code>start</code>等于<code>pre.start</code>, 只要考虑<code>cur.end</code>与<code>pre.end</code>的大小关系, 如果<code>cur.end &lt;= pre.end</code>, 那么新区间与<code>pre</code>相同; 如果<code>cur.end &gt; pre.end</code>那么要把<code>pre</code>也就是结果集的最后一个区间的<code>end</code>修改为<code>cur.end</code>.</p><pre><code>/*** Definition for an interval.* struct Interval {*     int start;*     int end;*     Interval() : start(0), end(0) {}*     Interval(int s, int e) : start(s), end(e) {}* };*/class Solution {public:    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) {        vector&lt;Interval&gt; ret;        if(intervals.empty()) return ret;        sort(intervals.begin(), intervals.end(), [=](Interval &amp;a, Interval &amp;b){            return a.start &lt; b.start;        });        ret.push_back(intervals[0]);        for(int i = 1; i &lt; intervals.size(); i++){            Interval cur = intervals[i], pre = ret.back();            if(cur.start &gt; pre.end){                ret.push_back(cur);            }            else{                if(cur.end &gt; pre.end){                    ret.back().end = cur.end;                }            }        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 55. Jump Game</title>
      <link href="/2016/08/03/leetcode-55-jump-game/"/>
      <url>/2016/08/03/leetcode-55-jump-game/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>For example:</p><p>A = [2,3,1,1,4], return true.</p><p>A = [3,2,1,0,4], return false.</p></blockquote><p>数组中的每个元素表示从当前下标可以向前跳的距离, 返回能不能到达最后一个下标. 从第一个元素开始记录从当前元素能到达的最远的下标值, 对之后的每个元素更新这个值, 如果该值小于当前下标则说明该下标无法到达.</p><pre><code>class Solution {public:    bool canJump(vector&lt;int&gt;&amp; nums) {        int farthest = nums[0], i;        for(i = 1; i &lt; nums.size() &amp;&amp; farthest &gt;= i; i++){            farthest = max(farthest, nums[i] + i);        }        if(farthest &gt;= nums.size() - 1)            return true;        else            return false;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 54. Spiral Matrix</title>
      <link href="/2016/08/02/leetcode-54-spiral-matrix/"/>
      <url>/2016/08/02/leetcode-54-spiral-matrix/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p><p>For example,Given the following matrix:</p><pre><code>[  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ]]</code></pre><p>You should return <code>[1,2,3,6,9,8,7,4,5]</code>.</p></blockquote><p>螺旋形输出一个矩阵, 我的方法就是螺旋形地遍历这个矩阵. 用一个变量来表示方向, 到达矩阵边缘的时候就更改方向.</p><pre><code>class Solution {public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {        vector&lt;int&gt; re;        if (matrix.size() == 0 || matrix[0].size() == 0)            return re;        int m = matrix.size(), n = matrix[0].size(), num = m * n;        vector&lt;int&gt; row(n, 0);        vector&lt;vector&lt;int&gt;&gt; visited(m, row);        int direction = 0;// 0 =&gt; right, 1 =&gt; down, 2 =&gt; left, 3 =&gt; up        int posRow = 0, posCol = 0, cnt = 0;        while (cnt &lt; num) {            int nextPosRow, nextPosCol;            if(!visited[posRow][posCol]){                re.push_back(matrix[posRow][posCol]);                visited[posRow][posCol] = 1;                cnt++;            }            bool nextPosValid = true;            switch (direction) {            case 0:                nextPosRow = posRow;                nextPosCol = posCol + 1;                if (nextPosCol &gt;= n || visited[nextPosRow][nextPosCol] == 1) {                    nextPosValid = false;                }                break;            case 1:                nextPosRow = posRow + 1;                nextPosCol = posCol;                if (nextPosRow &gt;= m || visited[nextPosRow][nextPosCol] == 1) {                    nextPosValid = false;                }                break;            case 2:                nextPosRow = posRow;                nextPosCol = posCol - 1;                if (nextPosCol &lt; 0 || visited[nextPosRow][nextPosCol] == 1) {                    nextPosValid = false;                }                break;            case 3:                nextPosRow = posRow - 1;                nextPosCol = posCol;                if (nextPosRow &lt; 0 || visited[nextPosRow][nextPosCol] == 1) {                    nextPosValid = false;                }                break;            }            if(nextPosValid){                posRow = nextPosRow;                posCol = nextPosCol;            }            else{                direction = (direction + 1) % 4;            }        }        return re;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 53. Maximum Subarray</title>
      <link href="/2016/08/02/leetcode-53-maximum-subarray/"/>
      <url>/2016/08/02/leetcode-53-maximum-subarray/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p></blockquote><p>题目要求找出最大的连续子序列的和, 首先采用一种分治法. 对于一个数组, 把它中中间分成两半, 和最大的连续子序列可能出现在左半边, 可能出现在右半边, 也有可能出现跨越左右的情况. 对于在左半边或右半边的情况, 可以使用递归缩小问题, 对于跨越左右的情况, 可以使用线性算法来获得结果. 最后返回三个值中的最大值.</p><pre><code>class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        return maxSub(nums, 0, nums.size());    }    int maxSub(vector&lt;int&gt;&amp; nums, int left, int right) {        if (right - left == 1) {            return nums[left];        }        int leftSum, rightSum, mid = (left + right) / 2;        leftSum = maxSub(nums, left, mid);        rightSum = maxSub(nums, mid, right);        int midLeftSum = 0, midLeftMaxSum = INT_MIN, midRightSum = 0, midRightMaxSum = INT_MIN;        for (int i = mid - 1; i &gt;= left; i--) {            midLeftSum += nums[i];            if (midLeftSum &gt; midLeftMaxSum) midLeftMaxSum = midLeftSum;        }        for (int i = mid; i &lt; right; i++) {            midRightSum += nums[i];            if (midRightSum &gt; midRightMaxSum) midRightMaxSum = midRightSum;        }        int midSum = midRightMaxSum + midLeftMaxSum;        return max(midSum, max(leftSum, rightSum));    }};</code></pre><p>还可以使用动态规划法. 使用<code>dp[i]</code>来表示包含<code>nums[i]</code>的和最大的连续子串的和. 如果<code>dp[i-1]</code>是大于0的, 那么就可以加上<code>dp[i-1]</code>, 因为<code>nums[i]</code>是必须有的. 用另一种方式来说, 这个题目的主要问题在于和最大的连续子串中可能出现负数, 要考虑的是负数及负数之前的子串要不要加到当前子串中来, 而这个判断就是看以该负数结尾的连续子串的和是否大于0, 如果小于0则不能加进来, 大于0则可以.</p><pre><code>class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp(nums.size(), 0);        int ret = nums[0];        dp[0] = nums[0];        for(int i = 1; i &lt; nums.size(); i++){            dp[i] = dp[i - 1] &gt; 0 ? dp[i - 1] + nums[i] : nums[i];            if(ret &lt; dp[i])                ret = dp[i];        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 52. N-Queens II</title>
      <link href="/2016/08/01/leetcode-52-n-queens-ii/"/>
      <url>/2016/08/01/leetcode-52-n-queens-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Follow up for N-Queens problem.</p><p>Now, instead outputting board configurations, return the total number of distinct solutions.</p></blockquote><p>与上一题<a href="http://xiadong.info/2016/08/leetcode-51-n-queens/" target="_blank" rel="noopener">51. N-Queens</a>基本类似, 但是要求返回共有多少个解, 对上一个程序稍加改动即可. <s>当然, 最投机取巧的做法是算出n=1到9的结果然后直接返回</s>.</p><pre><code>class Solution {public:    int totalNQueens(int n) {        vector&lt;vector&lt;int&gt;&gt; board(n, vector&lt;int&gt;(n, 0));        int re = 0;        NQueensRow(n, board, 0, re);        return re;    }    void NQueensRow(int n, vector&lt;vector&lt;int&gt;&gt; &amp;board, int row, int &amp;re) {        if (row == n) {            re++;            return;        }        for (int i = 0; i &lt; n; i++) {            if (validPos(board, row, i)) {                board[row][i] = 1;                NQueensRow(n, board, row + 1, re);                board[row][i] = 0;            }        }    }    bool validPos(vector&lt;vector&lt;int&gt;&gt; &amp;board, int x, int y) {        int n = board.size();        for (int i = 0; i &lt; n; i++) {            if (board[x][i] &amp;&amp; i != y)                return false;            else if (board[i][y] &amp;&amp; i != x)                return false;        }        int xt, yt;        for (xt = x - 1, yt = y - 1; xt &gt;= 0 &amp;&amp; yt &gt;= 0; xt--, yt--){            if (board[xt][yt])                return false;        }        for (xt = x + 1, yt = y + 1; xt &lt; n &amp;&amp; yt &lt; n; xt++, yt++) {            if (board[xt][yt])                return false;        }        for (xt = x - 1, yt = y + 1; xt &gt;= 0 &amp;&amp; yt &lt; n; xt--, yt++){            if (board[xt][yt])                return false;        }        for (xt = x + 1, yt = y - 1; xt &lt; n &amp;&amp; yt &gt;= 0; xt++, yt--) {            if (board[xt][yt])                return false;        }        return true;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 51. N-Queens</title>
      <link href="/2016/08/01/leetcode-51-n-queens/"/>
      <url>/2016/08/01/leetcode-51-n-queens/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p><p><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt=""></p><p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p><p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p><p>For example,There exist two distinct solutions to the 4-queens puzzle:</p><pre><code>[    [&quot;.Q..&quot;,  // Solution 1    &quot;...Q&quot;,    &quot;Q...&quot;,    &quot;..Q.&quot;],    [&quot;..Q.&quot;,  // Solution 2    &quot;Q...&quot;,    &quot;...Q&quot;,    &quot;.Q..&quot;]]</code></pre></blockquote><p>N皇后问题, 采用递归+回溯的方法, 依次穷举每一种情况.</p><pre><code>class Solution {public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {        vector&lt;vector&lt;int&gt;&gt; board(n, vector&lt;int&gt;(n, 0));        vector&lt;vector&lt;string&gt;&gt; re;        NQueensRow(n, board, 0, re);        return re;    }    void NQueensRow(int n, vector&lt;vector&lt;int&gt;&gt; &amp;board, int row, vector&lt;vector&lt;string&gt;&gt; &amp;re) {        if (row == n) {            reItem(board, re);            return;        }        for (int i = 0; i &lt; n; i++) {            if (validPos(board, row, i)) {                board[row][i] = 1;                NQueensRow(n, board, row + 1, re);                board[row][i] = 0;            }        }    }    bool validPos(vector&lt;vector&lt;int&gt;&gt; &amp;board, int x, int y) {        int n = board.size();        for (int i = 0; i &lt; n; i++) {            if (board[x][i] &amp;&amp; i != y)                return false;            else if (board[i][y] &amp;&amp; i != x)                return false;        }        int xt, yt;        for (xt = x - 1, yt = y - 1; xt &gt;= 0 &amp;&amp; yt &gt;= 0; xt--, yt--){            if (board[xt][yt])                return false;        }        for (xt = x + 1, yt = y + 1; xt &lt; n &amp;&amp; yt &lt; n; xt++, yt++) {            if (board[xt][yt])                return false;        }        for (xt = x - 1, yt = y + 1; xt &gt;= 0 &amp;&amp; yt &lt; n; xt--, yt++){            if (board[xt][yt])                return false;        }        for (xt = x + 1, yt = y - 1; xt &lt; n &amp;&amp; yt &gt;= 0; xt++, yt--) {            if (board[xt][yt])                return false;        }        return true;    }    void reItem(vector&lt;vector&lt;int&gt;&gt; &amp;board, vector&lt;vector&lt;string&gt;&gt; &amp;ret) {        int n = board.size();        vector&lt;string&gt; re(n, string(n, '.'));        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; n; j++) {                if(board[i][j]) re[i][j] = 'Q';            }        }        ret.push_back(re);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 378. Kth Smallest Element in a Sorted Matrix</title>
      <link href="/2016/08/01/leetcode-378-kth-smallest-element-in-a-sorted-matrix/"/>
      <url>/2016/08/01/leetcode-378-kth-smallest-element-in-a-sorted-matrix/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p><p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p><p>Example:</p><pre><code>matrix = [   [ 1,  5,  9],   [10, 11, 13],   [12, 13, 15]],k = 8,return 13.</code></pre><p>Note:</p><p>You may assume k is always valid, 1 ≤ k ≤ n<sup>2</sup>.</p></blockquote><p>首先的想法是每次从n行中取最前端的n个值中的最小值, 然后这个值从该行删除, 重复k次. 时间复杂度O(nk). 实际运行时间280ms.</p><pre><code>class Solution {public:    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {        int n = matrix.size();        vector&lt;int&gt; matrixPos(n, 0);        int ret;        for(int i = 0; i &lt; k; i++){            int minNum = INT_MAX, minPos = 0;            for(int j = 0; j &lt; n; j++){                if(matrixPos[j] == n) continue;                if(matrix[j][matrixPos[j]] &lt; minNum){                    minNum = matrix[j][matrixPos[j]];                    minPos = j;                }            }            matrixPos[minPos]++;            ret = minNum;        }        return ret;    }};</code></pre><p>使用二分搜索, 不过搜算范围是<code>int</code>类型的整个表示范围, 为避免溢出, 使用long long来保存左右边界. Runtime: 80ms.</p><pre><code>class Solution {public:    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {        int n = matrix.size();        long long l = INT_MIN, r = INT_MAX, mid;        while(l &lt; r){            mid = (l + r) &gt;&gt; 1;            int kth = 0;            for(int i = 0; i &lt; n; i++){                for(int j = 0; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++){                    kth++;                }            }            if(kth &lt; k) l = mid + 1;            else r = mid;        }        return l;    }};</code></pre><p>另一种使用堆的方法, 先按从上往下, 从左往右的顺序将k个元素放入堆中. 对于剩下的元素, 每一行从头开始与堆顶比较, 如果小于堆顶, 就把它放入堆中, 把原堆顶弹出. 改行中出现&gt;=堆顶的元素时即可停止对这一行的处理. 运行时间112ms.</p><pre><code>class Solution {public:    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {        int n = matrix.size();        priority_queue&lt;int&gt; heap;        for(int i = 0; i &lt; n; i++){            if(heap.size() &lt; k){                int j;                for(j = 0; j &lt; n &amp;&amp; heap.size() &lt; k; j++){                    heap.push(matrix[i][j]);                }                for(; j &lt; n &amp;&amp; heap.top() &gt; matrix[i][j]; j++){                    heap.pop();                    heap.push(matrix[i][j]);                }            }            else{                for(int j = 0; j &lt; n &amp;&amp; heap.top() &gt; matrix[i][j]; j++){                    heap.pop();                    heap.push(matrix[i][j]);                }            }        }        return heap.top();    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 50. Pow(x, n)</title>
      <link href="/2016/07/31/leetcode-50-powx-n/"/>
      <url>/2016/07/31/leetcode-50-powx-n/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Implement pow(x, n).</p></blockquote><p>题目要求实现pow函数. 首先n若小于0, 则可以先把x取倒数, 然后n取相反数, 从而变为n大于0的情况(但是由于int表示范围的问题, 所以新的n应该使用long long来存储), 所以只要考虑n大于0的情况. x<sup>n</sup> = (x<sup>2</sup>)<sup>n/2</sup>(n为偶数); x<sup>n</sup> = x*(x<sup>2</sup>)<sup>(n - 1)/2</sup>(n为奇数), 所以循环次数可以降低至logn次.</p><pre><code>class Solution {public:    double myPow(double x, int n) {        long long nn = n;        double re = 1;        if(nn == 0) return 1;        if(nn &lt; 0){            x = 1 / x;            nn = -nn;        }        while(nn &gt; 1){            if(nn % 2 == 0){                x *= x;                nn = nn &gt;&gt; 1;            }            else{                re *= x;                nn -= 1;            }        }        return re * x;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 49. Group Anagrams</title>
      <link href="/2016/07/31/leetcode-49-group-anagrams/"/>
      <url>/2016/07/31/leetcode-49-group-anagrams/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array of strings, group anagrams together.</p><p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],Return:</p><pre><code>[  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],  [&quot;nat&quot;,&quot;tan&quot;],  [&quot;bat&quot;]]</code></pre></blockquote><p>anagram的意思是&quot;颠倒字母而成的词句&quot;, 也就是要把由相同字母组成的但顺序不同的字符串放到一起. 使用hash表, 对每个字符串中的字符排序后得到的新字符串作为hash表的key, value则是对应的原字符串集合.</p><pre><code>class Solution {public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {        unordered_map&lt;string, vector&lt;string&gt;&gt; m;        vector&lt;vector&lt;string&gt;&gt; ret;        for(int i = 0; i &lt; strs.size(); i++){            string s = strs[i];            sort(s.begin(), s.end());            if(m.count(s)){                m[s].push_back(strs[i]);            }            else{                m[s] = vector&lt;string&gt;(1, strs[i]);            }        }        ret.resize(m.size()); //预先扩展ret的大小, 避免在循环中push_back频繁分配新的内存空间        int cnt = 0;        for(auto i = m.begin(); i != m.end(); i++){            ret[cnt++] = (i-&gt;second);        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 48. Rotate Image</title>
      <link href="/2016/07/31/leetcode-48-rotate-image/"/>
      <url>/2016/07/31/leetcode-48-rotate-image/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>You are given an n x n 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p>Follow up:Could you do this in-place?</p></blockquote><p>题目要求将一个n*n数组顺时针旋转90度, 并且最好不使用额外空间. 所以用对角线将矩阵分为四个区域, 对于每个区域内的每个元素依次放入上一个区域的值.</p><pre><code>class Solution {public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {        int n = matrix.size();        for(int i = 0; i &lt; n / 2; i++){            for(int j = i; j &lt; n - 1 - i; j++){                int swap_t = matrix[i][j];                matrix[i][j] = matrix[n - 1 - j][i];                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];                matrix[j][n - 1 - i] = swap_t;            }        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL容器学习笔记四 - List</title>
      <link href="/2016/07/30/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-list/"/>
      <url>/2016/07/30/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-list/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="list-双向链表"><a href="http://www.cplusplus.com/reference/list/list/" target="_blank" rel="noopener">List</a> 双向链表</h1><p>list是允许在容器内任意位置以常数时间进行插入删除操作的顺序容器, 它的迭代器也是双向的.</p><p>list被实现为双向链表, 它与<code>forward_list</code>的主要区别在于<code>forward_list</code>是单向链表, 迭代器只能向前.</p><p>与其他顺序容器相比主要优点在于在容器任意位置插入, 提取和移动的表现更好. 不足在于不能根据元素在容器中的位置来访问元素.</p><h1 id="部分函数">部分函数</h1><p>list没有随机访问方法, 没有<code>at</code>成员函数或者<code>[]</code>运算符.</p><h2 id="构造函数">构造函数</h2><p>与其他顺序容器类似</p><table><thead><tr><th>类型</th><th>原型</th></tr></thead><tbody><tr><td>default (1)</td><td><code>explicit list (const allocator_type&amp; alloc = allocator_type());</code></td></tr><tr><td>fill (2)</td><td><code>explicit list (size_type n, const value_type&amp; val = value_type(),</code> <code>const allocator_type&amp; alloc = allocator_type());</code></td></tr><tr><td>range (3)</td><td><code>template &lt;class InputIterator&gt; list (InputIterator first, InputIterator last,</code> <code>const allocator_type&amp; alloc = allocator_type());</code></td></tr><tr><td>copy (4)</td><td><code>list (const list&amp; x);</code></td></tr></tbody></table><h2 id="list-merge">list::merge</h2><pre><code>void merge (list&amp; x);  void merge (list&amp;&amp; x);template &lt;class Compare&gt;  void merge (list&amp; x, Compare comp);template &lt;class Compare&gt;  void merge (list&amp;&amp; x, Compare comp);</code></pre><p>将x中的元素按照相应的顺序放入容器中, 两个容器都应有序. 该操作移除x中的所有元素, 但不会析构或构造任何对象.</p><p>该函数的模板版本使用comp作为比较元素大小的方法. 结果得到的list是稳定的. 当<code>&amp;x == this</code>时不会做任何事.</p><h2 id="list-splice">list::splice</h2><p>将元素从x中转移到当前容器中, 插入到position指定的位置.</p><p>晕啊素会从x中移除, 两个容器的大小都会改变. 该操作不会析构或构造任何对象.</p><pre><code>void splice (const_iterator position, list&amp; x);void splice (const_iterator position, list&amp;&amp; x);</code></pre><p>x中的所有元素都转移到list中.</p><pre><code>void splice (const_iterator position, list&amp; x, const_iterator i);void splice (const_iterator position, list&amp;&amp; x, const_iterator i);</code></pre><p>只有迭代器<code>i</code>指定的元素被移动.</p><pre><code>void splice (const_iterator position, list&amp; x,            const_iterator first, const_iterator last);void splice (const_iterator position, list&amp;&amp; x,            const_iterator first, const_iterator last);</code></pre><p><code>[first, last)</code>范围内的元素被移动.</p><h2 id="list-unique">list::unique</h2><pre><code>void unique();</code></pre><p>删除除了第一个元素以外的重复元素. **注意:**只有与前一个元素相等的元素才会被移除, 所以该函数只能用于有序list.</p><pre><code>template &lt;class BinaryPredicate&gt;    void unique (BinaryPredicate binary_pred);</code></pre><p>使用一个比较函数来决定两个元素是否相等. <code>unique</code>会对每个相邻元素调用<code>binary_pred(*i, *(i - 1))</code>, 如果返回true则删除<code>i</code>.</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 47. Permutations II</title>
      <link href="/2016/07/30/leetcode-47-permutations-ii/"/>
      <url>/2016/07/30/leetcode-47-permutations-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p><p>For example,<code>[1,1,2]</code> have the following unique permutations:</p><pre><code>[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre></blockquote><p>与上一题<a href="http://xiadong.info/2016/07/leetcode-46-permutations/" target="_blank" rel="noopener">46. Permutations</a>类似, 只不过输入集合中可能有重复数字, 而输出要求没有重复. 所以先对输入序列进行排序, 然后每次递归时跳过多次出现的数字中除了第一个数字以外的数.</p><pre><code>class Solution {    vector&lt;vector&lt;int&gt;&gt; ret;    int numsLen;public:    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {        sort(nums.begin(), nums.end());        vector&lt;bool&gt; flag(nums.size(), false);        vector&lt;int&gt; p;        numsLen = nums.size();        for(int i = 0; i &lt; numsLen; i++){            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            flag[i] = true;            p.push_back(nums[i]);            permute(nums, flag, p, nums.size() - 1);            p.pop_back();            flag[i] = false;        }        return ret;    }        void permute(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt; &amp;flag, vector&lt;int&gt; &amp;p, int lastLen){        if(lastLen == 0){            ret.push_back(p);            return;        }        for(int i = 0; i &lt; numsLen; i++){            if(flag[i]) continue;            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !flag[i - 1]) continue;            flag[i] = true;            p.push_back(nums[i]);            permute(nums, flag, p, lastLen - 1);            p.pop_back();            flag[i] = false;        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 46. Permutations</title>
      <link href="/2016/07/30/leetcode-46-permutations/"/>
      <url>/2016/07/30/leetcode-46-permutations/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a collection of distinct numbers, return all possible permutations.</p><p>For example,</p><pre><code>[1,2,3] have the following permutations:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre></blockquote><p>使用递归来创建所有排列.</p><pre><code>class Solution {    vector&lt;vector&lt;int&gt;&gt; ret;    int numsLen;public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {        vector&lt;bool&gt; flag(nums.size(), false);        vector&lt;int&gt; p;        numsLen = nums.size();        for(int i = 0; i &lt; numsLen; i++){            flag[i] = true;            p.push_back(nums[i]);            permute(nums, flag, p, nums.size() - 1);            p.pop_back();            flag[i] = false;        }        return ret;    }        void permute(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt; &amp;flag, vector&lt;int&gt; &amp;p, int lastLen){        if(lastLen == 0){            ret.push_back(p);            return;        }        for(int i = 0; i &lt; numsLen; i++){            if(flag[i]) continue;            flag[i] = true;            p.push_back(nums[i]);            permute(nums, flag, p, lastLen - 1);            p.pop_back();            flag[i] = false;        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 45. Jump Game II</title>
      <link href="/2016/07/30/leetcode-45-jump-game-ii/"/>
      <url>/2016/07/30/leetcode-45-jump-game-ii/</url>
      
        <content type="html"><![CDATA[<p>问题描述:</p><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>For example:Given array A = [2,3,1,1,4]</p><p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p><p>Note:</p><p>You can assume that you can always reach the last index.</p></blockquote><p>当走到<code>nums[i]</code>时, 遍历<code>[i + 1, i + nums[i]]</code>范围内的元素, 找到其中最大的值, 作为下一次循环的<code>i</code>. 对于只有一个元素的nums单独处理.</p><pre><code>class Solution {public:    int jump(vector&lt;int&gt;&amp; nums) {        if(nums.size() == 1) return 0;        int p = 0,step = 0;        while(p + nums[p] &lt; nums.size() - 1){            step++;            int nextP = -1, nextPPos = 0;            for(int j = 1; j &lt;= nums[p] &amp;&amp; p + j &lt; nums.size(); j++){                if(nums[p + j] + p + j &gt; nextP){                    nextP = nums[p + j] + p + j;                    nextPPos = p + j;                }            }            p = nextPPos;        }        return step + 1;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 377. Combination Sum IV</title>
      <link href="/2016/07/29/leetcode-377-combination-sum-iv/"/>
      <url>/2016/07/29/leetcode-377-combination-sum-iv/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p><p>Example:</p><pre><code>nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7.</code></pre><p>Follow up:</p><ul><li>What if negative numbers are allowed in the given array?</li><li>How does it change the problem?</li><li>What limitation we need to add to the question to allow negative numbers?</li></ul></blockquote><p>这是一道比较明显的动态规划题, 但是我一开始还是直接用了递归, 无悬念的超时.</p><p>和等于target的组合数量等于target减去nums中每一个元素后的所有新target的组合数量之和. 如果target与nums中某个值相等则再加1.</p><pre><code>class Solution {public:    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; dp(target + 1);        for(int i = 0; i &lt;= target; i++){            for(int j = 0; j &lt; nums.size(); j++){                if(i == nums[j]) dp[i]++;                else if(i &gt; nums[j]){                    dp[i] += dp[i - nums[j]];                }            }        }        return dp[target];    }};</code></pre><p>关于Follow up: 如果nums中出现了负数, 那么问题在于新的<code>target</code>值是通过<code>target - nums[i]</code>来得到的, 如果nums[i]为负, 那么新的<code>target</code>将会大于旧的<code>target</code>, 这会有两个问题</p><ol><li>动态规划只保存了小于旧<code>target</code>的值</li><li>如果动态规划不以<code>target</code>为终点而继续到新的<code>target</code>值, 那么又会产生更大的<code>target</code>, <code>target</code>会无穷增长下去.</li></ol><p>在题目中要求每个数只能选择一次就可以避免<code>target</code>的无限增长, 从而使求解成为可能.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 44. Wildcard Matching</title>
      <link href="/2016/07/29/leetcode-44-wildcard-matching/"/>
      <url>/2016/07/29/leetcode-44-wildcard-matching/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Implement wildcard pattern matching with support for ‘?’ and ‘*’.</p><pre><code>'?' Matches any single character.'*' Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;*&quot;) → trueisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;ab&quot;, &quot;?*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false</code></pre></blockquote><p>与<a href="http://xiadong.info/2016/07/leetcode-10-regular-expression-matching/" target="_blank" rel="noopener">LeetCode 10. Regular Expression Matching</a>这道题看起来十分相似, 但是使用相同的方法的话会超时. 然后我参考了这篇文章: <a href="http://yucoding.blogspot.jp/2013/02/leetcode-question-123-wildcard-matching.html" target="_blank" rel="noopener">http://yucoding.blogspot.jp/2013/02/leetcode-question-123-wildcard-matching.html</a>. 主要思路如下:</p><ul><li>用两个指针i,j或下标分别指向字符串s和p的开头</li><li><code>s[i] == p[j]</code>或<code>p[j] == '?'</code>, 字符匹配, i和j都加1</li><li><code>p[j] == '*'</code>, 也匹配, 记录下该<code>*</code>出现的位置<code>lastStar</code>和此时匹配的s中的位置<code>lastPosAfterStarMatch</code>, 这种情况下先认为<code>*</code>符号匹配空串, 所以只有j++</li><li>剩下的情况就是不匹配, 先看p串之前有没有位置<code>lastStar</code>, 如果有, 就将该位置的<code>*</code>所匹配的串长度加1(初始为0), 也就是把i变为<code>++lastPosAfterStarMatch</code>, j变为<code>lastStar + 1</code></li><li>如果之前没有<code>*</code>, 那么就返回不匹配</li><li>整个循环要处理完s, 然后查看p中剩下的字符是不是都是<code>*</code>, 如果是就返回true</li></ul><p>这个方法实际是回溯法, 只不过只回溯到上一个<code>*</code>而不再往前回溯.</p><p>代码:</p><pre><code>class Solution {public:    bool isMatch(string s, string p) {        int i = 0, j = 0, lastStar = -1, lastPosAfterStarMatch = -1;        while(i &lt; s.size()){            if(j &lt; p.size() &amp;&amp; (s[i] == p[j] || p[j] == '?')){                i++;j++;            }            else if(j &lt; p.size() &amp;&amp; p[j] == '*'){                lastStar = j++;                lastPosAfterStarMatch = i;            }            else if(lastStar != -1){                i = ++lastPosAfterStarMatch;                j = lastStar + 1;            }            else return false;        }        for(; j &lt; p.size(); j++){            if(p[j] != '*') return false;        }        return true;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 43. Multiply Strings</title>
      <link href="/2016/07/29/leetcode-43-multiply-strings/"/>
      <url>/2016/07/29/leetcode-43-multiply-strings/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p><p>Note:</p><ul><li>The numbers can be arbitrarily large and are non-negative.</li><li>Converting the input string to integer is NOT allowed.</li><li>You should NOT use internal library such as BigInteger.</li></ul></blockquote><p>输入两个用数组表示的非负数, 输出它们相乘的结果. 使用模拟手算的方法:</p><pre><code>class Solution {public:    void multiplyWithOneDigit(string&amp; num1, char num2, vector&lt;string&gt;&amp; v){        int jw = 0;        string re;        for(int i = num1.size() - 1; i &gt;= 0; i--){            int t = (num2) * (num1[i]) + jw;            re.push_back((t % 10));            jw = t / 10;        }        if(jw)            re.push_back(jw);        v.push_back(re);    }    void plusString(string&amp; a, string&amp; b){        if(a.size() &lt; b.size()){            swap(a, b);        }        string re;        int jw = 0;        for(int i = 0; i &lt; b.size(); i++){            int t = a[i] + b[i] + jw;            re.push_back((t % 10));            jw = t / 10;        }        for(int i = b.size(); i &lt; a.size(); i++){            int t = a[i] + jw;            re.push_back((t % 10));            jw = t / 10;        }        if(jw)            re.push_back(jw);        a = re;    }    string plusAll(vector&lt;string&gt;&amp; v){        string re = {0};        for(int i = 0; i &lt; v.size(); i++){            plusString(re, v[i]);        }        while(!re.empty() &amp;&amp; re.back() == 0) re.pop_back();        if(re.empty())            re = {0};        return re;    }    string multiply(string num1, string num2) {        for(auto &amp;i : num1) i -= '0';        for(auto &amp;i : num2) i -= '0';        vector&lt;string&gt; v;        if(num2.size() &gt; num1.size()) swap(num1, num2);        for(int i = num2.size() - 1; i &gt;= 0; i--){            multiplyWithOneDigit(num1, num2[i], v);            v.back().insert(v.back().begin(), num2.size() - i - 1, 0);        }        string ret = plusAll(v);        reverse(ret.begin(), ret.end());        for(auto &amp;i : ret) i += '0';        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 42. Trapping Rain Water</title>
      <link href="/2016/07/28/leetcode-42-trapping-rain-water/"/>
      <url>/2016/07/28/leetcode-42-trapping-rain-water/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p>For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p><p><img src="http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt=""></p><p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p></blockquote><p>蓄水的问题，我的想法是一个凹槽能蓄水，意味着它的两边比最低处高。考虑两边的话，最高的水面高度与较矮的一边相同。所以从左到右遍历每一个高度，对每一个高度向右寻找比它高的第一个高度，得到的就是蓄水的宽度。但是也有左边高右边低的情况，所以我先找到最高的高度，该高度左边的高度的右边都必然存在一个比它高的高度（最高的）。最高高度右边的高度则从右向左遍历。</p><pre><code>class Solution {public:    int trap(vector&lt;int&gt;&amp; height) {        int i = 0, j = 0;        int len = height.size(), ret = 0;        int maxPos = 0, maxHeight = INT_MIN;        for(int i = 0; i &lt; len; i++){            if(height[i] &gt; maxHeight){                maxHeight = height[i];                maxPos = i;            }        }        while(i &lt; maxPos){            for(j = i + 1; j &lt; maxPos &amp;&amp; height[j] &lt; height[i]; j++) ret += (height[i] - height[j]);            i = j;        }        i = len - 1;        while(i &gt; maxPos){            for(j = i - 1; j &gt; maxPos &amp;&amp; height[j] &lt; height[i]; j--) ret += (height[i] - height[j]);            i = j;        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 41. First Missing Positive</title>
      <link href="/2016/07/28/leetcode-41-first-missing-positive/"/>
      <url>/2016/07/28/leetcode-41-first-missing-positive/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an unsorted integer array, find the first missing positive integer.</p><p>For example,</p><p>Given [1,2,0] return 3,</p><p>and [3,4,-1,1] return 2.</p><p>Your algorithm should run in O(n) time and uses constant space.</p></blockquote><p>给定一个未排序数组, 要求找到其中缺失的最小正整数. 由于题目要求使用常数的空间, 因此只能利用输入数组中的空间. 我的思路是将正整数<code>1...n</code>与下标<code>0...n-1</code>对应起来, 假设数组大小为n, 将数值在[1, n]范围内的元素放到下标[0,n-1]的对应位置上, 然后再从头遍历一次数组, <code>nums[i] != i + 1</code>的位置就是缺失的第一个正整数. 对与<code>&lt;=0</code>和<code>&gt;n</code>的数不需要处理, 因为<code>&lt;=0</code>的数与结果无关, 而如果出现了<code>&gt;n</code>的数, 那么必然在[1,n]中有缺失的数, 也只需要处理[1,n]即可. 时间复杂度O(n).</p><p>由于交换nums中的两个元素后, 将<code>nums[i]</code>中的数放到了<code>nums[nums[i] - 1]</code>中, 因此<code>nums[i]</code>中此时仍然储存一个没有放到相应位置的数, 所以下一个循环还要处理i而不是i+1, 所以i要减1, 但是这在<code>[1,1]</code>这种输入数据中会导致死循环, 因此还要加一个判断, 即要交换的目标位置是不是已经有了对应的数, 如果有则不再需要处理.</p><pre><code>class Solution {public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {        for(int i = 0; i &lt; nums.size(); i++){            if(nums[i] &lt;= nums.size() &amp;&amp; nums[i] &gt; 0 &amp;&amp; nums[nums[i] - 1] != nums[i]){                swap(nums[nums[i] - 1], nums[i]);                i--;            }        }        for(int i = 0; i &lt; nums.size(); i++){            if(nums[i] != i + 1) return i + 1;        }        return nums.size() + 1;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 40. Combination Sum II</title>
      <link href="/2016/07/28/leetcode-40-combination-sum-ii/"/>
      <url>/2016/07/28/leetcode-40-combination-sum-ii/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a collection of candidate numbers © and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p><p>Each number in C may only be used once in the combination.</p><p>Note:</p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,</p><p>A solution set is:</p><pre><code>[  [1, 7],  [1, 2, 5],  [2, 6],  [1, 1, 6]]</code></pre></blockquote><p>解法参照上一题: <a href="http://xiadong.info/2016/07/leetcode-39-combination-sum/" target="_blank" rel="noopener">LeetCode 39. Combination Sum</a>, 区别在于两点</p><ul><li>输入数组中可能存在重复数字</li><li>每个元素只能选择一次</li></ul><p>解决第二个问题的办法很简单, 就是在每次进入下一级递归时从下一个元素开始. 解决第一个问题的办法是当一个值已经出现在结果中的某个位置时跳过接下来与这个值相等的所有元素.</p><p>代码如下:</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {        sort(candidates.begin(), candidates.end());        vector&lt;vector&lt;int&gt;&gt; re;        for (int i = 0; i &lt; candidates.size(); i++) {            if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1]) continue; //防止重复而跳过元素            vector&lt;int&gt; path;            getWithFirst(candidates, target, i, re, path);        }        return re;    }        void getWithFirst(vector&lt;int&gt;&amp; c, int target, int first, vector&lt;vector&lt;int&gt;&gt; &amp;ret, vector&lt;int&gt; &amp;path) {        if (c[first] == target) {            path.push_back(c[first]);            ret.push_back(path);            path.pop_back();            return;        }        int newTarget = target - c[first];        path.push_back(c[first]);        for (int i = first + 1; i &lt; c.size() &amp;&amp; c[i] &lt;= newTarget; i++) { //从first+1开始循环            if(i &gt; first + 1 &amp;&amp; c[i] == c[i - 1]) continue; //防止重复而跳过元素            getWithFirst(c, newTarget, i, ret, path);        }        path.pop_back();    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 39. Combination Sum</title>
      <link href="/2016/07/27/leetcode-39-combination-sum/"/>
      <url>/2016/07/27/leetcode-39-combination-sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a set of candidate numbers © and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p><p>The same repeated number may be chosen from C unlimited number of times.</p><p>Note:</p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:</p><pre><code>[  [7],  [2, 2, 3]]</code></pre></blockquote><p>在一个整数集合中取出元素(同一个元素可以选出多次)使它们的和等于<code>target</code>. 思路是先对数组排序, 然后以每个元素作为第一个元素, 从它后面的元素(包括它自己)中再继续选取元素. 使用递归来实现这个思路.</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {        sort(candidates.begin(), candidates.end());        vector&lt;vector&lt;int&gt;&gt; re;        for (int i = 0; i &lt; candidates.size() &amp;&amp; candidates[i] &lt;= target; i++) {            vector&lt;int&gt; path;            getWithFirst(candidates, target, i, re, path);        }        return re;    }    //函数参数和返回值都应该尽量不要直接使用对象, 虽然这样会损失函数封装性.    void getWithFirst(vector&lt;int&gt;&amp; c, int target, int first, vector&lt;vector&lt;int&gt;&gt; &amp;ret, vector&lt;int&gt; &amp;path) {        if (c[first] == target) {            //找到一组符合要求的元素            path.push_back(c[first]);            ret.push_back(path);            path.pop_back();            return;        }        int newTarget = target - c[first];        path.push_back(c[first]);        for (int i = first; i &lt; c.size() &amp;&amp; c[i] &lt;= newTarget; i++) {            //继续遍历first下标及之后的元素            getWithFirst(c, newTarget, i, ret, path);        }        path.pop_back();    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 38. Count and Say</title>
      <link href="/2016/07/27/leetcode-38-count-and-say/"/>
      <url>/2016/07/27/leetcode-38-count-and-say/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>The count-and-say sequence is the sequence of integers beginning as follows:<code>1, 11, 21, 1211, 111221, ...</code></p><p>1 is read off as “one 1” or 11.</p><p>11 is read off as “two 1s” or 21.</p><p>21 is read off as “one 2, then one 1” or 1211.</p><p>Given an integer n, generate the nth sequence.</p><p>Note: The sequence of integers will be represented as a string.</p></blockquote><p>题目意思要求把数字&quot;说出来&quot;, 其实含义就是给定一个包含数字的字符串, 把它用另一种方式表示出来, 即&quot;数字连续出现的数量 + 该数字&quot;. 这个新字符串作为下一次处理的源字符串. 因此我的解法就是模拟这种做法.</p><pre><code>class Solution {public:    string countAndSay(int n) {        string s = &quot;1&quot;;        for (int i = 1; i &lt; n; i++) {            string re;            char now = s[0];            int num = 1;            int len = s.size();            for (int i = 1; i &lt; len; i++) {                if (s[i] == now) num++;                else {                    re = re + to_string(num);                    re.push_back(now);                    num = 1;                    now = s[i];                }            }            re = re + to_string(num);            re.push_back(now);            s = re;        }        return s;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 37. Sudoku Solver</title>
      <link href="/2016/07/27/leetcode-37-sudoku-solver/"/>
      <url>/2016/07/27/leetcode-37-sudoku-solver/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>Empty cells are indicated by the character ‘.’.</p><p>You may assume that there will be only one unique solution.</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p><p>A sudoku puzzle…</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt=""></p><p>…and its solution numbers marked in red.</p></blockquote><p>题目要求解数独, 首先想到的解法是通过递归来穷举每一种可能的解. 在<code>getValidNum</code>函数中根据数独中已经存在的数获得当前位置可能填入的数. 该解法运行时间356ms.</p><pre><code>class Solution {public:    vector&lt;char&gt; getValidNum(vector&lt;vector&lt;char&gt;&gt;&amp; board, int step) {        int r = step / 9, c = step % 9;        set&lt;char&gt; re = { '1', '2', '3', '4', '5', '6', '7', '8', '9' };        for (int i = 0; i &lt; 9; i++) {            if (board[r][i] != '.')                re.erase(board[r][i]);            if (board[i][c] != '.')                re.erase(board[i][c]);        }        int rr = (r / 3) * 3, cc = (c / 3) * 3;        for (int i = 0; i &lt; 3; i++) {            for (int j = 0; j &lt; 3; j++) {                if (board[rr + i][cc + j] != '.')                    re.erase(board[rr + i][cc + j]);            }        }        vector&lt;char&gt; rev;        for (auto i : re)            rev.push_back(i);        return rev;    }    bool solveStep(vector&lt;vector&lt;char&gt;&gt;&amp; board, int step) {        if (step &gt;= 81)            return true;        int r = step / 9, c = step % 9;        if (board[r][c] != '.') {            return solveStep(board, step + 1);        }        vector&lt;char&gt; validNum = getValidNum(board, step);        for (auto i : validNum) {            board[r][c] = i;            if (solveStep(board, step + 1))                return true;        }        board[r][c] = '.';        return false;    }    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        bool re = solveStep(board, 0);    }};</code></pre><p>使用位运算代替set和vector来记录合法数字, 运算时间可以降至20ms.</p><pre><code>class Solution {public:    int getValidNum(vector&lt;vector&lt;char&gt;&gt;&amp; board, int step) {        int r = step / 9, c = step % 9;        int re = 0;        for (int i = 0; i &lt; 9; i++) {            if (board[r][i] != '.')                re |= 1 &lt;&lt; (board[r][i] - '1');            if (board[i][c] != '.')                re |= 1 &lt;&lt; (board[i][c] - '1');        }        int rr = (r / 3) * 3, cc = (c / 3) * 3;        for (int i = 0; i &lt; 3; i++) {            for (int j = 0; j &lt; 3; j++) {                if (board[rr + i][cc + j] != '.')                    re |= 1 &lt;&lt; (board[rr + i][cc + j] - '1');            }        }        return re;    }    bool solveStep(vector&lt;vector&lt;char&gt;&gt;&amp; board, int step) {        if (step &gt;= 81)            return true;        int r = step / 9, c = step % 9;        if (board[r][c] != '.') {            return solveStep(board, step + 1);        }        int validNum = getValidNum(board, step);        for (int i = 0; i &lt; 9; i++) {            if(validNum &amp; (1 &lt;&lt; i)) continue;            board[r][c] = i + '1';            if (solveStep(board, step + 1))                return true;        }        board[r][c] = '.';        return false;    }    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        bool re = solveStep(board, 0);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 36. Valid Sudoku</title>
      <link href="/2016/07/26/leetcode-36-valid-sudoku/"/>
      <url>/2016/07/26/leetcode-36-valid-sudoku/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" target="_blank" rel="noopener">Sudoku Puzzles - The Rules</a>.</p><p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p><p>A partially filled sudoku which is valid.</p><p>Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p></blockquote><p>要求判断一个数独题目是否合法, 但并不要求一定有解. 一个数独题目合法有以下三个条件:</p><ol><li>每一行都没有重复元素</li><li>每一列都没有重复元素</li><li>九个3x3方格中都没有重复元素</li></ol><p>因此验证这三个条件即可.</p><pre><code>class Solution {public:    void setNumFlag(vector&lt;int&gt;&amp; v){        for(int i = 0; i &lt; v.size(); i++) v[i] = 0;    }    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        vector&lt;int&gt; numFlag(9);        for(int i = 0; i &lt; 9; i++){            setNumFlag(numFlag);            for(int j = 0; j &lt; 9; j++){                char t = board[i][j];                if(t &gt;= '1' &amp;&amp; t &lt;= '9'){                    if(numFlag[t - '1'] == 1)                        return false;                    else                        numFlag[t - '1'] = 1;                }            }        }        for(int i = 0; i &lt; 9; i++){            setNumFlag(numFlag);            for(int j = 0; j &lt; 9; j++){                char t = board[j][i];                if(t &gt;= '1' &amp;&amp; t &lt;= '9'){                    if(numFlag[t - '1'] == 1)                        return false;                    else                        numFlag[t - '1'] = 1;                }            }        }        for(int i = 0; i &lt; 3; i++){            for(int j = 0; j &lt; 3; j++){                int x = i * 3, y = j * 3;                setNumFlag(numFlag);                for(int ii = 0; ii &lt; 3; ii++){                    for(int jj = 0; jj &lt; 3; jj++){                        char t = board[x + ii][y + jj];                        if(t &gt;= '1' &amp;&amp; t &lt;= '9'){                            if(numFlag[t - '1'] == 1)                                return false;                            else                                numFlag[t - '1'] = 1;                        }                    }                }            }        }        return true;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 35. Search Insert Position</title>
      <link href="/2016/07/25/leetcode-35-search-insert-position/"/>
      <url>/2016/07/25/leetcode-35-search-insert-position/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p>Here are few examples.</p><p><code>[1,3,5,6], 5 → 2</code></p><p><code>[1,3,5,6], 2 → 1</code></p><p><code>[1,3,5,6], 7 → 4</code></p><p><code>[1,3,5,6], 0 → 0</code></p></blockquote><p>二分查找先确定数组中存不存在target, 如果存在则返回它的下标, 如果不存在那么就看target是不是比nums中的所有元素都大, 如果是就返回最后一个元素的下标<code>nums.size()</code>, 接下来判断二分搜索的结束位置与target的关系, 如果比target大, 那么就返回结束位置, 如果比target小, 那么就返回结束位置 + 1.</p><pre><code>class Solution {public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {        int low = 0, high = nums.size();        while(low &lt; high){            if(nums[(low + high) / 2] == target) return (low + high) / 2;            else if(nums[(low + high) / 2] &lt; target){                low = (low + high) / 2 + 1;            }else{                high = (low + high) / 2;            }        }        if(low == nums.size() || nums[low] &gt; target)return low;        else return low + 1;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 34. Search for a Range</title>
      <link href="/2016/07/25/leetcode-34-search-for-a-range/"/>
      <url>/2016/07/25/leetcode-34-search-for-a-range/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>If the target is not found in the array, return [-1, -1].</p><p>For example,Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,return <code>[3, 4]</code>.</p></blockquote><p>先使用二分搜索查找到目标, 再向前后搜索到数值的起始位置.</p><pre><code>class Solution {public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {        int left = 0, right = nums.size();        while(left &lt; right){            int mid = left + (right - left) / 2;            if(nums[mid] == target){                vector&lt;int&gt; ret = {mid, mid};                while(ret[0] &gt;= 0 &amp;&amp; nums[ret[0]] == target) ret[0]--;                while(ret[1] &lt; nums.size() &amp;&amp; nums[ret[1]] == target) ret[1]++;                ret[0]++;                ret[1]--;                return ret;            }            else if(nums[mid] &gt; target){                right = mid;            }            else{                left = mid + 1;            }        }        return vector&lt;int&gt;(2, -1);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再一次被OneNote击退了</title>
      <link href="/2016/07/24/%E5%86%8D%E4%B8%80%E6%AC%A1%E8%A2%ABonenote%E5%87%BB%E9%80%80%E4%BA%86/"/>
      <url>/2016/07/24/%E5%86%8D%E4%B8%80%E6%AC%A1%E8%A2%ABonenote%E5%87%BB%E9%80%80%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>印象笔记前段时间调整了收费策略, 免费账户只能同时登录两个设备, 这个就有点不爽了. 而且我也不是重度用户, 觉得并不值得为高级账户付钱, 所以想起了被传的神乎其神的OneNote.</p><p>我在装Office的时候一起装了OneNote, 所以直接打开试试, 不得不说功能可以的, 但是同步实在太过于艰难了, 在移动设备上同步更改要等很久很久, 这还是在Wi-Fi下, 在网络不好的时候岂不是完全不能用了? 而且我从印象笔记使用微软官方提供的工具导入笔记, 但是同步的时候却告诉我格式错误. Exo me? 这不是你自己导入的吗? 因为OneNote是基于OndDrive来同步的, 所以OneNote的同步问题就是OneDrive的同步问题, 我在Win10中彻底禁用OneDrive就是因为这个同步功能过于坑爹.</p><p>难道我跟微软的东西都是相性不合? 微软做的东西我就没几个是用的舒心的(少数的几个有VS, OutLook邮箱不是客户端, Windows和VS Online的Git服务), 尤其是跟网络沾边的东西, 不过这大概也不全是巨硬的锅, 毕竟我现在还生活在一个不正常国家. 另外, 相比于OneNote的类Word的编辑体验, 我更喜欢纯文本的编辑(比如Markdown), 大概是因为这给了我更大的自主性吧, 而且一些其他的高级功能我也用不上. 我现在还是用Markdown+Git来写东西和同步(BTW, 我的私人Git服务是用的微软的, 不过这该算是Git好用还是难得我用巨硬的东西用的舒服呢), 我喜欢这种每一个环节都可以彻底掌控的感觉, 只不过手机和平板上就没办法了.</p><p>最后, 折腾了几个小时OneNote最后还是<strong>浪费时间</strong>. 暂时还是用着印象笔记吧.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 吐槽 </tag>
            
            <tag> 微软 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 33. Search in Rotated Sorted Array</title>
      <link href="/2016/07/24/leetcode-33-search-in-rotated-sorted-array/"/>
      <url>/2016/07/24/leetcode-33-search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p></blockquote><p>首先找到有序序列平移了多少位, 然后根据target在哪个范围内使用二分搜索.</p><pre><code>class Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {        if(nums.empty()) return -1;        int start = 0, end = nums.size();        for(int i = 0; i &lt; nums.size() - 1; i++){            if(nums[i] &gt; nums[i + 1]){                start = i + 1;                break;            }        }        if(target &lt; nums[0]){            return binSearch(nums, start, nums.size(), target);        }        else{            return binSearch(nums, 0, start ? start : nums.size(), target);        }    }        int binSearch(vector&lt;int&gt; &amp;nums, int left, int right, int target){        int low = left, high = right, mid = (low + high) / 2;        while(low &lt; high){            if(nums[mid] == target)                return mid;            else if(nums[mid] &gt; target)                high = mid;            else                low = mid + 1;                        mid = (low + high) / 2;        }        return -1;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 32. Longest Valid Parentheses</title>
      <link href="/2016/07/24/leetcode-32-longest-valid-parentheses/"/>
      <url>/2016/07/24/leetcode-32-longest-valid-parentheses/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p><p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p><p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p></blockquote><p>求最长的合法括号的长度, 采用先求匹配, 再求长度的方法.</p><pre><code>class Solution {public:    int longestValidParentheses(string s) {        if(s.empty()) return 0;        vector&lt;int&gt; pStack;        vector&lt;bool&gt; pMatch(s.length(), false);        int len = s.length();        for(int i = 0; i &lt; len; i++){            if(s[i] == '('){                pStack.push_back(i);            }            else if(pStack.empty() || s[pStack.back()] == ')'){                pStack.push_back(i);            }            else{                pMatch[i] = pMatch[pStack.back()] = true;                pStack.pop_back();            }        }        int maxLen = 0, curLen = 0;        for(int i = 0; i &lt; len; i++){            if(pMatch[i]){                curLen++;                if(curLen &gt; maxLen) maxLen = curLen;            }            else{                curLen = 0;            }        }        return maxLen;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 栈 </tag>
            
            <tag> 括号匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 31. Next Permutation</title>
      <link href="/2016/07/24/leetcode-31-next-permutation/"/>
      <url>/2016/07/24/leetcode-31-next-permutation/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place, do not allocate extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><p><code>1,2,3 → 1,3,2</code></p><p><code>3,2,1 → 1,2,3</code></p><p><code>1,1,5 → 1,5,1</code></p></blockquote><p>提要求输入一个数组, 返回下一个字典序比它大的排列, 如果不存在比它大的就返回最小的排列. 首先解决判断一个排列是不是最大的问题, 这个问题比较简单: 只要是这个序列是从大到小排列的, 那么它就是最大的序列. 然后再思考比较两个序列大小的问题: 从前到后逐个比较数组中的数字, 出现第一个不相等的位置, 较大的那一个序列就是字典序较大的. 然后再考虑给定一个序列获得它的下一个序列的方法, 因为随着数组下标增加, 该下标位置的数对于整个序列大小的影响是越来越小的, 因此要获得下一个排列, 应该修改尽量靠后位置的元素, 同时这个元素应该变为一个较大的值, 但是这个较大的值要在该元素之后, 因为要是与该位置之前的较大元素交换位置这个排列是变小了; 而且这个变换的目标值应该尽量小, 也就是找到该位置之后比该位置元素大的最小值. 然后是该位置之后的序列要最小, 把它们从小到大排序就可以了.</p><p>因此算法如下:</p><ul><li>判断是不是最大值</li><li>从后向前查找第一个在它之后有比它大的值的元素</li><li>在这个元素之后找到比它大的最小值</li><li>交换之后对于该元素之后的序列从小到大排序</li></ul><pre><code>class Solution {public:    bool isBiggest(vector&lt;int&gt;&amp; nums){        if(nums.size() &lt;= 1)            return true;        for(int i = 1; i &lt; nums.size(); i++){            if(nums[i] &gt; nums[i - 1])                return false;        }        return true;    }    int findCloestBiggerBehind(vector&lt;int&gt;&amp; nums, int pos){        int index = pos, n = INT_MAX;        for(int i = pos + 1; i &lt; nums.size(); i++){            if(nums[i] &gt; nums[pos] &amp;&amp; nums[i] &lt; n){                index = i;                n = nums[i];            }        }        return index;    }    void nextPermutation(vector&lt;int&gt;&amp; nums) {        if(isBiggest(nums)){            sort(nums.begin(), nums.end());            return;        }        int maxNum = INT_MIN;        for(int i = nums.size() - 1; i &gt;= 0; i--){            if(nums[i] &lt; maxNum){                int pos = findCloestBiggerBehind(nums, i);                int t = nums[i];                nums[i] = nums[pos];                nums[pos] = t;                sort(nums.begin() + i + 1, nums.end());                break;            }            maxNum = nums[i];        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> CPP </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 30. Substring with Concatenation of All Words</title>
      <link href="/2016/07/23/leetcode-30-substring-with-concatenation-of-all-words/"/>
      <url>/2016/07/23/leetcode-30-substring-with-concatenation-of-all-words/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p><p>For example, given:</p><p>s: “barfoothefoobarman”</p><p>words: [“foo”, “bar”]</p><p>You should return the indices: [0,9].</p><p>(order does not matter).</p></blockquote><p>首先使用暴力法, 将words中的词放入一个哈希表中, 这样可以在常数时间内找到它. 然后用一个双重循环来遍历字符串s.</p><pre><code>class Solution {public:    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {        vector&lt;int&gt; ret;        int wordsLen = words.size();        if(wordsLen == 0)            return ret;        int wordLen = words[0].length(), sLen = s.length(), totalLen = wordsLen * wordLen;                unordered_map&lt;string, int&gt; wordExistOrig;                for(int i = 0; i &lt; wordsLen; i++){            if(wordExistOrig.count(words[i])){                wordExistOrig[words[i]]++;            }            else{                wordExistOrig[words[i]] = 1;            }        }                for(int i = 0; i &lt;= sLen - totalLen; i++){            unordered_map&lt;string, int&gt; wordExist = wordExistOrig;            bool valid = true;            for(int j = i; j &lt; totalLen + i; j += wordLen){                string str = s.substr(j, wordLen);                if(wordExist.count(str) == 0) {                    valid = false;                    break;                }                else{                    wordExist[str]--;                    if(wordExist[str] &lt; 0){                        valid = false;                        break;                    }                }            }            if(valid) ret.push_back(i);        }                return ret;    }};</code></pre><p>还可以使用一种&quot;滑动窗口&quot;方法, 或者是双指针方法, 思路参考这里: <a href="http://www.2cto.com/kf/201406/311648.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201406/311648.html</a>. 举例来说比如题目中的例子: <code>&quot;barfoothefoobarman&quot;</code>和数组<code>[&quot;foo&quot;, &quot;bar&quot;]</code>, 首先窗口长度为0, 起始位置为0, 窗口长度和起始位置都是以单词长度的整数倍变化的, 这里是3, 首先把第一个单词放进窗口(用<code>{}</code>来表示窗口): <code>{bar}foothefoobarman</code>, 由于<code>foo</code>和<code>bar</code>每个都只出现一次, 所以把<code>bar</code>的剩余次数(这个次数保存在hash表中)减1变为0, 接下来把下一个单词放入窗口: <code>{barfoo}thefoobarman</code>, 同样把<code>foo</code>的次数减1变为0, 这时窗口中已经有两个单词, 与words数组的大小相同, 就可以把当前的窗口起始位置放入结果集中. 接下来是单词<code>the</code>, 这个单词在words数组中没有, 所以窗口可以直接跳过它, 将窗口起始位置越过的<code>bar</code>和<code>foo</code>的允许出现次数加1, 此时窗口位置位于<code>barfoothe{}foobarman</code>, 然后重复这个步骤. 为了不忽略类似<code>abarfoo</code>这种字符串中的结果, 所以要将窗口起始位置从0到单词长度3遍历一次.</p><p>代码如下, 运行时间36ms:</p><pre><code>class Solution {public:    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {        vector&lt;int&gt; ret;        int wordsLen = words.size();        if (wordsLen == 0)            return ret;        int wordLen = words[0].length(), sLen = s.length(), totalLen = wordsLen * wordLen;        unordered_map&lt;string, int&gt; wordExist;        for (int i = 0; i &lt; wordsLen; i++) {            if (wordExist.count(words[i])) {                wordExist[words[i]]++;            }            else {                wordExist[words[i]] = 1;            }        }        for (int i = 0; i &lt; wordLen; i++) {            int slideLeft = i, j = i, wordFound = 0;            while (slideLeft &lt;= sLen - totalLen &amp;&amp; j &lt; sLen) {                string str = s.substr(j, wordLen);                if (wordExist.count(str) == 0) {                    //下一个单词不再words中时将窗口初始位置移到当前之后的位置                    j += wordLen;                    for (; slideLeft &lt; j; slideLeft += wordLen) {                        string toDropStr = s.substr(slideLeft, wordLen);                        if(wordExist.count(toDropStr))wordExist[toDropStr]++;                    }                    //slideLeft = j;                    wordFound = 0;                    continue;                }                if (wordFound == wordsLen) {                    //当窗口满的时候丢弃最前端的字符串                    string toDropStr = s.substr(slideLeft, wordLen);                    wordExist[toDropStr]++;                    slideLeft += wordLen;                    wordFound--;                }                wordExist[str]--;                if (wordExist[str] &lt; 0) {                    //当前字符串出现次数已满, 要不停的丢弃窗口最前端的字符串直到出现次数为0为止                    while (wordExist[str] &lt; 0) {                        string toDropStr = s.substr(slideLeft, wordLen);                        wordExist[toDropStr]++;                        slideLeft += wordLen;                        wordFound--;                    }                }                wordFound++;                if (wordFound == wordsLen) {//找到一个要求的位置                    ret.push_back(slideLeft);                }                j += wordLen;            }            for (; slideLeft &lt; j; slideLeft += wordLen) {                //恢复每个单词出现的次数                string toDropStr = s.substr(slideLeft, wordLen);                if (wordExist.count(toDropStr)) wordExist[toDropStr]++;            }        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 29. Divide Two Integers</title>
      <link href="/2016/07/23/leetcode-29-divide-two-integers/"/>
      <url>/2016/07/23/leetcode-29-divide-two-integers/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Divide two integers without using multiplication, division and mod operator.</p><p>If it is overflow, return MAX_INT.</p></blockquote><p>不使用乘除和取模运算实现整数除法. 我的实现方法是使用位运算来实现二进制除法, 首先确定结果的符号位后取得被除数与除数的绝对值, 这样就可以只考虑原码不用考虑补码除法. 需要注意的是对于<code>INT_MIN</code>这个值(也就是-2147483648)要特殊处理, 因为它的值是这样的: <code>0x80000000</code>, 也就是只有最高位是1, <code>abs</code>函数无法对这个值取绝对值, 而且可能造成溢出问题.</p><p>关于二进制除法可以参考这里: <a href="http://www.tyut.edu.cn/kecheng1/2008/site08/courseware/chapter1/1.2.htm" target="_blank" rel="noopener">http://www.tyut.edu.cn/kecheng1/2008/site08/courseware/chapter1/1.2.htm</a></p><blockquote><p>二进制数除法与十进制数除法很类似。可先从被除数的最高位开始，将被除数（或中间余数）与除数相比较，若被除数（或中间余数）大于除数，则用被除数（或中间余数）减去除数，商为1，并得相减之后的中间余数，否则商为0。再将被除数的下一位移下补充到中间余数的末位，重复以上过程，就可得到所要求的各位商数和最终的余数。</p></blockquote><p>代码:</p><pre><code>class Solution {public:    int divide(int dividend, int divisor) {        if(divisor == 0) return INT_MAX;        int sign = (dividend ^ divisor) &amp; 0x80000000 ? -1 : 1;        int absDividend = abs(dividend), absDivisor = abs(divisor);        if(dividend == INT_MIN){            if(divisor == -1) return INT_MAX;            else absDividend = INT_MIN;        }        else{            if(absDividend &lt; absDivisor) return 0;        }                return sign * absDivid(absDividend, absDivisor);    }        int absDivid(unsigned int dividend, unsigned int divisor){        int mDividend = getBit(dividend, 31), ret = 0;        for(int i = 31; i &gt;= 0; i--){            if(mDividend &gt;= divisor){                ret |= (1 &lt;&lt; i);A                mDividend = mDividend - divisor;            }            if(i != 0){                mDividend = (mDividend &lt;&lt; 1) + getBit(dividend, i - 1);            }        }        return ret;    }        int getBit(unsigned int n, int p){        return n &amp; (1 &lt;&lt; p) ? 1 : 0;    }};</code></pre><p>这段代码是默认<code>int</code>类型长度是4个字节.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 28. Implement strStr()</title>
      <link href="/2016/07/22/leetcode-28-implement-strstr/"/>
      <url>/2016/07/22/leetcode-28-implement-strstr/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Implement strStr().</p><p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p></blockquote><p>实现查找子串函数. 使用双重循环.</p><pre><code>class Solution {public:    int strStr(string haystack, string needle) {        int haylength = haystack.length(), needlelength = needle.length();        if(haylength &lt; needlelength) return -1;        for(int i = 0; i &lt;= haylength - needlelength; i++){            int j;            for(j = 0; j &lt; needlelength; j++){                if(haystack[i + j] != needle[j]) break;            }            if(j == needlelength)                return i;        }                return -1;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 376. Wiggle Subsequence</title>
      <link href="/2016/07/21/leetcode-376-wiggle-subsequence/"/>
      <url>/2016/07/21/leetcode-376-wiggle-subsequence/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p><p>For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p><p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p><p>Examples:</p><pre><code>Input: [1,7,4,9,2,5]Output: 6The entire sequence is a wiggle sequence.Input: [1,17,5,10,13,15,10,5,16,8]Output: 7There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].Input: [1,2,3,4,5,6,7,8,9]Output: 2</code></pre><p>Follow up:Can you do it in O(n) time?</p></blockquote><p>使用动态规划, 只需要保存当前节点与之前一个节点的信息.</p><pre><code>class Solution {public:    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {        int len = nums.size();        if(len &lt;= 2) return len;        int maxLen = 2, diff = nums[1] - nums[0];        for(int i = 2; i &lt; len; i++){            int d = nums[i] - nums[i - 1];            if(d &amp;&amp; diff &amp;&amp; ((d ^ diff) &amp; 0x80000000)){                maxLen++;            }            if(d != 0){                diff = d;            }        }        return maxLen;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于给父母分享照片</title>
      <link href="/2016/07/21/%E5%85%B3%E4%BA%8E%E7%BB%99%E7%88%B6%E6%AF%8D%E5%88%86%E4%BA%AB%E7%85%A7%E7%89%87/"/>
      <url>/2016/07/21/%E5%85%B3%E4%BA%8E%E7%BB%99%E7%88%B6%E6%AF%8D%E5%88%86%E4%BA%AB%E7%85%A7%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>关于照片存储备份的问题, 我现在用的Google相册, 虽然按照Google的尿性说不定哪天就给关了, 但是现在用起来还是挺方便的. 但是本来应该是主要功能的照片分享功能却由于那说是不存在但是却是确确实实无处不在的GFW的原因而变得几乎不可用. 尤其是对于我父母这样别说搭梯子, 百度云都不会用(我也不敢给他们用百度)的, 分享照片更是非常麻烦.</p><p>我先来总结一下给我父母这样的用户分享照片所需要的服务应该有什么样的特性:</p><ul><li>访问方便, 便于查找; 也就是说可生成分享链接或者与社交网络绑定</li><li>国内访问速度快; 这就没有了用Google相册或者Flickr之类服务的可能</li><li>稳定; 谁都不想过一段时间服务就关闭了</li><li>要有相册管理功能, 至少缩略图之类应该具备</li><li>免费</li><li>最好有权限访问控制, 因为与父母分享的照片不少是不想公开的</li><li>手机访问支持比较好</li></ul><p>出于以上的几点, 我首先排除了国内的所有网盘, 因为它们基本都没有相册管理功能; 然后把目标划定在国内大型的互联网企业上. 至于iCloud, 小米, 华为等公司推出的云相册服务因为与要与设备绑定所以也排除. 百度家的东西排除, 网易相册的iOS客户端快三年没有更新了也不知道还能挺多久, 而且初始容量只有1G, 超出后只有每月300M, 有点不太够用. 至于阿里似乎没有推出过这种服务.</p><p>剩下的考虑企鹅, 不得不说企鹅的占有率真是厉害, 我父母手机上使用频率最高的应用就是微信了. 所以我一直用朋友圈来给父母分享一些照片. 但是这问题仍然很大, 首先是一次只能选择9张, 我一次上传一千多张根本就是不可能; 其次是微信对于图片压缩地太厉害, 基本上属于放大就不能看; 然后是没有PC端, 电脑上的许多照片不可能都传到手机上. 所以我每次都是选几张照片传上去.</p><p>直到昨天, 我突然心血来潮打开了尘封已久的QQ空间, 突然发现QQ空间相册竟然支持原图上传(其实我忘记了它以前支不支持), 并且有了只允许部分好友查看的功能. 突然觉得这就是我想要的与父母分享照片的工具. 父母都有QQ号并且可以通过手机QQ客户端查看; 可以保存原图, 不压缩画质(<strong>实测分辨率不变但是体积减少100-200kB左右, 并且不提供批量下载功能, 加上下载后会丢失EXIF信息, 因此不太适合做照片备份</strong>); 有访问权限控制; 国内访问速度有保障; 可以在PC端上传图片; 服务免费, 我现在有30G容量, 虽然不大, 但也勉强够用(而且不知道它是怎么计算容量的, 我昨天上传了1000+张3M左右的照片原图, 但是现在只显示用了0.4G).</p><p>关于安全和隐私, 企鹅虽然不能说很安全, 但是也算是有底线. 而想要隐私的话, 东西还是根本不要放到网上为好.</p><p>对我来说, 目前用QQ空间的相册功能算是给父母分享照片的最佳方案了.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL容器学习笔记三 - Forward_list</title>
      <link href="/2016/07/20/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-forward-list/"/>
      <url>/2016/07/20/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-forward-list/</url>
      
        <content type="html"><![CDATA[<h1 id="forward-list-前向链表-c-11"><a href="http://www.cplusplus.com/reference/forward_list/forward_list/" target="_blank" rel="noopener">Forward list</a> 前向链表[C++11]</h1><p>前向链表是提供常数复杂度的插入删除操作的容器, 它被实现为一个单链接链表.</p><p><code>forward_list</code>与<code>list</code>的区别在于前者保存指向每个节点的后一个节点的指针, 而后者保存前后两个节点的指针. <code>forward_list</code>比<code>list</code>稍微高效, 但是缺点在于只能向前遍历.</p><p>与其他顺序容器相比主要优点在于在容器任意位置插入, 提取和移动的表现更好. 不足在于不能根据元素在容器中的位置来访问元素.</p><p><code>forward_list</code>被设计得非常高效, 它与一个简单的C语言手写单向链表的效率相当. 实际上, <strong>它是唯一一个出于性能考虑而不提供<code>size</code>成员函数的标准容器</strong>.</p><h1 id="部分函数">部分函数</h1><p>只列举一些我不太熟悉的函数.</p><h2 id="构造函数">构造函数</h2><h3 id="默认构造函数">默认构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>创建一个空容器.​</p><h3 id="填充构造函数">填充构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>创建一个大小为n的容器, 如果提供了val, 则n个值都初始化为val.​</p><h3 id="范围构造函数">范围构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">forward_list</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br></pre></td></tr></table></figure><p>用<code>[first, last)</code>中的数据初始化.</p><h3 id="拷贝构造函数">拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst);</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br></pre></td></tr></table></figure><h3 id="移动构造函数">移动构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (forward_list&amp;&amp; fwdlst);</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br></pre></td></tr></table></figure><p>除非alloc的类型与fwdlst不一致, 否则不会构造任何一个元素, 它们的所有权被直接转移.</p><h3 id="初始化列表">初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span><br><span class="line"><span class="keyword">const</span> allocator_type&amp; alloc = allocator_type());</span><br></pre></td></tr></table></figure><h2 id="forward-list-before-begin">forward_list::before___begin</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>返回指向容器中首个元素之前的元素的迭代器. 该迭代器不能解引用, 主要作为成员函数<code>emplace_after</code>, <code>insert_after</code>, <code>erase_after</code>和<code>splice_after</code>的参数.</p><h2 id="forward-list-emplace-after">forward_list::emplace_after</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">emplace_after</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>在position的位置之后插入元素, args为插入的新元素的初始化参数.</p><h2 id="forward-list-emplace-front">forward_list::emplace_front</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">emplace_front</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>在容器头部插入新元素, args为插入的新元素的初始化参数.</p><h2 id="forward-list-erase-after">forward_list::erase_after</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase_after</span> <span class="params">(const_iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase_after</span> <span class="params">(const_iterator <span class="built_in">position</span>, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>删除容器中position之后的一个元素或者(position, last)范围内的元素.</p><h2 id="forward-list-merge">forward_list::merge</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(forward_list&amp; fwdlst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(forward_list&amp;&amp; fwdlst)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">forward_list</span>&amp; <span class="title">fwdlst</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">forward_list</span>&amp;&amp; <span class="title">fwdlst</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure><p>根据指定顺序将fwdlst与当前容器合并.</p><h2 id="forward-list-remove-if">forward_list::remove_if</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">remove_if</span> (<span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure><p>对容器中的每个元素, 执行pred(以<code>pred(*i)</code>的形式), 如果为true则删除该元素.</p><p>pred可以为函数指针或者函数对象.</p><h2 id="forward-list-sort">forward_list::sort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span> (<span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure><p>排序函数, 该函数是稳定排序. 整个操作不包括任何的元素构造, 析构和复制. 元素只是在容器内移动.</p><p><strong>时间复杂度</strong>: NlogN.</p><h2 id="forward-list-unique">forward_list::unique</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">unique</span> (<span class="title">BinaryPredicate</span> <span class="title">binary_pred</span>);</span></span><br></pre></td></tr></table></figure><p>删除重复元素. <strong>这个操作只会删除与前一个元素相同的元素, 也就是说只能用于已经排序的容器.</strong></p><p>第二种形式中的参数binary_pred以<code>binary_pred(*i, *(i - 1))</code>的形式调用, 此函数返回true则认为两个元素相等.</p><p>binary_pred可以为函数指针或者函数对象.</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 27. Remove Element</title>
      <link href="/2016/07/20/leetcode-26-remove-duplicates-from-sorted-array-2/"/>
      <url>/2016/07/20/leetcode-26-remove-duplicates-from-sorted-array-2/</url>
      
        <content type="html"><![CDATA[<p>问题描述:</p><blockquote><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this in place with constant memory.</p><p>For example,Given input array nums = [1,1,2],</p><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p></blockquote><p>对一个有序数组去重, 并且要求不使用额外的存储空间.</p><p>首先解决的是去重的问题, 如果没有额外空间的限制, 首先想到的是创建一个新的数组, 然后遍历nums, 大于新数组末尾的数则把当前的数加入新数组. 这里数组末尾的数其实就是已经遍历过的最大值, 因此可以用一个变量来保存.</p><p>接下来是存储空间的问题, 由于nums中每个数在遍历时的作用只是与当前遍历过的最大值比较, 而已经遍历过的数是没有什么作用的, 所以可以使用已经遍历过的nums数所占的空间.</p><pre><code>class Solution {public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) {        int num = 0, totalLen = nums.size(), curMax = INT_MIN;        for(int i = 0, j = 0; i &lt; totalLen; i++){            if(nums[i] &gt; curMax){                curMax = nums[i];                num++;                nums[j++] = nums[i];            }        }        return num;    }};</code></pre><p>这段代码的Runtime是36毫秒, 但是许多AC代码的Runtime都在32ms, 说明这个程序还有一定的优化空间.</p><p>首先循环体内部的操作已经非常简洁, 应该很难有所作为, 所以优化的目标应该在循环次数上. 先将nums中最大的数保存下来, 当遍历到与该值相等的时候, 把这个数处理完后就可以退出循环了. 所以最终代码:</p><pre><code>class Solution {public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) {        int num = 0, totalLen = nums.size(), curMax = INT_MIN;        int maxItem = nums.empty() ? 0 : nums.back();        for(int i = 0, j = 0; i &lt; totalLen; i++){            if(nums[i] &gt; curMax){                curMax = nums[i];                num++;                nums[j++] = nums[i];            }            if(nums[i] == maxItem){                break;            }        }        return num;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 26. Remove Duplicates from Sorted Array</title>
      <link href="/2016/07/20/leetcode-26-remove-duplicates-from-sorted-array/"/>
      <url>/2016/07/20/leetcode-26-remove-duplicates-from-sorted-array/</url>
      
        <content type="html"><![CDATA[<p>问题描述:</p><blockquote><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this in place with constant memory.</p><p>For example,Given input array nums = [1,1,2],</p><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p></blockquote><p>对一个有序数组去重, 并且要求不使用额外的存储空间.</p><p>首先解决的是去重的问题, 如果没有额外空间的限制, 首先想到的是创建一个新的数组, 然后遍历nums, 大于新数组末尾的数则把当前的数加入新数组. 这里数组末尾的数其实就是已经遍历过的最大值, 因此可以用一个变量来保存.</p><p>接下来是存储空间的问题, 由于nums中每个数在遍历时的作用只是与当前遍历过的最大值比较, 而已经遍历过的数是没有什么作用的, 所以可以使用已经遍历过的nums数所占的空间.</p><pre><code>class Solution {public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) {        int num = 0, totalLen = nums.size(), curMax = INT_MIN;        for(int i = 0, j = 0; i &lt; totalLen; i++){            if(nums[i] &gt; curMax){                curMax = nums[i];                num++;                nums[j++] = nums[i];            }        }        return num;    }};</code></pre><p>这段代码的Runtime是36毫秒, 但是许多AC代码的Runtime都在32ms, 说明这个程序还有一定的优化空间.</p><p>首先循环体内部的操作已经非常简洁, 应该很难有所作为, 所以优化的目标应该在循环次数上. 先将nums中最大的数保存下来, 当遍历到与该值相等的时候, 把这个数处理完后就可以退出循环了. 所以最终代码:</p><pre><code>class Solution {public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) {        int num = 0, totalLen = nums.size(), curMax = INT_MIN;        int maxItem = nums.empty() ? 0 : nums.back();        for(int i = 0, j = 0; i &lt; totalLen; i++){            if(nums[i] &gt; curMax){                curMax = nums[i];                num++;                nums[j++] = nums[i];            }            if(nums[i] == maxItem){                break;            }        }        return num;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 25. Reverse Nodes in k-Group</title>
      <link href="/2016/07/20/leetcode-25-reverse-nodes-in-k-group/"/>
      <url>/2016/07/20/leetcode-25-reverse-nodes-in-k-group/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>You may not alter the values in the nodes, only nodes itself may be changed.</p><p>Only constant memory is allowed.</p><p>For example,Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p></blockquote><p>以k个节点为一组进行顺序颠倒. 首先实现一个从某个节点开始, 把包括它的接下来的k个节点的顺序颠倒的函数, 再不断迭代这个函数直到链表末尾. 由于如果链表长度不是k的整数倍的话, 最后的<code>m(m&lt;k)</code>个元素不进行处理, 所以先计算出链表的总长度<code>len</code>, 在每次迭代时计算已经处理过的节点数<code>reversedLen</code>, 当<code>reversedLen + k &gt; len</code>时结束循环.</p><pre><code>/*** Definition for singly-linked list.* struct ListNode {*     int val;*     ListNode *next;*     ListNode(int x) : val(x), next(NULL) {}* };*/class Solution {public:    ListNode* reverse(ListNode* prev, int k){        if(!prev-&gt;next) return nullptr;        ListNode *tail = prev-&gt;next, *pPrev = tail, *pCur = pPrev-&gt;next;        for(int i = 1; pCur &amp;&amp; i &lt; k; i++){            ListNode *pNext = pCur-&gt;next;            pCur-&gt;next = pPrev;            pPrev = pCur;            pCur = pNext;        }        prev-&gt;next = pPrev;        tail-&gt;next = pCur;        return tail;    }        int countListLength(ListNode *list){        int len = 0;        ListNode *p = list;        while(p){            len++;            p = p-&gt;next;        }        return len;    }    ListNode* reverseKGroup(ListNode* head, int k) {        if(head == nullptr || k &lt;= 1)            return head;        ListNode *trueHead = new ListNode(0), *p = trueHead;        trueHead-&gt;next = head;        int listLen = countListLength(head);        int reversedLen = 0;                while(true){            if(reversedLen + k &gt; listLen) break;            p = reverse(p, k);            reversedLen += k;        }        return trueHead-&gt;next;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 24. Swap Nodes in Pairs</title>
      <link href="/2016/07/18/leetcode-24-swap-nodes-in-pairs/"/>
      <url>/2016/07/18/leetcode-24-swap-nodes-in-pairs/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>For example,Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p><p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p></blockquote><p>交换链表相邻节点。</p><p>C++:</p><pre><code>class Solution {public:    ListNode *swapPairs(ListNode *head) {        if(head == NULL || head-&gt;next == NULL) return head;        ListNode *first = head, *second = head-&gt;next, *prev = NULL;        first-&gt;next = second-&gt;next;        second-&gt;next = first;        head = second;        prev = first;        first = first-&gt;next;        while(first){            second = first-&gt;next;            if(second == NULL)break;            first-&gt;next = second-&gt;next;            second-&gt;next = first;            prev-&gt;next = second;            prev = first;            first = first-&gt;next;        }        return head;    }};</code></pre><p>时间4ms。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 23. Merge k Sorted Lists</title>
      <link href="/2016/07/18/leetcode-23-merge-k-sorted-lists/"/>
      <url>/2016/07/18/leetcode-23-merge-k-sorted-lists/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p></blockquote><p>合并k个有序链表. 首先创建一个小顶堆(比较的是每个链表节点的值), 其中的元素是k个链表的头结点, 每次取出堆顶的节点, 加入到合并后的链表中, 然后将这个节点的后一个节点放入堆中, 如果是链表尾则不放入. 重复这个步骤直到堆为空.</p><p>由于建n个元素的堆的时间复杂度为O(n)(证明见: <a href="http://blog.csdn.net/anonymalias/article/details/8807895" target="_blank" rel="noopener">http://blog.csdn.net/anonymalias/article/details/8807895</a>). 假设共有n个节点, 总的时间复杂度约为<code>O(k)+O(nlogk)</code>(我并不太会算复杂度, 这个也只是估计的…).</p><pre><code>/*** Definition for singly-linked list.* struct ListNode {*     int val;*     ListNode *next;*     ListNode(int x) : val(x), next(NULL) {}* };*/class Solution {public:    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {        auto comp = [=](ListNode *a, ListNode *b){            return a-&gt;val &lt;= b-&gt;val;        };        ListNode *head = new ListNode(0), *p = head;        if(lists.empty()) return head-&gt;next;        set&lt;ListNode*, decltype(comp)&gt; s(comp);        for(int i = 0; i &lt; lists.size(); i++){            if(lists[i] != nullptr){                s.insert(lists[i]);            }        }        while(!s.empty()){            ListNode *node = *(s.begin());            s.erase(s.begin());            if(node-&gt;next != nullptr) s.insert(node-&gt;next);            p-&gt;next = node;            p = p-&gt;next;        }        return head-&gt;next;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 22. Generate Parentheses</title>
      <link href="/2016/07/18/leetcode-22-generate-parentheses/"/>
      <url>/2016/07/18/leetcode-22-generate-parentheses/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><pre><code>[  &quot;((()))&quot;,  &quot;(()())&quot;,  &quot;(())()&quot;,  &quot;()(())&quot;,  &quot;()()()&quot;]</code></pre></blockquote><p>题目要求输出n个括号的所有组合. 每个合法的字符串的长度都是<code>2*n</code>, 其中每个位置的字符有两种可能: 左括号和右括号. 因此循环<code>2*n</code>次, 每次对于结果集ret中的每个字符串末尾添加括号, 判断两种情况哪一种合法.或者两种都合法.</p><p><strong>左括号合法的情况</strong></p><p>字符串中出现的左括号总数没有超过<code>n</code>, 则在尾部添加左括号总是合法的.</p><p><strong>右括号合法的情况</strong></p><p>字符串中含有未配对的左括号. 注意: 如果左括号总数没有超过<code>n</code>, 那么该字符串添加左右括号都是合法的, 因此要在结果集末尾增加一条; 如果已经有了<code>n</code>个左括号, 那么只能添加右括号.</p><pre><code>class Solution {public:    vector&lt;string&gt; generateParenthesis(int n) {        vector&lt;string&gt; ret = {&quot;(&quot;};        vector&lt;int&gt; leftNum = {1};   //ret中每个字符串中左括号的数量        vector&lt;int&gt; singleLeftNum = {1};  //ret中每个字符串中未配对的左括号数量        int strLen = n * 2;        for(int i = 1; i &lt; strLen; i++){            int len = ret.size();            for(int j = 0; j &lt; len; j++){                if(singleLeftNum[j] &gt; 0){                    if(leftNum[j] == n){                        ret[j].push_back(')');                        singleLeftNum[j]--;                    }                    else{                        ret.push_back(ret[j] + &quot;)&quot;);                        leftNum.push_back(leftNum[j]);                        singleLeftNum.push_back(singleLeftNum[j] - 1);                    }                }                if(leftNum[j] &lt; n){                    ret[j].push_back('(');                    leftNum[j]++;                    singleLeftNum[j]++;                }            }        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL容器学习笔记二 - Deque</title>
      <link href="/2016/07/17/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-deque/"/>
      <url>/2016/07/17/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-deque/</url>
      
        <content type="html"><![CDATA[<h1 id="deque简介"><a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank" rel="noopener">Deque</a>简介</h1><p>deque(读作<em>deck</em>)是双向队列的缩写(<strong>d</strong>ouble-<strong>e</strong>nded <strong>que</strong>ue), 它是可以在两端动态变更大小的顺序容器.</p><p>不同的库可能会以不同的方法来实现deque, 但不管怎样, 它们都允许通过随机访问迭代器访问特定元素, 并且根据需要自动管理存储空间.</p><p>deque提供与vector相似的功能, 但是允许首尾两端高效的插入删除元素而不是像vector一样只能在尾部. <strong>但是</strong>, deque不像vector一样保证使用顺序存储空间来保存元素, 因此如果通过指针和偏移量访问deque中的另一个元素会引发<strong>未定义行为</strong>.</p><p>Vector与deque提供相似的接口并且可以用于相似的用途, 但它们的内部实现确完全不同. Vector使用一个在元素数量增长时偶尔需要重新分配空间的数组, 而deque中的元素可以分散存储在内存中的不同位置, deque容器内部通过保存必要的信息来提供在常数时间内访问任意元素的功能, 并且通过迭代器提供一个统一的顺序访问接口. 因此, deque的内部实现比vector要复杂, 但是这使得它在特定情况下可以更高效的增长, 比如在序列非常长时, 重新分配空间会非常耗时.</p><p>对于需要在首尾以外的位置频繁插入删除的操作来说, deque比list和forward list表现要差.</p><h1 id="容器属性">容器属性</h1><h2 id="顺序">顺序</h2><p>顺序容器中的元素都遵循严格的线性序列, 每个元素都可以通过他们在序列中的位置来访问.</p><h2 id="动态数组">动态数组</h2><p>通常实现类似于动态数组, 提供随机访问序列中任意元素的能力并且提供在序列首尾高效插入/删除的操作.</p><h2 id="allocator-aware">Allocator-aware[?]</h2><p>容器使用一个allocator对象来动态管理存储空间.</p><h1 id="部分常用函数">部分常用函数</h1><p>一些常用的函数比如<code>size</code>, <code>back</code>, <code>push_back</code>, <code>pop_back</code>, <code>push_front</code>, <code>pop_front</code>等我就不再赘述了</p><h2 id="构造函数">构造函数</h2><h3 id="默认构造函数-default-constructor">默认构造函数 <em>Default constructor</em></h3><pre><code>explicit deque (const allocator_type&amp; alloc = allocator_type());</code></pre><p>创建一个空容器.</p><h3 id="填充构造函数-fill-constructor">填充构造函数 <em>Fill constructor</em></h3><pre><code>explicit deque (size_type n);         deque (size_type n, const value_type&amp; val,                const allocator_type&amp; alloc = allocator_type());</code></pre><p>创建一个有n个元素的容器, 如果提供了val, 则n个元素的值都为val.</p><h3 id="范围构造函数-range-constructor">范围构造函数 <em>Range constructor</em></h3><pre><code>template &lt;class InputIterator&gt;  deque (InputIterator first, InputIterator last,         const allocator_type&amp; alloc = allocator_type());</code></pre><p>构建一个数量与[first, last)相同的容器, 以与之相同的顺序初始化每个元素.</p><h3 id="拷贝构造函数">拷贝构造函数</h3><pre><code>deque (const deque&amp; x);deque (const deque&amp; x, const allocator_type&amp; alloc);</code></pre><p>创建一个以x中的元素的拷贝组成的容器.</p><h3 id="移动构造函数-move-constructor">移动构造函数 <em>Move constructor</em></h3><pre><code>deque (deque&amp;&amp; x);deque (deque&amp;&amp; x, const allocator_type&amp; alloc);</code></pre><p>创建一个由从x中取得的元素组成的容器, 下面这句话我没有太看懂:</p><blockquote><p>If alloc is specified and is different from x’s allocator, the elements are moved. Otherwise, no elements are constructed (their ownership is directly transferred).</p></blockquote><p>x会保持一个未定义但合法的状态.</p><h3 id="初始化列表构造函数">初始化列表构造函数</h3><pre><code>deque (initializer_list&lt;value_type&gt; il,       const allocator_type&amp; alloc = allocator_type());</code></pre><p>以il中元素的顺序用每个元素的拷贝创建一个容器.</p><h3 id="例子">例子</h3><pre><code>// code url: http://www.cplusplus.com/reference/deque/deque/deque/// constructing deques#include &lt;iostream&gt;#include &lt;deque&gt;int main (){    unsigned int i;    // constructors used in the same order as described above:    std::deque&lt;int&gt; first;                                // empty deque of ints    std::deque&lt;int&gt; second (4,100);                       // four ints with value 100    std::deque&lt;int&gt; third (second.begin(),second.end());  // iterating through second    std::deque&lt;int&gt; fourth (third);                       // a copy of third    // the iterator constructor can be used to copy arrays:    int myints[] = {16,2,77,29};    std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) );    std::cout &lt;&lt; &quot;The contents of fifth are:&quot;;    for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it)        std::cout &lt;&lt; ' ' &lt;&lt; *it;    std::cout &lt;&lt; '\n';    return 0;}</code></pre><p>输出</p><pre><code>The contents of fifth are: 16 2 77 29</code></pre><h2 id="deque-assign">deque::assign</h2><p><strong>range (1)</strong></p><pre><code>template &lt;class InputIterator&gt;void assign (InputIterator first, InputIterator last);</code></pre><p><strong>fill (2)</strong></p><pre><code>void assign (size_type n, const value_type&amp; val);</code></pre><p><strong>initializer list (3)</strong></p><pre><code>void assign (initializer_list&lt;value_type&gt; il);</code></pre><p>重新配置deque中的内容, 并相应地调整大小. 使用方法类似于相应的构造函数.</p><h2 id="deque-clear">deque::clear</h2><pre><code>void clear() noexcept;</code></pre><p>清空容器中的所有元素.</p><p><strong>时间复杂度:</strong> 与size有关的线性(因为要执行元素的析构函数).</p><h2 id="deque-max-size">deque::max_size</h2><pre><code>size_type max_size() const noexcept;</code></pre><p>返回deque容器所能保存的最大元素数量. 但是deque不保证一定能达到这个数量.</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 21. Merge Two Sorted Lists</title>
      <link href="/2016/07/17/leetcode-21-merge-two-sorted-lists/"/>
      <url>/2016/07/17/leetcode-21-merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<p>问题描述:</p><blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p></blockquote><p>简单的链表操作。</p><pre><code>/*** Definition for singly-linked list.* struct ListNode {*     int val;*     ListNode *next;*     ListNode(int x) : val(x), next(NULL) {}* };*/class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        if(l1 == NULL &amp;&amp; l2 == NULL)return NULL;        if(l1 == NULL)return l2;        if(l2 == NULL)return l1;        ListNode *head = new ListNode(0), *l1Node = l1, *l2Node = l2, *p = head;        while(l1Node || l2Node){            if(!l1Node){                p-&gt;next = l2Node;                break;            }            else if(!l2Node){                p-&gt;next = l1Node;                break;            }            else{                if(l1Node-&gt;val &lt; l2Node-&gt;val){                    p-&gt;next = l1Node;                    l1Node = l1Node-&gt;next;                }                else{                    p-&gt;next = l2Node;                    l2Node = l2Node-&gt;next;                }            }            p = p-&gt;next;        }        return head-&gt;next;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 20. Valid Parentheses</title>
      <link href="/2016/07/17/leetcode-20-valid-parentheses/"/>
      <url>/2016/07/17/leetcode-20-valid-parentheses/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string containing just the characters ‘(’, ‘)’, ‘{’, ‘}’, ‘[’ and ‘]’, determine if the input string is valid.</p><p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p></blockquote><p>要求判断输入字符串中的括号是否正确匹配, 因为括号要正确闭合, 因此使用计数器来记录左右括号数量是不行的. 我用栈来保存所有的左括号, 每遇到一个右括号就与栈顶端的左括号匹配, 不匹配则返回false, 匹配则将栈顶括号出栈. 循环过程中如果出现栈为空, 或者循环结束后栈不为空则返回false. 其他情况返回true.</p><pre><code>class Solution {public:    bool isValid(string s) {        vector&lt;char&gt; bracket;        for(auto i : s){            if(i == '(' || i == '[' | i == '{')                bracket.push_back(i);            else{                if(bracket.empty())                    return false;                else if( (i == ')' &amp;&amp; bracket.back() == '(') || (i == ']' &amp;&amp; bracket.back() == '[') || (i == '}' &amp;&amp; bracket.back() == '{'))                    bracket.pop_back();                else                    return false;            }        }                return bracket.empty() ? true : false;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 19. Remove Nth Node From End of List</title>
      <link href="/2016/07/17/leetcode-19-remove-nth-node-from-end-of-list/"/>
      <url>/2016/07/17/leetcode-19-remove-nth-node-from-end-of-list/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a linked list, remove the n<sup>th</sup> node from the end of list and return its head.</p><p>For example,</p><pre><code>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</code></pre><p>Note:</p><p>Given n will always be valid.</p><p>Try to do this in one pass.</p></blockquote><p>要求删除链表从后往前数第n个节点, 并且只遍历一次. 所以我采用一个vector来保存每个节点的指针, 遍历一次后从vector中找到倒数第n个节点并删除之.</p><pre><code>/*** Definition for singly-linked list.* struct ListNode {*     int val;*     ListNode *next;*     ListNode(int x) : val(x), next(NULL) {}* };*/class Solution {public:    ListNode* removeNthFromEnd(ListNode* head, int n) {        vector&lt;ListNode*&gt; listPointer;        ListNode* p = head;        while(p != nullptr){            listPointer.push_back(p);            p = p-&gt;next;        }                int len = listPointer.size(), toDeleteIndex = len - n;        ListNode* toDelete = listPointer[toDeleteIndex];        if(toDeleteIndex == 0){            return head-&gt;next;        }        else{            ListNode* prev = listPointer[toDeleteIndex - 1];            prev-&gt;next = toDelete-&gt;next;            return head;        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 18. 4Sum</title>
      <link href="/2016/07/16/leetcode-18-4sum/"/>
      <url>/2016/07/16/leetcode-18-4sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p>Note: The solution set must not contain duplicate quadruplets.</p><pre><code>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[  [-1,  0, 0, 1],  [-2, -1, 1, 2],  [-2,  0, 0, 2]]</code></pre></blockquote><p>这道题可以继续使用2Sum, 3Sum题目的方法, 在3Sum外面再增加一次处理. 还有另外一种使用HashMap的方法, 但是我现在还没有完全实现它, 主要问题在于最后的去重. 更多的信息可以参考这里:<a href="http://www.sigmainfy.com/blog/summary-of-ksum-problems.html" target="_blank" rel="noopener">http://www.sigmainfy.com/blog/summary-of-ksum-problems.html</a>.</p><p>我的代码, 效率并不高:</p><pre><code>class Solution {    vector&lt;vector&lt;int&gt;&gt; fourSumRet;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {        sort(nums.begin(), nums.end());        for(int i = 0; i &lt; nums.size(); i++){            if(i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) continue;            if(target &gt; 0 &amp;&amp; nums[i] &gt; target) break;            threeSum(nums, target - nums[i], i + 1, nums.size());        }        return fourSumRet;    }        void threeSum(vector&lt;int&gt;&amp; nums, int target, int left, int right) {        for(int i = left; i &lt; right; i++){            if(i &gt;= left + 1 &amp;&amp; nums[i] == nums[i - 1]) continue;            twoSum(nums, target - nums[i], i + 1, right, left - 1);        }    }        void twoSum(vector&lt;int&gt;&amp; nums, int target, int left, int right, int fourSumIndex) {        int l = left, r = right - 1;        while(l &lt; r){            int sum = nums[l] + nums[r];            if(sum == target){                vector&lt;int&gt; t = {nums[fourSumIndex], nums[left - 1], nums[l], nums[r]};                fourSumRet.push_back(t);                do{r--;}while(nums[r] == nums[r + 1]);                do{l++;}while(nums[l] == nums[l - 1]);            }            else if(sum &gt; target){                r--;            }            else{                l++;            }        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL容器学习笔记一 - 标准容器与Array</title>
      <link href="/2016/07/15/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%B8%8Earray/"/>
      <url>/2016/07/15/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%B8%8Earray/</url>
      
        <content type="html"><![CDATA[<p>在做LeetCode题目的过程中, 我发现我对于STL容器的了解还是过于浅薄, 因此决定专门学习总结一下. 主要资料来源是<a href="http://www.cplusplus.com/reference/stl/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/stl/</a>.</p><h1 id="标准容器">标准容器</h1><p>一个<strong>容器</strong>是一个保存一组其他对象(元素 <em>element</em>)的对象, 他们都是用类模板来实现的. 容器管理着保存元素的存储空间并且提供直接或通过迭代器(<em>iterators</em>)访问它们的成员函数.</p><p>stack, queue和priority_queue被实现为<strong>容器适配器(container adaptors)</strong>, 容器适配器不是完整的容器类, 而是提供依赖于容器类(如deque或list)对象的特定接口的类.</p><h2 id="顺序容器-sequence-containers">顺序容器 Sequence Containers</h2><ul><li>array</li><li>vector</li><li>deque</li><li>forward_list</li><li>list</li></ul><h2 id="容器适配器-container-adaptors">容器适配器 Container Adaptors</h2><ul><li>stack</li><li>queue</li><li>priority_queue</li></ul><h2 id="关联容器-associative-containers">关联容器 Associative Containers</h2><ul><li>set</li><li>multiset</li><li>map</li><li>multimap</li></ul><h2 id="无序关联容器-unordered-associative-containers">无序关联容器 Unordered Associative Containers</h2><ul><li>unordered_set</li><li>unordered_multiset</li><li>unordered_map</li><li>unordered_multimap</li></ul><p><em>更多参考资料: <a href="http://www.cplusplus.com/reference/stl/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/stl/</a></em></p><h1 id="array-c-11"><a href="http://www.cplusplus.com/reference/array/array/" target="_blank" rel="noopener">Array</a> <em>[C++11]</em></h1><p>Array是固定大小的顺序容器, 它以固定的线性顺序存储特定数量的元素(注意<strong>不是</strong>特定的大小顺序). 在内部, Array不保存除了它包含的元素以外的任何数据(包括容器大小, 它是在编译期确定的值). 不同于vector, array不能动态改变大小. 大小为0的array是合法的, 但是它不应该被解引用(front, back和data成员函数). 不同于其他STL容器, swap两个array是一个线性操作, 会对每一个元素单独进行swap, 这一般被认为是一种低效操作.</p><h2 id="部分成员函数">部分成员函数</h2><p>绝大部分array容器的成员函数时间复杂度都是常数时间复杂度.</p><h2 id="array-data">array::data</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">value_type* <span class="title">data</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">const value_type* data() const noexcept;`&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>返回指向array对象首个元素的指针. 因为元素是连续存储的, 因此可以用偏移量(<em>offset</em>)来访问array中的元素.​</p><h2 id="array-fill">array::fill</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>把array中的所有元素都设置为val.<strong>时间复杂度:</strong> 线性.</p><h2 id="array-swap">array::swap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="built_in">array</span>&amp; x)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;())))</span></span>;</span><br></pre></td></tr></table></figure><p>与array x交换内容.<strong>时间复杂度:</strong> 线性.<strong>迭代器合法性:</strong> 所有迭代器, 引用和指针的合法性都不会改变. 它们仍然与调用前相同的容器的相同位置相关联, 但是他们指向的值会是交换后的值.</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 17. Letter Combinations of a Phone Number</title>
      <link href="/2016/07/15/leetcode-17-letter-combinations-of-a-phone-number/"/>
      <url>/2016/07/15/leetcode-17-letter-combinations-of-a-phone-number/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p><pre><code>Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></pre><p><strong>Note:</strong>Although the above answer is in lexicographical order, your answer could be in any order you want.</p></blockquote><p>这道题要求输入一串手机九宫格按键, 输出所有可能的字母组合. 方法是每读入一个按键, 就将原字符串数组复制数次(数量取决于这个按键上有几个字母), 然后加上当前读入的按键.</p><pre><code>class Solution {public:    vector&lt;string&gt; letterCombinations(string digits) {        int letterNumOnButton[] = {1, 1, 3, 3 ,3, 3, 3, 4, 3, 4};        vector&lt;string&gt; m = {            &quot; &quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;        };                if(digits.empty())            return vector&lt;string&gt;();                vector&lt;string&gt; re = {&quot;&quot;};        for(int i = 0; i &lt; digits.length(); i++){            int button = digits[i] - '0';                        int size = re.size();            for(int j = 0; j &lt; letterNumOnButton[button] - 1; j++){                for(int k = 0; k &lt; size; k++){                    re.push_back(re[k]);                }            }                        for(int j = 0; j &lt; m[button].length(); j++){                for(int k = 0; k &lt; size; k++){                    re[j * size + k].push_back(m[button][j]);                }            }        }                return re;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 16. 3Sum Closest</title>
      <link href="/2016/07/15/leetcode-16-3sum-closest/"/>
      <url>/2016/07/15/leetcode-16-3sum-closest/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><pre><code>For example, given array S = {-1 2 1 -4}, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</code></pre></blockquote><p>首先这是一个3Sum问题, 因此仍然先使用上一道题目的思路, 用双指针实现2Sum, 用target - nums[i]作为2Sum的target. 接下来的问题就是<strong>closest</strong>的问题了, 我的办法是遍历所有的2Sum组合(只需要遍历下标在i之后的元素), 找到最接近target - nums[i]的组合. 当三个数的和与target差距为0时也可以退出循环, 否则直到i等于nums.size() - 1为止.</p><pre><code>class Solution {public:    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {        sort(nums.begin(), nums.end());        int minLen = INT_MAX, ret;        for(int i = 0; i &lt; nums.size(); i++){            int oldMinLen = minLen;            int sum = twoSum(nums, target - nums[i], i + 1, nums.size(), minLen);            if(minLen &lt; oldMinLen){                ret = sum + nums[i];            }            if(minLen == 0) break;        }        return ret;    }        int twoSum(vector&lt;int&gt;&amp; nums, int target, int left, int right, int &amp;minLen) {        int l = left, r = right - 1;        int ret;        while(l &lt; r){            int sum = nums[l] + nums[r];            if(sum == target){                ret = sum;                minLen = 0;                break;            }            else if(sum &gt; target){                r--;            }            else{                l++;            }            int len = lenBetweenInt(sum, target);            if(len &lt; minLen){                minLen = len;                ret = sum;            }        }        return ret;    }        int lenBetweenInt(int a, int b){        return abs(a - b);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows中使用Linux</title>
      <link href="/2016/07/14/windows%E4%B8%AD%E4%BD%BF%E7%94%A8linux/"/>
      <url>/2016/07/14/windows%E4%B8%AD%E4%BD%BF%E7%94%A8linux/</url>
      
        <content type="html"><![CDATA[<p>对我来说, 相比于Windows, Linux更加能胜任开发的工作, 开发工具丰富, 有Terminal. 但是因为我只有一台笔记本电脑, 以前安装双系统总是被驱动问题所困扰, 显卡驱动, 网卡驱动是重灾区, 而且双系统切换需要重启, 非常繁琐. 在我增加了一块SSD后就一直没有再安装双系统.</p><p>最近微软为Windows 10提供了Ubuntu子系统, 但是到目前位置还是有Insider预览版可以安装. 我并不想去给微软当小白鼠, 况且我对于Windows系统本身也没什么兴趣, 也早就不再追逐软件的最新版. 从另一个方面来说, 我觉得这混淆了Windows和Linux, 写代码我喜欢Linux的那一套东西, 但是我觉得这拼凑出来的东西并不会好用.</p><p>虚拟机是一个不错的解决办法, 以前我都是使用VmWare运行桌面版的Linux, 但是性能是一个问题, 而且我发现我似乎用不到虚拟机Linux的桌面环境.</p><p>所以我今天用Hyper-V安装了Ubuntu Server版, 用SSH的办法登录上去, 就可以使用较低的硬件资源.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 15. 3Sum</title>
      <link href="/2016/07/13/leetcode-15-3sum/"/>
      <url>/2016/07/13/leetcode-15-3sum/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note: The solution set must not contain duplicate triplets.</p><pre><code>For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[  [-1, 0, 1],  [-1, -1, 2]]</code></pre></blockquote><p>参考<a href="http://xiadong.info/2016/07/1-two-sum/" target="_blank" rel="noopener">http://xiadong.info/2016/07/1-two-sum/</a>Two Sum这道题, 我们可以先取得一个数n, 将-n作为target就变为了Two Sum问题, 代码如下:</p><pre><code>class Solution {    vector&lt;vector&lt;int&gt;&gt; ret;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {        sort(nums.begin(), nums.end());        for(int i = 0; i &lt; nums.size(); i++){            if(i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) continue;            if(nums[i] &gt; 0) break;            twoSum(nums, -nums[i], i + 1, nums.size());        }        return ret;    }        void twoSum(vector&lt;int&gt;&amp; nums, int target, int left, int right) {        int l = left, r = right - 1;        while(l &lt; r){            int sum = nums[l] + nums[r];            if(sum == target){                vector&lt;int&gt; t = {-target, nums[l], nums[r]};                ret.push_back(t);                do{r--;}while(nums[r] == nums[r + 1]);                do{l++;}while(nums[l] == nums[l - 1]);            }            else if(sum &gt; target){                r--;            }            else{                l++;            }        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 14. Longest Common Prefix</title>
      <link href="/2016/07/13/leetcode-14-longest-common-prefix/"/>
      <url>/2016/07/13/leetcode-14-longest-common-prefix/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Write a function to find the longest common prefix string amongst an array of strings.</p></blockquote><p>寻找一组字符串的最长公共前缀. 首先, 如果只有一个字符串, 那么它就是最长公共前缀, 如果有两个, 那么再跟第二个字符串逐个字符对比, 找出最长公共前缀. 再增加字符串则依次类推.</p><p>在这个方法的基础上, 可以想到最长公共前缀一定不会比字符串数组中最短的字符串长, 因此可以先找到最短字符串, 以它为一开始的基准.</p><p>代码:</p><pre><code>class Solution {public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {        if(strs.empty())            return &quot;&quot;;                int shortestIndex = findShortest(strs);        int prefixLen = strs[shortestIndex].length();        int len = strs.size();                for(int i = 0; i &lt; len; i++){            if(prefixLen == 0) return &quot;&quot;;            string s = strs[i];            int l1 = prefixLen, l2 = s.length(), j;            for(j = 0; j &lt; l1 &amp;&amp; j &lt; l2; j++){                if(strs[0][j] != s[j])                    break;            }                        if(j != l1 &amp;&amp; j != l2){                prefixLen = j;            }            else if(j == l2){                prefixLen = l2;            }        }                return strs[shortestIndex].substr(0, prefixLen);    }        int findShortest(vector&lt;string&gt; &amp;strs){        int minLen = INT_MAX, index;        for(int i = 0; i &lt; strs.size(); i++){            if(strs[i].length() &lt; minLen){                minLen = strs[i].length();                index = i;            }        }        return index;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 374. Guess Number Higher or Lower</title>
      <link href="/2016/07/13/leetcode-374-guess-number-higher-or-lower/"/>
      <url>/2016/07/13/leetcode-374-guess-number-higher-or-lower/</url>
      
        <content type="html"><![CDATA[<p>问题描述:</p><blockquote><p>We are playing the Guess Game. The game is as follows:</p><p>I pick a number from 1 to n. You have to guess which number I picked.</p><p>Every time you guess wrong, I’ll tell you whether the number is higher or lower.</p><p>You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):</p><pre><code>-1 : My number is lower 1 : My number is higher 0 : Congrats! You got it!</code></pre><p>Example:</p><pre><code>n = 10, I pick 6.Return 6.</code></pre></blockquote><p>二分搜索问题.</p><pre><code>// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution {public:    int guessNumber(int n) {        int mid = n / 2, left = 1, right = n, tmpResult;        while((tmpResult = guess(mid)) != 0){            if(tmpResult == -1){                right = mid;            }            else if(tmpResult == 1){                left = mid + 1;            }            mid = (right - left) / 2 + left;        }        return mid;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 13. Roman to Integer</title>
      <link href="/2016/07/12/leetcode-13-roman-to-integer/"/>
      <url>/2016/07/12/leetcode-13-roman-to-integer/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a roman numeral, convert it to an integer.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p></blockquote><p>与第12题相反, 同样是简单模拟:</p><pre><code>class Solution {public:    int romanToInt(string s) {        int ret = 0;        int last_weight = -1;        for(int i = s.length() - 1; i &gt;= 0; i--){            int w = symbolToVal(s[i]);            if(w &lt; last_weight)                ret -= w;            else{                last_weight = w;                ret += w;            }        }        return ret;    }        int symbolToVal(char s){        switch(s){            case 'I':                return 1;            case 'V':                return 5;            case 'X':                return 10;            case 'L':                return 50;            case 'C':                return 100;            case 'D':                return 500;            case 'M':                return 1000;            default:                return -1;        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 12. Integer to Roman</title>
      <link href="/2016/07/12/leetcode-12-integer-to-roman/"/>
      <url>/2016/07/12/leetcode-12-integer-to-roman/</url>
      
        <content type="html"><![CDATA[<p>题目要求:</p><blockquote><p>Given an integer, convert it to a roman numeral.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p></blockquote><p>关于罗马数字的表示方法参考这里<a href="https://www.wikiwand.com/en/Roman_numerals" target="_blank" rel="noopener">https://www.wikiwand.com/en/Roman_numerals</a></p><table>    <tr><th>Symbol</th><th>Value</th></tr>    <tr><td>I</td><td>1</td></tr>    <tr><td>V</td><td>5</td></tr>    <tr><td>X</td><td>10</td></tr>    <tr><td>L</td><td>50</td></tr>    <tr><td>C</td><td>100</td></tr>    <tr><td>D</td><td>500</td></tr>    <tr><td>M</td><td>1000</td></tr></table><p>同时有以下三条规则:</p><ul><li>I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)</li><li>X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)</li><li>C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)</li></ul><p>整数转化为罗马数字，简单模拟。</p><pre><code>class Solution {public:    string intToRoman(int num) {        int numArr[4] = {0};        int numArrIndex = 3;        while(num &gt; 0){            numArr[numArrIndex--] = num % 10;            num /= 10;        }        string ret;        for(int i = 3, offset = 1; i &gt;= 0; i--, offset *= 10){            if(numArr[i] == 0) continue;            else if(numArr[i] &lt; 4){                for(int j = 0; j &lt; numArr[i]; j++) ret.push_back(valToSymbol(1 * offset));            }            else if(numArr[i] == 4){                ret.push_back(valToSymbol(5 * offset));                ret.push_back(valToSymbol(1 * offset));            }            else if(numArr[i] &lt; 9){                for(int j = 5; j &lt; numArr[i]; j++) ret.push_back(valToSymbol(1 * offset));                ret.push_back(valToSymbol(5 * offset));            }            else{                ret.push_back(valToSymbol(10 * offset));                ret.push_back(valToSymbol(1 * offset));            }        }        reverse(ret.begin(), ret.end());        return ret;    }        char valToSymbol(int val){        switch(val){            case 1:                return 'I';            case 5:                return 'V';            case 10:                return 'X';            case 50:                return 'L';            case 100:                return 'C';            case 500:                return 'D';            case 1000:                return 'M';            default:                return 0;        }    }};</code></pre><p>Runtime: 28ms</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 11. Container With Most Water</title>
      <link href="/2016/07/12/leetcode-11-container-with-most-water/"/>
      <url>/2016/07/12/leetcode-11-container-with-most-water/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container.</p></blockquote><p>稍微优化的暴力搜索，时间复杂度比<code>O(n^2)</code>稍低。</p><p>C:</p><pre><code>int maxArea(int height[], int n) {    int max = 0, len = n;    for(int i = 0; i &lt; len; i++){        if(height[i] * (len - i - 1) &lt;= max)continue;        for(int j = i + (max / height[i] &gt; 1 ? max / height[i] : 1); j &lt; len; j++){            int area = (j - i) * (height[i] &lt; height[j] ? height[i] : height[j]);            if(area &gt; max)max = area;        }    }        return max;}</code></pre><p>使用双指针的方法，从数组两端向中间遍历，时间复杂度约为<code>O(n)</code>。</p><p>C++:</p><pre><code>class Solution {public:    int maxArea(vector&lt;int&gt; &amp;height) {        int start = 0, end = height.size() - 1, max = 0, area;                while(start &lt; end){            if(height[start] &lt; height[end]){                area = height[start] * (end - start);                max = max &gt; area ? max : area;                start++;            }            else{                area = height[end] * (end - start);                max = max &gt; area ? max : area;                end--;            }        }                return max;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Jetpack为Wordpress博客添加分享按钮</title>
      <link href="/2016/07/11/%E4%BD%BF%E7%94%A8jetpack%E4%B8%BAwordpress%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%E6%8C%89%E9%92%AE/"/>
      <url>/2016/07/11/%E4%BD%BF%E7%94%A8jetpack%E4%B8%BAwordpress%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%E6%8C%89%E9%92%AE/</url>
      
        <content type="html"><![CDATA[<p>分享按钮对于博客来说是一个很有用的小工具, Wordpress也有很多分享插件, 但是可惜都是支持国外的社交网络, 支持国内的都许久未更新了. 现在国内比较好用的分享工具就是百度家的了, 鉴于百度劣迹斑斑, 今天我决定不用百度的分享工具而转而使用Wordpress官方出品的Jetpack工具包中的分享功能. 和绝大多数国外开发的插件一样, 这个工具默认没有国内的社交网络, 但是它有自定义分享连接的功能, 我就用这个工具来添加自己的分享按钮. 本文只介绍微信和微博的分享按钮设置方法, 其他网站都很类似, 就不在赘述了.</p><p>Wordpress版本: 4.5.3</p><p>JetPack版本: 4.1.1</p><p><em>本文中所有图片都使用Google服务, 如无法显示请自备梯子.</em></p><h2 id="开启分享功能">开启分享功能</h2><p>在Jetpack后台中启用分享功能</p><p><img src="https://lh3.googleusercontent.com/-liLebQ3iGHA/V4NwgSWebTI/AAAAAAAAD0g/bTnW9EqxTZYZFY-eOisTrVHml2p8k3JcgCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711180858.png" alt="https://lh3.googleusercontent.com/-liLebQ3iGHA/V4NwgSWebTI/AAAAAAAAD0g/bTnW9EqxTZYZFY-eOisTrVHml2p8k3JcgCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711180858.png"></p><h2 id="设置">设置</h2><p>在设置=&gt;共享菜单中可以设置分享按钮的外观等属性, 设置好后就可以使用它本身自带的FB, Twitter等分享功能了. 但是我想分享到微博怎么办呢? 在这里有一个&quot;添加一个新的服务&quot;功能, 就是自定义分享链接啦.</p><p><img src="https://lh3.googleusercontent.com/-7y3GiYpLU5I/V4NyFYj31MI/AAAAAAAAD04/3utLPaLzr68CKQ3qVmG68mqcgh8JneFpQCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711181616.png" alt="https://lh3.googleusercontent.com/-7y3GiYpLU5I/V4NyFYj31MI/AAAAAAAAD04/3utLPaLzr68CKQ3qVmG68mqcgh8JneFpQCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711181616.png"></p><p>点击连接后弹出该窗口:</p><p><img src="https://lh3.googleusercontent.com/-Od71yJSjhow/V4NzBVJw8CI/AAAAAAAAD1I/iDly88CEai4IhYR5uJsAR8NeQpH-BzLRQCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711182011.png" alt="https://lh3.googleusercontent.com/-Od71yJSjhow/V4NzBVJw8CI/AAAAAAAAD1I/iDly88CEai4IhYR5uJsAR8NeQpH-BzLRQCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711182011.png"></p><p>服务名称我们可以自己选择, 接下来的参数就是分享链接和图标了, 我们先来搞定分享链接.</p><h2 id="微博分享链接">微博分享链接</h2><p>一般的分享链接都是通过URL参数传递的要分享的数据, 我们先来看看一个正常的微博分享链接长什么样. 首先随便打开一篇门户网站的文章, 比如这篇<a href="http://cul.qq.com/a/20160711/007865.htm" target="_blank" rel="noopener">http://cul.qq.com/a/20160711/007865.htm</a>, 找到分享按钮然后点击, 打开的URL是这样的:</p><p><code>http://service.weibo.com/share/share.php?url=http%3A%2F%2Fcul.qq.com%2Fa%2F20160711%2F007865.htm&amp;appkey=&amp;title=%A1%B6%B4%F3%D3%E3%BA%A3%CC%C4%A1%B7%B3%F6%C1%CB%CE%CA%CC%E2%A3%AC%BB%B9%CA%C7%B9%DB%D6%DA%B3%F6%C1%CB%CE%CA%CC%E2&amp;pic=http://img1.gtimg.com/cul/pics/hv1/7/145/2096/136329382.jpg||http://img1.gtimg.com/cul/pics/hv1/56/145/2096/136329431.jpg||http://img1.gtimg.com/cul/pics/hv1/83/145/2096/136329458.jpg&amp;ralateUid=&amp;language=&amp;searchPic=false</code></p><p>它有这样几个参数:</p><ul><li>url: 要分享的URL</li><li>appkey</li><li>title: 标题</li><li>pic: 应该是文章图片了</li><li>relateUid</li><li>language</li><li>searchPic</li></ul><p>其中我们只要关心url和title两个参数就可以了, 尝试删除其他参数, 只保留url和title</p><p><code>http://service.weibo.com/share/share.php?url=http%3A%2F%2Fcul.qq.com%2Fa%2F20160711%2F007865.htm&amp;title=%A1%B6%B4%F3%D3%E3%BA%A3%CC%C4%A1%B7%B3%F6%C1%CB%CE%CA%CC%E2%A3%AC%BB%B9%CA%C7%B9%DB%D6%DA%B3%F6%C1%CB%CE%CA%CC%E2</code></p><p>OK, 工作地很好. 这样我们就可以进行设置了, 把分享链接设置如下:</p><p><code>http://service.weibo.com/share/share.php?url=%post_full_url%&amp;title=%post_title%</code></p><h2 id="微博分享图标">微博分享图标</h2><p>直接使用Google图片搜索, 设置图片大小为16*16, 可以找到微博官方提供的图标:</p><p><a href="http://www.sinaimg.cn/blog/developer/wiki/LOGO_16x16.png" target="_blank" rel="noopener">http://www.sinaimg.cn/blog/developer/wiki/LOGO_16x16.png</a></p><h2 id="微信分享">微信分享</h2><p>微信分享网页一般都是通过二维码扫描后在微信内置浏览器内打开后再分享, 因此分享到微信我们只要生成URL对应的二维码即可. 有许多在线二维码生成的网站, 我使用<a href="http://cli.im/api" target="_blank" rel="noopener">http://cli.im/api</a>这个网站提供的API.</p><p>分享链接设置为<code>http://cli.im/api/qrcode/code?text=%post_full_url%&amp;mhid=sELPDFnok80gPHovKdI</code>, 图标设置为<a href="https://res.wx.qq.com/zh_CN/htmledition/v2/images/favicon2e4e03.ico" target="_blank" rel="noopener">https://res.wx.qq.com/zh_CN/htmledition/v2/images/favicon2e4e03.ico</a></p><h2 id="最终效果">最终效果</h2><p><img src="https://lh3.googleusercontent.com/-x44806CaDcE/V4N7foI_EMI/AAAAAAAAD1Y/dbS4bBzEs0IP1fxmDJgyCmi6Mbzsn6l6ACCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711185625.png" alt="https://lh3.googleusercontent.com/-x44806CaDcE/V4N7foI_EMI/AAAAAAAAD1Y/dbS4bBzEs0IP1fxmDJgyCmi6Mbzsn6l6ACCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711185625.png"></p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 10. Regular Expression Matching</title>
      <link href="/2016/07/10/leetcode-10-regular-expression-matching/"/>
      <url>/2016/07/10/leetcode-10-regular-expression-matching/</url>
      
        <content type="html"><![CDATA[<p>正则表达式匹配, 题目描述:</p><blockquote><p>Implement regular expression matching with support for ‘.’ and ‘*’.</p><pre><code>'.' Matches any single character.'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true</code></pre></blockquote><p>这个题目我是用动态规划AC的, 主要思路是这样的: 数组<code>dp[i][j]</code>表示s的前i个字符(下标从0到i - 1)和p的前j个字符(下标从0到j - 1)是否匹配(p经过处理, 表示重复任意次的<code>*</code>单独保存在另一个数组里). 因此我们的随后结果就是要得到<code>dp[s.size()][p.size()]</code>. 而<code>dp[i][j]</code>的值为真有以下三种可能:</p><ol><li>dp[i - 1][j]为真且s[i - 1]这个字符加与不加不影响匹配成立与否. 这要求p[j - 1]这个字符是被*标记的, 并且字符s[i - 1]与p[j - 1]可以匹配, 即s[i - 1] == p[j- 1]或p[j - 1] == ‘.’.</li><li>dp[i][j - 1]为真且p[j - 1]这个字符加与不加不影响匹配成立与否. 这要求p[j - 1]这个字符是被*标记的.</li><li>dp[i - 1][j - 1]为真并且s[i - 1]与p[j - 1]可以匹配, 即s[i - 1] == p[j- 1]或p[j - 1] == ‘.’.</li></ol><p>可以得到<code>dp[i][j] = (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.') &amp;&amp; star[j - 1]) || (dp[i][j - 1] &amp;&amp; (star[j - 1])) || (dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'))</code>, 其中star[i]表示p[i]是否被*标记.</p><pre><code>class Solution {public:    bool isMatch(string s, string p) {        string e;        vector&lt;bool&gt; star;        for(int i = 0; i &lt; p.size(); i++){            if(p[i] == '*') star.back() = true;            else{                e.push_back(p[i]);                star.push_back(false);            }        }        p = e;        vector&lt;vector&lt;bool&gt;&gt; dp(s.size() + 1, vector&lt;bool&gt;(p.size() + 1, false));        dp[0][0] = true;        for(int i = 1; i &lt;= p.size(); i++){            dp[0][i] = dp[0][i - 1] &amp;&amp; star[i - 1];        }        for(int i = 1; i &lt;= s.size(); i++)            for(int j = 1; j &lt;= p.size(); j++){                dp[i][j] = (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.') &amp;&amp; star[j - 1]) || (dp[i][j - 1] &amp;&amp; (star[j - 1])) || (dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'));            }        return dp[s.size()][p.size()];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 9. Palindrome Number</title>
      <link href="/2016/07/09/leetcode-9-palindrome-number/"/>
      <url>/2016/07/09/leetcode-9-palindrome-number/</url>
      
        <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>Determine whether an integer is a palindrome. Do this without extra space.</p></blockquote><p>我没有太明白这个<code>without extra space</code>的具体含义, 传入数据只有一个int型, 难道是要完全不使用局部变量吗? 这个要求总觉得有点匪夷所思. 忽略这一点, 这个题目还是很简单的.</p><p>代码:</p><pre><code>class Solution {public:    bool isPalindrome(int x) {        if(x &lt; 0)            return false;                long long r = 0, t = x;        while(t &gt; 0){            r = r * 10 + t % 10;            t /= 10;        }                if(x == r)            return true;        else            return false;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 8. String to Integer (atoi)</title>
      <link href="/2016/07/09/leetcode-8-string-to-integer-atoi/"/>
      <url>/2016/07/09/leetcode-8-string-to-integer-atoi/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Implement atoi to convert a string to an integer.</p><p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p><p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p></blockquote><p>比较简单的题目, 因为要转换的是整数, 因此只需要考虑前导空格和符号.</p><p>代码:</p><pre><code>class Solution {public:    bool isNumber(char a){        return a &gt;= '0' &amp;&amp; a &lt;= '9';    }    int myAtoi(string str) {        int len = str.length(), p = 0;        if(str[0] == ' '){            for(int i = 0; str[i] == ' '; i++) p++;        }        if(!(isNumber(str[p]) || str[p] == '-' || str[p] == '+'))            return 0;                    int sign = 1;        if(str[p] == '-'){            sign = -1;        }                if(str[p] == '-' || str[p] == '+')            p++;                    long long re = 0;        len = str.length();        for(int i = p; i &lt; len &amp;&amp; isNumber(str[i]); i++){            re *= 10;            re += str[i] - '0';                        if(sign &gt; 0 &amp;&amp; re &gt; INT_MAX)                return INT_MAX;            if(sign &lt; 0 &amp;&amp; -re &lt; INT_MIN)                return INT_MIN;        }                return sign * re;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 7. Reverse Integer</title>
      <link href="/2016/07/09/leetcode-7-reverse-integer/"/>
      <url>/2016/07/09/leetcode-7-reverse-integer/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Reverse digits of an integer.</p><p>Example1: x = 123, return 321</p><p>Example2: x = -123, return -321</p></blockquote><p>问题比较简单, 关键问题在于对于int类型数据表示范围的了解和对溢出的处理.</p><p>代码:</p><pre><code>class Solution {public:    int reverse(int x) {        long long re = 0;        int sign = 1;        if(x &lt; 0){            sign = -1;            x = -x;        }        while(x &gt; 0){            re = re * 10 + ( x % 10 );            x /= 10;        }                if(re &gt; 0x7fffffff)            return 0;                return sign * re;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 6. ZigZag Conversion</title>
      <link href="/2016/07/09/leetcode-6-zigzag-conversion/"/>
      <url>/2016/07/09/leetcode-6-zigzag-conversion/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p><p>Write the code that will take a string and make this conversion given a number of rows:</p><pre><code>string convert(string text, int nRows);</code></pre><p><code>convert(&quot;PAYPALISHIRING&quot;, 3)</code> should return <code>&quot;PAHNAPLSIIGYIR&quot;</code>.</p></blockquote><p>比较简单的字符串处理, 根据给定的要求模拟即可.</p><pre><code>class Solution {public:    string convert(string s, int numRows) {        int n = numRows * 2 - 2, len = s.length(), column;        if(len == 0)            return string(&quot;&quot;);        if(numRows == 1)            return s;        else            column = (len / n) * 2 + 2;        char arr[numRows][column];        memset(arr, 0, sizeof(arr));        for(int i = 0; i &lt; len; i++){            if((i % n) &lt; numRows)                arr[i % n][i / n * 2] = s[i];            else                arr[numRows - (i % n - numRows) - 2][i / n * 2+ 1] = s[i];        }        string re;        for(int i = 0; i &lt; numRows; i++){            for(int j = 0; j &lt; column; j++)                if(arr[i][j] != 0)                    re.push_back(arr[i][j]);        }        return re;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5. Longest Palindromic Substring</title>
      <link href="/2016/07/09/leetcode-5-longest-palindromic-substring/"/>
      <url>/2016/07/09/leetcode-5-longest-palindromic-substring/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p></blockquote><p>要求找出一个字符串中出现的最长的回文子串. 我自己没有想出什么特别好的办法, 只能用比较暴力的手段来通过. 主要思想就是遍历每一个字符, 对这个字符向两边延伸, 直到不符合回文的定义, 记录下最大值.</p><p>代码:</p><pre><code>class Solution {public:    string longestPalindrome(string s) {        int len = s.length(), longestLen = 0, longestBegin;        for(int i = 0; i &lt; len; i++){            bool oddInvalidFlag = false, evenInvalidFlag = false;            for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; len; j++){                if(s[i - j] != s[i + j]) oddInvalidFlag = true;                if(s[i - j] != s[i + j + 1]) evenInvalidFlag = true;                if(oddInvalidFlag &amp;&amp; evenInvalidFlag)                    break;                if(!oddInvalidFlag &amp;&amp; s[i - j] == s[i + j] &amp;&amp; (j &lt;&lt; 1) + 1 &gt; longestLen){                    longestLen = (j &lt;&lt; 1) + 1;                    longestBegin = i - j;                }                if(!evenInvalidFlag &amp;&amp; s[i - j] == s[i + j + 1] &amp;&amp; (j &lt;&lt; 1) + 2 &gt; longestLen){                    longestLen = (j &lt;&lt; 1) + 2;                    longestBegin = i - j;                }            }            int j = len - i - 1;            if(!oddInvalidFlag &amp;&amp; i &gt;= j &amp;&amp; s[i - j] == s[i + j] &amp;&amp; (j &lt;&lt; 1) + 1 &gt; longestLen){                longestLen = (j &lt;&lt; 1) + 1;                longestBegin = i - j;            }                    }                return s.substr(longestBegin, longestLen);    }};</code></pre><p>以上代码对每一个字符使用了一个循环, 运行时间120ms左右. 但是如果把子串长度为奇数和偶数分开来的话, 速度反而会变快, 我想应该是特定测试数据使总得指令数变少了.</p><p>另一个版本:</p><pre><code>class Solution {public:    string longestPalindrome(string s) {        int len = s.length(), longestLen = 0, longestBegin;        for(int i = 0; i &lt; len; i++){            for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; len; j++){                if(s[i - j] != s[i + j])                    break;                if((j &lt;&lt; 1) + 1 &gt; longestLen){                    longestLen = (j &lt;&lt; 1) + 1;                    longestBegin = i - j;                }            }                        for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; len; j++){                if(s[i - j] != s[i + j + 1])                    break;                if((j &lt;&lt; 1) + 2 &gt; longestLen){                    longestLen = (j &lt;&lt; 1) + 2;                    longestBegin = i - j;                }            }        }                return s.substr(longestBegin, longestLen);    }};</code></pre><p><strong>一个优化小Trick</strong></p><p>在最外层循环中将循环条件<code>i &lt; len</code>变为<code>i &lt; len - longestLen / 2</code>, Runtime可缩短近半.</p><p><strong>更优解</strong></p><p>根据这个帖子的方法<a href="https://discuss.leetcode.com/topic/49578/directly-reaching-the-best-solution-4ms-in-c-quite-simple" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/49578/directly-reaching-the-best-solution-4ms-in-c-quite-simple</a>, 运行时间成功缩短到4ms.</p><pre><code>class Solution {public:    string longestPalindrome(string s) {        int len = s.length(), longestLen = 0, longestBegin = 0;        int i = 0;        while(i &lt; len - longestLen / 2){            int r = i, l = i;            for(; r &lt; len - 1 &amp;&amp; s[r] == s[r + 1]; r++);            i = r + 1;            for(; l &gt;= 0 &amp;&amp; r &lt; len &amp;&amp; s[l] == s[r]; l--, r++);            int curLen = r - l - 1;            if(curLen &gt; longestLen) longestLen = curLen, longestBegin = l + 1;        }                return s.substr(longestBegin, longestLen);    }};</code></pre><p>说明: 判断回文子串的方法不变, 都是向两边延伸, 关键在于回文串中心的选择, <code>for(; r &lt; len - 1 &amp;&amp; s[r] == s[r + 1]; r++);</code>跳过了连续相同的字符, 这是因为连续的相同字符必然是回文串, 可以直接从这样的回文串开始向两边延伸.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 4. Median of Two Sorted Arrays</title>
      <link href="/2016/07/08/leetcode-4-median-of-two-sorted-arrays/"/>
      <url>/2016/07/08/leetcode-4-median-of-two-sorted-arrays/</url>
      
        <content type="html"><![CDATA[<p>题目:</p><blockquote><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p></blockquote><blockquote><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p></blockquote><blockquote><p>Example 1:</p></blockquote><blockquote><pre><code>nums1 = [1, 3]nums2 = [2]</code></pre></blockquote><blockquote><pre><code>The median is 2.0</code></pre></blockquote><blockquote><p>Example 2:</p></blockquote><blockquote><pre><code>nums1 = [1, 2]nums2 = [3, 4]</code></pre></blockquote><blockquote><pre><code>The median is (2 + 3)/2 = 2.5</code></pre></blockquote><p>最直接方法, 合并为一个数组后进行排序, 运行时间56ms:</p><pre><code>class Solution {public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        for(int i = 0 ; i &lt; nums2.size(); i++)            nums1.push_back(nums2[i]);                int n = nums1.size();        partial_sort(nums1.begin(), nums1.end(), nums1.end());        if(n % 2 == 0)            return ((double)nums1[n / 2] + (double)nums1[n / 2 - 1]) / 2;        else            return (double)nums1[n / 2];            }};</code></pre><p>另一种方法是利用两个数组都是排好序的这一属性, 将两个数组看作堆, 每次pop出两个数组顶端较小的值, 直到有一半的数被pop出去, 剩下的两个顶端值就可以求得中间值.</p><p>运行速度稍有提升:</p><pre><code>class Solution {public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        int numTotal = nums1.size() + nums2.size();        int n = numTotal / 2;        int p1 = 0, p2 = 0;        if(numTotal % 2){            while(p1 &lt; nums1.size() &amp;&amp; p2 &lt; nums2.size() &amp;&amp; p1 + p2 &lt; n){                if(nums1[p1] &lt; nums2[p2]) p1++;                else p2++;            }            if(p1 + p2 &lt; n){                if(p1 == nums1.size()){                    while(p1 + p2 &lt; n) p2++;                }                if(p2 == nums2.size()){                    while(p1 + p2 &lt; n) p1++;                }            }            if(p1 == nums1.size()) return (double)nums2[p2];            else if(p2 == nums2.size()) return (double)nums1[p1];            else return (double)min(nums1[p1], nums2[p2]);        }        else{            while(p1 &lt; nums1.size() &amp;&amp; p2 &lt; nums2.size() &amp;&amp; p1 + p2 &lt; n - 1){                if(nums1[p1] &lt; nums2[p2]) p1++;                else p2++;            }            if(p1 + p2 &lt; n - 1){                if(p1 == nums1.size()){                    while(p1 + p2 &lt; n - 1) p2++;                }                if(p2 == nums2.size()){                    while(p1 + p2 &lt; n - 1) p1++;                }            }            if(p1 == nums1.size()) return (double)((nums2[p2] + nums2[p2 + 1]) / 2.0);            else if(p2 == nums2.size()) return (double)((nums1[p1] + nums1[p1 + 1]) / 2.0);            else{                int t1, t2;                if(nums1[p1] &lt; nums2[p2]) t1 = nums1[p1++];                else t1 = nums2[p2++];                if(p1 == nums1.size()){                    t2 = nums2[p2++];                }                else if(p2 == nums2.size()){                    t2 = nums1[p1++];                }                else{                    if(nums1[p1] &lt; nums2[p2]) t2 = nums1[p1++];                    else t2 = nums2[p2++];                }                return (double)((t1 + t2) / 2.0);            }        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 3. Longest Substring Without Repeating Characters</title>
      <link href="/2016/07/08/leetcode-3-longest-substring-without-repeating-characters/"/>
      <url>/2016/07/08/leetcode-3-longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<p>题目:</p><blockquote><p>Given a string, find the length of the longest substring without repeating characters.</p></blockquote><blockquote><p>Examples:</p></blockquote><blockquote><p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p></blockquote><blockquote><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p></blockquote><blockquote><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p></blockquote><p>基本思路是遍历一遍字符串, 每访问到一个新字符时, 先检查有没有出现过(而一个字符有没有出现过用一个用字符的ASCII码作为索引的数组保存). 如果没有出现过(用-1表示)就记录下这个第一次出现的下标; 如果出现过, 就把子串的起始位置变为上次出现位置+1, 并把上次出现位置之前的字符设置为-1. 每次循环记录找到的最长长度.</p><p>代码:</p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        int charHash[128];        for(int i = 0; i &lt; 128; i++)            charHash[i] = -1;                    int p1 = 0, p2 = 0, maxLength = 0;        for(; p2 &lt; s.length(); p2++){            if(charHash[s[p2]] == -1)                charHash[s[p2]] = p2;            else{                int t = charHash[s[p2]] + 1;                for(; p1 &lt; t; p1++)                    charHash[s[p2]] = -1;                charHash[s[p2]] = p2;            }                        if(p2 - p1 + 1&gt; maxLength)                maxLength = p2 - p1 + 1;        }                return maxLength;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 372. Super Pow</title>
      <link href="/2016/07/08/leetcode-372-super-pow/"/>
      <url>/2016/07/08/leetcode-372-super-pow/</url>
      
        <content type="html"><![CDATA[<p>题目描述:</p><blockquote><p>Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.</p></blockquote><blockquote><p>Example1:</p></blockquote><blockquote><pre><code>a = 2b = [3]</code></pre></blockquote><blockquote><pre><code>Result: 8</code></pre><p>Example2:</p></blockquote><blockquote><pre><code>a = 2b = [1,0]</code></pre></blockquote><blockquote><pre><code>Result: 1024</code></pre></blockquote><p>计算a的b次幂的值, 其中b很大并且用数组表示. 关键在于结果要对于1337取余, 这就意味着在计算过程中不会发生溢出问题. 根据公式:</p><pre><code>(a * b) % n = ((a % n) * (b % n)) % n</code></pre><p>以及</p><pre><code>a ^ (n + m) = (a ^ n) * (a ^ m)</code></pre><p>用b{i}表示数组b中到下标i为止的数, <code>a ^ b{i} = ((a ^ b{i - 1}) ^ 10) * (a ^ b[i])</code>, 把幂运算替换为乘法运算和循环, 在每一个循环体中都对结果取余. 就可以得到结果. 其中b[i]为0和第一次循环要特别处理.</p><p>代码如下, 耗时24ms:</p><pre><code>class Solution {    int MOD = 1337;public:    int superPow(int a, vector&lt;int&gt;&amp; b) {        int ret = 0;        for(int i = 0; i &lt; b.size(); i++){            int t = b[i], retPowTen = 1;            long long powT = 1;            for(int j = 0; j &lt; 10; j++){                retPowTen = (retPowTen * ret) % MOD;            }            ret = retPowTen;            if(t == 0){                powT = 0;            }            else{                for(int j = 0; j &lt; t; j++){                    powT = (powT * a) % MOD;                }            }            if(powT &amp;&amp; ret)                ret = (ret * (powT % MOD)) % MOD;            else if(!ret)                ret = powT % MOD;            else                ret = ret % MOD;        }        return ret;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2. Add Tow Numbers</title>
      <link href="/2016/07/08/leetcode-2-add-tow-numbers/"/>
      <url>/2016/07/08/leetcode-2-add-tow-numbers/</url>
      
        <content type="html"><![CDATA[<p>题目:</p><blockquote><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p></blockquote><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p></blockquote><blockquote><p>Output: 7 -&gt; 0 -&gt; 8</p></blockquote><p>简单的加法模拟, 代码如下:</p><pre><code>/*** Definition for singly-linked list.* struct ListNode {*     int val;*     ListNode *next;*     ListNode(int x) : val(x), next(NULL) {}* };*/class Solution {public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        //如果有一个链表为空,则直接返回另一个        if(l1 == nullptr)            return l2;        if(l2 == nullptr)            return l1;                    ListNode *p1 = l1, *p2 = l2;        while(p1-&gt;next != nullptr || p2-&gt;next != nullptr){            //填充较短的数, 高位添加0, 这一步可以用计算后再处理的办法替代            if(p1-&gt;next == nullptr)                p1-&gt;next = new ListNode(0);            if(p2-&gt;next == nullptr)                p2-&gt;next = new ListNode(0);            p1 = p1-&gt;next, p2 = p2-&gt;next;        }                ListNode *head = new ListNode(0), *p = head;        int jw = 0;//jw保存上一位计算后的进位        for(p1 = l1, p2 = l2; p1 != nullptr &amp;&amp; p2 != nullptr; p1 = p1-&gt;next, p2 = p2-&gt;next){            //模拟每一位的加法            int t = p1-&gt;val + p2-&gt;val + jw;            jw = (t &gt; 9 ? 1 : 0);                        t = t % 10;            p-&gt;next = new ListNode(t);            p = p-&gt;next;        }        if(jw == 1){            //最后有进位的处理            p-&gt;next = new ListNode(1);        }                return head-&gt;next;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1. Two Sum</title>
      <link href="/2016/07/08/leetcode-1-two-sum/"/>
      <url>/2016/07/08/leetcode-1-two-sum/</url>
      
        <content type="html"><![CDATA[<p>LeetCode的第一题，题目如下：</p><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p></blockquote><blockquote><p>You may assume that each input would have exactly one solution.</p></blockquote><blockquote><p><strong>Example:</strong></p></blockquote><blockquote><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre></blockquote><p>首先是简单粗暴的使用STL Map的方法. 基本思路是把nums中的数据与其下标建立一个映射关系, 这样就可以在logn的时间里通过数值获得它的下标：</p><pre><code>class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        map&lt;int, int&gt; a;        for(int i = 0; i &lt; nums.size(); i++){            a[nums[i]] = i;        }        for(int i = 0; i &lt; nums.size(); i++){            auto p = a.find(target - nums[i]);            if(p != a.end() &amp;&amp; p-&gt;second != i){                vector&lt;int&gt; re = {i, p-&gt;second};                return re;            }        }        return vector&lt;int&gt;();    }};</code></pre><p>以上方法有两个循环, 其中第一个循环遍历了一遍nums,同时对于每个nums中的数据都进行了map的插入/修改操作, 假设nums的数据个数为n, 复杂度约为O(nlogn). 第二个循环中也是遍历了一遍nums, 然后每一遍循环都执行了一次map的find()操作,最好的情况下只需要循环一次,最坏的情况下需要循环n次,因此平均复杂度约为O((n/2)logn), 总的复杂度在O(nlogn)级别.</p><p>这段程序运行时间28ms.</p><p>但是这个代码使用了STL中的Map容器, 可能有较大的额外开销, 接下来使用排序 + 二分搜索的方法:</p><pre><code>class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; re;        vector&lt;int&gt; oldNums = nums;        sort(nums.begin(), nums.end());        for(int i = 0; i &lt; nums.size(); i++){            int t = target - nums[i];            if(t &lt; nums.front() || t &gt; nums.back()) continue;            int j = binSearch(nums, t);            if(j == -1 || j == i) continue;            else {                int num1 = nums[i], num2 = nums[j];                for(int k = 0; k &lt; oldNums.size(); k++){                    if(oldNums[k] == num1 || oldNums[k] == num2) re.push_back(k);                    if(re.size() == 2) break;                }                return re;            }        }        return re;    }        int binSearch(vector&lt;int&gt; &amp;nums, int t){        int l = 0, r = nums.size(), m = (l + r) / 2;        while(l &lt; r){            if(nums[m] == t) return m;            else if(nums[m] &gt; t) r = m;            else l = m + 1;            m = (l + r) / 2;        }        return -1;    }};</code></pre><p>第二个方法的运行时间缩短为12ms.</p><p>还有另一种更加简洁的双指针方法:</p><pre><code>class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; re;        vector&lt;int&gt; oldNums = nums;        sort(nums.begin(), nums.end());        int l = 0, r = nums.size() - 1;        while(l &lt; r){            int sum = nums[l] + nums[r];            if(sum == target){                for(int i = 0; i &lt; nums.size() &amp;&amp; re.size() &lt; 2; i++){                    if(oldNums[i] == nums[l] || oldNums[i] == nums[r]) re.push_back(i);                }                break;            }            else if(sum &gt; target){                r--;            }            else{                l++;            }        }        return re;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>川大江安校区宽带破解</title>
      <link href="/2016/06/10/%E5%B7%9D%E5%A4%A7%E6%B1%9F%E5%AE%89%E6%A0%A1%E5%8C%BA%E5%AE%BD%E5%B8%A6%E7%A0%B4%E8%A7%A3/"/>
      <url>/2016/06/10/%E5%B7%9D%E5%A4%A7%E6%B1%9F%E5%AE%89%E6%A0%A1%E5%8C%BA%E5%AE%BD%E5%B8%A6%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="0-前言">0 前言</h2><p>四年大学生活马上就要结束了，想一想这四年在江安的生活还真是相当不错的；不过对于我来说，网络大概是江安学习生活中最烦人的东西了。从我2012年入学开始到现在的2016年，川大江安在宿舍所能使用的网络接入方式有三种：校园网、移动CMCC-EDU和电信宽带。其中校园网虽然免费，这四年来雷打不动的512kbps的带宽，基本是处于看图片都是煎熬的水平；CMCC-EDU我基本没用过，速度大概是4Mbps左右，可惜无线不稳定；剩下的电信宽带虽然非常贵（一个月79元，带宽6Mbps，但是可以抵扣话费，奈何我不用电信手机），但是矮子里面拔将军，是唯一比较好用的了。</p><p><strong>但是</strong>，这是建立在电信不限制路由器的基础上的。其实在2012年下半年的时候，电信宽带是不限制路由器的，使用普通的pppoe拨号方式就可以上网了。但是这只是电信认证系统的bug而已（还有另一种阴谋论的说法，就不详细说了。另外江安这个认证系统bug极多，后面我会详细说说），2013年上半年的时候修复了，导致路由器失效，接着电信更新了拨号器（就是本文将要破解的），导致飞扬俱乐部的在线算号器失效（方法是粗暴的禁止Linux版拨号器，至今再没有可用的官方Linux拨号器），当时在学生中算是引起了很大的反弹，可是学校方面不知道出于什么原因一直避而不谈这件事（<s>呵呵，这其中必然有肮脏的**交易</s>），电信抬出什么公安部教育部要求大学生上网一人一号的文件（<s>监控之心不死</s>）来当挡箭牌，这件事后来也不了了之了。但是不能用路由器你让手机iPad怎么上网？许多同学选择通过电脑发射无线信号（其实这也是被拨号器所屏蔽的，不过比较好突破），但是这个方法非常繁琐，要保持电脑一直开机。除了这种方法以外就只能放弃电信宽带了，不过我是一个网速多快都不嫌快，慢一点就无法忍受的人，所以就只能自己动手来破解电信的拨号器了。</p><p>在此要特别感谢软件学院的HZY同学，在我破解的过程中提供了很多帮助。</p><p><strong>我的宽带帐号是12年就有的，用户名是学号，跟后来的用户名是手机号的不一样，所以不保证对后来的账号有效。</strong></p><p>完整代码与原版Mac拨号器程序请移步<a href="https://github.com/xiadong1994/SCU_JiangAn_Dialer" target="_blank" rel="noopener">Github</a>。</p><h2 id="1-2-21版mac协同拨号器拨号流程">1 2.21版Mac协同拨号器拨号流程</h2><p>我在13年的时候破解的是2.21版的Mac拨号器，Windows版的拨号器的程序逻辑要相对复杂许多，这个版本的算法直到目前（16年6月）都还是可用的。PPPoE的介绍和普通的PPPoE拨号流程可以参考Wikipedia：<a href="https://www.wikiwand.com/zh-cn/PPPoE" target="_blank" rel="noopener">https://www.wikiwand.com/zh-cn/PPPoE</a>和RFC文档：<a href="https://tools.ietf.org/html/rfc2516" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2516</a>。计算机自带的PPPoE拨号器无法连接电信宽带的原因主要出在电信使用一种“二次验证”的机制，即计算机第一次拨号的时候是必然失败的，同时认证服务器返回一个字符串，拨号器根据这个字符串通过算法生成一个新的用户名，再次进行拨号才能成功。其中第一次拨号的用户名也是通过算法生成的，不过与服务器无关。</p><p>通过抓包就可以比较直观的看到拨号器拨号的整个流程，我已经很久没有装过协同拨号器了，在这里只贴一下我的路由器模拟的拨号过程。</p><p>这是第一次拨号的过程，可以看到CHAP认证失败并且返回16进制字符串：37f13ef44a72。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: Plugin rp-pppoe.so loaded.</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: RP-PPPoE plugin version 3.8p compiled against pppd 2.4.5</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.notice pppd[2435]: pppd 2.4.5 started by root, uid 0</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: PPP session is 30874</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.warn pppd[2435]: Connected to 00:25:9e:08:b8:3e via interface eth2.2</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: Using interface pppoe-wan</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.notice pppd[2435]: Connect: pppoe-wan &lt;--&gt; eth2.2</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: syncppp not active</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: CHAP authentication failed: 37f13ef44a72</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.err pppd[2435]: CHAP authentication failed</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.notice pppd[2435]: Connection terminated.</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: Exit.</span><br></pre></td></tr></table></figure><p>这是第二次的拨号流程，可以看到认证成功并分配了IP地址等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: Plugin rp-pppoe.so loaded.</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: RP-PPPoE plugin version 3.8p compiled against pppd 2.4.5</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.notice pppd[2447]: pppd 2.4.5 started by root, uid 0</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: PPP session is 19277</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.warn pppd[2447]: Connected to 00:25:9e:08:b8:3e via interface eth2.2</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: Using interface pppoe-wan</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.notice pppd[2447]: Connect: pppoe-wan &lt;--&gt; eth2.2</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.info pppd[2447]: syncppp not active</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.info pppd[2447]: CHAP authentication succeeded: Authentication success,Welcome!</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: CHAP authentication succeeded</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: peer from calling number 00:25:9E:08:B8:3E authorized</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: local  IP address 220.167.43.208</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: remote IP address 220.167.40.1</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: primary   DNS address 61.139.2.69</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: secondary DNS address 202.98.96.68</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice netifd: Interface &#39;wan&#39; is now up</span><br></pre></td></tr></table></figure><h2 id="3-关于如何破解">3 关于如何破解</h2><p>主要使用IDA作为反汇编工具，最关键的就是阅读反汇编拨号器出来的汇编代码和IDA生成的反编译代码。编写自己的拨号器的使用的是C语言，当然也可以自由选择其他的语言。使用libpcap在程序内进行抓包。我在破解的最后阶段还用了GDB在命令行模式下直接调试官方拨号器，在没有调试信息的情况下跟踪程序运行真是很酸爽。</p><p>这个破解程序是差不多三年前写的了，当时接触编程和C语言不到一年，代码写的很烂，但是因为一直能用就没有再做什么改动了。</p><h2 id="4-生成第一次拨号的用户名">4 生成第一次拨号的用户名</h2><p>这个生成第一次拨号用户名的算法是完全模拟的协同拨号器的工作方式。首先获取系统时间，再和一个特殊字符串、用户名、密码拼接成一个新字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time1=time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">sprintf</span>((<span class="keyword">char</span>*)strTime,<span class="string">"%08x"</span>,time1);</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)first,<span class="string">"%s%s%s%s"</span>,strTime,<span class="string">"m2o=crE54nyNUht["</span>,username,psw);</span><br></pre></td></tr></table></figure><p>对该字符串计算MD5值并转换成16进制表示的字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MD5_CTX md5;</span><br><span class="line">MD5Init(&amp;md5);         </span><br><span class="line">MD5Update(&amp;md5,first,<span class="built_in">strlen</span>((<span class="keyword">char</span>*)first));</span><br><span class="line">MD5Final(&amp;md5,md5Result);</span><br><span class="line"><span class="comment">//把md5转换成字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)pMd5Str,<span class="string">"%02x"</span>,md5Result[j]);</span><br><span class="line">    pMd5Str+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后取该字符串的前19个字符，再与其他字符串一起拼接成最终的用户名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> md5Str19[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(md5Str19,md5Str,<span class="number">19</span>);<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)userName,<span class="string">"%s%s%s%s%s"</span>,strTime,<span class="string">"M"</span>,<span class="string">"2021"</span>,md5Str19,username);</span><br></pre></td></tr></table></figure><h2 id="5-进行拨号">5 进行拨号</h2><p>获得了第一个用户名之后就可以进行拨号了。这个拨号的方法是根据不同的平台而不同，我在Windows和Linux系统（主要是路由器运行的OpenWRT）上都移植过这个程序，可以说唯一需要修改的地方就是这里了。我在这里放一下我在路由器上运行的版本的拨号函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PPPoeDial</span><span class="params">(<span class="keyword">char</span> *user,<span class="keyword">char</span> *pwd,<span class="keyword">char</span> *name,<span class="keyword">char</span> *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> pppoe_cmd[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> ifname[<span class="number">40</span>]=<span class="string">"pppoe-"</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(pppoe_cmd,<span class="string">"/usr/sbin/pppd nodetach ipparam %s ifname %s nodefaultroute usepeerdns persist maxfail 1 user %s password %s ip-up-script /lib/netifd/ppp-up ipv6-up-script /lib/netifd/ppp-up ip-down-script /lib/netifd/ppp-down ipv6-down-script /lib/netifd/ppp-down mtu 1492 mru 1492 plugin rp-pppoe.so nic-%s &amp;"</span>,\</span><br><span class="line">    name,<span class="built_in">strcat</span>(ifname,name),user,pwd,device);</span><br><span class="line">    system(pppoe_cmd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"拨号中。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的pppoe_cmd的内容要根据对应的平台调整。<strong>Windows平台本身就提供了拨号函数，不需要运行pppd之类的命令了。</strong></p><h2 id="6-获取服务返回的参数">6 获取服务返回的参数</h2><p>在我的程序中是通过使用libpcap库进行抓包来获取服务器返回的字符串的。libpcap库相关的信息请访问官网<a href="http://www.tcpdump.org" target="_blank" rel="noopener">http://www.tcpdump.org</a>。对每个数据包的回调函数是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(valid &amp;&amp; pkt_data[<span class="number">22</span>]==<span class="number">0x04</span>&amp;&amp;pkt_data[<span class="number">23</span>]==<span class="number">0x01</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pcap_breakloop(adhandle);</span><br><span class="line">        valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> seed[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(&amp;seed[i],<span class="string">"%c"</span>,pkt_data[<span class="number">30</span>+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"seed:%s\n"</span>,seed);</span><br><span class="line">        <span class="keyword">int</span> time2=((<span class="keyword">unsigned</span> <span class="keyword">int</span>)rand())&lt;&lt;<span class="number">16</span>|rand();</span><br><span class="line">        <span class="keyword">char</span> result[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        getSecondUserName(result,seed,g_userName,g_pwd,time1,time2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,result);</span><br><span class="line">        sleep(<span class="number">8</span>);</span><br><span class="line">        PPPoeDial(result,g_pwd,wan,d-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>pkt_data[22]==0x04&amp;&amp;pkt_data[23]==0x01</code>是表示这个数据包是服务器返回的认证失败的数据包，从中取得字符串<code>seed</code>，然后产生一个随机数time2，作为产生第二个用户名的参数。sleep(8)的目的是等待第一次拨号的进程完全退出以免造成冲突。​</p><h2 id="7-生成第二次的用户名">7 生成第二次的用户名</h2><p>生成第二次用户名的函数比较复杂，具体还是参见代码中的实现吧。主要思路仍然是对字符串进行处理后计算MD5值再进行拼接。</p><h2 id="8-运行平台">8 运行平台</h2><p>在破解出这个算法后，我写过Windows和OpenWRT版本的拨号器，我相信大多数同学都是想使用路由器的，使用路由器很简单，只需要一个刷了OpenWRT的路由器就可以了，下载相应的工具链之后进行交叉编译，把得到的可执行文件上传到路由器上，再添加启动脚本就可以实现开机自动连接宽带了。</p><h2 id="9-后记与扯扯淡">9 后记与扯扯淡</h2><p>江安校区的电信宽带真的是相当奇葩，贵而难用，而且BUG多多，单单我知道的就有：把用户名最后几位去掉就可以使用无上限的带宽（取决于你寝室的出口物理带宽）；同样是去掉几位就可以进行无限制的多拨（带宽叠加）；绑定的手机号注销之后宽带帐号还在等等。靠着前两个bug我还是享受了将近两年的50M以上宽带的，虽然到现在这些bug已经修复了，但是说不定还是有其他bug，这就交给学弟学妹们来开发啦。</p><p>有了OpenWRT路由器之后可玩的东西就变得挺多了，完全可以当一个24h运行小服务器来用。比如以前我还在用多拨叠加宽带的时候因为有一定概率拨号失败（挺低的），所以就写了一个shell脚本，拨号完成后发邮件通知我有没有没连上的连接。或者写一个桥接CMCC信号并且自动登陆的脚本等等。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Qt中使用Botan库进行加解密</title>
      <link href="/2016/04/21/%E5%9C%A8qt%E4%B8%AD%E4%BD%BF%E7%94%A8botan%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
      <url>/2016/04/21/%E5%9C%A8qt%E4%B8%AD%E4%BD%BF%E7%94%A8botan%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="在qt中使用botan库进行加解密">在Qt中使用Botan库进行加解密</h1><p>在毕设项目中需要使用RSA和AES加解密, 因为Qt自带Botan库, 所以使用Botan库来实现. Botan项目网站<a href="http://botan.randombit.net" target="_blank" rel="noopener">http://botan.randombit.net</a></p><h2 id="在项目中使用">在项目中使用</h2><p>因为Qt Creator自带Botan库, 所以很容易就可在Qt项目中使用. 首先到Qt Creator的Github页面<a href="https://github.com/qtproject/qt-creator" target="_blank" rel="noopener">https://github.com/qtproject/qt-creator</a>, 找到<code>qt-creator/src/libs/3rdparty/botan/</code>目录, 下载其中的文件. 然后在项目的pro文件中使用<code>include(botan/botan.pri)</code>引入Botan的源代码.</p><h2 id="rsa加解密">RSA加解密</h2><p>引入头文件#include “botan/botan.h”</p><p>生成密钥对</p><pre><code>Botan::AutoSeeded_RNG rng;Botan::RSA_PrivateKey privateKey(rng, 1024);</code></pre><p>输出密钥</p><pre><code>qDebug() &lt;&lt; Botan::X509::PEM_encode(privateKey).c_str() &lt;&lt; Botan::PKCS8::PEM_encode(privateKey).c_str();</code></pre><p>对字符串加密</p><pre><code>Botan::PK_Encryptor_EME enc(privateKey, &quot;EME1(SHA-256)&quot;);char msg[] = &quot;Test&quot;;Botan::SecureVector&lt;Botan::byte&gt; en = enc.encrypt(msg, 6, rng);</code></pre><p>解密</p><pre><code>Botan::PK_Decryptor_EME dec(privateKey, &quot;EME1(SHA-256)&quot;);Botan::SecureVector&lt;Botan::byte&gt; re = dec.decrypt(en);</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows平台poppler-qt5预编译库</title>
      <link href="/2016/03/16/windows%E5%B9%B3%E5%8F%B0poppler-qt5%E9%A2%84%E7%BC%96%E8%AF%91%E5%BA%93/"/>
      <url>/2016/03/16/windows%E5%B9%B3%E5%8F%B0poppler-qt5%E9%A2%84%E7%BC%96%E8%AF%91%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>项目中要对PDF文件进行预览, 搜索与Qt搭配的库之后选择poppler库, 官网地址: <a href="https://poppler.freedesktop.org/" target="_blank" rel="noopener">https://poppler.freedesktop.org/</a>, 没有找到win32平台的二进制文件, 所以只能下载源码自行编译, 由于依赖库众多, 经常报莫名其妙的编译错误, 在耗费了十几个小时后终于编译出了可用的dll文件, 在Qt工程中使用正常. 为了备份和方便后来人, 提供编译好的poppler-qt5的库下载.</p><p><strong>poppler版本:</strong></p><p>0.41.0</p><p><strong>编译器</strong></p><ul><li>gcc 5.1.0 32-bit</li><li>mingw32-make GNU make 3.82.90</li></ul><p><strong>目录结构</strong></p><pre><code>libpoppler.zip||--bin|   |--freetype6.dll|   |--jpeg62.dll|   |--libpoppler.dll|   |--libpoppler-qt5.dll|   |--libtiff3.dll|   |--openjpeg.dll|   |--pdfinfo.exe|   |--zlib1.dll||--include|   |--poppler|       |--qt5|           |--poppler-annotation.h|           |--poppler-export.h|           |--poppler-form.h|           |--poppler-link.h|           |--poppler-media.h|           |--poppler-optcontent.h|           |--poppler-page-transition.h|           |--poppler-qt5.h||--lib    |--libpoppler.dll.a    |--libpoppler-qt5.dll.a</code></pre><p><strong>下载地址:</strong></p><p><a href="https://pub-b8c7c13887be4f9fb8bd159a86e85ef5.r2.dev/libpoppler.zip" target="_blank" rel="noopener">https://pub-b8c7c13887be4f9fb8bd159a86e85ef5.r2.dev/libpoppler.zip</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Study </category>
          
          <category> 备忘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++&amp;Qt操作Word模版基础</title>
      <link href="/2016/01/02/c++qt%E6%93%8D%E4%BD%9Cword%E6%A8%A1%E7%89%88%E5%9F%BA%E7%A1%80/"/>
      <url>/2016/01/02/c++qt%E6%93%8D%E4%BD%9Cword%E6%A8%A1%E7%89%88%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>项目中要对Word模版进行操作, 使用C++&amp;Qt进行开发, 将学到的东西记录如下.</p><h2 id="0-参考链接">0 参考链接</h2><ol><li><p><a href="https://en.wikipedia.org/wiki/OLE_Automation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/OLE_Automation</a></p></li><li><p><a href="http://www.cgoakley.org/prog/oleaut.html" target="_blank" rel="noopener">http://www.cgoakley.org/prog/oleaut.html</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/ActiveX" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/ActiveX</a></p></li><li><p><a href="http://www.oschina.net/question/1243014_120926" target="_blank" rel="noopener">http://www.oschina.net/question/1243014_120926</a></p></li><li><p><a href="http://blog.csdn.net/csxiaoshui/article/details/47333989" target="_blank" rel="noopener">http://blog.csdn.net/csxiaoshui/article/details/47333989</a></p></li></ol><h2 id="1-基础知识">1 基础知识</h2><h3 id="1-1-ole-automation">1.1 OLE Automation</h3><p>在Windows应用开发中, OLE Automation是一种进程间通信机制. 它基于COM和MFC, 因此在我的项目中并不适用.<a href="https://en.wikipedia.org/wiki/OLE_Automation" target="_blank" rel="noopener">[1]</a><a href="http://www.cgoakley.org/prog/oleaut.html" target="_blank" rel="noopener">[2]</a></p><blockquote><p>OLE（Object Linking and Embedding，对象链接与嵌入），是能让应用程序创建包含不同来源的复合文档的一项技术。OLE不仅是桌面应用程序集成，而且还定义和实现了一种允许应用程序作为软件“对象”（数据集合和操作数据的函数）彼此进行“链接”的机制，这种链接机制和协议称为部件对象模型(Component Object Model),简称COM。OLE可以用来创建复合文档，复合文档包含了创建于不同源应用程序，有着不同类型的数据，因此它可以把文字、声音、图像、表格、应用程序等组合在一起。</p></blockquote><h3 id="1-2-activex">1.2 ActiveX</h3><p>根据Wikipedia<a href="https://zh.wikipedia.org/wiki/ActiveX" target="_blank" rel="noopener">[3]</a>, ActiveX的含义是:</p><blockquote><p>ActiveX在广义上是指微软公司的整个COM架构，但是现在通常用来称呼基于标准COM接口来实现对象链接与嵌入（OLE）的ActiveX控件。[1]后者是指从VBX发展而来的，面向微软的Internet Explorer技术而设计的以OCX为扩展名的OLE控件。通过定义容器和组件之间的接口规范，如果编写了一个遵循规范的控件，那么可以很方便地在多种容器中使用而不用修改控件的代码。同样，通过实现标准接口调用，一个遵循规范的容器可以很容易地嵌入任何遵循规范的控件。由于OLE在ActiveX控件中的应用的普及，现在OLE技术中只有少数独立于ActiveX技术，例如复合文档。</p></blockquote><h2 id="2-qt中的activex-5">2 Qt中的ActiveX<a href="http://blog.csdn.net/csxiaoshui/article/details/47333989" target="_blank" rel="noopener">[5]</a></h2><p>Qt中提供QtActiveX模块来支持ActiveX, 有两种开发方式:</p><ol><li>将已有的COM或者ActiveX空间引入到Qt的应用程序中</li><li>将Qt应用程序或者Qt的对象导出成COM对象或者ActiveX控件供他人使用</li></ol><p>Qt是通过两个模块来支持上述所说的两种方式的:</p><ol><li>使用QAxContainer模块, 通过QAxObject和QAxWidget分别支持COM对象和ActiveX控件的开发, 可以通过这两个对象将外部的COM或者ActiveX组件接入到Qt应用程序.</li><li>使用QAxServer模块, 通过QAxAggregated, QAxBindable和QAxFactory类, 通过了进程内和可执行程序exe两种方式的COM Server模式, 用来将Qt写的内容导出为COM或者ActiveX供他人使用.</li></ol><h2 id="3-qt中使用activex-4">3 Qt中使用ActiveX<a href="http://www.oschina.net/question/1243014_120926" target="_blank" rel="noopener">[4]</a></h2><p>Qt版本5.4.2, 编译器: MinGW 4.9.1 32-bit.</p><h3 id="3-1-准备工作">3.1 准备工作</h3><p>创建一个Word模版, 插入一个表格和三个书签: pos1, pos2, pos3. 保存为Doc1.dot.</p><p><img src="https://lh3.googleusercontent.com/-Vh0Ca5Homwc/VofF7M2vCwI/AAAAAAAAD0M/BazOwEELCWwZjizGLApPj9JHnXGzQARrACCo/s800/20160102200655.png" alt=""></p><h3 id="3-2-在项目的-pro文件中增加如下一行">3.2 在项目的.pro文件中增加如下一行</h3><pre><code>QT   += axcontainer`&lt;/pre&gt;</code></pre><h3 id="3-3-新建qt项目-输入如下代码">3.3 新建Qt项目,输入如下代码:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAxWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAxObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">  MainWindow w;</span><br><span class="line">  w.show();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//新建一个word应用程序</span></span><br><span class="line">  QAxWidget *<span class="keyword">word</span> = <span class="keyword">new</span> QAxWidget(<span class="string">"Word.Application"</span>, <span class="number">0</span>, Qt::MSWindowsOwnDC);</span><br><span class="line">  <span class="comment">//设置为不可见</span></span><br><span class="line">  <span class="keyword">word</span>-&gt;setProperty(<span class="string">"Visible"</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">//获取所有工作文档</span></span><br><span class="line">  QAxObject *docs = <span class="keyword">word</span>-&gt;querySubObject(<span class="string">"Documents"</span>);</span><br><span class="line">  <span class="comment">//新建一个文档</span></span><br><span class="line">  docs-&gt;dynamicCall(<span class="string">"Add(QString)"</span>, QString::fromLocal8Bit(<span class="string">"E:\\Study\\Design\\WordTempTest\\Doc1.dot"</span>));</span><br><span class="line">  <span class="comment">//获取激活文档</span></span><br><span class="line">  QAxObject *activeDoc = <span class="keyword">word</span>-&gt;querySubObject(<span class="string">"ActiveDocument"</span>);</span><br><span class="line">  <span class="comment">//获取pos1标签</span></span><br><span class="line">  QAxObject *bookmarkPos1 = activeDoc-&gt;querySubObject(<span class="string">"Bookmarks(QVariant)"</span>, <span class="string">"pos1"</span>);</span><br><span class="line">  <span class="comment">//选中并插入字符</span></span><br><span class="line">  <span class="keyword">if</span>(!bookmarkPos1-&gt;isNull())&#123;</span><br><span class="line">    bookmarkPos1-&gt;dynamicCall(<span class="string">"Select(void)"</span>);</span><br><span class="line">    bookmarkPos1-&gt;querySubObject(<span class="string">"Range"</span>)-&gt;setProperty(<span class="string">"Text"</span>, <span class="string">"pos1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取pos2标签</span></span><br><span class="line">  QAxObject *bookmarkPos2 = activeDoc-&gt;querySubObject(<span class="string">"Bookmarks(QVariant)"</span>, <span class="string">"pos2"</span>);</span><br><span class="line">  <span class="comment">//选中并插入字符</span></span><br><span class="line">  <span class="keyword">if</span>(!bookmarkPos2-&gt;isNull())&#123;</span><br><span class="line">    bookmarkPos2-&gt;dynamicCall(<span class="string">"Select(void)"</span>);</span><br><span class="line">    bookmarkPos2-&gt;querySubObject(<span class="string">"Range"</span>)-&gt;setProperty(<span class="string">"Text"</span>, <span class="string">"pos2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取pos3标签</span></span><br><span class="line">  QAxObject *bookmarkPos3 = activeDoc-&gt;querySubObject(<span class="string">"Bookmarks(QVariant)"</span>, <span class="string">"pos3"</span>);</span><br><span class="line">  <span class="comment">//选中并插入字符</span></span><br><span class="line">  <span class="keyword">if</span>(!bookmarkPos3-&gt;isNull())&#123;</span><br><span class="line">    bookmarkPos3-&gt;dynamicCall(<span class="string">"Select(void)"</span>);</span><br><span class="line">    bookmarkPos3-&gt;querySubObject(<span class="string">"Range"</span>)-&gt;setProperty(<span class="string">"Text"</span>, <span class="string">"pos3"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//文档另存为Doc1.doc</span></span><br><span class="line">  activeDoc-&gt;dynamicCall(<span class="string">"SaveAs (const QString&amp;)"</span>, QString(<span class="string">"E:\\Study\\Design\\WordTempTest\\Doc1.doc"</span>));</span><br><span class="line">  activeDoc-&gt;dynamicCall(<span class="string">"Close (boolean)"</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">word</span>-&gt;dynamicCall(<span class="string">"Quit()"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-运行结果">3.4 运行结果</h2><p>程序运行后Doc1.doc文件的内容:</p><p><img src="https://lh3.googleusercontent.com/-dAT5kINBxfQ/VofF7O-Oo7I/AAAAAAAAA18/iiKZDWcC8wo/s800-Ic42/20160102204208.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Study </category>
          
          <category> 备忘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10 自动锁屏问题解决</title>
      <link href="/2015/12/30/windows-10-%E8%87%AA%E5%8A%A8%E9%94%81%E5%B1%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2015/12/30/windows-10-%E8%87%AA%E5%8A%A8%E9%94%81%E5%B1%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>升级到Windows10以后我遇到的各种小毛病不少，比如中文输入法失灵，锁屏无法显示幻灯片还有这次要说的自动锁屏问题。前两个问题基本上都已经解决了，但是这个自动锁屏的问题却还是顽固地出现。</p><p>具体的症状表现就是每半小时就会自动锁屏，无论在干什么都是这样。不过幸好这个问题不是一直不停地出现，一般都是在睡眠唤醒之后半小时出现一次，虽然很烦但是对于我这样的懒人还不是无法忍受。可是今天这种情况反复不停出现，每半小时一次，所以我不得不想办法把它彻底解决了。</p><h2 id="问题原因"><s>问题原因</s></h2><p><strong>晚上这个问题又出现了，所以这并不是直接原因</strong></p><p><s>由于是精确的每半小时出现一次，所以我就到事件查看器里看看到底是出了什么状况。很容易就找到了相应的事件：</s><img src="http://7xkh37.com1.z0.glb.clouddn.com/20151230141322.png" alt=""><s>所对应的具体信息为：</s></p><blockquote><p><s>应用程序-特定 权限设置并未向在应用程序容器 不可用 SID (不可用)中运行的地址 LocalHost (使用 LRPC) 中的用户 NT AUTHORITY\SYSTEM SID (S-1-5-18)授予针对 CLSID 为 {D63B10C5-BB46-4990-A94F-E40B9D520160}、APPID 为 {9CA88EE3-ACB7-47C8-AFC4-AB702511C276}</s></p></blockquote><h2 id="解决方案"><s>解决方案</s></h2><p><strong>同样这也不是解决方法</strong></p><p><s>Google之后，根据<a href="http://www.lxway.com/458800126.htm" target="_blank" rel="noopener">这篇文章</a>所描述的方法设置了权限之后重启，问题解决。</s></p><h2 id="可能的其他原因">可能的其他原因</h2><p>根据MS Community的这篇帖子(<a href="http://answers.microsoft.com/en-us/windows/forum/windows_10-security/windows-10-auto-locks-every-30-minutes-even-when/b53e7ff7-7644-4d51-8038-62f8f2eb9a26" target="_blank" rel="noopener">http://answers.microsoft.com/en-us/windows/forum/windows_10-security/windows-10-auto-locks-every-30-minutes-even-when/b53e7ff7-7644-4d51-8038-62f8f2eb9a26</a>)，可能的原因是由于锁屏幻灯片导致的，而我的锁屏幻灯片也确实是有问题的，按照帖子的说法把锁屏幻灯片关掉就好，可是我并不想关，所以我先把<strong>设置-&gt;个性化-&gt;锁屏界面-&gt;高级幻灯片放映设置-&gt;自动关闭屏幕</strong>设置为不自动关闭（因为这里原来设置为30分钟，跟锁屏的频率吻合）。接下来就要看看还会不会出现同样的问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015腾讯实习笔试+面试+offer</title>
      <link href="/2015/04/17/2015%E8%85%BE%E8%AE%AF%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95offer/"/>
      <url>/2015/04/17/2015%E8%85%BE%E8%AE%AF%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95offer/</url>
      
        <content type="html"><![CDATA[<p>本来我是已经决定要保研，但是这个学期还是投了一些实习简历，主要是想看一下我的水平到底如何，顺便也能感受一下找工作的感觉。寒假快要结束的时候给阿里投了内推，在寒假的最后一天接到电面，面试过程相当坑爹，我基本是裸面，结果是毫无悬念的跪了。来到学校之后又尝试着投了腾讯和阿里的正式校招，也参加了微软的在线笔试（到现在都没有动静估计也是没戏了）。上个星期腾讯面试完，今天拿到offer，简单记录一下腾讯实习的面试经历。</p><h2 id="笔试">笔试</h2><p>笔试在电子科大在郫县的校区进行，人数还是不少了，占用了不少阶梯教室。基本上所有报技术职位的都使用一张笔试试卷，很长的一张，正反一共十面，不过有大概三分之一是各个事业群的介绍。有20（还是25道？）选择题（都是不定项选择题），和四道简答题。总体来说难度不是很小，考察了js，C/C++，计算机网络，数据库，运维和一些概率统计方面的问题。我感觉至少有一半的题目不确定，印象比较深刻的知识点有字节对齐，基类有虚函数的派生类的大小等等。。。记忆已经有些模糊了。大题第一题是存储了很多很多QQ号的vector、set和map其中的两个（= =我已经记不清了），删除其中是奇数的QQ号，写算法。第二题是经典的斐波那契数列问题。第三题和第四题已经忘记了，只记得做了第三题，第四题和第一题一样是空白。</p><h2 id="一面">一面</h2><p>笔试似乎刷人不多，跟我一起笔试的同学基本都进入面试了。面试是在成都的明宇尚雅饭店进行，就在锦江边上，4月7号晚上发短信要第二天早上11点面试。</p><p>第二天早上先坐67路再转地铁到华西坝站，出地铁站走几百米就到了。到那里发现人还是很多的，大概是一面的人比较多的缘故，还遇到了CJW君去霸面（而且还霸面成功了。。。）。签到之后等了没几分钟就让去楼上面试。面试官是一个瘦瘦的眼镜小哥。主要问的问题有</p><ul><li>结构体字节对齐(<a href="http://www.cnblogs.com/clover-toeic/p/3853132.html" target="_blank" rel="noopener">C语言字节对齐问题详解</a>)</li><li>要求不对齐有哪些方法</li><li>异构网络中怎么解决不同主机对齐不同的问题（没答出来）</li><li>C可变参数(<a href="http://blog.csdn.net/jackystudio/article/details/17523523" target="_blank" rel="noopener">【C++基础之二十】可变参数的函数</a>)</li><li>笛卡尔积（数据库）</li><li>左右连接</li><li>tcp建立拆除(三次和四次握手，这问题几乎是必问，阿里问了，后面的二面也问了)</li><li>md5冲突（md5重复的问题）</li><li>实习地点、时间</li><li>C++只问了会不会没有具体问</li></ul><p>一共大概二十多分钟就出来了，没有要求写代码。</p><h2 id="还是一面">还是一面。。。</h2><p>我自认为第一次面试回答的还是不错的，只有一个没答出来。可是回学校的时候一查。。。岗位不合适。。。= =#，结合后面的面试经历我猜测面试官一开始就没打算让我进微信事业群（我报的微信事业群后台开发），基本没有问什么有实际意义的东西。</p><p>到了晚上十一点多的时候又接到短信，再去初试（一面），看来是换了个部门。第二天下午6点半又到了饭店，这次等待面试的地方人明显少了很多（这个时候一面已经基本结束了）。这次直接到顶楼，面试官年纪比上一个要大一些。上来没有自我介绍，先问我会啥，我说C/C<ins>比较熟，于是就问：“说一说C</ins>的多态吧”。C++这方面的东西还是前几天恶补的，只能硬着头皮扯。扯到了动态绑定、虚函数等等，然后面试官问虚函数的继承是怎么实现的，有什么意义。我只说出来了虚函数表。。。又问为什么基类的析构函数一般都是虚函数，这个我是看过的，可是一下子想不起来。。。这个话题结束了。。。下一个问题是new和malloc的区别，这个我还有点印象；然后问到堆与栈的区别；静态变量存储在哪个区域。这些都答上来了。然后问到从数据库中读取了很多联系人数据，在内存中用什么数据结构来管理，要求搜索，排序，添加删除都比较快，数组添加删除太慢，链表搜索排序慢，最后我也只扯出来了平衡二叉搜索树这种，本来想说B+树可是实在不熟。接下来是三个数据结构题：</p><ul><li>两个单向链表可能相交也可能不相交，求相交的节点（暴力遍历不行）</li><li>一个字符串中单词顺序反转（反转两次）</li><li>交换单链表的相邻两个节点（这个要手写代码，前面两个讲思路）</li></ul><p>这三个题答得都还不错。面试官说可以进入复试，然后我问了一下现在面的是什么部门，结果是SNG（社交网络事业群）的移动客户端。。。就是手机QQ、QQ空间等。然后面试结束，让我明天早上来复试。</p><h2 id="二面">二面</h2><p>坐电梯刚到一楼接到面试官的电话，说我现在就可以去二面，于是又坐电梯上去。这次的面试官气场有点强。。。先问了问项目经历、成绩等等。然后开始写代码，先是经典的上台阶问题，然后要求实现strlen，我只考虑了空指针的问题，然后用遍历来求长度，然后面试官问怎么优化。。我是没想出来（回来之后才知道要优化一要分配寄存器，二要考虑字节对齐）；然后是一个很长的字符串，求第一个只出现了一次的字符。接下来问了一个智力题：两个外观大小重量都完全相同的金球和铅球在不破坏它们的情况下怎么区分开。。。我一开始想的是硬度，可是这被认为破坏了，然后是导电性，被说不好操作，其他的我也没想出来。最后问了数据库的问题，谈到了项目中用的框架，于是又聊到了框架对SQL的封装等等。。。最后得到的评价是还不错，但是项目经验太少。</p><h2 id="hr面">HR面</h2><p>二面之后我基本确定能进HR面了。HR面没有技术问题，问了籍贯、家庭背景、爱好、对成都怎么看、能不能去深圳实习等等问题。HR小哥明显跟前面的技术面试官不一样，也热情的多。</p><h2 id="offer">offer</h2><p>一个星期后接到电话说拿到了实习名额，但是啊。。但是，考虑再三还是决定保研为重，学院还要求必须七月去实训，时间也不够还是决定拒掉实习offer了。下个月的阿里面试估计也不会再去了。。。</p><h2 id="总结">总结</h2><p>校招时对于本科生的技术要求不是太高，面对面的面试中也不太可能出现复杂的问题，时间上也来不及，所以问的问题多集中在语言的特性（对语言的熟练程度）和数据结构上。还有简历不要乱写，写在上面的每一条都有可能被刨根问底，不是很熟悉的项目还是不要写为妙。我都没有敢说对Python比较熟，因为我只是用它但是却没有极其深入的研究，随随便便就能被问倒。</p><p>重点还是在计算机专业的核心科目上：C/C++，计算机网络，数据结构与算法、操作系统和数据库等。</p><p>说实话能拿到实习offer还是很幸运的，我的水平还是不够啊。。。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 备忘 </tag>
            
            <tag> 实习 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用微软的免费Git服务</title>
      <link href="/2015/03/13/%E4%BD%BF%E7%94%A8%E5%BE%AE%E8%BD%AF%E7%9A%84%E5%85%8D%E8%B4%B9git%E6%9C%8D%E5%8A%A1/"/>
      <url>/2015/03/13/%E4%BD%BF%E7%94%A8%E5%BE%AE%E8%BD%AF%E7%9A%84%E5%85%8D%E8%B4%B9git%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Github上的软件仓库必须公开，今天找了一下免费的私人Git，找到了bitbucket和Visual Studio Online。权衡了一下还是选择了微软的。<a href="www.visualstudio.com" title="www.visualstudio.com">www.visualstudio.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>year=2015</title>
      <link href="/2015/01/01/year2015/"/>
      <url>/2015/01/01/year2015/</url>
      
        <content type="html"><![CDATA[<p>2014又过去了，感觉上很快，但是又好像经历了很多事情。从大二到大三，说不上什么巨大的变化，但是为什么却让我觉得这一年中充斥着许许多多的事情呢？而且很多事情仿佛才过去没有多久而已。</p><p>年初的时候，那就是大二上的期末考试吧，当时是怎么考的，考了什么竟然印象全无。甚至寒假的时候在家里干了什么也没有印象呢。嗯，只记得大概练了一些题吧，然后就糊里糊涂的来了学校。然后四月份大创立项，不过也是直到暑假之前都没有怎么动手。还有参加蓝桥杯的省赛，拿了一个省一等奖，这也算是我现在为止最高的奖了吧。象ACM那样的团队比赛我似乎总是卡在“没有队友”这一点，是因为不善交际吗。。不过我的身边似乎也没有能和我一起去学习的人。班里的其他几位学霸除了上课也没有什么交集。所以我从上大学开始学习的路上就一直是一个人呢。</p><p>五月，我又真正的再次回到孤独一人的状态。很对不起，让你在这一年多的时间里忍受我的愚钝和低情商，现在真的只希望你能快乐的继续走下去。</p><p>暑假的前夕，在学校上着小学期的时候竟然入了二次元这个坑。说起来真的是很幸运，否则我真的还找不到什么学习和写程序以外的爱好了。记得以前在知乎看到一个答案，说人需要一种类似“能量”的东西，外向的人通过和他人接触从他人那里获得“能量”；而内向的人却可以自己产生这种“能量”，所以他们没有什么与别人打交道的欲望。对于这个观点我还是比较赞同的，像我这样对于和他人接触没有什么兴趣的人却可以从代码、小说或者动漫中获得满足。不知道喜欢幻想世界的人是不是都有逃避现实的倾向，但是幻想中的美好世界确实比现实中这个更有吸引力。</p><p>暑假基本都在学车，真的很坑，每天都相当累，而且科目二训练了接近二十天，从不会到会又到了不会。不过好在科目二通过了，一个月的辛苦没有全白费。暑假里面把自己的大创项目开了个头，这个项目全部都是我自己一个来完成，说实话我对于我校计算机专业的学生的平均水平基本已经不抱什么希望了。</p><p>下半年开始的一个月把项目差不多赶完了，虽然还是很粗糙但是总算所有功能都完成了。而且通过这个项目和上个学期研究开发实践的项目我对于WEB开发的流程和基本功能的开发已经比较熟悉了，前端后端都能写，怎么说也是向着所谓“Full Stack”发展吧:-)。</p><p>接下来就是日复一日的上课、学习。这学期我倒是把睡眠调整了过来，十一点之后睡觉，八点之前就能起来，算是一个好习惯吧。就这样一直到了期末，让我说这个学期学到了什么呢？嗯貌似除了课堂上学习的网络、数据库、软件工程还真没有学到什么。不过这些课都是程序员的安身立命之本，也不算荒废吧。</p><p>2015年又要到了一个人生的十字路口了，工作/保研该怎么选择我还没有下定决心。在我的意识之中现在的IT界对于本科以上学历的高低的区别已经不大了，在校园中学到的东西在工作中能用到多少还是个问题。但是看着互联网尤其是移动互联网的疯狂发展，我总是觉得有点担忧，如果国内的互联网产业真的有泡沫，那么如果一旦破了，普通程序员就是最先遭殃的一部分人。而且看着国内IT业界一片纷纷扰扰的乱象总是不像是有着多模巨大的发展潜力，我只看到了互相倾轧，各种口水战，无下限的营销手段，把普通用户当作待宰的羔羊。我如果明年就结束校园生活，那么这种环境我又能发展的什么地步呢？我真的没有信心。</p><p>现在我越来越感到自己相比于其他更优秀的人的差距，要说什么突出的技能，傲人的奖项、出众的科研能力我都没有，我拿什么去竞争呢？前几天看到中山大学超算冬令营的通知，看到要学术讨论，有论文或者科研项目，我深深的觉得我差的还太多，没有怎么接触过科研，也就无从谈起什么科研能力。我现在会的只不过是基础中的基础而已，距离优秀还远得很，而且有那么多比我努力的多的人。</p><p>现在的计划大概是先参加保研夏令营，看看能不能拿到名额，如果可以的话就继续读研究生。如果没有理想的大学就还是去找工作吧。上半年的时候尝试一下BAT或者外企的实习。</p><p>2014年的末尾时我又一次的感觉到了这个国家的寒意。政府对于“墙”的不断加强已经让我感到前方的黑暗。2014年一系列的打击海外文化的举措，一遍遍的用政治力强行控制人民已经让我彻底的失望了，执政者的想法总是向着更坏的方向发展。希望有朝一日能够走出这堵墙，这是我现在最大的愿望了吧。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zip文件名乱码的解决方法</title>
      <link href="/2014/12/19/zip%E6%96%87%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2014/12/19/zip%E6%96%87%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在Mac下压缩的ZIP文件在Windows下用WinRAR或者7-ZIP打开都会产生文件名乱码的问题。</p><p>网上的办法都是在Mac下从新打包。今天突然找到了一个压缩软件<a href="http://www.bandisoft.com/bandizip/cn/" target="_blank" rel="noopener">Bandizip</a>，可以打开Unicode编码的文件名，乱码问题彻底解决。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> 备忘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>杂记——我就是要吐槽Windows</title>
      <link href="/2014/11/19/%E6%9D%82%E8%AE%B0%E2%80%94%E2%80%94%E6%88%91%E5%B0%B1%E6%98%AF%E8%A6%81%E5%90%90%E6%A7%BDWindows/"/>
      <url>/2014/11/19/%E6%9D%82%E8%AE%B0%E2%80%94%E2%80%94%E6%88%91%E5%B0%B1%E6%98%AF%E8%A6%81%E5%90%90%E6%A7%BDWindows/</url>
      
        <content type="html"><![CDATA[<p>这几天微软因为.Net开源的原因又搞出了个“大新闻”，知乎上也是一片喊着Java可以去死了的声音，但是作为一个微软粉转路人，昨天折腾了我一下午的事情简直让我想变成一生黑。</p><p>事情是这样的：上个周末的时候看着又要告急万里江山一片红的C盘，想着还是去卸载一些东西吧，于是遵从微软的教导，打开控制面板－程序－卸载程序，结果看来看去发现实在没有什么可以卸载的，于是打算拿从来没有用过的SQL Server下手。不要问我为什么装它，装VS的时候貌似是默认的，亦或者我没有把它勾掉。说实话我知道VS是一个优秀的IDE，但是我仍然对它没有什么好感，过于臃肿，要不是课程要用到我才不会装呢。不论如何，我是打算拿SQL Server开刀了，列表中列出了大概六到七个相关的组件，嗯，挨个卸载吧。开头两个点击卸载后提示依赖于另一个程序，要先卸载另一个，好，你说先卸载就先卸载，结果依赖的程序点击卸载后卸载出错，出错就出错吧，也不少见了，但是可气的是只告诉我出错又不告诉我哪里出错，要是移动设备什么的也就算了，告诉用户出错原因用户可能也束手无策。但是作为桌面操作系统，就不能告诉我到底哪里错了吗？这个问题后面再讨论，还是继续我的卸载之旅吧。既然正常的卸载方法卸载不掉，那就只能用非常手段了，于是祭出Installer Clean Up，这是微软官方的用于删除msi安装包的工具，虽然很久没有更新了，但是在删除一些极其顽固的软件的时候还是很有用的（没错，Office，说的就是你）。找到要卸载的软件后点Clean，继续坑爹，删除进程卡住了，这是一个命令行工具，主要是扫描注册表和系统文件再执行删除，但是它运行到一半的时候卡住了。看来这个办法也行不通了，作为一个轻度强迫症患者，我想卸载却无法卸载简直就是折磨，于是一通Google，在微软官网找到了官方卸载修复工具，down下来之后总算是把SQL Server删除了。但是这却引起了更严重的问题，Office 2013每次打开的时候都要进行一次配置，当时我还没有在意，以为是没有重启导致的，结果昨天重启之后还是这个样子，这简直可以把强迫症逼疯好麻！！结果在尝试了修改注册表等方法无果后，还是痛下决心决定重装Office（昨天是要做明天答辩的PPT的，这个时候决定重装需要多大的决心你造吗？）这中间又出了多么坑爹的注册表权限问题我就不提了，安装完Office 2013 SP1后打补丁吧，我不说要打三个G的Office补丁了，但是你有两个跟Office和SQL Server没半毛钱关系的补丁出现未知错误是怎么回事？我已经不想吐槽了，又花了大半个晚上的时间才把这两个补丁装上。</p><p>微软是一家伟大的公司，它的产品技术也是世界顶级的，但是作为一个长年Windows用户（其实是没钱买不起Mac，呵呵说多了都是泪）实在不觉得Windows是个优秀的产品，它为了兼容性和市场份额而背负了太多的包袱。而且Windows作为一个操作系统本身的复杂程度就已经非常高，谁也不能保证不出问题，但是它总是会出一些莫名奇妙的问题我就无法理解了。如果是第三方软件出问题还可以辩解说是第三方软件的问题，但是微软自家产品出的问题也不少，比如我每次要重装Office的时候都几乎必然会出问题（注册表是重灾区），还经常有上文这样无法卸载的东西，甚至用官方的东西卸载后导致其他部分出问题，一个人生病，全家卧床不起。你可以说我本来就不应该去卸载SQL Server，一个软件连最基本的卸载都搞不定我还怎么对它有好感？</p><p>大概Windows认为大多数用户无法自己解决问题，所以出错提示都相当简短，最多有个错误号，即使到系统日志里看到了具体的错误一般也是个程序的返回码，比如我最后安装那两个补丁时报的错，还有这周在网络实验室的Server 2008 R2上添加活动区域的时候，都是告诉用户错了，但是具体哪里错了我就是不告诉你，其实系统也不知道到底哪里错了，它只从程序那里得到一个错误码而已。没有很深的专业知识和经验想要查出问题在哪简直是不可能。而且因为Win的开放度和兼容性导致Win的目录结构常常变的极其混乱，这个时候出问题大多数人还是重装了事吧。</p><p>昨天在遇到最后的更新问题时，在微软的官方论坛上列出的方法有十几种之多，几乎大半要求重启，作为一个普通用户我觉得这种建议是毫无意义的，因为太过于麻烦，可操作性差，全部尝试也不一定能解决问题，原因还是错误原因千奇百怪，根本原因呢？怕还是在Windows自己身上。什么时候Windows对软件的限制多一些，强硬一些，把自家大型软件的耦合性降低一些（比如VS做成插件模式就很好，不会像现在这样臃肿，当然我只是在闲扯），那么Windows的体验还能上升一个台阶。</p><p> </p><p> </p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV图像直方图均衡化处理</title>
      <link href="/2014/11/08/pythonopencv%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96%E5%A4%84%E7%90%86/"/>
      <url>/2014/11/08/pythonopencv%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">u"图片为同目录下的test.jpg，先显示原图的灰度直方图，关闭后显示变换后的直方图，再关闭显示变换后的图片"</span>.encode(<span class="string">"gbk"</span>)</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'test.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">rows,cols = img.shape</span><br><span class="line"></span><br><span class="line">grey_img = numpy.zeros((<span class="number">256</span>,<span class="number">256</span>),numpy.uint8)</span><br><span class="line"></span><br><span class="line">hist= cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0.0</span>,<span class="number">255.0</span>])</span><br><span class="line">minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(hist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    intensity = int(hist[h]*<span class="number">256</span>/maxVal)</span><br><span class="line">    cv2.line(grey_img,(h,<span class="number">256</span>), (h,<span class="number">256</span>-intensity),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">u"原灰度图"</span>.encode(<span class="string">'gbk'</span>), grey_img)</span><br><span class="line">cv2.waitKey (<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">grey_img_arr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> hist:</span><br><span class="line">    grey_img_arr.append(int(i[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">grey_img_arr_2 = [grey_img_arr[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">grey_img_arr_3 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    grey_img_arr_2.append(grey_img_arr_2[i<span class="number">-1</span>] + grey_img_arr[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> grey_img_arr_2:</span><br><span class="line">    a = (i/<span class="number">921600.0</span>)/(<span class="number">1.0</span>/<span class="number">255.0</span>)</span><br><span class="line">    <span class="keyword">if</span> a-int(a) &gt; <span class="number">0.5</span>:</span><br><span class="line">        grey_img_arr_3.append(int(a)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        grey_img_arr_3.append(int(a))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grey_img_arr_2)):</span><br><span class="line">    grey_img_arr_2[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        img[i,j] = grey_img_arr_3[img[i,j]]</span><br><span class="line"></span><br><span class="line">hist= cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0.0</span>,<span class="number">255.0</span>])</span><br><span class="line">minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(hist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    intensity = int(hist[h]*<span class="number">256</span>/maxVal)</span><br><span class="line">    cv2.line(grey_img,(h,<span class="number">256</span>), (h,<span class="number">256</span>-intensity),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">u"变换过的直方图图"</span>.encode(<span class="string">'gbk'</span>),grey_img)</span><br><span class="line">cv2.waitKey (<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">u"变换过的图片"</span>.encode(<span class="string">'gbk'</span>),img)</span><br><span class="line">cv2.waitKey (<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]在Linux下用tftp刷写路由器固件</title>
      <link href="/2014/11/03/%E8%BD%AC%E5%9C%A8linux%E4%B8%8B%E7%94%A8tftp%E5%88%B7%E5%86%99%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9B%BA%E4%BB%B6/"/>
      <url>/2014/11/03/%E8%BD%AC%E5%9C%A8linux%E4%B8%8B%E7%94%A8tftp%E5%88%B7%E5%86%99%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9B%BA%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>源地址：http://blog.csdn.net/zyphio/article/details/8555742</p><p>1.在Ubuntu中，保证正常访问互联网软件源的情况下，找到并进入“terminal”（终端）界面；2.输入“sudo apt-get update”按回车，根据提示输入管理员密码，开始更新软件包信息；3.输入“sudo apt-get install tftp”，开始安装tftp软件包；4.用牙签捅住路由器复位按钮10秒（如果固件不支持复位按钮，那这一步无意义）；5.拔掉路由器的电源；6.用网线连接电脑LAN口与路由LAN口（注意不要接成蓝色的WAN口）；7.输入“sudo service network-manager stop”（适用Ubuntu 10.4或以上版本）或“sudo service networking stop”（适用Ubuntu 9.10或以前版本）命令，以关闭系统的网络管理服务；8.输入“ifconfig”查看是哪一个网卡与路由器相连，一般为“eth0”代号的网卡；9.输入“sudo ifconfig eth0 192.168.11.2”，强行设定“eth0”代号的网卡的IP为192.168.11.2（因为Buffalo路由器的bootloader里的默认是IP是192.168.11.1）；10.输入“sudo ifconfig eth0 netmask 255.255.255.0”，设置掩码；11.输入“sudo arp -s 192.168.11.1 XX:XX:XX:XX:XX:XX”，“XX:XX:XX:XX:XX:XX”你Buffalo路由器的MAC地址，MAC地址在Buffalo路由器背面的标签上SSID可查到，可不输入冒号间格。12.输入“tftp”，出现“tftp&gt;”提示符；13.输入“verbose”，出现“Verbose mode on.”提示；15.输入“binary”，出现“mode set to octet.”提示；16.输入“trace”，出现“Packet tracing on.”提示；17.输入“rexmt 1”，每格一秒尝试一次推送；19.输入“timeout 60”，推送尝试的时间不超过60秒；20.输入“connect 192.168.11.1”，连接路由器（实际上并没连接，只是为连接作好准备）；21.输入“put rf.bin”，会提示失败，并每格1秒就尝试一次推送；</p>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>被极路由坑了一下</title>
      <link href="/2014/11/02/%E8%A2%AB%E6%9E%81%E8%B7%AF%E7%94%B1%E5%9D%91%E4%BA%86%E4%B8%80%E4%B8%8B/"/>
      <url>/2014/11/02/%E8%A2%AB%E6%9E%81%E8%B7%AF%E7%94%B1%E5%9D%91%E4%BA%86%E4%B8%80%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p>原来用来搞多拨的hg255d不知是什么原因flash芯片损坏了，总是引发文件系统错误，换了几个固件都是这样，正好这段时间有经费可以报销，就去京东买了一台极路由1S来刷op。</p><p>本来在极路由出来的时候我对它还是很有兴趣的，主要是我校的宽带要使用电信天翼拨号器极其的坑爹，只能改造路由器来使用，或者自己编写算号器。我选择了后一种办法，但是由于需要人工操作总是觉得不方便，于是便想买个能刷openwrt的路由，当时入了hg255d，一直到坏掉。极路由一直给我的印象都是所谓“极客”，我也一直以为它很自由，因为本身系统就是基于openwrt所以应该对op兼容很好，而且标榜“极客”那么也应该鼓励刷机吧。</p><p>尤记得在极路由出来不久，也就是我在准备买路由的时候曾经给极路由官方发过一封邮件询问如何开发的问题，当时的回复是说下一代产品会开放系统。但是我没有想到极路由竟然会走向封闭，在我看来这是自掘坟墓的行为。今天路由到货，开箱后兴冲冲准备刷机，到论坛一看教程，竟然要降级，仔细一看是极路由在新的固件中用u-boot锁死了固件版本，不允许刷其他系统，不过幸好还有降级root方法，用各种办法折腾了一两个小时悲剧的发现网上的所有正常刷机方法全部失效了，上传固件后不会刷机而是直接重启。</p><p>我又去问了客服，结果客服跟我说刷机就会保修失效，拜托我买来就是为了刷机和折腾，你跟我说保修？我就没有打算让你保修好吗，几十块的东西也没那功夫。在网络上看到一个自称内部员工的人说防刷机的理由是有人刷坏了要求保修，如果这么简单就粗暴禁止刷机，那买极路由与其他普通路由有什么区别呢？</p><p>我去看了一下小米路由mini，发现它没有做任何限制，在官方固件中就有ssh开关。相比之下，真的看不出极路由你还有什么优势。智能路由本来这么一个创意极好的产品为什么在生态环境基本没有的情况下还越来越封闭？本来极路由插件就极少，基本没有什么特色，再不给用户自己折腾的权利，我看也走不了多远。</p><p>接下来只能去焊各个ttl线来刷机了。下次换路由之前还是要仔细调查一番。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在指定的 DSN 中，驱动程序和应用程序之间的体系结构不匹配</title>
      <link href="/2014/10/16/%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%9A%84-dsn-%E4%B8%AD%EF%BC%8C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93/"/>
      <url>/2014/10/16/%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%9A%84-dsn-%E4%B8%AD%EF%BC%8C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这个问题是由于PHP版本与DSN结构不匹配，要都选择32位或都是64位。</p>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV图片旋转</title>
      <link href="/2014/10/13/pythonopencv%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC/"/>
      <url>/2014/10/13/pythonopencv%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment">#载入图片</span></span><br><span class="line">img = cv2.imread(<span class="string">'test.jpg'</span>)</span><br><span class="line"><span class="comment">#获取长宽</span></span><br><span class="line">rows,cols,depth = img.shape</span><br><span class="line"><span class="comment">#输入要旋转的角度（逆时针）</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Please input angle to rotate counterclockwise:'</span></span><br><span class="line">degree = raw_input()</span><br><span class="line">degree = float(degree)</span><br><span class="line"><span class="comment">#旋转</span></span><br><span class="line">M = cv2.getRotationMatrix2D((cols/<span class="number">2</span>,rows/<span class="number">2</span>),degree,<span class="number">1</span>)</span><br><span class="line">dst = cv2.warpAffine(img,M,(cols,rows))</span><br><span class="line"><span class="comment">#显示旋转后的图片</span></span><br><span class="line">cv2.namedWindow(<span class="string">"Image"</span>) </span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>, dst) </span><br><span class="line">cv2.waitKey (<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python安装OpenCV过程记录</title>
      <link href="/2014/10/13/python%E5%AE%89%E8%A3%85opencv%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
      <url>/2014/10/13/python%E5%AE%89%E8%A3%85opencv%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>因为课程需要用到OpenCV，又不喜欢用VS来开发，所以就安装Python版本的OpenCV。</p><p>官方安装教程：<a href="http://docs.opencv.org/trunk/doc/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html" target="_blank" rel="noopener" title="http://docs.opencv.org/trunk/doc/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html">http://docs.opencv.org/trunk/doc/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html</a></p><p>OpenCV只支持python2.7版本，不支持3.x。</p><p>1、先到OpenCV项目网站<a href="http://sourceforge.net/projects/opencvlibrary/files/" target="_blank" rel="noopener" title="http://sourceforge.net/projects/opencvlibrary/files/">http://sourceforge.net/projects/opencvlibrary/files/</a>下载安装包，选择Windows平台的exe安装包即可，这是7-zip自解压文件，大小约350M。</p><p>2、下载过程中可以先为Python安装Numpy包和Matplotlib（推荐但不是必须）包。</p><p>Numpy：<a href="http://sourceforge.net/projects/numpy/files/NumPy" target="_blank" rel="noopener" title="http://sourceforge.net/projects/numpy/files/NumPy">http://sourceforge.net/projects/numpy/files/NumPy</a></p><p>Matplotlib：<a href="http://sourceforge.net/projects/matplotlib/files/matplotlib" target="_blank" rel="noopener" title="http://sourceforge.net/projects/matplotlib/files/matplotlib">http://sourceforge.net/projects/matplotlib/files/matplotlib</a></p><p>3、运行OpenCV的安装文件，选择解压目录，解压大小约为3.5G，因此请保证有足够的磁盘空间。</p><p>4、打开解压的目录，进入/build/python/2.7/x86，拷贝cv2.pyd文件到Python安装目录Lib/site-packages目录下。</p><p>5、运行Python交互式界面，输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> cv2</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> cv2.__version__</span><br></pre></td></tr></table></figure><p>测试安装是否成功。</p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
          <category> Python </category>
          
          <category> 备忘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Activity Theme设置</title>
      <link href="/2014/09/27/android-activity-theme%E8%AE%BE%E7%BD%AE/"/>
      <url>/2014/09/27/android-activity-theme%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>安卓新手，在编写layout文件时预览的Activity主题并不是最终生成的样子。要在AndroidManife.xml中设置每个Activity的Theme属性。否则会使用Application中的默认theme。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python ctypes传值的问题</title>
      <link href="/2014/09/13/python-ctypes%E4%BC%A0%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2014/09/13/python-ctypes%E4%BC%A0%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>使用ctypes调用dll时又遇到了一个问题，向ctypes调用的dll中的函数传递一个参数时参数值发送了变化。我是在Django中使用的这个dll，用shell直接使用传值没有任何问题。问题代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构造函数中载入dll并且初始化一个字符串保存路径</span></span><br><span class="line">self.so = ctypes.CDLL(<span class="string">"/home/pi/RaspCloud/bin/librcfile.so"</span>)</span><br><span class="line">self.cur_path = path</span><br><span class="line">......</span><br><span class="line">fun = self.so.list_file</span><br><span class="line">string = ctypes.create_string_buffer(MAXN)</span><br><span class="line">fun(string, self.cur_path)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是到了dll的函数中，路径就变成了&quot;/&quot;，现在还没有搞明白原因，暂时的解决方案如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun = self.so.list_file</span><br><span class="line">string = ctypes.create_string_buffer(MAXN)</span><br><span class="line">path = ctypes.create_string_buffer(MAXN)</span><br><span class="line">path.value = self.cur_path</span><br><span class="line">fun(string, path)</span><br></pre></td></tr></table></figure><p>猜测原因可能是字符串的兼容，但是shell中却没有问题。。。难道是Django的原因吗。。。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctypes多次载入dll</title>
      <link href="/2014/09/12/ctypes%E5%A4%9A%E6%AC%A1%E8%BD%BD%E5%85%A5dll/"/>
      <url>/2014/09/12/ctypes%E5%A4%9A%E6%AC%A1%E8%BD%BD%E5%85%A5dll/</url>
      
        <content type="html"><![CDATA[<p>python中使用ctypes.CDLL可以载入dll文件，今天遇到一个问题就是如果先后载入同一个文件（例如有两个对象），实际上是共享了同一个dll对象。这在dll中存在参数并且两次载入进行了不同的操作时会造成问题。大概我的dll设计的不好，以后还是不要再dll中保存参数或者数据。</p><p>实验：测试dll代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tprint</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=aa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,id)</span>:</span></span><br><span class="line">self.so = ctypes.CDLL(<span class="string">"dll.dll"</span>)</span><br><span class="line">self.id = id</span><br><span class="line"></span><br><span class="line">a = test(<span class="string">'a'</span>)</span><br><span class="line">b = test(<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">a.so.set(<span class="number">1</span>)</span><br><span class="line">b.so.set(<span class="number">2</span>)</span><br><span class="line">aa=a.so.tprint()</span><br><span class="line">bb=b.so.tprint()</span><br><span class="line"><span class="keyword">print</span> a.id+<span class="string">':'</span></span><br><span class="line"><span class="keyword">print</span> aa</span><br><span class="line"><span class="keyword">print</span> b.id+<span class="string">':'</span></span><br><span class="line"><span class="keyword">print</span> bb</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:</span><br><span class="line">2</span><br><span class="line">b:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
