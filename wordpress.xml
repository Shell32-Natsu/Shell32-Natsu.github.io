<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.7.3" created="2017-04-15 02:02" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>Shell32</title>
	<link>http://xiadong.info</link>
	<description>Code/Life</description>
	<pubDate>Sat, 15 Apr 2017 02:02:17 +0000</pubDate>
	<language>en-US</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://xiadong.info</wp:base_site_url>
	<wp:base_blog_url>http://xiadong.info</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[xiadong]]></wp:author_login><wp:author_email><![CDATA[xiadong.main@gmail.com]]></wp:author_email><wp:author_display_name><![CDATA[xiadong]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

	<wp:category>
		<wp:term_id>30</wp:term_id>
		<wp:category_nicename><![CDATA[acg]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[ACG]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>4</wp:term_id>
		<wp:category_nicename><![CDATA[life]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[Life]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>39</wp:term_id>
		<wp:category_nicename><![CDATA[linux]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[Linux]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>7</wp:term_id>
		<wp:category_nicename><![CDATA[study]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[Study]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>8</wp:term_id>
		<wp:category_nicename><![CDATA[web]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[WEB]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>9</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%a4%87%e5%bf%98]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[备忘]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>1</wp:term_id>
		<wp:category_nicename><![CDATA[uncategorized]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[未分类]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>10</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%bd%91%e7%bb%9c]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[网络]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>2</wp:term_id>
		<wp:category_nicename><![CDATA[android]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[Android]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>12</wp:term_id>
		<wp:category_nicename><![CDATA[c]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[C]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>11</wp:term_id>
		<wp:category_nicename><![CDATA[cpp]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[C++]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>52</wp:term_id>
		<wp:category_nicename><![CDATA[docker]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[Docker]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>3</wp:term_id>
		<wp:category_nicename><![CDATA[javascript]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[JavaScript]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>13</wp:term_id>
		<wp:category_nicename><![CDATA[leetcode]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[LeetCode]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>5</wp:term_id>
		<wp:category_nicename><![CDATA[opencv]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[OpenCV]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>6</wp:term_id>
		<wp:category_nicename><![CDATA[python]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[Python]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>14</wp:term_id>
		<wp:category_nicename><![CDATA[stl]]></wp:category_nicename>
		<wp:category_parent><![CDATA[study]]></wp:category_parent>
		<wp:cat_name><![CDATA[STL]]></wp:cat_name>
	</wp:category>
	<wp:tag>
		<wp:term_id>49</wp:term_id>
		<wp:tag_slug><![CDATA[bst]]></wp:tag_slug>
		<wp:tag_name><![CDATA[BST]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>17</wp:term_id>
		<wp:tag_slug><![CDATA[c]]></wp:tag_slug>
		<wp:tag_name><![CDATA[C++]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>51</wp:term_id>
		<wp:tag_slug><![CDATA[kmp]]></wp:tag_slug>
		<wp:tag_name><![CDATA[KMP]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>15</wp:term_id>
		<wp:tag_slug><![CDATA[leetcode]]></wp:tag_slug>
		<wp:tag_name><![CDATA[LeetCode]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>41</wp:term_id>
		<wp:tag_slug><![CDATA[linux]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Linux]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>33</wp:term_id>
		<wp:tag_slug><![CDATA[stl]]></wp:tag_slug>
		<wp:tag_name><![CDATA[STL]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>40</wp:term_id>
		<wp:tag_slug><![CDATA[vim]]></wp:tag_slug>
		<wp:tag_name><![CDATA[VIM]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>24</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2]]></wp:tag_slug>
		<wp:tag_name><![CDATA[二分搜索]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>42</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%ba%8c%e5%8f%89%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[二叉树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>38</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%bd%8d%e8%bf%90%e7%ae%97]]></wp:tag_slug>
		<wp:tag_name><![CDATA[位运算]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>36</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%88%86%e6%b2%bb]]></wp:tag_slug>
		<wp:tag_name><![CDATA[分治]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>48</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%bc%80%e6%a0%91trie]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前缀树(Trie)]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>29</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:tag_slug>
		<wp:tag_name><![CDATA[动态规划]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>27</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8f%8c%e6%8c%87%e9%92%88]]></wp:tag_slug>
		<wp:tag_name><![CDATA[双指针]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>22</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%90%90%e6%a7%bd]]></wp:tag_slug>
		<wp:tag_name><![CDATA[吐槽]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>34</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%93%88%e5%b8%8c%e8%a1%a8]]></wp:tag_slug>
		<wp:tag_name><![CDATA[哈希表]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>28</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%9b%9e%e6%ba%af]]></wp:tag_slug>
		<wp:tag_name><![CDATA[回溯]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>45</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%9b%be]]></wp:tag_slug>
		<wp:tag_name><![CDATA[图]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>35</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%a0%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[堆]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>26</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:tag_slug>
		<wp:tag_name><![CDATA[字符串]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>43</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b7%a5%e5%85%b7]]></wp:tag_slug>
		<wp:tag_name><![CDATA[工具]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>53</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b9%b6%e6%9f%a5%e9%9b%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[并查集]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>23</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%be%ae%e8%bd%af]]></wp:tag_slug>
		<wp:tag_name><![CDATA[微软]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>50</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[拓扑排序]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>20</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8b%ac%e5%8f%b7%e5%8c%b9%e9%85%8d]]></wp:tag_slug>
		<wp:tag_name><![CDATA[括号匹配]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>18</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88]]></wp:tag_slug>
		<wp:tag_name><![CDATA[排列组合]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>46</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8e%92%e5%ba%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[排序]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>21</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:tag_slug>
		<wp:tag_name><![CDATA[搜索]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>31</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%97%a5%e6%9c%ac%e5%8a%a8%e7%94%bb]]></wp:tag_slug>
		<wp:tag_name><![CDATA[日本动画]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>19</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%a0%88]]></wp:tag_slug>
		<wp:tag_name><![CDATA[栈]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>32</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%ac%94%e8%ae%b0]]></wp:tag_slug>
		<wp:tag_name><![CDATA[笔记]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>16</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%ae%97%e6%b3%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[算法]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>47</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%b4%aa%e5%bf%83]]></wp:tag_slug>
		<wp:tag_name><![CDATA[贪心]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>25</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%80%92%e5%bd%92]]></wp:tag_slug>
		<wp:tag_name><![CDATA[递归]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>37</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%93%be%e8%a1%a8]]></wp:tag_slug>
		<wp:tag_name><![CDATA[链表]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>44</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%9a%8f%e6%9c%ba%e6%95%b0]]></wp:tag_slug>
		<wp:tag_name><![CDATA[随机数]]></wp:tag_name>
	</wp:tag>
	<wp:term>
		<wp:term_id><![CDATA[30]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[acg]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[ACG]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[49]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[bst]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[BST]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[17]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[c]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[C++]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[51]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[kmp]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[KMP]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[15]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[leetcode]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[LeetCode]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[4]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[life]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Life]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[39]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linux]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Linux]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[41]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linux]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Linux]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[33]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[stl]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[STL]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[7]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[study]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Study]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[40]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[vim]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[VIM]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[8]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[web]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[WEB]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[24]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[二分搜索]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[42]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%8c%e5%8f%89%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[二叉树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[38]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%bd%8d%e8%bf%90%e7%ae%97]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[位运算]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[36]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%88%86%e6%b2%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[分治]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[48]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%bc%80%e6%a0%91trie]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前缀树(Trie)]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[29]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[27]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8f%8c%e6%8c%87%e9%92%88]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[双指针]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[22]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%90%e6%a7%bd]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[吐槽]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[34]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%93%88%e5%b8%8c%e8%a1%a8]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[哈希表]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[28]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%9b%9e%e6%ba%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[回溯]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[45]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%9b%be]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[图]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[35]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%a0%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[堆]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[9]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%a4%87%e5%bf%98]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[备忘]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[26]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[字符串]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[43]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b7%a5%e5%85%b7]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[工具]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[53]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b6%e6%9f%a5%e9%9b%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[并查集]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[23]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%be%ae%e8%bd%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[微软]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[50]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[拓扑排序]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[20]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8b%ac%e5%8f%b7%e5%8c%b9%e9%85%8d]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[括号匹配]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[18]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[排列组合]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[46]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8e%92%e5%ba%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[排序]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[21]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[搜索]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[31]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%97%a5%e6%9c%ac%e5%8a%a8%e7%94%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[日本动画]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[1]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uncategorized]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[未分类]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[19]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%88]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[栈]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[32]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ac%94%e8%ae%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[笔记]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[16]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[算法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[10]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bd%91%e7%bb%9c]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[网络]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[47]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%b4%aa%e5%bf%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[贪心]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[25]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%80%92%e5%bd%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[递归]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[37]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%93%be%e8%a1%a8]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[链表]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[44]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%9a%8f%e6%9c%ba%e6%95%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[随机数]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[2]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[android]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[Android]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[12]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[c]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[C]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[11]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[cpp]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[C++]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[52]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[docker]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[Docker]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[3]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[javascript]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[JavaScript]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[13]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[leetcode]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[LeetCode]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[5]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[opencv]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[OpenCV]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[6]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[python]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[Python]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[14]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[stl]]></wp:term_slug>
		<wp:term_parent><![CDATA[study]]></wp:term_parent>
		<wp:term_name><![CDATA[STL]]></wp:term_name>
	</wp:term>

	<generator>https://wordpress.org/?v=4.7.3</generator>

<image>
	<url>http://xiadong.info/wp-content/uploads/2014/10/cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-32x32.png</url>
	<title>Shell32</title>
	<link>http://xiadong.info</link>
	<width>32</width>
	<height>32</height>
</image> 
<site xmlns="com-wordpress:feed-additions:1">95830885</site>
	<item>
		<title>cropped-129144-106.jpg</title>
		<link>http://xiadong.info/cropped-129144-106-jpg/</link>
		<pubDate>Mon, 14 Jul 2014 01:25:15 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/cropped-129144-106.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[http://xiadong.info/wordpress/wp-content/uploads/2014/07/cropped-129144-106.jpg]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>6</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 09:25:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 01:25:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[cropped-129144-106-jpg]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/cropped-129144-106.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/cropped-129144-106.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1000;s:6:"height";i:288;s:4:"file";s:30:"2014/07/cropped-129144-106.jpg";s:5:"sizes";a:3:{s:9:"thumbnail";a:4:{s:4:"file";s:30:"cropped-129144-106-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:29:"cropped-129144-106-300x86.jpg";s:5:"width";i:300;s:6:"height";i:86;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:30:"cropped-129144-106-825x288.jpg";s:5:"width";i:825;s:6:"height";i:288;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>PiDay_ROW11974953961_1920x1080</title>
		<link>http://xiadong.info/about/piday_row11974953961_1920x1080/</link>
		<pubDate>Mon, 14 Jul 2014 02:16:20 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/PiDay_ROW11974953961_1920x1080.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>7</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 10:16:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 02:16:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[piday_row11974953961_1920x1080]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>5</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/PiDay_ROW11974953961_1920x1080.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/PiDay_ROW11974953961_1920x1080.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1920;s:6:"height";i:1080;s:4:"file";s:42:"2014/07/PiDay_ROW11974953961_1920x1080.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:42:"PiDay_ROW11974953961_1920x1080-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:42:"PiDay_ROW11974953961_1920x1080-300x169.jpg";s:5:"width";i:300;s:6:"height";i:169;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:43:"PiDay_ROW11974953961_1920x1080-1024x576.jpg";s:5:"width";i:1024;s:6:"height";i:576;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:42:"PiDay_ROW11974953961_1920x1080-825x510.jpg";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>190241-106.jpg</title>
		<link>http://xiadong.info/190241-106-jpg/</link>
		<pubDate>Mon, 14 Jul 2014 11:04:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/190241-106.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[http://xiadong.info/wordpress/wp-content/uploads/2014/07/190241-106.jpg]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>33</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 19:04:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 11:04:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[190241-106-jpg]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/190241-106.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/190241-106.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1366;s:6:"height";i:768;s:4:"file";s:22:"2014/07/190241-106.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:22:"190241-106-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:22:"190241-106-300x169.jpg";s:5:"width";i:300;s:6:"height";i:169;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:23:"190241-106-1024x576.jpg";s:5:"width";i:1024;s:6:"height";i:576;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:22:"190241-106-825x510.jpg";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>126994-106</title>
		<link>http://xiadong.info/126994-106/</link>
		<pubDate>Mon, 14 Jul 2014 11:06:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/126994-106.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>34</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 19:06:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 11:06:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[126994-106]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/126994-106.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/126994-106.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1366;s:6:"height";i:768;s:4:"file";s:22:"2014/07/126994-106.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:22:"126994-106-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:22:"126994-106-300x169.jpg";s:5:"width";i:300;s:6:"height";i:169;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:23:"126994-106-1024x576.jpg";s:5:"width";i:1024;s:6:"height";i:576;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:22:"126994-106-825x510.jpg";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>112</title>
		<link>http://xiadong.info/112/</link>
		<pubDate>Mon, 14 Jul 2014 11:08:05 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/112.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>35</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 19:08:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 11:08:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[112]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/112.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/112.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1872;s:6:"height";i:1847;s:4:"file";s:15:"2014/07/112.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:15:"112-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:15:"112-300x296.jpg";s:5:"width";i:300;s:6:"height";i:296;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:17:"112-1024x1010.jpg";s:5:"width";i:1024;s:6:"height";i:1010;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:15:"112-825x510.jpg";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>129144-106</title>
		<link>http://xiadong.info/129144-106/</link>
		<pubDate>Mon, 14 Jul 2014 11:08:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/129144-106.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>36</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 19:08:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 11:08:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[129144-106]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/129144-106.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/129144-106.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1366;s:6:"height";i:768;s:4:"file";s:22:"2014/07/129144-106.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:22:"129144-106-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:22:"129144-106-300x169.jpg";s:5:"width";i:300;s:6:"height";i:169;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:23:"129144-106-1024x576.jpg";s:5:"width";i:1024;s:6:"height";i:576;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:22:"129144-106-825x510.jpg";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>129144-106</title>
		<link>http://xiadong.info/129144-106-2/</link>
		<pubDate>Mon, 14 Jul 2014 11:09:07 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/129144-1061.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>37</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 19:09:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 11:09:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[129144-106-2]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/129144-1061.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/129144-1061.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1366;s:6:"height";i:768;s:4:"file";s:23:"2014/07/129144-1061.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:23:"129144-1061-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:23:"129144-1061-300x169.jpg";s:5:"width";i:300;s:6:"height";i:169;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:24:"129144-1061-1024x576.jpg";s:5:"width";i:1024;s:6:"height";i:576;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:23:"129144-1061-825x510.jpg";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>129144-106s</title>
		<link>http://xiadong.info/129144-106s/</link>
		<pubDate>Mon, 14 Jul 2014 11:12:09 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/129144-106s.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>38</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 19:12:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 11:12:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[129144-106s]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/129144-106s.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/129144-106s.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1360;s:6:"height";i:475;s:4:"file";s:23:"2014/07/129144-106s.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:23:"129144-106s-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:23:"129144-106s-300x105.jpg";s:5:"width";i:300;s:6:"height";i:105;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:24:"129144-106s-1024x358.jpg";s:5:"width";i:1024;s:6:"height";i:358;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:23:"129144-106s-825x475.jpg";s:5:"width";i:825;s:6:"height";i:475;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>182471-106</title>
		<link>http://xiadong.info/182471-106/</link>
		<pubDate>Mon, 14 Jul 2014 11:12:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/182471-106.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>39</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 19:12:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 11:12:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[182471-106]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/182471-106.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/182471-106.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1366;s:6:"height";i:768;s:4:"file";s:22:"2014/07/182471-106.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:22:"182471-106-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:22:"182471-106-300x169.jpg";s:5:"width";i:300;s:6:"height";i:169;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:23:"182471-106-1024x576.jpg";s:5:"width";i:1024;s:6:"height";i:576;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:22:"182471-106-825x510.jpg";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>112</title>
		<link>http://xiadong.info/112-2/</link>
		<pubDate>Tue, 15 Jul 2014 11:01:15 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/1121.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>64</wp:post_id>
		<wp:post_date><![CDATA[2014-07-15 19:01:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-15 11:01:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[112-2]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/1121.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/1121.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1872;s:6:"height";i:1847;s:4:"file";s:16:"2014/07/1121.jpg";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:16:"1121-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:16:"1121-300x296.jpg";s:5:"width";i:300;s:6:"height";i:296;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:18:"1121-1024x1010.jpg";s:5:"width";i:1024;s:6:"height";i:1010;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:16:"1121-825x510.jpg";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>该处为本文档的题目</title>
		<link>http://xiadong.info/2014/07/pppoe%e6%b5%81%e7%a8%8b/%e8%af%a5%e5%a4%84%e4%b8%ba%e6%9c%ac%e6%96%87%e6%a1%a3%e7%9a%84%e9%a2%98%e7%9b%ae/</link>
		<pubDate>Mon, 21 Jul 2014 09:22:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/该处为本文档的题目.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>78</wp:post_id>
		<wp:post_date><![CDATA[2014-07-21 17:22:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-21 09:22:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%af%a5%e5%a4%84%e4%b8%ba%e6%9c%ac%e6%96%87%e6%a1%a3%e7%9a%84%e9%a2%98%e7%9b%ae]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>77</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/该处为本文档的题目.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/该处为本文档的题目.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:680;s:6:"height";i:4892;s:4:"file";s:39:"2014/07/该处为本文档的题目.png";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:39:"该处为本文档的题目-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:38:"该处为本文档的题目-42x300.png";s:5:"width";i:42;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}s:5:"large";a:4:{s:4:"file";s:40:"该处为本文档的题目-142x1024.png";s:5:"width";i:142;s:6:"height";i:1024;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:39:"该处为本文档的题目-680x510.png";s:5:"width";i:680;s:6:"height";i:510;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[DHR&amp;Hakugetsu][Hyouka][22][BDrip][1080P][AVC_Hi10P_FLAC_AAC].mkv_20140812_174758.000</title>
		<link>http://xiadong.info/dhrhakugetsuhyouka22bdrip1080pavc_hi10p_flac_aac-mkv_20140812_174758-000/</link>
		<pubDate>Mon, 13 Oct 2014 15:01:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/10/DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>129</wp:post_id>
		<wp:post_date><![CDATA[2014-10-13 23:01:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-13 15:01:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[dhrhakugetsuhyouka22bdrip1080pavc_hi10p_flac_aac-mkv_20140812_174758-000]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/10/DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/10/DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1077;s:6:"height";i:1077;s:4:"file";s:84:"2014/10/DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:84:"DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:84:"DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-300x300.png";s:5:"width";i:300;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}s:5:"large";a:4:{s:4:"file";s:86:"DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-1024x1024.png";s:5:"width";i:1024;s:6:"height";i:1024;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:84:"DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-825x510.png";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>image_thumb.png</title>
		<link>http://xiadong.info/2014/10/iisphp%e5%ae%89%e8%a3%85%e8%ae%b0%e5%bd%95/image_thumb-png/</link>
		<pubDate>Tue, 14 Oct 2014 10:24:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/10/image_thumb.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>135</wp:post_id>
		<wp:post_date><![CDATA[2014-10-14 18:24:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-14 10:24:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[image_thumb-png]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>138</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/10/image_thumb.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/10/image_thumb.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:233;s:6:"height";i:111;s:4:"file";s:23:"2014/10/image_thumb.png";s:5:"sizes";a:1:{s:9:"thumbnail";a:4:{s:4:"file";s:23:"image_thumb-150x111.png";s:5:"width";i:150;s:6:"height";i:111;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>image.png</title>
		<link>http://xiadong.info/2014/10/iisphp%e5%ae%89%e8%a3%85%e8%ae%b0%e5%bd%95/image-png-2/</link>
		<pubDate>Tue, 14 Oct 2014 10:24:53 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/10/image1.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>136</wp:post_id>
		<wp:post_date><![CDATA[2014-10-14 18:24:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-14 10:24:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[image-png-2]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>138</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/10/image1.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/10/image1.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:81;s:6:"height";i:90;s:4:"file";s:18:"2014/10/image1.png";s:5:"sizes";a:0:{}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>博客大图</title>
		<link>http://xiadong.info/%e5%8d%9a%e5%ae%a2%e5%a4%a7%e5%9b%be/</link>
		<pubDate>Sat, 18 Jul 2015 11:01:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2015/07/FireShot-Screen-Capture-011--55aa3227v1_site_icon.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>247</wp:post_id>
		<wp:post_date><![CDATA[2015-07-18 19:01:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-07-18 11:01:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%8d%9a%e5%ae%a2%e5%a4%a7%e5%9b%be]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2015/07/FireShot-Screen-Capture-011--55aa3227v1_site_icon.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2015/07/FireShot-Screen-Capture-011--55aa3227v1_site_icon.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:512;s:6:"height";i:512;s:4:"file";s:61:"2015/07/FireShot-Screen-Capture-011--55aa3227v1_site_icon.png";s:5:"sizes";a:7:{s:9:"thumbnail";a:4:{s:4:"file";s:61:"FireShot-Screen-Capture-011--55aa3227v1_site_icon-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-256";a:4:{s:4:"file";s:61:"FireShot-Screen-Capture-011--55aa3227v1_site_icon-256x256.png";s:5:"width";i:256;s:6:"height";i:256;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-128";a:4:{s:4:"file";s:61:"FireShot-Screen-Capture-011--55aa3227v1_site_icon-128x128.png";s:5:"width";i:128;s:6:"height";i:128;s:9:"mime-type";s:9:"image/png";}s:12:"site_icon-80";a:4:{s:4:"file";s:59:"FireShot-Screen-Capture-011--55aa3227v1_site_icon-80x80.png";s:5:"width";i:80;s:6:"height";i:80;s:9:"mime-type";s:9:"image/png";}s:12:"site_icon-64";a:4:{s:4:"file";s:59:"FireShot-Screen-Capture-011--55aa3227v1_site_icon-64x64.png";s:5:"width";i:64;s:6:"height";i:64;s:9:"mime-type";s:9:"image/png";}s:12:"site_icon-32";a:4:{s:4:"file";s:59:"FireShot-Screen-Capture-011--55aa3227v1_site_icon-32x32.png";s:5:"width";i:32;s:6:"height";i:32;s:9:"mime-type";s:9:"image/png";}s:12:"site_icon-16";a:4:{s:4:"file";s:59:"FireShot-Screen-Capture-011--55aa3227v1_site_icon-16x16.png";s:5:"width";i:16;s:6:"height";i:16;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:11:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png</title>
		<link>http://xiadong.info/cropped-dhrhakugetsuhyouka22bdrip1080pavc_hi10p_flac_aac-mkv_20140812_174758-000-png/</link>
		<pubDate>Wed, 30 Dec 2015 11:14:43 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/10/cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png</guid>
		<description></description>
		<content:encoded><![CDATA[http://xiadong.info/wordpress/wp-content/uploads/2014/10/cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>273</wp:post_id>
		<wp:post_date><![CDATA[2015-12-30 19:14:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-30 11:14:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[cropped-dhrhakugetsuhyouka22bdrip1080pavc_hi10p_flac_aac-mkv_20140812_174758-000-png]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/10/cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/10/cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_context]]></wp:meta_key>
			<wp:meta_value><![CDATA[site-icon]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:512;s:6:"height";i:512;s:4:"file";s:92:"2014/10/cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000.png";s:5:"sizes";a:6:{s:9:"thumbnail";a:4:{s:4:"file";s:92:"cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:92:"cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-300x300.png";s:5:"width";i:300;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-270";a:4:{s:4:"file";s:92:"cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-270x270.png";s:5:"width";i:270;s:6:"height";i:270;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-192";a:4:{s:4:"file";s:92:"cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-192x192.png";s:5:"width";i:192;s:6:"height";i:192;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-180";a:4:{s:4:"file";s:92:"cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-180x180.png";s:5:"width";i:180;s:6:"height";i:180;s:9:"mime-type";s:9:"image/png";}s:12:"site_icon-32";a:4:{s:4:"file";s:90:"cropped-DHRHakugetsuHyouka22BDrip1080PAVC_Hi10P_FLAC_AAC.mkv_20140812_174758.000-32x32.png";s:5:"width";i:32;s:6:"height";i:32;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_custom_header_last_used_me]]></wp:meta_key>
			<wp:meta_value><![CDATA[1451475126]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_is_custom_header]]></wp:meta_key>
			<wp:meta_value><![CDATA[me]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_wp_user_avatar]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>cropped-126994-106.jpg</title>
		<link>http://xiadong.info/cropped-126994-106-jpg/</link>
		<pubDate>Wed, 30 Dec 2015 12:28:16 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/cropped-126994-106.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>275</wp:post_id>
		<wp:post_date><![CDATA[2015-12-30 20:28:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-30 12:28:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[cropped-126994-106-jpg]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/cropped-126994-106.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/cropped-126994-106.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_context]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom-header]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1200;s:6:"height";i:674;s:4:"file";s:30:"2014/07/cropped-126994-106.jpg";s:5:"sizes";a:5:{s:9:"thumbnail";a:4:{s:4:"file";s:30:"cropped-126994-106-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:30:"cropped-126994-106-300x169.jpg";s:5:"width";i:300;s:6:"height";i:169;s:9:"mime-type";s:10:"image/jpeg";}s:12:"medium_large";a:4:{s:4:"file";s:30:"cropped-126994-106-768x431.jpg";s:5:"width";i:768;s:6:"height";i:431;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:31:"cropped-126994-106-1024x575.jpg";s:5:"width";i:1024;s:6:"height";i:575;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:31:"cropped-126994-106-1200x674.jpg";s:5:"width";i:1200;s:6:"height";i:674;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:12:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>cropped-129144-106-1.jpg</title>
		<link>http://xiadong.info/cropped-129144-106-1-jpg/</link>
		<pubDate>Wed, 30 Dec 2015 12:28:40 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/wp-content/uploads/2014/07/cropped-129144-106-1.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>276</wp:post_id>
		<wp:post_date><![CDATA[2015-12-30 20:28:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-30 12:28:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[cropped-129144-106-1-jpg]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://xiadong.info/wp-content/uploads/2014/07/cropped-129144-106-1.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2014/07/cropped-129144-106-1.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_context]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom-header]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1200;s:6:"height";i:280;s:4:"file";s:32:"2014/07/cropped-129144-106-1.jpg";s:5:"sizes";a:5:{s:9:"thumbnail";a:4:{s:4:"file";s:32:"cropped-129144-106-1-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:31:"cropped-129144-106-1-300x70.jpg";s:5:"width";i:300;s:6:"height";i:70;s:9:"mime-type";s:10:"image/jpeg";}s:12:"medium_large";a:4:{s:4:"file";s:32:"cropped-129144-106-1-768x179.jpg";s:5:"width";i:768;s:6:"height";i:179;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:33:"cropped-129144-106-1-1024x239.jpg";s:5:"width";i:1024;s:6:"height";i:239;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:33:"cropped-129144-106-1-1200x280.jpg";s:5:"width";i:1200;s:6:"height";i:280;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:12:{s:8:"aperture";i:0;s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";i:0;s:9:"copyright";s:0:"";s:12:"focal_length";i:0;s:3:"iso";i:0;s:13:"shutter_speed";i:0;s:5:"title";s:0:"";s:11:"orientation";i:0;s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_custom_header_last_used_twentysixteen]]></wp:meta_key>
			<wp:meta_value><![CDATA[1451478521]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_is_custom_header]]></wp:meta_key>
			<wp:meta_value><![CDATA[twentysixteen]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>amethyst</title>
		<link>http://xiadong.info/2016/12/amethyst/</link>
		<pubDate>Wed, 07 Dec 2016 09:46:30 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/2016/12/amethyst/</guid>
		<description></description>
		<content:encoded><![CDATA[/*
欢迎学习自定义 CSS！

要了解其工作原理，请访问 http://wp.me/PEmnE-Bt
*/]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1011</wp:post_id>
		<wp:post_date><![CDATA[2016-12-07 17:46:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-07 09:46:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[amethyst]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_publicize_pending]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>omega</title>
		<link>http://xiadong.info/2016/12/omega/</link>
		<pubDate>Wed, 07 Dec 2016 09:46:30 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/2016/12/omega/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1018</wp:post_id>
		<wp:post_date><![CDATA[2016-12-07 17:46:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-07 09:46:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[omega]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_publicize_pending]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>About</title>
		<link>http://xiadong.info/about/</link>
		<pubDate>Sun, 13 Jul 2014 17:16:41 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?page_id=2</guid>
		<description></description>
		<content:encoded><![CDATA[向着硅谷努力的学生党, WEB前端, 后端, 操作系统和计算机网络都有兴趣但是都没有深入, 想学许多东西可是总觉得时间不够. 语言熟练度C++ = C &gt; Python &gt; JavaScript = PHP &gt;&gt; Java
平时兴趣有计算机和日本ACG, 重度宅, 萌豚.

现在在苦逼地找暑期实习中……哪位路过的大大能给个机会T_T

E-mail：
<a href="mailto:xiadong.main@gmail.com">xiadong.main@gmail.com</a>
<a href="mailto:dongx@andrew.cmu.edu">dongx@andrew.cmu.edu</a>

Facebook：
<a href="https://www.facebook.com/xiadong1994">https://www.facebook.com/xiadong1994</a>

<!--微信号：

xiadong_1994
<img src="http://7xkh37.com1.z0.glb.clouddn.com/IMG_2914.JPG" />-->

知乎:
<a href="https://www.zhihu.com/people/xia_dong">https://www.zhihu.com/people/xia_dong</a>

Bangumi:
<a href="http://bgm.tv/user/xiadong1994">http://bgm.tv/user/xiadong1994</a>

LinkedIn:
<a href="https://www.linkedin.com/in/dong-xia">https://www.linkedin.com/in/dong-xia</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>5</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 01:16:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-13 17:16:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[about]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106561]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_97bae45fffaef26ccb0060f48824928a]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_4f4fa3a82976e8eeabe3347ec5a3f95e]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>The First</title>
		<link>http://xiadong.info/2014/07/the-first/</link>
		<pubDate>Mon, 14 Jul 2014 03:20:23 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=9</guid>
		<description></description>
		<content:encoded><![CDATA[以前总是看到许多博客，也曾经在博客园，CSDN等注册过。但是总是提不起写东西的兴趣，看到大神写的东西再看看自己写的实在是差距太大。希望这次能坚持一下啦。。。。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>9</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 11:20:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 03:20:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[the-first]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106562]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>情绪“问题”--The Economist Translation</title>
		<link>http://xiadong.info/2014/07/%e6%83%85%e7%bb%aa%e9%97%ae%e9%a2%98-the-economist-translation/</link>
		<pubDate>Mon, 14 Jul 2014 10:49:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=23</guid>
		<description></description>
		<content:encoded><![CDATA[原文链接：<a href="http://www.economist.com/blogs/babbage/2014/06/facebook" target="_blank">http://www.economist.com/blogs/babbage/2014/06/facebook</a>

（post不知如何翻译，“新鲜事”似乎有些不妥，于是写成“消息”）

记者（笔者？？）刚刚看了一下他的Facebook上的新消息，这个社交网站展示着来自用户以及他们的朋友们的新鲜事，视频和图片。有一些在莫斯科渡假的朋友们的漂亮照片，一个前不久在瑞士结婚的朋友的婚礼消息（ wedding news from a friend who had just got hitched in Switzerland），一个朋友的奶奶七十岁生日时的温暖故事，以及一个在亚洲的《经济学人》记者同事讲得关于他津津有味地欣赏一个出租车司机随着车里的迷你卡拉OK机唱歌的故事。唯一有些让人不愉快的是一个朋友因为墨西哥队在世界杯上被荷兰打败而悲痛不已（bemoan）。

跟平常一样，他不会去多想（think twice about）为什么他会看这些充斥着乐观消息的信息杂烩（mix of posts），但是提到Facebook已经通过操控（manipulate）用户看到的信息来测试这样是否可以影响他们的情绪的报道让他想知道自己是不是被有意的玩弄（deliberately toyed with）。

发表在美国国家科学院院刊的一篇论文正使愤怒情绪不断扩大（论文链接<a href="http://www.pnas.org/content/111/24/8788.full" target="_blank">http://www.pnas.org/content/111/24/8788.full</a>）。论文提到一项由Facebook在2012年一月进行的实验，在一周的时间里篡改了近690000位用户看到的消息。研究人员们试图（sought to）证明Facebook的信息是否可以影响用户的精神状态。研究的对象是随机选择的但对此并不知情。

在一周的时间里，所有的好友消息都是真实的，但是一些作为样例的分组看到的主要是积极的，同时另一些看到的主要是消极的。Facebook的软件导致了这些现象。在这个由一位Facebook的数据学家（data scientist）和两位外围研究者进行的实验总共覆盖了包含1.22亿个单词的三百万条消息。

在人工干预消息的这一周结束之后，研究人员发现那些总是看到较多的（preponderance）积极（upbeat）信息的人在接下来的日子里总是发表一些关于他们自己的积极的消息。那些总是受到消极信息的人总是发表一些语气上消沉的消息。研究人员表示这是“（情绪）通过社交网络可以大范围传染（massive-scale contagion）的实验证据”。

身边的朋友可以影响我们的感受很难说是什么爆炸性（earth-shattering）新闻，就算是Facebook隐瞒了它对我们看到的东西做了手脚的事实（包括视频）也不过如此。但是（still）社交网络愿意支持故意操控人们情绪的大范围研究让人深感不安。

首先，它引起了马克·扎克伯格和他的同事们愿意让这种实验进行到什么程度的问题。Facebook现在拥有十亿用户的事实让它处在了一个可以深深影响大量用户的位置。研究论文中说该项试验仅仅对用户的行为有适度的（modest）影响，但也指出如果该实验在2013应用到全部Facebook用户的身上，可能会影响“每天更新的数十万的情感表达”。

这个实验令人担心的另一个原因在于它在当事人不知情的情况下进行。当人们注册Facebook时他们同意了允许公司使用他们的数据进行研究的条款。但是如果特别说明这项研究旨在人工干预他们的感受，大多数人更倾向于会反对。Facebook本可以招募愿意参加实验的用户，但是它没有。

甚至卷入其中的Facebook研究人员也承认（conced）这项研究的余波（fallout）已经变得非常有害。在一则关于这项实验的消息中，Adam Kramer说道

“我能理解为什么很多人对此这么关心，我和我的同事们也对论文描述实验的方法和由此造成的忧虑情绪深感抱歉。现在看来（hindsight），这篇论文的研究价值和它造成的这些忧虑并不配。”

Mr Kramer并不承认这个研究的整个途径是错误的，他只是说论文的描述方法不对，它造成如此激烈的反应（backlash）实在很让人吃惊（startling）。他在这条消息中接着说Facebook还在推动内部审核过程并且从实验实施以来已经取得很大进展（Facebook has since been “working on improving” its internal review practices and that it has “come a long way” since the experiment was conducted）。但他没有说明Facebook现在的政策如何以及它将如何影响一个现在进行类似研究的决定。在社交网络澄清立场（clarifies its stance）之前，关于此事的情绪可能会变得更激烈。

========================

看到这篇文章下面的第一条评论，想到了国内的许多“免费的午餐”
<blockquote><em>If a product or service is ostensibly free, then there's a good chance that _you're_ the product or service....</em></blockquote>
一家企业必然是要以盈利为目的，表面上免费提供的产品和服务必然是在某个方面从用户的身上获得了利益，无论是广告，付费服务还是用户隐私，真正的免费还是不可能的。

开源的精神没有成为主流，这也是主因之一。

原文：
<blockquote><em>YOUR correspondent just took a look at his News Feed on Facebook, where the social network displays news, videos and pictures from users and their friends. There were some beautiful photos posted by pals vacationing in Moscow; wedding news from a friend who had just got hitched in Switzerland; a heartwarming story about a friend’s grandmother’s 70th birthday; and a tale from a fellow Economist journalist in Asia who was having fun listening to a cab driver sing along to a mini karaoke machine he’d installed in his cab. The only negative note was sounded by a friend bemoaning Mexico’s defeat in its World Cup soccer match against Holland.</em>

<em>Normally, he wouldn’t think twice about why he was seeing this particular mix of posts, which was largely full of upbeat news. But reports that Facebook has in the past manipulated what some users have seen in their News Feeds in order to test whether it can influence their emotions has him wondering about whether he is being deliberately toyed with.</em>

<em>The furore has blown up around a paper recently published in the Proceedings of the National Academy of Sciences, which can be found online <a href="http://www.pnas.org/content/111/24/8788.full">here</a>. It reports on an experiment in which Facebook altered the news-feed content that nearly 690,000 users saw during one week in January 2012. Researchers sought to learn whether Facebook feeds influenced the emotional state of users. The test's subjects were chosen at random but were not notified.</em>

<em>During the week in question all of the News Feed posts were genuine, but some in the sample group saw posts that were largely positive, while others saw posts that were largely negative. Facebook software simply influenced what appeared. The experiment, which was conducted by a Facebook data scientist and two outside researchers, covered some 3m posts containing 122m words.</em>

<em>After the week was up and the deliberate manipulation of feeds ended, the researchers found that those who had seen a preponderance of upbeat news over the period were more likely to produce upbeat posts of their own in the days that followed. Those who had been exposed to more negative news tended to produce posts that were more downbeat in tone. According to the researchers, this showed “experimental evidence for massive-scale contagion via social networks”.</em>

<em>The news that friends can influence how we feel is hardly earth-shattering. Nor has Facebook made any secret of the fact that it manipulates what we see in News Feed, including the <a href="http://newsroom.fb.com/news/2014/06/news-feed-fyi-showing-better-videos/">videos</a> that are served up. Still, the news that the social network is willing to support broad-based research that deliberately manipulates people’s emotions is disturbing.</em>

<em>First, it raises questions about just how far Mark Zuckerberg, Facebook’s boss, and his colleagues are willing to let such experiments go. The fact that Facebook now has well over a billion users puts it in a powerful position to influence vast numbers of people. The research paper notes that the experiment only had a modest influence on user behaviour. But it also points out that if had been applied to the entire universe of Facebook users at the start of 2013, the experiment could have influenced “hundreds of thousands of emotion expressions in updates per day”.</em>

<em>Another reason this experiment crossed the creepy line is that it was conducted without the knowledge of users whose feeds were being manipulated. When people sign up to Facebook, they agree to terms of service that specifically allow the company to conduct research using their data without seeking their permission. But most people would probably object if it specifically made clear that part of that research would be aimed at manipulating the way they feel. Facebook could have advertised for users willing to take part in this kind of research, but it chose not to.</em>

<em>Even the Facebook researcher involved has conceded that the fallout from the research has been very damaging. In a <a href="https://www.facebook.com/akramer/posts/10152987150867796">post</a> on Facebook about the experiment, Adam Kramer says:</em>

<em>I can understand why some people have concerns about it, and my co-authors and I are very sorry for the way the paper described the research and any anxiety it caused. In hindsight, the research benefit of the paper may not have justified all this anxiety.</em>

<em>Note that Mr Kramer doesn't admit that the entire approach to the research was wrong-headed. He only says that the way the paper describes it was a mistake, which is rather startling given the <a href="http://www.techzim.co.zw/2014/06/why-the-internet-is-angry-about-an-experiment-facebook-carried-out/">backlash</a> that has occurred. He goes on to say in his post that Facebook has since been “working on improving” its internal review practices and that it has “come a long way” since the experiment was conducted. But he fails to spell out what Facebook’s current policy is and how it would affect a decision to conduct a similar experiment today. Until the social network clarifies its stance, emotions on this issue are likely to run high.</em>

<em>(Photo credit: JOSH EDELSON / AFP)</em></blockquote>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>23</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 18:49:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 10:49:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%83%85%e7%bb%aa%e9%97%ae%e9%a2%98-the-economist-translation]]></wp:post_name>
		<wp:status><![CDATA[private]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106563]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>tablecloth.js--jQuery表格插件</title>
		<link>http://xiadong.info/2014/07/tablecloth-js-jquery%e8%a1%a8%e6%a0%bc%e6%8f%92%e4%bb%b6/</link>
		<pubDate>Tue, 15 Jul 2014 10:28:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=57</guid>
		<description></description>
		<content:encoded><![CDATA[tablecloth.js是一个用来显示表格的jQuery插件.

网址：http://www.tableclothjs.com/

初始化的示例代码：
<pre lang="javascript">// Without any customizations
$("table").tablecloth();

// With customizations
$("table").tablecloth({
  theme: "default",
  bordered: true,
  condensed: true,
  striped: true,
  sortable: true,
  clean: true,
  cleanElements: "th td",
  customClass: "my-table"
});</pre>
tablecloth.js主要有以下选项：
<table width="713" border="3" cellspacing="0" cellpadding="1">
<tbody>
<tr>
<td valign="top" width="98">属性</td>
<td valign="top" width="99">类型</td>
<td valign="top" width="99">默认值</td>
<td valign="top" width="411">描述</td>
</tr>
<tr>
<td valign="top" width="98">theme</td>
<td valign="top" width="99">string</td>
<td valign="top" width="99">‘default’</td>
<td valign="top" width="411">设置主题（default，dark，stats，paper</td>
</tr>
<tr>
<td valign="top" width="98">bordered</td>
<td valign="top" width="99">boolean</td>
<td valign="top" width="99">false</td>
<td valign="top" width="411">添加边框</td>
</tr>
<tr>
<td valign="top" width="98">condensed</td>
<td valign="top" width="99">boolean</td>
<td valign="top" width="99">false</td>
<td valign="top" width="411">边距</td>
</tr>
<tr>
<td valign="top" width="98">striped</td>
<td valign="top" width="99">boolean</td>
<td valign="top" width="99">false</td>
<td valign="top" width="411">设置每行背景，具体依赖于theme</td>
</tr>
<tr>
<td valign="top" width="98">sortable</td>
<td valign="top" width="99">boolean</td>
<td valign="top" width="99">false</td>
<td valign="top" width="411">设置用tablesorter插件进行排序</td>
</tr>
<tr>
<td valign="top" width="98">clean</td>
<td valign="top" width="99">boolean</td>
<td valign="top" width="99">false</td>
<td valign="top" width="411">去除样式</td>
</tr>
<tr>
<td valign="top" width="98">cleanElements</td>
<td valign="top" width="99">string</td>
<td valign="top" width="99">‘*’</td>
<td valign="top" width="411">指定去除子元素的样式，要求clean为true</td>
</tr>
<tr>
<td valign="top" width="98">customClass</td>
<td valign="top" width="99">string</td>
<td valign="top" width="99"></td>
<td valign="top" width="411">给表格添加样式</td>
</tr>
</tbody>
</table>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>57</wp:post_id>
		<wp:post_date><![CDATA[2014-07-15 18:28:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-15 10:28:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[tablecloth-js-jquery%e8%a1%a8%e6%a0%bc%e6%8f%92%e4%bb%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106564]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>WP-Syntx支持的语言</title>
		<link>http://xiadong.info/2014/07/wp-syntx%e6%94%af%e6%8c%81%e7%9a%84%e8%af%ad%e8%a8%80/</link>
		<pubDate>Tue, 15 Jul 2014 10:41:10 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=60</guid>
		<description></description>
		<content:encoded><![CDATA[备忘

'actionscript' =&gt; array('as'),
'ada' =&gt; array('a', 'ada', 'adb', 'ads'),
'apache' =&gt; array('conf'),
'asm' =&gt; array('ash', 'asm', 'inc'),
'asp' =&gt; array('asp'),
'bash' =&gt; array('sh'),
'bf' =&gt; array('bf'),
'c' =&gt; array('c', 'h'),
'c_mac' =&gt; array('c', 'h'),
'caddcl' =&gt; array(),
'cadlisp' =&gt; array(),
'cdfg' =&gt; array('cdfg'),
'cobol' =&gt; array('cbl'),
'cpp' =&gt; array('cpp', 'hpp', 'C', 'H', 'CPP', 'HPP'),
'csharp' =&gt; array('cs'),
'css' =&gt; array('css'),
'd' =&gt; array('d'),
'delphi' =&gt; array('dpk', 'dpr', 'pp', 'pas'),
'diff' =&gt; array('diff', 'patch'),
'dos' =&gt; array('bat', 'cmd'),
'gettext' =&gt; array('po', 'pot'),
'gml' =&gt; array('gml'),
'gnuplot' =&gt; array('plt'),
'groovy' =&gt; array('groovy'),
'haskell' =&gt; array('hs'),
'html4strict' =&gt; array('html', 'htm'),
'ini' =&gt; array('ini', 'desktop'),
'java' =&gt; array('java'),
'javascript' =&gt; array('js'),
'klonec' =&gt; array('kl1'),
'klonecpp' =&gt; array('klx'),
'latex' =&gt; array('tex'),
'lisp' =&gt; array('lisp'),
'lua' =&gt; array('lua'),
'matlab' =&gt; array('m'),
'mpasm' =&gt; array(),
'mysql' =&gt; array('sql'),
'nsis' =&gt; array(),
'objc' =&gt; array(),
'oobas' =&gt; array(),
'oracle8' =&gt; array(),
'oracle10' =&gt; array(),
'pascal' =&gt; array('pas'),
'perl' =&gt; array('pl', 'pm'),
'php' =&gt; array('php', 'php5', 'phtml', 'phps'),
'povray' =&gt; array('pov'),
'providex' =&gt; array('pvc', 'pvx'),
'prolog' =&gt; array('pl'),
'python' =&gt; array('py'),
'qbasic' =&gt; array('bi'),
'reg' =&gt; array('reg'),
'ruby' =&gt; array('rb'),
'sas' =&gt; array('sas'),
'scala' =&gt; array('scala'),
'scheme' =&gt; array('scm'),
'scilab' =&gt; array('sci'),
'smalltalk' =&gt; array('st'),
'smarty' =&gt; array(),
'tcl' =&gt; array('tcl'),
'vb' =&gt; array('bas'),
'vbnet' =&gt; array(),
'visualfoxpro' =&gt; array(),
'whitespace' =&gt; array('ws'),
'xml' =&gt; array('xml', 'svg'),
'z80' =&gt; array('z80', 'asm', 'inc')]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>60</wp:post_id>
		<wp:post_date><![CDATA[2014-07-15 18:41:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-15 10:41:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[wp-syntx%e6%94%af%e6%8c%81%e7%9a%84%e8%af%ad%e8%a8%80]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106565]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>PPPoe流程</title>
		<link>http://xiadong.info/2014/07/pppoe%e6%b5%81%e7%a8%8b/</link>
		<pubDate>Mon, 21 Jul 2014 09:24:44 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=77</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="color: #000000;">PPPoe介绍以及认证流程</span>

<a href="http://xiadong.info/wordpress/wp-content/uploads/2014/07/该处为本文档的题目.png"><img class="alignnone size-full wp-image-78" title="该处为本文档的题目" src="http://xiadong.info/wordpress/wp-content/uploads/2014/07/该处为本文档的题目.png" alt="" width="680" height="4892" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>77</wp:post_id>
		<wp:post_date><![CDATA[2014-07-21 17:24:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-21 09:24:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[pppoe%e6%b5%81%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c"><![CDATA[网络]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106567]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ctypes多次载入dll</title>
		<link>http://xiadong.info/2014/09/ctypes%e5%a4%9a%e6%ac%a1%e8%bd%bd%e5%85%a5dll/</link>
		<pubDate>Fri, 12 Sep 2014 14:58:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=96</guid>
		<description></description>
		<content:encoded><![CDATA[python中使用ctypes.CDLL可以载入dll文件，今天遇到一个问题就是如果先后载入同一个文件（例如有两个对象），实际上是共享了同一个dll对象。这在dll中存在参数并且两次载入进行了不同的操作时会造成问题。大概我的dll设计的不好，以后还是不要再dll中保存参数或者数据。

实验：
测试dll代码：
<pre lang="c">#include 
int a=0;
void add(void)
{
    a=2;
}
int tprint(void)
{
    return a;
}
void set(int aa)
{
    a=aa;
}</pre>
测试python代码：
<pre lang="python">import ctypes

class test:
	def __init__(self,id):
		self.so = ctypes.CDLL("dll.dll")
		self.id = id

a = test('a')
b = test('b')

a.so.set(1)
b.so.set(2)
aa=a.so.tprint()
bb=b.so.tprint()
print a.id+':'
print aa
print b.id+':'
print bb</pre>
输出结果:
<pre lang="c">a:
2
b:
2</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>96</wp:post_id>
		<wp:post_date><![CDATA[2014-09-12 22:58:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-09-12 14:58:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ctypes%e5%a4%9a%e6%ac%a1%e8%bd%bd%e5%85%a5dll]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="python"><![CDATA[Python]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106568]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>python ctypes传值的问题</title>
		<link>http://xiadong.info/2014/09/python-ctypes%e4%bc%a0%e5%80%bc%e7%9a%84%e9%97%ae%e9%a2%98/</link>
		<pubDate>Sat, 13 Sep 2014 02:29:17 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=102</guid>
		<description></description>
		<content:encoded><![CDATA[使用ctypes调用dll时又遇到了一个问题，向ctypes调用的dll中的函数传递一个参数时参数值发送了变化。我是在Django中使用的这个dll，用shell直接使用传值没有任何问题。
问题代码：
<pre lang="python">
#构造函数中载入dll并且初始化一个字符串保存路径
self.so = ctypes.CDLL("/home/pi/RaspCloud/bin/librcfile.so")
self.cur_path = path
......
fun = self.so.list_file
string = ctypes.create_string_buffer(MAXN)
fun(string, self.cur_path)
...
</pre>
但是到了dll的函数中，路径就变成了"/"，现在还没有搞明白原因，暂时的解决方案如下：
<pre lang="python">
fun = self.so.list_file
string = ctypes.create_string_buffer(MAXN)
path = ctypes.create_string_buffer(MAXN)
path.value = self.cur_path
fun(string, path)
</pre>
猜测原因可能是字符串的兼容，但是shell中却没有问题。。。难道是Django的原因吗。。。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>102</wp:post_id>
		<wp:post_date><![CDATA[2014-09-13 10:29:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-09-13 02:29:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[python-ctypes%e4%bc%a0%e5%80%bc%e7%9a%84%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="python"><![CDATA[Python]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106569]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android Activity Theme设置</title>
		<link>http://xiadong.info/2014/09/android-activity-theme%e8%ae%be%e7%bd%ae/</link>
		<pubDate>Sat, 27 Sep 2014 12:46:37 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=108</guid>
		<description></description>
		<content:encoded><![CDATA[安卓新手，在编写layout文件时预览的Activity主题并不是最终生成的样子。要在AndroidManife.xml中设置每个Activity的Theme属性。否则会使用Application中的默认theme。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>108</wp:post_id>
		<wp:post_date><![CDATA[2014-09-27 20:46:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-09-27 12:46:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android-activity-theme%e8%ae%be%e7%bd%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[Android]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106570]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Python安装OpenCV过程记录</title>
		<link>http://xiadong.info/2014/10/python%e5%ae%89%e8%a3%85opencv%e8%bf%87%e7%a8%8b%e8%ae%b0%e5%bd%95/</link>
		<pubDate>Mon, 13 Oct 2014 11:59:45 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=114</guid>
		<description></description>
		<content:encoded><![CDATA[因为课程需要用到OpenCV，又不喜欢用VS来开发，所以就安装Python版本的OpenCV。

官方安装教程：<a title="http://docs.opencv.org/trunk/doc/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html" href="http://docs.opencv.org/trunk/doc/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html">http://docs.opencv.org/trunk/doc/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html</a>

OpenCV只支持python2.7版本，不支持3.x。

1、先到OpenCV项目网站<a title="http://sourceforge.net/projects/opencvlibrary/files/" href="http://sourceforge.net/projects/opencvlibrary/files/">http://sourceforge.net/projects/opencvlibrary/files/</a>下载安装包，选择Windows平台的exe安装包即可，这是7-zip自解压文件，大小约350M。

2、下载过程中可以先为Python安装Numpy包和Matplotlib（推荐但不是必须）包。

Numpy：<a title="http://sourceforge.net/projects/numpy/files/NumPy" href="http://sourceforge.net/projects/numpy/files/NumPy">http://sourceforge.net/projects/numpy/files/NumPy</a>

Matplotlib：<a title="http://sourceforge.net/projects/matplotlib/files/matplotlib" href="http://sourceforge.net/projects/matplotlib/files/matplotlib">http://sourceforge.net/projects/matplotlib/files/matplotlib</a>

3、运行OpenCV的安装文件，选择解压目录，解压大小约为3.5G，因此请保证有足够的磁盘空间。

4、打开解压的目录，进入/build/python/2.7/x86，拷贝cv2.pyd文件到Python安装目录Lib/site-packages目录下。

5、运行Python交互式界面，输入
<pre lang="python">
>>>import cv2
>>>print cv2.__version__
</pre>
测试安装是否成功。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>114</wp:post_id>
		<wp:post_date><![CDATA[2014-10-13 19:59:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-13 11:59:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[python%e5%ae%89%e8%a3%85opencv%e8%bf%87%e7%a8%8b%e8%ae%b0%e5%bd%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="opencv"><![CDATA[OpenCV]]></category>
		<category domain="category" nicename="python"><![CDATA[Python]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106571]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>杂记——我就是要吐槽Windows</title>
		<link>http://xiadong.info/2014/11/178/</link>
		<pubDate>Wed, 19 Nov 2014 04:00:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=178</guid>
		<description></description>
		<content:encoded><![CDATA[这几天微软因为.Net开源的原因又搞出了个“大新闻”，知乎上也是一片喊着Java可以去死了的声音，但是作为一个微软粉转路人，昨天折腾了我一下午的事情简直让我想变成一生黑。<br><br>
事情是这样的：上个周末的时候看着又要告急万里江山一片红的C盘，想着还是去卸载一些东西吧，于是遵从微软的教导，打开控制面板－程序－卸载程序，结果看来看去发现实在没有什么可以卸载的，于是打算拿从来没有用过的SQL Server下手。不要问我为什么装它，装VS的时候貌似是默认的，亦或者我没有把它勾掉。说实话我知道VS是一个优秀的IDE，但是我仍然对它没有什么好感，过于臃肿，要不是课程要用到我才不会装呢。不论如何，我是打算拿SQL Server开刀了，列表中列出了大概六到七个相关的组件，嗯，挨个卸载吧。开头两个点击卸载后提示依赖于另一个程序，要先卸载另一个，好，你说先卸载就先卸载，结果依赖的程序点击卸载后卸载出错，出错就出错吧，也不少见了，但是可气的是只告诉我出错又不告诉我哪里出错，要是移动设备什么的也就算了，告诉用户出错原因用户可能也束手无策。但是作为桌面操作系统，就不能告诉我到底哪里错了吗？这个问题后面再讨论，还是继续我的卸载之旅吧。既然正常的卸载方法卸载不掉，那就只能用非常手段了，于是祭出Installer Clean Up，这是微软官方的用于删除msi安装包的工具，虽然很久没有更新了，但是在删除一些极其顽固的软件的时候还是很有用的（没错，Office，说的就是你）。找到要卸载的软件后点Clean，继续坑爹，删除进程卡住了，这是一个命令行工具，主要是扫描注册表和系统文件再执行删除，但是它运行到一半的时候卡住了。看来这个办法也行不通了，作为一个轻度强迫症患者，我想卸载却无法卸载简直就是折磨，于是一通Google，在微软官网找到了官方卸载修复工具，down下来之后总算是把SQL Server删除了。但是这却引起了更严重的问题，Office 2013每次打开的时候都要进行一次配置，当时我还没有在意，以为是没有重启导致的，结果昨天重启之后还是这个样子，这简直可以把强迫症逼疯好麻！！结果在尝试了修改注册表等方法无果后，还是痛下决心决定重装Office（昨天是要做明天答辩的PPT的，这个时候决定重装需要多大的决心你造吗？）这中间又出了多么坑爹的注册表权限问题我就不提了，安装完Office 2013 SP1后打补丁吧，我不说要打三个G的Office补丁了，但是你有两个跟Office和SQL Server没半毛钱关系的补丁出现未知错误是怎么回事？我已经不想吐槽了，又花了大半个晚上的时间才把这两个补丁装上。<br><br>
微软是一家伟大的公司，它的产品技术也是世界顶级的，但是作为一个长年Windows用户（其实是没钱买不起Mac，呵呵说多了都是泪）实在不觉得Windows是个优秀的产品，它为了兼容性和市场份额而背负了太多的包袱。而且Windows作为一个操作系统本身的复杂程度就已经非常高，谁也不能保证不出问题，但是它总是会出一些莫名奇妙的问题我就无法理解了。如果是第三方软件出问题还可以辩解说是第三方软件的问题，但是微软自家产品出的问题也不少，比如我每次要重装Office的时候都几乎必然会出问题（注册表是重灾区），还经常有上文这样无法卸载的东西，甚至用官方的东西卸载后导致其他部分出问题，一个人生病，全家卧床不起。你可以说我本来就不应该去卸载SQL Server，一个软件连最基本的卸载都搞不定我还怎么对它有好感？<br><br>
大概Windows认为大多数用户无法自己解决问题，所以出错提示都相当简短，最多有个错误号，即使到系统日志里看到了具体的错误一般也是个程序的返回码，比如我最后安装那两个补丁时报的错，还有这周在网络实验室的Server 2008 R2上添加活动区域的时候，都是告诉用户错了，但是具体哪里错了我就是不告诉你，其实系统也不知道到底哪里错了，它只从程序那里得到一个错误码而已。没有很深的专业知识和经验想要查出问题在哪简直是不可能。而且因为Win的开放度和兼容性导致Win的目录结构常常变的极其混乱，这个时候出问题大多数人还是重装了事吧。<br><br>
昨天在遇到最后的更新问题时，在微软的官方论坛上列出的方法有十几种之多，几乎大半要求重启，作为一个普通用户我觉得这种建议是毫无意义的，因为太过于麻烦，可操作性差，全部尝试也不一定能解决问题，原因还是错误原因千奇百怪，根本原因呢？怕还是在Windows自己身上。什么时候Windows对软件的限制多一些，强硬一些，把自家大型软件的耦合性降低一些（比如VS做成插件模式就很好，不会像现在这样臃肿，当然我只是在闲扯），那么Windows的体验还能上升一个台阶。

<div style="clear: both;"></div>

&nbsp;

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>178</wp:post_id>
		<wp:post_date><![CDATA[2014-11-19 12:00:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-19 04:00:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[178]]></wp:post_name>
		<wp:status><![CDATA[private]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106588]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>首页</title>
		<link>http://xiadong.info/?p=324</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=324</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>324</wp:post_id>
		<wp:post_date><![CDATA[2016-06-11 23:37:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[324]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://xiadong.info/]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_orphaned]]></wp:meta_key>
			<wp:meta_value><![CDATA[1465659436]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://xiadong.info/?p=325</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=325</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>325</wp:post_id>
		<wp:post_date><![CDATA[2016-06-11 23:37:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_orphaned]]></wp:meta_key>
			<wp:meta_value><![CDATA[1465659436]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>首页</title>
		<link>http://xiadong.info/?p=326</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=326</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>326</wp:post_id>
		<wp:post_date><![CDATA[2016-06-11 23:43:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[326]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://xiadong.info/]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_orphaned]]></wp:meta_key>
			<wp:meta_value><![CDATA[1465659834]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://xiadong.info/?p=327</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=327</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>327</wp:post_id>
		<wp:post_date><![CDATA[2016-06-11 23:43:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_orphaned]]></wp:meta_key>
			<wp:meta_value><![CDATA[1465659834]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode Notes</title>
		<link>http://xiadong.info/leetcode-notes/</link>
		<pubDate>Wed, 13 Jul 2016 12:30:45 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?page_id=404</guid>
		<description></description>
		<content:encoded><![CDATA[目前为止我已经做了331道LeetCode Algorithms题目(2017年3月27日, 目前题目编号到了546, 包括需要Subscribe的题目……感觉已经追不上进度了T^T), 还剩一些Hard题和收费题目没有做. 现在我在从头开始详细地记录下每一道题的学习笔记, 以方便以后练习.

还有一年时间就要去美国了, 到了美帝基本就要开始找工作了, 但我的水平离FLAG还是不知道差了多少, 还是要加油啊↖(^ω^)↗.

<a href="/category/study/leetcode/">博客文章</a>

<a href="https://github.com/xiadong1994/my_LeetCode">Github地址</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>404</wp:post_id>
		<wp:post_date><![CDATA[2016-07-13 20:30:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-13 12:30:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-notes]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>twentysixteen</title>
		<link>http://xiadong.info/2016/12/twentysixteen/</link>
		<pubDate>Wed, 07 Dec 2016 09:46:30 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/2016/12/twentysixteen/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1020</wp:post_id>
		<wp:post_date><![CDATA[2016-12-07 17:46:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-07 09:46:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[twentysixteen]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_publicize_pending]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ribosome</title>
		<link>http://xiadong.info/2016/12/ribosome/</link>
		<pubDate>Wed, 07 Dec 2016 09:46:30 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/2016/12/ribosome/</guid>
		<description></description>
		<content:encoded><![CDATA[/*
欢迎学习自定义 CSS！

要了解其工作原理，请访问 http://wp.me/PEmnE-Bt
*/
.entry-content code, .comment-content code {
	font-family: Consolas;
	line-height: 1.5;
}

.ir-arriba {
	z-index: 1;
}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1022</wp:post_id>
		<wp:post_date><![CDATA[2016-12-07 17:46:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-07 09:46:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[ribosome]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_publicize_pending]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>tortuga</title>
		<link>http://xiadong.info/2016/12/tortuga/</link>
		<pubDate>Wed, 07 Dec 2016 09:46:30 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/2016/12/tortuga/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1024</wp:post_id>
		<wp:post_date><![CDATA[2016-12-07 17:46:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-07 09:46:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[tortuga]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_publicize_pending]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Python+OpenCV图片旋转</title>
		<link>http://xiadong.info/2014/10/pythonopencv%e5%9b%be%e7%89%87%e6%97%8b%e8%bd%ac/</link>
		<pubDate>Mon, 13 Oct 2014 12:31:07 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=116</guid>
		<description></description>
		<content:encoded><![CDATA[<pre lang="python">import cv2
#载入图片
img = cv2.imread('test.jpg')
#获取长宽
rows,cols,depth = img.shape
#输入要旋转的角度（逆时针）
print 'Please input angle to rotate counterclockwise:'
degree = raw_input()
degree = float(degree)
#旋转
M = cv2.getRotationMatrix2D((cols/2,rows/2),degree,1)
dst = cv2.warpAffine(img,M,(cols,rows))
#显示旋转后的图片
cv2.namedWindow("Image") 
cv2.imshow("Image", dst) 
cv2.waitKey (0)
cv2.destroyAllWindows()</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>116</wp:post_id>
		<wp:post_date><![CDATA[2014-10-13 20:31:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-13 12:31:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[pythonopencv%e5%9b%be%e7%89%87%e6%97%8b%e8%bd%ac]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="opencv"><![CDATA[OpenCV]]></category>
		<category domain="category" nicename="python"><![CDATA[Python]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106572]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>IIS+PHP安装记录</title>
		<link>http://xiadong.info/2014/10/iisphp%e5%ae%89%e8%a3%85%e8%ae%b0%e5%bd%95/</link>
		<pubDate>Tue, 14 Oct 2014 10:24:58 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=138</guid>
		<description></description>
		<content:encoded><![CDATA[在Win7下安装

1、在控制面板程序中选择打开和关闭Windows功能，选择Internet信息服务后点确定。

2、打开<a href="http://www.microsoft.com/web/platform/phponwindows.aspx">http://www.microsoft.com/web/platform/phponwindows.aspx</a>下载安装器，安装完成后再安装PHPManager（安装器中自带PHPManager，不过装了后没有作用，因此我又手动安装了一遍）<a href="http://phpmanager.codeplex.com/">http://phpmanager.codeplex.com/</a>

3、安装完成后在计算机图标上右键，选择“管理”，然后打开服务和应用程序里的IIS管理器

<a href="http://xiadong.info/wordpress/wp-content/uploads/2014/10/image.png"><img style="display: inline; border-width: 0px;" title="image" src="http://xiadong.info/wordpress/wp-content/uploads/2014/10/image_thumb.png" alt="image" width="233" height="111" border="0" /></a> 选择PHPManager<a href="http://xiadong.info/wordpress/wp-content/uploads/2014/10/image1.png"><img style="display: inline; border-width: 0px;" title="image" src="http://xiadong.info/wordpress/wp-content/uploads/2014/10/image_thumb1.png" alt="image" width="85" height="94" border="0" /></a>

4、点击Register New PHP Version，选择C:Program Files (x86)PHPv5.3php-cgi.exe文件。

5、完成。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>138</wp:post_id>
		<wp:post_date><![CDATA[2014-10-14 18:24:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-14 10:24:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[iisphp%e5%ae%89%e8%a3%85%e8%ae%b0%e5%bd%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="web"><![CDATA[WEB]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106573]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>在指定的 DSN 中，驱动程序和应用程序之间的体系结构不匹配</title>
		<link>http://xiadong.info/2014/10/%e5%9c%a8%e6%8c%87%e5%ae%9a%e7%9a%84-dsn-%e4%b8%ad%ef%bc%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f%e5%92%8c%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b9%8b%e9%97%b4%e7%9a%84%e4%bd%93%e7%b3%bb%e7%bb%93/</link>
		<pubDate>Thu, 16 Oct 2014 04:28:56 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=156</guid>
		<description></description>
		<content:encoded><![CDATA[这个问题是由于PHP版本与DSN结构不匹配，要都选择32位或都是64位。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>156</wp:post_id>
		<wp:post_date><![CDATA[2014-10-16 12:28:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-16 04:28:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9c%a8%e6%8c%87%e5%ae%9a%e7%9a%84-dsn-%e4%b8%ad%ef%bc%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f%e5%92%8c%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b9%8b%e9%97%b4%e7%9a%84%e4%bd%93%e7%b3%bb%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106574]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>PHP5.3+IIS7+ACCESS中使用ODBC读取数据库memo类型时非法游标问题</title>
		<link>http://xiadong.info/2014/10/php5-3iis7access%e4%b8%ad%e4%bd%bf%e7%94%a8odbc%e8%af%bb%e5%8f%96%e6%95%b0%e6%8d%ae%e5%ba%93memo%e7%b1%bb%e5%9e%8b%e6%97%b6%e9%9d%9e%e6%b3%95%e6%b8%b8%e6%a0%87%e9%97%ae%e9%a2%98/</link>
		<pubDate>Fri, 17 Oct 2014 13:40:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=158</guid>
		<description></description>
		<content:encoded><![CDATA[PHP5.3+IIS7+ACCESS开发网页时在PHP页面中用ODBC执行select语句时，始终读取不到数据库中memo，也就是长文本的属性。
<pre lang="php">$conn = odbc_connect("DBSTestAccess","","");//连接数据源
if(!$conn)
    {exit("Connection Failed: " . $conn);}
$sql = "select * from books where isbn='$isbn'";
$result=odbc_exec($conn,$sql);</pre>
查看log之后发现是这个问题：[17-Oct-2014 21:07:33 Asia/Brunei] PHP Warning:  odbc_result(): SQL error: [Microsoft][ODBC Microsoft Access 驱动程序]非法的游标位置；未定义键集 , SQL state S1109 in SQLGetData in ...。

一通Google尝试之后终于找到解决办法，在odbc_connect语句最后加上参数SQL_CUR_USE_ODBC就可以了。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>158</wp:post_id>
		<wp:post_date><![CDATA[2014-10-17 21:40:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-17 13:40:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[php5-3iis7access%e4%b8%ad%e4%bd%bf%e7%94%a8odbc%e8%af%bb%e5%8f%96%e6%95%b0%e6%8d%ae%e5%ba%93memo%e7%b1%bb%e5%9e%8b%e6%97%b6%e9%9d%9e%e6%b3%95%e6%b8%b8%e6%a0%87%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="web"><![CDATA[WEB]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106575]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>自动更新Host，可上facebook，twitter</title>
		<link>http://xiadong.info/2014/10/%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0host%ef%bc%8c%e5%8f%af%e4%b8%8afacebook%ef%bc%8ctwitter/</link>
		<pubDate>Tue, 21 Oct 2014 12:31:02 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=162</guid>
		<description></description>
		<content:encoded><![CDATA[没想到改Host的办法还活着，这个程序可以自动的同步Host。

项目主页：<a href="https://code.google.com/p/huhamhire-hosts/">https://code.google.com/p/huhamhire-hosts/</a>

为防止已经被墙，放个百度云的链接：<a href="http://pan.baidu.com/s/1dDGiMR3">http://pan.baidu.com/s/1dDGiMR3</a>，解压密码：fuckgfw]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>162</wp:post_id>
		<wp:post_date><![CDATA[2014-10-21 20:31:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-21 12:31:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0host%ef%bc%8c%e5%8f%af%e4%b8%8afacebook%ef%bc%8ctwitter]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106576]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>被极路由坑了一下</title>
		<link>http://xiadong.info/2014/11/%e8%a2%ab%e6%9e%81%e8%b7%af%e7%94%b1%e5%9d%91%e4%ba%86%e4%b8%80%e4%b8%8b/</link>
		<pubDate>Sun, 02 Nov 2014 14:40:02 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=166</guid>
		<description></description>
		<content:encoded><![CDATA[<html><body>原来用来搞多拨的hg255d不知是什么原因flash芯片损坏了，总是引发文件系统错误，换了几个固件都是这样，正好这段时间有经费可以报销，就去京东买了一台极路由1S来刷op。<br />本来在极路由出来的时候我对它还是很有兴趣的，主要是我校的宽带要使用电信天翼拨号器极其的坑爹，只能改造路由器来使用，或者自己编写算号器。我选择了后一种办法，但是由于需要人工操作总是觉得不方便，于是便想买个能刷openwrt的路由，当时入了hg255d，一直到坏掉。极路由一直给我的印象都是所谓“极客”，我也一直以为它很自由，因为本身系统就是基于openwrt所以应该对op兼容很好，而且标榜“极客”那么也应该鼓励刷机吧。<br />尤记得在极路由出来不久，也就是我在准备买路由的时候曾经给极路由官方发过一封邮件询问如何开发的问题，当时的回复是说下一代产品会开放系统。但是我没有想到极路由竟然会走向封闭，在我看来这是自掘坟墓的行为。今天路由到货，开箱后兴冲冲准备刷机，到论坛一看教程，竟然要降级，仔细一看是极路由在新的固件中用u-boot锁死了固件版本，不允许刷其他系统，不过幸好还有降级root方法，用各种办法折腾了一两个小时悲剧的发现网上的所有正常刷机方法全部失效了，上传固件后不会刷机而是直接重启。<br />我又去问了客服，结果客服跟我说刷机就会保修失效，拜托我买来就是为了刷机和折腾，你跟我说保修？我就没有打算让你保修好吗，几十块的东西也没那功夫。在网络上看到一个自称内部员工的人说防刷机的理由是有人刷坏了要求保修，如果这么简单就粗暴禁止刷机，那买极路由与其他普通路由有什么区别呢？<br />我去看了一下小米路由mini，发现它没有做任何限制，在官方固件中就有ssh开关。相比之下，真的看不出极路由你还有什么优势。智能路由本来这么一个创意极好的产品为什么在生态环境基本没有的情况下还越来越封闭？本来极路由插件就极少，基本没有什么特色，再不给用户自己折腾的权利，我看也走不了多远。<br />接下来只能去焊各个ttl线来刷机了。下次换路由之前还是要仔细调查一番。<div style="clear: both;"></div></body></html>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>166</wp:post_id>
		<wp:post_date><![CDATA[2014-11-02 22:40:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-02 14:40:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%a2%ab%e6%9e%81%e8%b7%af%e7%94%b1%e5%9d%91%e4%ba%86%e4%b8%80%e4%b8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106577]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[转]在Linux下用tftp刷写路由器固件</title>
		<link>http://xiadong.info/2014/11/%e8%bd%ac%e5%9c%a8linux%e4%b8%8b%e7%94%a8tftp%e5%88%b7%e5%86%99%e8%b7%af%e7%94%b1%e5%99%a8%e5%9b%ba%e4%bb%b6/</link>
		<pubDate>Mon, 03 Nov 2014 04:44:55 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=168</guid>
		<description></description>
		<content:encoded><![CDATA[源地址：http://blog.csdn.net/zyphio/article/details/8555742

1.在Ubuntu中，保证正常访问互联网软件源的情况下，找到并进入“terminal”（终端）界面；
2.输入“sudo apt-get update”按回车，根据提示输入管理员密码，开始更新软件包信息；
3.输入“sudo apt-get install tftp”，开始安装tftp软件包；
4.用牙签捅住路由器复位按钮10秒（如果固件不支持复位按钮，那这一步无意义）；
5.拔掉路由器的电源；
6.用网线连接电脑LAN口与路由LAN口（注意不要接成蓝色的WAN口）；
7.输入“sudo service network-manager stop”（适用Ubuntu 10.4或以上版本）或“sudo service networking stop”（适用Ubuntu 9.10或以前版本）命令，以关闭系统的网络管理服务；
8.输入“ifconfig”查看是哪一个网卡与路由器相连，一般为“eth0”代号的网卡；
9.输入“sudo ifconfig eth0 192.168.11.2”，强行设定“eth0”代号的网卡的IP为192.168.11.2（因为Buffalo路由器的bootloader里的默认是IP是192.168.11.1）；
10.输入“sudo ifconfig eth0 netmask 255.255.255.0”，设置掩码；
11.输入“sudo arp -s 192.168.11.1 XX:XX:XX:XX:XX:XX”，“XX:XX:XX:XX:XX:XX”你Buffalo路由器的MAC地址，MAC地址在Buffalo路由器背面的标签上SSID可查到，可不输入冒号间格。
12.输入“tftp”，出现“tftp&gt;”提示符；
13.输入“verbose”，出现“Verbose mode on.”提示；
15.输入“binary”，出现“mode set to octet.”提示；
16.输入“trace”，出现“Packet tracing on.”提示；
17.输入“rexmt 1”，每格一秒尝试一次推送；
19.输入“timeout 60”，推送尝试的时间不超过60秒；
20.输入“connect 192.168.11.1”，连接路由器（实际上并没连接，只是为连接作好准备）；
21.输入“put rf.bin”，会提示失败，并每格1秒就尝试一次推送；]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>168</wp:post_id>
		<wp:post_date><![CDATA[2014-11-03 12:44:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-03 04:44:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%bd%ac%e5%9c%a8linux%e4%b8%8b%e7%94%a8tftp%e5%88%b7%e5%86%99%e8%b7%af%e7%94%b1%e5%99%a8%e5%9b%ba%e4%bb%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106587]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Python+OpenCV图像直方图均衡化处理</title>
		<link>http://xiadong.info/2014/11/pythonopencv%e5%9b%be%e5%83%8f%e7%9b%b4%e6%96%b9%e5%9b%be%e5%9d%87%e8%a1%a1%e5%8c%96%e5%a4%84%e7%90%86/</link>
		<pubDate>Sat, 08 Nov 2014 12:29:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=176</guid>
		<description></description>
		<content:encoded><![CDATA[<pre lang="python">#coding=utf-8
import cv2
import numpy

print u"图片为同目录下的test.jpg，先显示原图的灰度直方图，关闭后显示变换后的直方图，再关闭显示变换后的图片".encode("gbk")

img = cv2.imread('test.jpg',0)
rows,cols = img.shape

grey_img = numpy.zeros((256,256),numpy.uint8)

hist= cv2.calcHist([img], [0], None, [256], [0.0,255.0])
minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(hist)

for h in range(256):
    intensity = int(hist[h]*256/maxVal)
    cv2.line(grey_img,(h,256), (h,256-intensity),(255,255,255))

cv2.imshow(u"原灰度图".encode('gbk'), grey_img)
cv2.waitKey (0)
cv2.destroyAllWindows()

grey_img_arr = []

for i in hist:
    grey_img_arr.append(int(i[0]))

grey_img_arr_2 = [grey_img_arr[0]]

grey_img_arr_3 = []

for i in range(1,256):
    grey_img_arr_2.append(grey_img_arr_2[i-1] + grey_img_arr[i])

for i in grey_img_arr_2:
    a = (i/921600.0)/(1.0/255.0)
    if a-int(a) &gt; 0.5:
        grey_img_arr_3.append(int(a)+1)
    else:
        grey_img_arr_3.append(int(a))

for i in range(len(grey_img_arr_2)):
    grey_img_arr_2[i] = 0

for i in range(rows):
    for j in range(cols):
        img[i,j] = grey_img_arr_3[img[i,j]]

hist= cv2.calcHist([img], [0], None, [256], [0.0,255.0])
minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(hist)

for h in range(256):
    intensity = int(hist[h]*256/maxVal)
    cv2.line(grey_img,(h,256), (h,256-intensity),(255,255,255))

cv2.imshow(u"变换过的直方图图".encode('gbk'),grey_img)
cv2.waitKey (0)
cv2.destroyAllWindows()

cv2.imshow(u"变换过的图片".encode('gbk'),img)
cv2.waitKey (0)
cv2.destroyAllWindows()</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>176</wp:post_id>
		<wp:post_date><![CDATA[2014-11-08 20:29:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-08 12:29:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[pythonopencv%e5%9b%be%e5%83%8f%e7%9b%b4%e6%96%b9%e5%9b%be%e5%9d%87%e8%a1%a1%e5%8c%96%e5%a4%84%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="opencv"><![CDATA[OpenCV]]></category>
		<category domain="category" nicename="python"><![CDATA[Python]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106589]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>JS TTS工具google-tts</title>
		<link>http://xiadong.info/2014/12/js-tts%e5%b7%a5%e5%85%b7google-tts/</link>
		<pubDate>Thu, 18 Dec 2014 09:34:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=190</guid>
		<description></description>
		<content:encoded><![CDATA[因为一个课的大作业要用JS的TTS功能，找了一下发现能用、轻量的库还真不多，

好在Google翻译的接口是公开的，也找到了一个基于这个的封装好的JS插件。

Github:<a href="https://github.com/hiddentao/google-tts" target="_blank">https://github.com/hiddentao/google-tts</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>190</wp:post_id>
		<wp:post_date><![CDATA[2014-12-18 17:34:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-18 09:34:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[js-tts%e5%b7%a5%e5%85%b7google-tts]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="category" nicename="web"><![CDATA[WEB]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106578]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>zip文件名乱码的解决方法</title>
		<link>http://xiadong.info/2014/12/zip%e6%96%87%e4%bb%b6%e5%90%8d%e4%b9%b1%e7%a0%81%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95/</link>
		<pubDate>Fri, 19 Dec 2014 11:58:06 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=193</guid>
		<description></description>
		<content:encoded><![CDATA[在Mac下压缩的ZIP文件在Windows下用WinRAR或者7-ZIP打开都会产生文件名乱码的问题。

网上的办法都是在Mac下从新打包。今天突然找到了一个压缩软件<a href="http://www.bandisoft.com/bandizip/cn/" target="_blank">Bandizip</a>，可以打开Unicode编码的文件名，乱码问题彻底解决。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>193</wp:post_id>
		<wp:post_date><![CDATA[2014-12-19 19:58:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-19 11:58:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[zip%e6%96%87%e4%bb%b6%e5%90%8d%e4%b9%b1%e7%a0%81%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106579]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>year=2015</title>
		<link>http://xiadong.info/2015/01/year2015/</link>
		<pubDate>Thu, 01 Jan 2015 08:38:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=200</guid>
		<description></description>
		<content:encoded><![CDATA[<div>2014又过去了，感觉上很快，但是又好像经历了很多事情。从大二到大三，说不上什么巨大的变化，但是为什么却让我觉得这一年中充斥着许许多多的事情呢？而且很多事情仿佛才过去没有多久而已。<br/><br/></div>
<div><br></div>
<div>年初的时候，那就是大二上的期末考试吧，当时是怎么考的，考了什么竟然印象全无。甚至寒假的时候在家里干了什么也没有印象呢。嗯，只记得大概练了一些题吧，然后就糊里糊涂的来了学校。然后四月份大创立项，不过也是直到暑假之前都没有怎么动手。还有参加蓝桥杯的省赛，拿了一个省一等奖，这也算是我现在为止最高的奖了吧。象ACM那样的团队比赛我似乎总是卡在“没有队友”这一点，是因为不善交际吗。。不过我的身边似乎也没有能和我一起去学习的人。班里的其他几位学霸除了上课也没有什么交集。所以我从上大学开始学习的路上就一直是一个人呢。<br/><br/></div>
<div></div>
<div>五月，我又真正的再次回到孤独一人的状态。很对不起，让你在这一年多的时间里忍受我的愚钝和低情商，现在真的只希望你能快乐的继续走下去。<br/><br/></div>
<div></div>
<div>暑假的前夕，在学校上着小学期的时候竟然入了二次元这个坑。说起来真的是很幸运，否则我真的还找不到什么学习和写程序以外的爱好了。记得以前在知乎看到一个答案，说人需要一种类似“能量”的东西，外向的人通过和他人接触从他人那里获得“能量”；而内向的人却可以自己产生这种“能量”，所以他们没有什么与别人打交道的欲望。对于这个观点我还是比较赞同的，像我这样对于和他人接触没有什么兴趣的人却可以从代码、小说或者动漫中获得满足。不知道喜欢幻想世界的人是不是都有逃避现实的倾向，但是幻想中的美好世界确实比现实中这个更有吸引力。<br/><br/></div>
<div></div>
<div>暑假基本都在学车，真的很坑，每天都相当累，而且科目二训练了接近二十天，从不会到会又到了不会。不过好在科目二通过了，一个月的辛苦没有全白费。暑假里面把自己的大创项目开了个头，这个项目全部都是我自己一个来完成，说实话我对于我校计算机专业的学生的平均水平基本已经不抱什么希望了。<br/><br/></div>
<div></div>
<div>下半年开始的一个月把项目差不多赶完了，虽然还是很粗糙但是总算所有功能都完成了。而且通过这个项目和上个学期研究开发实践的项目我对于WEB开发的流程和基本功能的开发已经比较熟悉了，前端后端都能写，怎么说也是向着所谓“Full Stack”发展吧:-)。<br/><br/></div>
<div></div>
<div>接下来就是日复一日的上课、学习。这学期我倒是把睡眠调整了过来，十一点之后睡觉，八点之前就能起来，算是一个好习惯吧。就这样一直到了期末，让我说这个学期学到了什么呢？嗯貌似除了课堂上学习的网络、数据库、软件工程还真没有学到什么。不过这些课都是程序员的安身立命之本，也不算荒废吧。<br/><br/></div>
<div></div>
<div>2015年又要到了一个人生的十字路口了，工作/保研该怎么选择我还没有下定决心。在我的意识之中现在的IT界对于本科以上学历的高低的区别已经不大了，在校园中学到的东西在工作中能用到多少还是个问题。但是看着互联网尤其是移动互联网的疯狂发展，我总是觉得有点担忧，如果国内的互联网产业真的有泡沫，那么如果一旦破了，普通程序员就是最先遭殃的一部分人。而且看着国内IT业界一片纷纷扰扰的乱象总是不像是有着多模巨大的发展潜力，我只看到了互相倾轧，各种口水战，无下限的营销手段，把普通用户当作待宰的羔羊。我如果明年就结束校园生活，那么这种环境我又能发展的什么地步呢？我真的没有信心。<br/><br/></div>
<div></div>
<div>现在我越来越感到自己相比于其他更优秀的人的差距，要说什么突出的技能，傲人的奖项、出众的科研能力我都没有，我拿什么去竞争呢？前几天看到中山大学超算冬令营的通知，看到要学术讨论，有论文或者科研项目，我深深的觉得我差的还太多，没有怎么接触过科研，也就无从谈起什么科研能力。我现在会的只不过是基础中的基础而已，距离优秀还远得很，而且有那么多比我努力的多的人。<br/><br/></div>
<div></div>
<div>现在的计划大概是先参加保研夏令营，看看能不能拿到名额，如果可以的话就继续读研究生。如果没有理想的大学就还是去找工作吧。上半年的时候尝试一下BAT或者外企的实习。<br/><br/></div>
<div></div>
<div>2014年的末尾时我又一次的感觉到了这个国家的寒意。政府对于“墙”的不断加强已经让我感到前方的黑暗。2014年一系列的打击海外文化的举措，一遍遍的用政治力强行控制人民已经让我彻底的失望了，执政者的想法总是向着更坏的方向发展。希望有朝一日能够走出这堵墙，这是我现在最大的愿望了吧。<br/><br/></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>200</wp:post_id>
		<wp:post_date><![CDATA[2015-01-01 16:38:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-01-01 08:38:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[year2015]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106580]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>计算机网络知识点整理</title>
		<link>http://xiadong.info/2015/01/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86/</link>
		<pubDate>Mon, 12 Jan 2015 00:38:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=213</guid>
		<description></description>
		<content:encoded><![CDATA[我画的一些计算机网络的知识点整理，其中网络层选路算法没有画完，链路层没有= =，教材是《计算机网络：自顶向下方法》

<a href="http://xiadong1994.github.io/static/%E7%AC%AC%E4%B8%80%E7%AB%A0.svg">第一章</a>

<a href="http://xiadong1994.github.io/static/%E5%BA%94%E7%94%A8%E5%B1%82.svg">应用层</a>

<a href="http://xiadong1994.github.io/static/%E8%BF%90%E8%BE%93%E5%B1%82.svg">运输层</a>

<a href="http://xiadong1994.github.io/static/%E7%BD%91%E7%BB%9C%E5%B1%82.svg">网络层</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>213</wp:post_id>
		<wp:post_date><![CDATA[2015-01-12 08:38:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-01-12 00:38:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study"><![CDATA[Study]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106581]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>nginx配置文件</title>
		<link>http://xiadong.info/2015/02/nginx%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6/</link>
		<pubDate>Wed, 04 Feb 2015 05:03:10 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=218</guid>
		<description></description>
		<content:encoded><![CDATA[配置文件位置：/usr/local/nginx/conf/nginx.conf
<pre lang="shell">#运行用户
user nobody;
#启动进程,通常设置成和cpu的数量相等
worker_processes  1;

#全局错误日志及PID文件
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;

#工作模式及连接数上限
events {
    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,
    #仅用于linux2.6以上内核,可以大大提高nginx的性能
    use   epoll; 

    #单个后台worker process进程的最大并发链接数    
    worker_connections  1024;

    # 并发总数是 worker_processes 和 worker_connections 的乘积
    # 即 max_clients = worker_processes * worker_connections
    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么
    # 为什么上面反向代理要除以4，应该说是一个经验值
    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000
    # worker_connections 值的设置跟物理内存大小有关
    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数
    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右
    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：
    # $ cat /proc/sys/fs/file-max
    # 输出 34336
    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内
    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置
    # 使得并发总数小于操作系统可以打开的最大文件数目
    # 其实质也就是根据主机的物理CPU和内存进行配置
    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。
    # ulimit -SHn 65535

}

http {
    #设定mime类型,类型由mime.type文件定义
    include    mime.types;
    default_type  application/octet-stream;
    #设定日志格式
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  logs/access.log  main;

    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，
    #对于普通应用，必须设为 on,
    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，
    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.
    sendfile     on;
    #tcp_nopush     on;

    #连接超时时间
    #keepalive_timeout  0;
    keepalive_timeout  65;
    tcp_nodelay     on;

    #开启gzip压缩
    gzip  on;
    gzip_disable "MSIE [1-6].";

    #设定请求缓冲
    client_header_buffer_size    128k;
    large_client_header_buffers  4 128k;

    #设定虚拟主机配置
    server {
        #侦听80端口
        listen    80;
        #定义使用 www.nginx.cn访问
        server_name  www.nginx.cn;

        #定义服务器的默认网站根目录位置
        root html;

        #设定本虚拟主机的访问日志
        access_log  logs/nginx.access.log  main;

        #默认请求
        location / {

            #定义首页索引文件的名称
            index index.php index.html index.htm;   

        }

        # 定义错误提示页面
        error_page   500 502 503 504 /50x.html;
        location = /50x.html {
        }

        #静态文件，nginx自己处理
        location ~ ^/(images|javascript|js|css|flash|media|static)/ {

            #过期30天，静态文件不怎么更新，过期可以设大一点，
            #如果频繁更新，则可以设置得小一点。
            expires 30d;
        }

        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.
        location ~ .php$ {
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include fastcgi_params;
        }

        #禁止访问 .htxxx 文件
            location ~ /.ht {
            deny all;
        }

    }
}</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>218</wp:post_id>
		<wp:post_date><![CDATA[2015-02-04 13:03:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-02-04 05:03:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[nginx%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="web"><![CDATA[WEB]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106582]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>使用微软的免费Git服务</title>
		<link>http://xiadong.info/2015/03/%e4%bd%bf%e7%94%a8%e5%be%ae%e8%bd%af%e7%9a%84%e5%85%8d%e8%b4%b9git%e6%9c%8d%e5%8a%a1/</link>
		<pubDate>Fri, 13 Mar 2015 13:15:57 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=223</guid>
		<description></description>
		<content:encoded><![CDATA[Github上的软件仓库必须公开，今天找了一下免费的私人Git，找到了bitbucket和Visual Studio Online。权衡了一下还是选择了微软的。<a title="www.visualstudio.com" href="www.visualstudio.com" target="_blank">www.visualstudio.com</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>223</wp:post_id>
		<wp:post_date><![CDATA[2015-03-13 21:15:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-03-13 13:15:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8%e5%be%ae%e8%bd%af%e7%9a%84%e5%85%8d%e8%b4%b9git%e6%9c%8d%e5%8a%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106583]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>购买VPS+shadowsocks搭建</title>
		<link>http://xiadong.info/2015/03/%e8%b4%ad%e4%b9%b0vpsshadowsocks%e6%90%ad%e5%bb%ba/</link>
		<pubDate>Sun, 22 Mar 2015 02:31:56 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=229</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>起因</h1>
今天刷知乎看到一个推荐海外VPS的答案，一年只要4.99美元，虽然性能不强，但是玩玩还是绰绰有余的。

<a href="http://www.zhihu.com/question/28705664" target="_blank">知乎某匿名用户的答案</a>
<h1>购买VPS</h1>
<h2>购买地址</h2>
购买地址:<a href="https://bandwagonhost.com/cart.php" target="_blank">https://bandwagonhost.com/cart.php</a>。其中最便宜的一年只要3.99美元，1.5G硬盘，64M内存，每月100G流量。虽然配置不高，但是价钱确实给力。

<img src="http://pic.yupoo.com/sinaweibo3392572243/Ewir0eId/medish.jpg" alt="页面截图" />

我选的是5.99美刀的。
<h2>付款</h2>
使用PayPal付款，没有的话去注册一个，记住要注册国际版的，否则不能支付美元。绑定银联卡就可以了。
<h2>购买完成</h2>
购买之后会收到邮件，通知预装了CentOS6系统，SSH端口号和IP地址。root密码需要登录网站控制台查看。
<h1>Shadowsocks</h1>
登录VPS后台，在左边栏的最下面有一个Shadowsocks Server，可以自动配置Shadowsocks（只支持CentOS 6，其他系统的就要自己配置了）。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>229</wp:post_id>
		<wp:post_date><![CDATA[2015-03-22 10:31:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-03-22 02:31:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%b4%ad%e4%b9%b0vpsshadowsocks%e6%90%ad%e5%bb%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106584]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>2015腾讯实习笔试+面试+offer</title>
		<link>http://xiadong.info/2015/04/2015%e8%85%be%e8%ae%af%e5%ae%9e%e4%b9%a0%e7%ac%94%e8%af%95%e9%9d%a2%e8%af%95offer/</link>
		<pubDate>Fri, 17 Apr 2015 13:33:27 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://1.shell32.sinaapp.com/?p=234</guid>
		<description></description>
		<content:encoded><![CDATA[本来我是已经决定要保研，但是这个学期还是投了一些实习简历，主要是想看一下我的水平到底如何，顺便也能感受一下找工作的感觉。寒假快要结束的时候给阿里投了内推，在寒假的最后一天接到电面，面试过程相当坑爹，我基本是裸面，结果是毫无悬念的跪了。来到学校之后又尝试着投了腾讯和阿里的正式校招，也参加了微软的在线笔试（到现在都没有动静估计也是没戏了）。上个星期腾讯面试完，今天拿到offer，简单记录一下腾讯实习的面试经历。

<h2>笔试</h2>

笔试在电子科大在郫县的校区进行，人数还是不少了，占用了不少阶梯教室。基本上所有报技术职位的都使用一张笔试试卷，很长的一张，正反一共十面，不过有大概三分之一是各个事业群的介绍。有20（还是25道？）选择题（都是不定项选择题），和四道简答题。总体来说难度不是很小，考察了js，C/C++，计算机网络，数据库，运维和一些概率统计方面的问题。我感觉至少有一半的题目不确定，印象比较深刻的知识点有字节对齐，基类有虚函数的派生类的大小等等。。。记忆已经有些模糊了。大题第一题是存储了很多很多QQ号的vector、set和map其中的两个（= =我已经记不清了），删除其中是奇数的QQ号，写算法。第二题是经典的斐波那契数列问题。第三题和第四题已经忘记了，只记得做了第三题，第四题和第一题一样是空白。

<h2>一面</h2>

笔试似乎刷人不多，跟我一起笔试的同学基本都进入面试了。面试是在成都的明宇尚雅饭店进行，就在锦江边上，4月7号晚上发短信要第二天早上11点面试。

第二天早上先坐67路再转地铁到华西坝站，出地铁站走几百米就到了。到那里发现人还是很多的，大概是一面的人比较多的缘故，还遇到了CJW君去霸面（而且还霸面成功了。。。）。签到之后等了没几分钟就让去楼上面试。面试官是一个瘦瘦的眼镜小哥。主要问的问题有

<ul>
    <li>结构体字节对齐(<a href="http://www.cnblogs.com/clover-toeic/p/3853132.html" target="_blank">C语言字节对齐问题详解</a>)</li>
    <li>要求不对齐有哪些方法</li>
    <li>异构网络中怎么解决不同主机对齐不同的问题（没答出来）</li>
    <li>C可变参数(<a href="http://blog.csdn.net/jackystudio/article/details/17523523" target="_blank">【C++基础之二十】可变参数的函数</a>)</li>
    <li>笛卡尔积（数据库）</li>
    <li>左右连接</li>
    <li>tcp建立拆除(三次和四次握手，这问题几乎是必问，阿里问了，后面的二面也问了)</li>
    <li>md5冲突（md5重复的问题）</li>
    <li>实习地点、时间</li>
    <li>C++只问了会不会没有具体问</li>
</ul>

一共大概二十多分钟就出来了，没有要求写代码。

<h2>还是一面。。。</h2>

我自认为第一次面试回答的还是不错的，只有一个没答出来。可是回学校的时候一查。。。岗位不合适。。。= =#，结合后面的面试经历我猜测面试官一开始就没打算让我进微信事业群（我报的微信事业群后台开发），基本没有问什么有实际意义的东西。

到了晚上十一点多的时候又接到短信，再去初试（一面），看来是换了个部门。第二天下午6点半又到了饭店，这次等待面试的地方人明显少了很多（这个时候一面已经基本结束了）。这次直接到顶楼，面试官年纪比上一个要大一些。上来没有自我介绍，先问我会啥，我说C/C++比较熟，于是就问：“说一说C++的多态吧”。C++这方面的东西还是前几天恶补的，只能硬着头皮扯。扯到了动态绑定、虚函数等等，然后面试官问虚函数的继承是怎么实现的，有什么意义。我只说出来了虚函数表。。。又问为什么基类的析构函数一般都是虚函数，这个我是看过的，可是一下子想不起来。。。这个话题结束了。。。下一个问题是new和malloc的区别，这个我还有点印象；然后问到堆与栈的区别；静态变量存储在哪个区域。这些都答上来了。然后问到从数据库中读取了很多联系人数据，在内存中用什么数据结构来管理，要求搜索，排序，添加删除都比较快，数组添加删除太慢，链表搜索排序慢，最后我也只扯出来了平衡二叉搜索树这种，本来想说B+树可是实在不熟。接下来是三个数据结构题：

<ul>
    <li>两个单向链表可能相交也可能不相交，求相交的节点（暴力遍历不行）</li>
    <li>一个字符串中单词顺序反转（反转两次）</li>
    <li>交换单链表的相邻两个节点（这个要手写代码，前面两个讲思路）</li>
</ul>

这三个题答得都还不错。面试官说可以进入复试，然后我问了一下现在面的是什么部门，结果是SNG（社交网络事业群）的移动客户端。。。就是手机QQ、QQ空间等。然后面试结束，让我明天早上来复试。

<h2>二面</h2>

坐电梯刚到一楼接到面试官的电话，说我现在就可以去二面，于是又坐电梯上去。这次的面试官气场有点强。。。先问了问项目经历、成绩等等。然后开始写代码，先是经典的上台阶问题，然后要求实现strlen，我只考虑了空指针的问题，然后用遍历来求长度，然后面试官问怎么优化。。我是没想出来（回来之后才知道要优化一要分配寄存器，二要考虑字节对齐）；然后是一个很长的字符串，求第一个只出现了一次的字符。接下来问了一个智力题：两个外观大小重量都完全相同的金球和铅球在不破坏它们的情况下怎么区分开。。。我一开始想的是硬度，可是这被认为破坏了，然后是导电性，被说不好操作，其他的我也没想出来。最后问了数据库的问题，谈到了项目中用的框架，于是又聊到了框架对SQL的封装等等。。。最后得到的评价是还不错，但是项目经验太少。

<h2>HR面</h2>

二面之后我基本确定能进HR面了。HR面没有技术问题，问了籍贯、家庭背景、爱好、对成都怎么看、能不能去深圳实习等等问题。HR小哥明显跟前面的技术面试官不一样，也热情的多。

<h2>offer</h2>

一个星期后接到电话说拿到了实习名额，但是啊。。但是，考虑再三还是决定保研为重，学院还要求必须七月去实训，时间也不够还是决定拒掉实习offer了。下个月的阿里面试估计也不会再去了。。。

<h2>总结</h2>

校招时对于本科生的技术要求不是太高，面对面的面试中也不太可能出现复杂的问题，时间上也来不及，所以问的问题多集中在语言的特性（对语言的熟练程度）和数据结构上。还有简历不要乱写，写在上面的每一条都有可能被刨根问底，不是很熟悉的项目还是不要写为妙。我都没有敢说对Python比较熟，因为我只是用它但是却没有极其深入的研究，随随便便就能被问倒。

重点还是在计算机专业的核心科目上：C/C++，计算机网络，数据结构与算法、操作系统和数据库等。

说实话能拿到实习offer还是很幸运的，我的水平还是不够啊。。。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>234</wp:post_id>
		<wp:post_date><![CDATA[2015-04-17 21:33:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-04-17 13:33:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[2015%e8%85%be%e8%ae%af%e5%ae%9e%e4%b9%a0%e7%ac%94%e8%af%95%e9%9d%a2%e8%af%95offer]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106585]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>买了一个东京的VPS</title>
		<link>http://xiadong.info/2015/07/%e4%b9%b0%e4%ba%86%e4%b8%80%e4%b8%aa%e4%b8%9c%e4%ba%ac%e7%9a%84vps/</link>
		<pubDate>Sat, 18 Jul 2015 11:46:17 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/?p=257</guid>
		<description></description>
		<content:encoded><![CDATA[今天买了一个vultr在东京的VPS，搭了SS之后速度真是快，比以前在美国的快多了，下载文件基本可以跑到满速。把wordpress也迁移到了这个VPS上，服务器用的Nginx，折腾了大半天终于搞的差不多了。

图片存储用的七牛，先贴个图试试，图来自秒五

<img class="alignnone" src="http://7xkh37.com1.z0.glb.clouddn.com/%5BKamigami%5D%20Byousoku%205%20Centimeter%20%5BBD%20x264%201920x1080%20AC3(5.%201ch%2Cjp%2Cen%2Crus%2Cita%2Cger)%20Sub(BIG5%2CGB%2Cen%2Cjp%2Cara%2Cger%2Ckor%2Cpor%2Ctha%2Cspa%2Cita%2Cind)%5D.mkv_004631.804.png" alt="" width="1920" height="1080" />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>257</wp:post_id>
		<wp:post_date><![CDATA[2015-07-18 19:46:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-07-18 11:46:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b9%b0%e4%ba%86%e4%b8%80%e4%b8%aa%e4%b8%9c%e4%ba%ac%e7%9a%84vps]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c"><![CDATA[网络]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_eb118051e5b9d0c20374f1dbca86dff4]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1188225723463106586]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_87f1104b70596927fdcf94301c918d0c]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Windows 10 自动锁屏问题解决</title>
		<link>http://xiadong.info/2015/12/windows-10-%e8%87%aa%e5%8a%a8%e9%94%81%e5%b1%8f%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3/</link>
		<pubDate>Wed, 30 Dec 2015 07:15:23 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/?p=269</guid>
		<description></description>
		<content:encoded><![CDATA[<h2 id="问题">问题</h2>

升级到Windows10以后我遇到的各种小毛病不少，比如中文输入法失灵，锁屏无法显示幻灯片还有这次要说的自动锁屏问题。前两个问题基本上都已经解决了，但是这个自动锁屏的问题却还是顽固地出现。

具体的症状表现就是每半小时就会自动锁屏，无论在干什么都是这样。不过幸好这个问题不是一直不停地出现，一般都是在睡眠唤醒之后半小时出现一次，虽然很烦但是对于我这样的懒人还不是无法忍受。可是今天这种情况反复不停出现，每半小时一次，所以我不得不想办法把它彻底解决了。

<h2 id="问题原因"><del>问题原因</del></h2>

<strong>晚上这个问题又出现了，所以这并不是直接原因</strong>

<del>由于是精确的每半小时出现一次，所以我就到事件查看器里看看到底是出了什么状况。很容易就找到了相应的事件：</del> <img src="http://7xkh37.com1.z0.glb.clouddn.com/20151230141322.png" alt="" /> <del>所对应的具体信息为：</del> &gt; <del>应用程序-特定 权限设置并未向在应用程序容器 不可用 SID (不可用)中运行的地址 LocalHost (使用 LRPC) 中的用户 NT AUTHORITYSID (S-1-5-18)授予针对 CLSID 为 {D63B10C5-BB46-4990-A94F-E40B9D520160}、APPID 为 {9CA88EE3-ACB7-47C8-AFC4-AB702511C276}</del>

<h2 id="解决方案"><del>解决方案</del></h2>

<strong>同样这也不是解决方法</strong>

<del>Google之后，根据<a href="http://www.lxway.com/458800126.htm">这篇文章</a>所描述的方法设置了权限之后重启，问题解决。</del>

<h2 id="可能的其他原因">可能的其他原因</h2>

根据MS Community的这篇帖子(<a href="http://answers.microsoft.com/en-us/windows/forum/windows_10-security/windows-10-auto-locks-every-30-minutes-even-when/b53e7ff7-7644-4d51-8038-62f8f2eb9a26" class="uri">http://answers.microsoft.com/en-us/windows/forum/windows_10-security/windows-10-auto-locks-every-30-minutes-even-when/b53e7ff7-7644-4d51-8038-62f8f2eb9a26</a>)，可能的原因是由于锁屏幻灯片导致的，而我的锁屏幻灯片也确实是有问题的，按照帖子的说法把锁屏幻灯片关掉就好，可是我并不想关，所以我先把<strong>设置-&gt;个性化-&gt;锁屏界面-&gt;高级幻灯片放映设置-&gt;自动关闭屏幕</strong>设置为不自动关闭（因为这里原来设置为30分钟，跟锁屏的频率吻合）。接下来就要看看还会不会出现同样的问题了。

<h2 id="目前的结果">目前的结果</h2>

现在已经不会再出现这个问题了。MS的英文论坛无论活跃度还是回复质量都比中文好太多了。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>269</wp:post_id>
		<wp:post_date><![CDATA[2015-12-30 15:15:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-30 07:15:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[windows-10-%e8%87%aa%e5%8a%a8%e9%94%81%e5%b1%8f%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[6233967828005815042]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>C++&amp;Qt操作Word模版基础</title>
		<link>http://xiadong.info/2016/01/cqt%e6%93%8d%e4%bd%9cword%e6%a8%a1%e7%89%88%e5%9f%ba%e7%a1%80/</link>
		<pubDate>Sat, 02 Jan 2016 13:03:40 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/?p=285</guid>
		<description></description>
		<content:encoded><![CDATA[项目中要对Word模版进行操作, 使用C++&amp;Qt进行开发, 将学到的东西记录如下.

<h2 id="参考链接">0 参考链接</h2>

[1]<a class="uri" href="https://en.wikipedia.org/wiki/OLE_Automation">https://en.wikipedia.org/wiki/OLE_Automation</a>

[2]<a class="uri" href="http://www.cgoakley.org/prog/oleaut.html">http://www.cgoakley.org/prog/oleaut.html</a>

[3]<a class="uri" href="https://zh.wikipedia.org/wiki/ActiveX">https://zh.wikipedia.org/wiki/ActiveX</a>

[4]<a class="uri" href="http://www.oschina.net/question/1243014_120926">http://www.oschina.net/question/1243014_120926</a>

[5]<a class="uri" href="http://blog.csdn.net/csxiaoshui/article/details/47333989">http://blog.csdn.net/csxiaoshui/article/details/47333989</a>

<h2 id="基础知识">1 基础知识</h2>

<h3 id="ole-automation">1.1 OLE Automation</h3>

在Windows应用开发中, OLE Automation是一种进程间通信机制. 它基于COM和MFC, 因此在我的项目中并不适用.<a href="https://en.wikipedia.org/wiki/OLE_Automation">[1]</a><a href="http://www.cgoakley.org/prog/oleaut.html">[2]</a>

<blockquote>OLE（Object Linking and Embedding，对象链接与嵌入），是能让应用程序创建包含不同来源的复合文档的一项技术。OLE不仅是桌面应用程序集成，而且还定义和实现了一种允许应用程序作为软件“对象”（数据集合和操作数据的函数）彼此进行“链接”的机制，这种链接机制和协议称为部件对象模型(Component Object Model),简称COM。OLE可以用来创建复合文档，复合文档包含了创建于不同源应用程序，有着不同类型的数据，因此它可以把文字、声音、图像、表格、应用程序等组合在一起。</blockquote>

<h3 id="activex">1.2 ActiveX</h3>

根据Wikipedia<a href="https://zh.wikipedia.org/wiki/ActiveX">[3]</a>, ActiveX的含义是:

<blockquote>ActiveX在广义上是指微软公司的整个COM架构，但是现在通常用来称呼基于标准COM接口来实现对象链接与嵌入（OLE）的ActiveX控件。[1]后者是指从VBX发展而来的，面向微软的Internet Explorer技术而设计的以OCX为扩展名的OLE控件。通过定义容器和组件之间的接口规范，如果编写了一个遵循规范的控件，那么可以很方便地在多种容器中使用而不用修改控件的代码。同样，通过实现标准接口调用，一个遵循规范的容器可以很容易地嵌入任何遵循规范的控件。由于OLE在ActiveX控件中的应用的普及，现在OLE技术中只有少数独立于ActiveX技术，例如复合文档。</blockquote>

<h2 id="qt中的activex5">2 Qt中的ActiveX<a href="http://blog.csdn.net/csxiaoshui/article/details/47333989">[5]</a></h2>

Qt中提供QtActiveX模块来支持ActiveX, 有两种开发方式:

<ol style="list-style-type: decimal;">
    <li>将已有的COM或者ActiveX空间引入到Qt的应用程序中</li>
    <li>将Qt应用程序或者Qt的对象导出成COM对象或者ActiveX控件供他人使用</li>
</ol>

Qt是通过两个模块来支持上述所说的两种方式的:

<ol style="list-style-type: decimal;">
    <li>使用QAxContainer模块, 通过QAxObject和QAxWidget分别支持COM对象和ActiveX控件的开发, 可以通过这两个对象将外部的COM或者ActiveX组件接入到Qt应用程序.</li>
    <li>使用QAxServer模块, 通过QAxAggregated, QAxBindable和QAxFactory类, 通过了进程内和可执行程序exe两种方式的COM Server模式, 用来将Qt写的内容导出为COM或者ActiveX供他人使用.</li>
</ol>

<h2 id="qt中使用activex4">3 Qt中使用ActiveX<a href="http://www.oschina.net/question/1243014_120926">[4]</a></h2>

Qt版本5.4.2, 编译器: MinGW 4.9.1 32-bit.

<h3 id="准备工作">3.1 准备工作</h3>

创建一个Word模版, 插入一个表格和三个书签: pos1, pos2, pos3. 保存为Doc1.dot.

<div class="figure"><img src="https://lh3.googleusercontent.com/-Vh0Ca5Homwc/VofF7M2vCwI/AAAAAAAAD0M/BazOwEELCWwZjizGLApPj9JHnXGzQARrACCo/s800/20160102200655.png" alt="" /></div>

<h3 id="在项目的.pro文件中增加如下一行">3.2 在项目的.pro文件中增加如下一行</h3>

<pre><code>QT   += axcontainer</code></pre>

<h3 id="新建qt项目输入如下代码">3.3 新建Qt项目,输入如下代码:</h3>

<pre lang="cpp"><code>
#include "mainwindow.h"
#include &lt;QApplication&gt;
#include &lt;QAxWidget&gt;
#include &lt;QAxObject&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();

    //新建一个word应用程序
    QAxWidget *word = new QAxWidget("Word.Application", 0, Qt::MSWindowsOwnDC);
    //设置为不可见
    word-&gt;setProperty("Visible", false);
    //获取所有工作文档
    QAxObject *docs = word-&gt;querySubObject("Documents");
    //新建一个文档
    docs-&gt;dynamicCall("Add(QString)", QString::fromLocal8Bit("E:\\Study\\Design\\WordTempTest\\Doc1.dot"));
    //获取激活文档
    QAxObject *activeDoc = word-&gt;querySubObject("ActiveDocument");
    //获取pos1标签
    QAxObject *bookmarkPos1 = activeDoc-&gt;querySubObject("Bookmarks(QVariant)", "pos1");
    //选中并插入字符
    if(!bookmarkPos1-&gt;isNull()){
        bookmarkPos1-&gt;dynamicCall("Select(void)");
        bookmarkPos1-&gt;querySubObject("Range")-&gt;setProperty("Text", "pos1");
    }
    //获取pos2标签
    QAxObject *bookmarkPos2 = activeDoc-&gt;querySubObject("Bookmarks(QVariant)", "pos2");
    //选中并插入字符
    if(!bookmarkPos2-&gt;isNull()){
        bookmarkPos2-&gt;dynamicCall("Select(void)");
        bookmarkPos2-&gt;querySubObject("Range")-&gt;setProperty("Text", "pos2");
    }
    //获取pos3标签
    QAxObject *bookmarkPos3 = activeDoc-&gt;querySubObject("Bookmarks(QVariant)", "pos3");
    //选中并插入字符
    if(!bookmarkPos3-&gt;isNull()){
        bookmarkPos3-&gt;dynamicCall("Select(void)");
        bookmarkPos3-&gt;querySubObject("Range")-&gt;setProperty("Text", "pos3");
    }
    //文档另存为Doc1.doc
    activeDoc-&gt;dynamicCall("SaveAs (const QString&amp;)", QString("E:\\Study\\Design\\WordTempTest\\Doc1.doc"));
    activeDoc-&gt;dynamicCall("Close (boolean)", false);
    word-&gt;dynamicCall("Quit()");

    return a.exec();
}
</code></pre>

<h2 id="运行结果">3.4 运行结果</h2>

程序运行后Doc1.doc文件的内容:

<div class="figure"><img src="https://lh3.googleusercontent.com/-dAT5kINBxfQ/VofF7O-Oo7I/AAAAAAAAA18/iiKZDWcC8wo/s800-Ic42/20160102204208.png" alt="" /></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>285</wp:post_id>
		<wp:post_date><![CDATA[2016-01-02 21:03:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-02 13:03:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[cqt%e6%93%8d%e4%bd%9cword%e6%a8%a1%e7%89%88%e5%9f%ba%e7%a1%80]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cpp"><![CDATA[C++]]></category>
		<category domain="category" nicename="study"><![CDATA[Study]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[6235170953215607553]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Windows平台poppler-qt5预编译库</title>
		<link>http://xiadong.info/2016/03/windows%e5%b9%b3%e5%8f%b0poppler-qt5%e9%a2%84%e7%bc%96%e8%af%91%e5%ba%93/</link>
		<pubDate>Wed, 16 Mar 2016 05:17:17 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/?p=294</guid>
		<description></description>
		<content:encoded><![CDATA[项目中要对PDF文件进行预览, 搜索与Qt搭配的库之后选择poppler库, 官网地址: <a class="uri" href="https://poppler.freedesktop.org/">https://poppler.freedesktop.org/</a>, 没有找到win32平台的二进制文件, 所以只能下载源码自行编译, 由于依赖库众多, 经常报莫名其妙的编译错误, 在耗费了十几个小时后终于编译出了可用的dll文件, 在Qt工程中使用正常. 为了备份和方便后来人, 提供编译好的poppler-qt5的库下载.

<strong>poppler版本:
</strong>
0.41.0

<strong>编译器</strong>

<ul>
    <li>gcc 5.1.0 32-bit</li>
    <li>mingw32-make GNU make 3.82.90</li>
</ul>

<strong>目录结构</strong>

<pre><code>libpoppler.zip
|
|--bin
|   |--freetype6.dll
|   |--jpeg62.dll
|   |--libpoppler.dll
|   |--libpoppler-qt5.dll
|   |--libtiff3.dll
|   |--openjpeg.dll
|   |--pdfinfo.exe
|   |--zlib1.dll
|
|--include
|   |--poppler
|       |--qt5
|           |--poppler-annotation.h
|           |--poppler-export.h
|           |--poppler-form.h
|           |--poppler-link.h
|           |--poppler-media.h
|           |--poppler-optcontent.h
|           |--poppler-page-transition.h
|           |--poppler-qt5.h
|
|--lib
    |--libpoppler.dll.a
    |--libpoppler-qt5.dll.a</code></pre>

<strong>下载地址:</strong>

Google Drive: <a class="uri" href="https://drive.google.com/open?id=0BzmeJgHvo4mIV1V1bW9zd2pRaWs">https://drive.google.com/open?id=0BzmeJgHvo4mIV1V1bW9zd2pRaWs</a>

百度云: <a class="uri" href="http://pan.baidu.com/s/1jHlxTOU">http://pan.baidu.com/s/1jHlxTOU</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>294</wp:post_id>
		<wp:post_date><![CDATA[2016-03-16 13:17:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-03-16 05:17:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[windows%e5%b9%b3%e5%8f%b0poppler-qt5%e9%a2%84%e7%bc%96%e8%af%91%e5%ba%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cpp"><![CDATA[C++]]></category>
		<category domain="category" nicename="study"><![CDATA[Study]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[6262514442542514945]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>8</wp:comment_id>
			<wp:comment_author><![CDATA[alvin]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[393488009@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.33]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-07-22 11:09:11]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-07-22 03:09:11]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[请问是通过cmake生成的吗，为毛生成的多事mingw的而不是msvc的库，o(╯□╰)o]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1469156951.879004;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1469182925.083472;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>9</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-07-22 18:23:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-07-22 10:23:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[是用cmake和mingw生成的, 因为我要用在Qt项目里, 而我是用Qt Creator和GCC来弄的.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>8</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1469183008.8095419;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>在Qt中使用Botan库进行加解密</title>
		<link>http://xiadong.info/2016/04/%e5%9c%a8qt%e4%b8%ad%e4%bd%bf%e7%94%a8botan%e5%ba%93%e8%bf%9b%e8%a1%8c%e5%8a%a0%e8%a7%a3%e5%af%86/</link>
		<pubDate>Thu, 21 Apr 2016 13:27:40 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/wordpress/?p=298</guid>
		<description></description>
		<content:encoded><![CDATA[<h1 id="在qt中使用botan库进行加解密">在Qt中使用Botan库进行加解密</h1>

在毕设项目中需要使用RSA和AES加解密, 因为Qt自带Botan库, 所以使用Botan库来实现. Botan项目网站<a class="uri" href="http://botan.randombit.net">http://botan.randombit.net</a>

<h2 id="在项目中使用">在项目中使用</h2>

因为Qt Creator自带Botan库, 所以很容易就可在Qt项目中使用. 首先到Qt Creator的Github页面<a class="uri" href="https://github.com/qtproject/qt-creator">https://github.com/qtproject/qt-creator</a>, 找到<code>qt-creator/src/libs/3rdparty/botan/</code>目录, 下载其中的文件. 然后在项目的pro文件中使用<code>include(botan/botan.pri)</code>引入Botan的源代码.

<h2 id="rsa加解密">RSA加解密</h2>

引入头文件 #include "botan/botan.h"

生成密钥对

<pre><code>Botan::AutoSeeded_RNG rng;
Botan::RSA_PrivateKey privateKey(rng, 1024);</code></pre>

输出密钥

<pre><code>qDebug() &lt;&lt; Botan::X509::PEM_encode(privateKey).c_str() &lt;&lt; Botan::PKCS8::PEM_encode(privateKey).c_str();</code></pre>

对字符串加密

<pre><code>Botan::PK_Encryptor_EME enc(privateKey, "EME1(SHA-256)");
char msg[] = "Test";
Botan::SecureVector&lt;Botan::byte&gt; en = enc.encrypt(msg, 6, rng);</code></pre>

解密

<pre><code>Botan::PK_Decryptor_EME dec(privateKey, "EME1(SHA-256)");
Botan::SecureVector&lt;Botan::byte&gt; re = dec.decrypt(en);</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>298</wp:post_id>
		<wp:post_date><![CDATA[2016-04-21 21:27:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-04-21 13:27:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9c%a8qt%e4%b8%ad%e4%bd%bf%e7%94%a8botan%e5%ba%93%e8%bf%9b%e8%a1%8c%e5%8a%a0%e8%a7%a3%e5%af%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cpp"><![CDATA[C++]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[duoshuo_thread_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[6276000399195374338]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>川大江安校区宽带破解</title>
		<link>http://xiadong.info/2016/06/%e5%b7%9d%e5%a4%a7%e6%b1%9f%e5%ae%89%e6%a0%a1%e5%8c%ba%e5%ae%bd%e5%b8%a6%e7%a0%b4%e8%a7%a3/</link>
		<pubDate>Fri, 10 Jun 2016 08:31:55 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=305</guid>
		<description></description>
		<content:encoded><![CDATA[<h2 id="前言">0 前言</h2>

四年大学生活马上就要结束了，想一想这四年在江安的生活还真是相当不错的；不过对于我来说，网络大概是江安学习生活中最烦人的东西了。从我2012年入学开始到现在的2016年，川大江安在宿舍所能使用的网络接入方式有三种：校园网、移动CMCC-EDU和电信宽带。其中校园网虽然免费，这四年来雷打不动的512kbps的带宽，基本是处于看图片都是煎熬的水平；CMCC-EDU我基本没用过，速度大概是2-3Mbps左右，可惜无线不稳定；剩下的电信宽带虽然非常贵（一个月79元，带宽6Mbps，但是可以抵扣话费，奈何我不用电信手机），但是矮子里面拔将军，是唯一比较好用的了。

<strong>但是</strong>，这是建立在电信不限制路由器的基础上的。其实在2012年下半年的时候，电信宽带是不限制路由器的，使用普通的pppoe拨号方式就可以上网了。但是这只是电信认证系统的bug而已（还有另一种阴谋论的说法，就不详细说了。另外江安这个认证系统bug极多，后面我会详细说说），2013年上半年的时候修复了，导致路由器失效，接着电信更新了拨号器（就是本文将要破解的），导致飞扬俱乐部的在线算号器失效（方法是粗暴的禁止Linux版拨号器，至今再没有可用的官方Linux拨号器），当时在学生中算是引起了很大的反弹，可是学校方面不知道出于什么原因一直避而不谈这件事<del>（呵呵，这其中必然有肮脏的**交易）</del>，电信抬出什么公安部教育部要求大学生上网一人一号的文件<del>（监控之心不死）</del>来当挡箭牌，这件事后来也不了了之了。但是不能用路由器你让手机iPad怎么上网？许多同学选择通过电脑发射无线信号（其实这也是被拨号器所屏蔽的，不过比较好突破），但是这个方法非常繁琐，要保持电脑一直开机。除了这种方法以外就只能放弃电信宽带了，不过我是一个网速多快都不嫌快，慢一点就无法忍受的人，所以就只能自己动手来破解电信的拨号器了。

<!--在此要特别感谢软件学院的H同学，在我破解的过程中提供了很多帮助。-->

<strong>我的宽带帐号是12年就有的，用户名是学号，跟后来的用户名是手机号的不一样，所以不保证对后来的账号有效。</strong>

完整代码与原版Mac拨号器程序请移步<a href="https://github.com/xiadong1994/SCU_JiangAn_Dialer">Github</a>。

<h2>目录</h2>

<ul>
    <li><a href="#版mac协同拨号器拨号流程">2.21版mac协同拨号器拨号流程</a></li>
    <li><a href="#关于如何破解">关于如何破解</a></li>
    <li><a href="#生成第一次拨号的用户名">生成第一次拨号的用户名</a></li>
    <li><a href="#进行拨号">进行拨号</a></li>
    <li><a href="#获取服务器返回的参数">获取服务器返回的参数</a></li>
    <li><a href="#生成第二次的用户名">生成第二次的用户名</a></li>
    <li><a href="#后记与扯扯淡">后记与扯扯淡</a></li>
</ul>

<h2 id="版mac协同拨号器拨号流程">1 2.21版Mac协同拨号器拨号流程</h2>

我在13年的时候破解的是2.21版的Mac拨号器，Windows版的拨号器的程序逻辑要相对复杂许多，这个版本的算法直到目前（16年6月）都还是可用的。PPPoE的介绍和普通的PPPoE拨号流程可以参考Wikipedia：<a class="uri" href="https://www.wikiwand.com/zh-cn/PPPoE">https://www.wikiwand.com/zh-cn/PPPoE</a>和RFC文档：<a class="uri" href="https://tools.ietf.org/html/rfc2516">https://tools.ietf.org/html/rfc2516</a>。计算机自带的PPPoE拨号器无法连接电信宽带的原因主要出在电信使用一种“二次验证”的机制，即计算机第一次拨号的时候是必然失败的，同时认证服务器返回一个字符串，拨号器根据这个字符串通过算法生成一个新的用户名，再次进行拨号才能成功。其中第一次拨号的用户名也是通过算法生成的，不过与服务器无关。

通过抓包就可以比较直观的看到拨号器拨号的整个流程，我已经很久没有装过协同拨号器了，在这里只贴一下我的路由器模拟的拨号过程。

这是第一次拨号的过程，可以看到CHAP认证失败并且返回16进制字符串：37f13ef44a72。

<pre><code>Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: Plugin rp-pppoe.so loaded.
Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: RP-PPPoE plugin version 3.8p compiled against pppd 2.4.5
Jan  1 00:34:12 PandoraBox daemon.notice pppd[2435]: pppd 2.4.5 started by root, uid 0
Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: PPP session is 30874
Jan  1 00:34:12 PandoraBox daemon.warn pppd[2435]: Connected to 00:25:9e:08:b8:3e via interface eth2.2
Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: Using interface pppoe-wan
Jan  1 00:34:12 PandoraBox daemon.notice pppd[2435]: Connect: pppoe-wan &lt;--&gt; eth2.2
Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: syncppp not active
Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: CHAP authentication failed: 37f13ef44a72
Jan  1 00:34:15 PandoraBox daemon.err pppd[2435]: CHAP authentication failed
Jan  1 00:34:15 PandoraBox daemon.notice pppd[2435]: Connection terminated.
Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: Exit.</code></pre>

这是第二次的拨号流程，可以看到认证成功并分配了IP地址等信息。

<pre><code>Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: Plugin rp-pppoe.so loaded.
Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: RP-PPPoE plugin version 3.8p compiled against pppd 2.4.5
Jan  1 00:34:23 PandoraBox daemon.notice pppd[2447]: pppd 2.4.5 started by root, uid 0
Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: PPP session is 19277
Jan  1 00:34:23 PandoraBox daemon.warn pppd[2447]: Connected to 00:25:9e:08:b8:3e via interface eth2.2
Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: Using interface pppoe-wan
Jan  1 00:34:23 PandoraBox daemon.notice pppd[2447]: Connect: pppoe-wan &lt;--&gt; eth2.2
Jan  1 00:34:26 PandoraBox daemon.info pppd[2447]: syncppp not active
Jan  1 00:34:26 PandoraBox daemon.info pppd[2447]: CHAP authentication succeeded: Authentication success,Welcome!
Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: CHAP authentication succeeded
Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: peer from calling number 00:25:9E:08:B8:3E authorized
Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: local  IP address 220.167.43.208
Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: remote IP address 220.167.40.1
Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: primary   DNS address 61.139.2.69
Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: secondary DNS address 202.98.96.68
Jan  1 00:34:26 PandoraBox daemon.notice netifd: Interface 'wan' is now up</code></pre>

<h2 id="关于如何破解">3 关于如何破解</h2>

主要使用IDA作为反汇编工具，最关键的就是阅读反汇编拨号器出来的汇编代码和IDA生成的反编译代码。编写自己的拨号器的使用的是C语言，当然也可以自由选择其他的语言。使用libpcap在程序内进行抓包。我在破解的最后阶段还用了GDB在命令行模式下直接调试官方拨号器，在没有调试信息的情况下跟踪程序运行真是很酸爽。

这个破解程序是差不多三年前写的了，当时接触编程和C语言不到一年，代码写的很烂，但是因为一直能用就没有再做什么改动了。

<h2 id="生成第一次拨号的用户名">4 生成第一次拨号的用户名</h2>

这个生成第一次拨号用户名的算法是完全模拟的协同拨号器的工作方式。首先获取系统时间，再和一个特殊字符串、用户名、密码拼接成一个新字符串：

<pre lang="c"><code>time1=time(NULL);
sprintf((char*)strTime,"%08x",time1);
sprintf((char*)first,"%s%s%s%s",strTime,"m2o=crE54nyNUht[",username,psw);</code></pre>

对该字符串计算MD5值并转换成16进制表示的字符串：

<pre lang="c"><code>MD5_CTX md5;
MD5Init(&amp;md5);              
MD5Update(&amp;md5,first,strlen((char*)first));
MD5Final(&amp;md5,md5Result);
//把md5转换成字符串
for(int j=0;j&lt;16;j++)
{
    sprintf((char*)pMd5Str,"%02x",md5Result[j]);
    pMd5Str+=2;
}</code></pre>

然后取该字符串的前19个字符，再与其他字符串一起拼接成最终的用户名：

<pre lang="c"><code>char md5Str19[20]={0};
memcpy(md5Str19,md5Str,19);
sprintf((char*)userName,"%s%s%s%s%s",strTime,"M","2021",md5Str19,username);</code></pre>

<h2 id="进行拨号">5 进行拨号</h2>

获得了第一个用户名之后就可以进行拨号了。这个拨号的方法是根据不同的平台而不同，我在Windows和Linux系统（主要是路由器运行的OpenWRT）上都移植过这个程序，可以说唯一需要修改的地方就是这里了。我在这里放一下我在路由器上运行的版本的拨号函数：

<pre lang="c"><code>int PPPoeDial(char *user,char *pwd,char *name,char *device)
{
    char pppoe_cmd[1024];
    char ifname[40]="pppoe-";
    sprintf(pppoe_cmd,"/usr/sbin/pppd nodetach ipparam %s ifname %s nodefaultroute usepeerdns persist maxfail 1 user %s password %s ip-up-script /lib/netifd/ppp-up ipv6-up-script /lib/netifd/ppp-up ip-down-script /lib/netifd/ppp-down ipv6-down-script /lib/netifd/ppp-down mtu 1492 mru 1492 plugin rp-pppoe.so nic-%s &amp;",\
            name,strcat(ifname,name),user,pwd,device);
    system(pppoe_cmd);
    puts("拨号中。。。");
    return 1;
}</code></pre>

这里的pppoe_cmd的内容要根据对应的平台调整。<strong>Windows平台本身就提供了拨号函数，不需要运行pppd之类的命令了。</strong>

<h2 id="获取服务器返回的参数">6 获取服务器返回的参数</h2>

在我的程序中是通过使用libpcap库进行抓包来获取服务器返回的字符串的。libpcap库相关的信息请访问官网<a class="uri" href="http://www.tcpdump.org">http://www.tcpdump.org</a>。对每个数据包的回调函数是这样的：

<pre lang="c"><code>void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{    
    if(valid &amp;&amp; pkt_data[22]==0x04&amp;&amp;pkt_data[23]==0x01)
    {
        pcap_breakloop(adhandle);
        valid = 0;
        char seed[10]={0};
        for(int i=0;i&lt;8;i++)
        {
            sprintf(&amp;seed[i],"%c",pkt_data[30+i]);
        }
        printf("seed:%s\n",seed);
        int time2=((unsigned int)rand())&lt;&lt;16|rand();
        char result[50]={0};
        getSecondUserName(result,seed,g_userName,g_pwd,time1,time2);
        printf("%s\n",result);
        sleep(8);
        PPPoeDial(result,g_pwd,wan,d-&gt;name);
    }
}</code></pre>

其中<code>pkt_data[22]==0x04&amp;&amp;pkt_data[23]==0x01</code>是表示这个数据包是服务器返回的认证失败的数据包，从中取得字符串<code>seed</code>，然后产生一个随机数time2，作为产生第二个用户名的参数。sleep(8)的目的是等待第一次拨号的进程完全退出以免造成冲突。

<h2 id="生成第二次的用户名">7 生成第二次的用户名</h2>

生成第二次用户名的函数比较复杂，具体还是参见代码中的实现吧。主要思路仍然是对字符串进行处理后计算MD5值再进行拼接。

<h2 id="运行平台">8 运行平台</h2>

在破解出这个算法后，我写过Windows和OpenWRT版本的拨号器，我相信大多数同学都是想使用路由器的，使用路由器很简单，只需要一个刷了OpenWRT的路由器就可以了，下载相应的工具链之后进行交叉编译，把得到的可执行文件上传到路由器上，再添加启动脚本就可以实现开机自动连接宽带了。

<h2 id="后记与扯扯淡">9 后记与扯扯淡</h2>

江安校区的电信宽带真的是相当奇葩，贵而难用，而且BUG多多，单单我知道的就有：把用户名最后几位去掉就可以使用无上限的带宽（取决于你寝室的出口物理带宽）；同样是去掉几位就可以进行无限制的多拨（带宽叠加）；绑定的手机号注销之后宽带帐号还在等等。靠着前两个bug我还是享受了将近两年的50M以上宽带的，虽然到现在这些bug已经修复了，但是说不定还是有其他bug，这就交给学弟学妹们来开发啦。

有了OpenWRT路由器之后可玩的东西就变得挺多了，完全可以当一个24h运行小服务器来用。比如以前我还在用多拨叠加宽带的时候因为有一定概率拨号失败（挺低的），所以就写了一个shell脚本，拨号完成后发邮件通知我有没有没连上的连接。或者写一个桥接CMCC信号并且自动登陆的脚本等等。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>305</wp:post_id>
		<wp:post_date><![CDATA[2016-06-10 16:31:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-06-10 08:31:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%b7%9d%e5%a4%a7%e6%b1%9f%e5%ae%89%e6%a0%a1%e5%8c%ba%e5%ae%bd%e5%b8%a6%e7%a0%b4%e8%a7%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="c"><![CDATA[C]]></category>
		<category domain="category" nicename="study"><![CDATA[Study]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c"><![CDATA[网络]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1</wp:comment_id>
			<wp:comment_author><![CDATA[hopper]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[121.48.204.4]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-07-05 16:31:26]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-07-05 08:31:26]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[学长好！<br/>我有个问题：Mac使用拨号器正常连接宽带找不到服务器，这个怎么办呢？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[duoshuo_post_id]]></wp:meta_key>
				<wp:meta_value><![CDATA[6303755654590890753]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong1994]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/1276531933</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[122.194.203.34]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-07-08 16:46:32]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-07-08 08:46:32]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[找不到服务器多半是物理链路的问题]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>1</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[duoshuo_parent_id]]></wp:meta_key>
				<wp:meta_value><![CDATA[6303755654590890753]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[duoshuo_post_id]]></wp:meta_key>
				<wp:meta_value><![CDATA[6304872800670728961]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[hopper]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[hilzeo@163.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.161]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-07-16 17:07:56]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-07-16 09:07:56]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[sad...]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>2</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1468660076.8630979;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1468660112.5812261;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.161]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-07-16 17:09:53]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-07-16 09:09:53]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你先看看校园网能不能连上, 然后你是用Mac还是黑苹果?]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>4</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1468660193.431138;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>14</wp:comment_id>
			<wp:comment_author><![CDATA[CHEN]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2243743569@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.73]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-09 14:56:05]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-09 06:56:05]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[学长，现在很多学校升级到了3.10的协同拨号，还能不能破解造福下其他学校的？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1473404165.795779;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1473404574.4299171;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>15</wp:comment_id>
			<wp:comment_author><![CDATA[CHEN]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2243743569@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.73]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-09 15:00:05]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-09 07:00:05]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[学长能不能研究一下最新的3.1.0版本的算法？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1473404405.386349;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1473404573.020803;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>16</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.33]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-09 15:05:21]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-09 07:05:21]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[首先你要确定别的学校禁用了旧的算法. 而且我早就已经不在川大了, 没时间也没办法测试. 后续的任务真的只能交给后辈们了......]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>15</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1473404721.079329;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[CHEN]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2243743569@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.73]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-09 15:18:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-09 07:18:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[恩好的。您破解mac os的pkg包的时候在哪个平台上搞的？我用windows中的IDA打开，为什么都是二进制。我打开的是最新的2.23版本。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>16</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1473405482.4497199;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>18</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.33]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-09 15:25:19]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-09 07:25:19]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[静态分析的话在哪个平台都可以, 我当时在windows上打开的. 动态跟踪拨号器的运行的话需要mac os.
用IDA打开看到的是反汇编的代码, 要是实在看不懂就找有反编译插件的IDA, 虽然反编译出来的代码也很难看懂.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>17</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1473405919.091203;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>20</wp:comment_id>
			<wp:comment_author><![CDATA[CHEN]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2243743569@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.81]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-12 20:22:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-12 12:22:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[学长，你这个github上的代码有没有windows版本的？希望可以学习一下，openwrt不太会用。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1473682922.2064581;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>21</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.73]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-12 20:24:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-12 12:24:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[windows版本只需要改拨号那个地方就可以了，windows有一个pppoe拨号函数。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>20</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1473683075.6534109;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>29</wp:comment_id>
			<wp:comment_author><![CDATA[HAO]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[325144278@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.9]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-10-09 01:31:50]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-10-08 17:31:50]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[学长你好，我在我的路由器上刷了openwrt的系统，但是你的代码不会用，有一点的嵌入式基础，学长能不能出个步骤教程或者指点一二，谢谢学长]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>16</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1475947910.401572;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1475973082.3438129;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>30</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.65]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-10-09 09:59:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-10-09 01:59:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我的本意不是提供一个拨号器成品, 只是把算法公开而已, 所以不会具体说如何编译安装. 
如果你只是想要编译我的拨号器的话, 你至少需要以下的知识:

<ul>
    <li>Linux操作系统使用</li>
    <li>了解C语言的编译流程</li>
    <li>了解gcc编译器的使用</li>
</ul>

简单地来说, 编译要分以下几步:

<ol>
    <li>下载你的路由器平台的交叉编译器(一般用Google搜索openwrt toolchain+芯片类型可以找到), 如果实在找不到, 那么可以通过Openwrt官网的办法自己编译toolchain.</li>
    <li>下载你的路由器平台的libpcap预编译静态库</li>
    <li>如果找不到libpcap的预编译库, 那么就用第一步的toolchain从libpcap的源码自行编译</li>
    <li>用toolchain编译链接拨号器</li>
</ol>]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>29</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1475978342.0434561;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>34</wp:comment_id>
			<wp:comment_author><![CDATA[star]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[chanxing9@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-11-06 20:01:54]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-11-06 12:01:54]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[兄弟，我也是四川某高校的，我想请教一下你是怎么用gdb动态调试mac版拨号器的呢？我调试的时候遇到多线程，gdb会卡住呢？能否指点一二？如果方便的话，可以邮件交流。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1478433714.0395241;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1478433780.083431;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>35</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.53.25]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-11-06 20:04:58]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-11-06 12:04:58]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我并没有完全地去跟踪整个流程, 而是先从静态汇编写出算法之后用gdb来验证算法是否正确. 很幸运没有差太多.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>34</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1478433898.071784;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>LeetCode 1. Two Sum</title>
		<link>http://xiadong.info/2016/07/1-two-sum/</link>
		<pubDate>Fri, 08 Jul 2016 08:47:22 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=330</guid>
		<description></description>
		<content:encoded><![CDATA[LeetCode的第一题，题目如下：

<blockquote>Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution.

<strong>Example:</strong>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>
</blockquote>

首先是简单粗暴的使用STL Map的方法. 基本思路是把nums中的数据与其下标建立一个映射关系, 这样就可以在logn的时间里通过数值获得它的下标：

<pre lang="C++"><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        map&lt;int, int&gt; a;
        for(int i = 0; i &lt; nums.size(); i++){
            a[nums[i]] = i;
        }
        for(int i = 0; i &lt; nums.size(); i++){
            auto p = a.find(target - nums[i]);
            if(p != a.end() &amp;&amp; p-&gt;second != i){
                vector&lt;int&gt; re = {i, p-&gt;second};
                return re;
            }
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>

以上方法有两个循环, 其中第一个循环遍历了一遍nums,同时对于每个nums中的数据都进行了map的插入/修改操作, 假设nums的数据个数为n, 复杂度约为O(nlogn). 第二个循环中也是遍历了一遍nums, 然后每一遍循环都执行了一次map的find()操作,最好的情况下只需要循环一次,最坏的情况下需要循环n次,因此平均复杂度约为O((n/2)logn), 总的复杂度在O(nlogn)级别.

这段程序运行时间28ms.

但是这个代码使用了STL中的Map容器, 可能有较大的额外开销, 接下来使用排序 + 二分搜索的方法:

<pre lang="C++"><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; re;
        vector&lt;int&gt; oldNums = nums;
        sort(nums.begin(), nums.end());
        for(int i = 0; i &lt; nums.size(); i++){
            int t = target - nums[i];
            if(t &lt; nums.front() || t &gt; nums.back()) continue;
            int j = binSearch(nums, t);
            if(j == -1 || j == i) continue;
            else {
                int num1 = nums[i], num2 = nums[j];
                for(int k = 0; k &lt; oldNums.size(); k++){
                    if(oldNums[k] == num1 || oldNums[k] == num2) re.push_back(k);
                    if(re.size() == 2) break;
                }
                return re;
            }
        }
        return re;
    }

    int binSearch(vector&lt;int&gt; &amp;nums, int t){
        int l = 0, r = nums.size(), m = (l + r) / 2;
        while(l &lt; r){
            if(nums[m] == t) return m;
            else if(nums[m] &gt; t) r = m;
            else l = m + 1;
            m = (l + r) / 2;
        }
        return -1;
    }
};
</code></pre>

第二个方法的运行时间缩短为12ms.

还有另一种更加简洁的双指针方法:

<pre lang="C++"><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; re;
        vector&lt;int&gt; oldNums = nums;
        sort(nums.begin(), nums.end());
        int l = 0, r = nums.size() - 1;
        while(l &lt; r){
            int sum = nums[l] + nums[r];
            if(sum == target){
                for(int i = 0; i &lt; nums.size() &amp;&amp; re.size() &lt; 2; i++){
                    if(oldNums[i] == nums[l] || oldNums[i] == nums[r]) re.push_back(i);
                }
                break;
            }
            else if(sum &gt; target){
                r--;
            }
            else{
                l++;
            }
        }
        return re;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>330</wp:post_id>
		<wp:post_date><![CDATA[2016-07-08 16:47:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-08 08:47:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[1-two-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 2. Add Tow Numbers</title>
		<link>http://xiadong.info/2016/07/leetcode-2-add-tow-numbers/</link>
		<pubDate>Fri, 08 Jul 2016 08:55:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=333</guid>
		<description></description>
		<content:encoded><![CDATA[题目:

<blockquote>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)

Output: 7 -&gt; 0 -&gt; 8</blockquote>

简单的加法模拟, 代码如下:

<pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        //如果有一个链表为空,则直接返回另一个
        if(l1 == nullptr)
            return l2;
        if(l2 == nullptr)
            return l1;

        ListNode *p1 = l1, *p2 = l2;
        while(p1-&gt;next != nullptr || p2-&gt;next != nullptr){
            //填充较短的数, 高位添加0, 这一步可以用计算后再处理的办法替代
            if(p1-&gt;next == nullptr)
                p1-&gt;next = new ListNode(0);
            if(p2-&gt;next == nullptr)
                p2-&gt;next = new ListNode(0);
            p1 = p1-&gt;next, p2 = p2-&gt;next;
        }

        ListNode *head = new ListNode(0), *p = head;
        int jw = 0;//jw保存上一位计算后的进位
        for(p1 = l1, p2 = l2; p1 != nullptr &amp;&amp; p2 != nullptr; p1 = p1-&gt;next, p2 = p2-&gt;next){
            //模拟每一位的加法
            int t = p1-&gt;val + p2-&gt;val + jw;
            jw = (t &gt; 9 ? 1 : 0);

            t = t % 10;
            p-&gt;next = new ListNode(t);
            p = p-&gt;next;
        }
        if(jw == 1){
            //最后有进位的处理
            p-&gt;next = new ListNode(1);
        }

        return head-&gt;next;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>333</wp:post_id>
		<wp:post_date><![CDATA[2016-07-08 16:55:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-08 08:55:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-2-add-tow-numbers]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 372. Super Pow</title>
		<link>http://xiadong.info/2016/07/leetcode-372-super-pow/</link>
		<pubDate>Fri, 08 Jul 2016 08:58:25 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=335</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.

Example1:
<pre><code>a = 2
b = [3]

Result: 8
</code></pre>
Example2:
<pre><code>a = 2
b = [1,0]

Result: 1024
</code></pre>
</blockquote>

计算a的b次幂的值, 其中b很大并且用数组表示. 关键在于结果要对于1337取余, 这就意味着在计算过程中不会发生溢出问题. 根据公式:

<pre><code>(a * b) % n = ((a % n) * (b % n)) % n
</code></pre>

以及

<pre><code>a ^ (n + m) = (a ^ n) * (a ^ m)
</code></pre>

用b{i}表示数组b中到下标i为止的数, <code>a ^ b{i} = ((a ^ b{i - 1}) ^ 10) * (a ^ b[i])</code>, 把幂运算替换为乘法运算和循环, 在每一个循环体中都对结果取余. 就可以得到结果. 其中b[i]为0和第一次循环要特别处理.

代码如下, 耗时24ms:

<pre><code>class Solution {
    int MOD = 1337;
public:
    int superPow(int a, vector&lt;int&gt;&amp; b) {
        int ret = 0;
        for(int i = 0; i &lt; b.size(); i++){
            int t = b[i], retPowTen = 1;
            long long powT = 1;
            for(int j = 0; j &lt; 10; j++){
                retPowTen = (retPowTen * ret) % MOD;
            }
            ret = retPowTen;
            if(t == 0){
                powT = 0;
            }
            else{
                for(int j = 0; j &lt; t; j++){
                    powT = (powT * a) % MOD;
                }
            }
            if(powT &amp;&amp; ret)
                ret = (ret * (powT % MOD)) % MOD;
            else if(!ret)
                ret = powT % MOD;
            else
                ret = ret % MOD;
        }
        return ret;
    }
};</code></pre>

使用快速幂算法可以获得更快的运行时间。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>335</wp:post_id>
		<wp:post_date><![CDATA[2016-07-08 16:58:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-08 08:58:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-372-super-pow]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 3. Longest Substring Without Repeating Characters</title>
		<link>http://xiadong.info/2016/07/leetcode-3-longest-substring-without-repeating-characters/</link>
		<pubDate>Fri, 08 Jul 2016 10:56:07 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=337</guid>
		<description></description>
		<content:encoded><![CDATA[题目:

<blockquote>Given a string, find the length of the longest substring without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.

Given "bbbbb", the answer is "b", with the length of 1.

Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.</blockquote>

基本思路是遍历一遍字符串, 每访问到一个新字符时, 先检查有没有出现过(而一个字符有没有出现过用一个用字符的ASCII码作为索引的数组保存). 如果没有出现过(用-1表示)就记录下这个第一次出现的下标; 如果出现过, 就把子串的起始位置变为上次出现位置+1, 并把上次出现位置之前的字符设置为-1. 每次循环记录找到的最长长度.

代码:

<pre><code>class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int charHash[128];
        for(int i = 0; i &lt; 128; i++)
            charHash[i] = -1;

        int p1 = 0, p2 = 0, maxLength = 0;
        for(; p2 &lt; s.length(); p2++){
            if(charHash[s[p2]] == -1)
                charHash[s[p2]] = p2;
            else{
                int t = charHash[s[p2]] + 1;
                for(; p1 &lt; t; p1++)
                    charHash[s[p2]] = -1;
                charHash[s[p2]] = p2;
            }

            if(p2 - p1 + 1&gt; maxLength)
                maxLength = p2 - p1 + 1;
        }

        return maxLength;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>337</wp:post_id>
		<wp:post_date><![CDATA[2016-07-08 18:56:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-08 10:56:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-3-longest-substring-without-repeating-characters]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 4. Median of Two Sorted Arrays</title>
		<link>http://xiadong.info/2016/07/leetcode-4-median-of-two-sorted-arrays/</link>
		<pubDate>Fri, 08 Jul 2016 11:36:09 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=339</guid>
		<description></description>
		<content:encoded><![CDATA[题目:

<blockquote>There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Example 1:
<pre><code>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</code></pre>
Example 2:
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</code></pre>
</blockquote>

最直接方法, 合并为一个数组后进行排序, 运行时间56ms:

<pre><code>class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        for(int i = 0 ; i &lt; nums2.size(); i++)
            nums1.push_back(nums2[i]);

        int n = nums1.size();
        partial_sort(nums1.begin(), nums1.end(), nums1.end());
        if(n % 2 == 0)
            return ((double)nums1[n / 2] + (double)nums1[n / 2 - 1]) / 2;
        else
            return (double)nums1[n / 2];

    }
};
</code></pre>

另一种方法是利用两个数组都是排好序的这一属性, 将两个数组看作堆, 每次pop出两个数组顶端较小的值, 直到有一半的数被pop出去, 剩下的两个顶端值就可以求得中间值.

运行速度稍有提升:

<pre><code>class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int numTotal = nums1.size() + nums2.size();
        int n = numTotal / 2;
        int p1 = 0, p2 = 0;
        if(numTotal % 2){
            while(p1 &lt; nums1.size() &amp;&amp; p2 &lt; nums2.size() &amp;&amp; p1 + p2 &lt; n){
                if(nums1[p1] &lt; nums2[p2]) p1++;
                else p2++;
            }
            if(p1 + p2 &lt; n){
                if(p1 == nums1.size()){
                    while(p1 + p2 &lt; n) p2++;
                }
                if(p2 == nums2.size()){
                    while(p1 + p2 &lt; n) p1++;
                }
            }
            if(p1 == nums1.size()) return (double)nums2[p2];
            else if(p2 == nums2.size()) return (double)nums1[p1];
            else return (double)min(nums1[p1], nums2[p2]);
        }
        else{
            while(p1 &lt; nums1.size() &amp;&amp; p2 &lt; nums2.size() &amp;&amp; p1 + p2 &lt; n - 1){
                if(nums1[p1] &lt; nums2[p2]) p1++;
                else p2++;
            }
            if(p1 + p2 &lt; n - 1){
                if(p1 == nums1.size()){
                    while(p1 + p2 &lt; n - 1) p2++;
                }
                if(p2 == nums2.size()){
                    while(p1 + p2 &lt; n - 1) p1++;
                }
            }
            if(p1 == nums1.size()) return (double)((nums2[p2] + nums2[p2 + 1]) / 2.0);
            else if(p2 == nums2.size()) return (double)((nums1[p1] + nums1[p1 + 1]) / 2.0);
            else{
                int t1, t2;
                if(nums1[p1] &lt; nums2[p2]) t1 = nums1[p1++];
                else t1 = nums2[p2++];
                if(p1 == nums1.size()){
                    t2 = nums2[p2++];
                }
                else if(p2 == nums2.size()){
                    t2 = nums1[p1++];
                }
                else{
                    if(nums1[p1] &lt; nums2[p2]) t2 = nums1[p1++];
                    else t2 = nums2[p2++];
                }
                return (double)((t1 + t2) / 2.0);
            }
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>339</wp:post_id>
		<wp:post_date><![CDATA[2016-07-08 19:36:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-08 11:36:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-4-median-of-two-sorted-arrays]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 5. Longest Palindromic Substring</title>
		<link>http://xiadong.info/2016/07/5-longest-palindromic-substring/</link>
		<pubDate>Sat, 09 Jul 2016 10:01:27 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=341</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</blockquote>

要求找出一个字符串中出现的最长的回文子串. 我自己没有想出什么特别好的办法, 只能用比较暴力的手段来通过. 主要思想就是遍历每一个字符, 对这个字符向两边延伸, 直到不符合回文的定义, 记录下最大值.

代码:

<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length(), longestLen = 0, longestBegin;
        for(int i = 0; i &lt; len; i++){
            bool oddInvalidFlag = false, evenInvalidFlag = false;
            for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; len; j++){
                if(s[i - j] != s[i + j]) oddInvalidFlag = true;
                if(s[i - j] != s[i + j + 1]) evenInvalidFlag = true;
                if(oddInvalidFlag &amp;&amp; evenInvalidFlag)
                    break;
                if(!oddInvalidFlag &amp;&amp; s[i - j] == s[i + j] &amp;&amp; (j &lt;&lt; 1) + 1 &gt; longestLen){
                    longestLen = (j &lt;&lt; 1) + 1;
                    longestBegin = i - j;
                }
                if(!evenInvalidFlag &amp;&amp; s[i - j] == s[i + j + 1] &amp;&amp; (j &lt;&lt; 1) + 2 &gt; longestLen){
                    longestLen = (j &lt;&lt; 1) + 2;
                    longestBegin = i - j;
                }
            }
            int j = len - i - 1;
            if(!oddInvalidFlag &amp;&amp; i &gt;= j &amp;&amp; s[i - j] == s[i + j] &amp;&amp; (j &lt;&lt; 1) + 1 &gt; longestLen){
                longestLen = (j &lt;&lt; 1) + 1;
                longestBegin = i - j;
            }

        }

        return s.substr(longestBegin, longestLen);
    }
};
</code></pre>

以上代码对每一个字符使用了一个循环, 运行时间120ms左右. 但是如果把子串长度为奇数和偶数分开来的话, 速度反而会变快, 我想应该是特定测试数据使总得指令数变少了.

另一个版本:

<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length(), longestLen = 0, longestBegin;
        for(int i = 0; i &lt; len; i++){
            for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; len; j++){
                if(s[i - j] != s[i + j])
                    break;
                if((j &lt;&lt; 1) + 1 &gt; longestLen){
                    longestLen = (j &lt;&lt; 1) + 1;
                    longestBegin = i - j;
                }
            }

            for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; len; j++){
                if(s[i - j] != s[i + j + 1])
                    break;
                if((j &lt;&lt; 1) + 2 &gt; longestLen){
                    longestLen = (j &lt;&lt; 1) + 2;
                    longestBegin = i - j;
                }
            }
        }

        return s.substr(longestBegin, longestLen);
    }
};
</code></pre>

<strong>一个优化小Trick</strong>

在最外层循环中将循环条件<code>i &lt; len</code>变为<code>i &lt; len - longestLen / 2</code>, Runtime可缩短近半.

<strong>更优解</strong>

根据这个帖子的方法<a href="https://discuss.leetcode.com/topic/49578/directly-reaching-the-best-solution-4ms-in-c-quite-simple">https://discuss.leetcode.com/topic/49578/directly-reaching-the-best-solution-4ms-in-c-quite-simple</a>, 运行时间成功缩短到4ms.

<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length(), longestLen = 0, longestBegin = 0;
        int i = 0;
        while(i &lt; len - longestLen / 2){
            int r = i, l = i;
            for(; r &lt; len - 1 &amp;&amp; s[r] == s[r + 1]; r++);
            i = r + 1;
            for(; l &gt;= 0 &amp;&amp; r &lt; len &amp;&amp; s[l] == s[r]; l--, r++);
            int curLen = r - l - 1;
            if(curLen &gt; longestLen) longestLen = curLen, longestBegin = l + 1;
        }

        return s.substr(longestBegin, longestLen);
    }
};
</code></pre>

说明: 判断回文子串的方法不变, 都是向两边延伸, 关键在于回文串中心的选择, <code>for(; r &lt; len - 1 &amp;&amp; s[r] == s[r + 1]; r++);</code>跳过了连续相同的字符, 这是因为连续的相同字符必然是回文串, 可以直接从这样的回文串开始向两边延伸.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>341</wp:post_id>
		<wp:post_date><![CDATA[2016-07-09 18:01:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-09 10:01:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[5-longest-palindromic-substring]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 6. ZigZag Conversion</title>
		<link>http://xiadong.info/2016/07/leetcode-6-zigzag-conversion/</link>
		<pubDate>Sat, 09 Jul 2016 10:35:38 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=345</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
<pre><code>P   A   H   N
A P L S I I G
Y   I   R
</code></pre>
And then read line by line: <code>"PAHNAPLSIIGYIR"</code>

Write the code that will take a string and make this conversion given a number of rows:
<pre><code>string convert(string text, int nRows);
</code></pre>
<code>convert("PAYPALISHIRING", 3)</code> should return <code>"PAHNAPLSIIGYIR"</code>.</blockquote>

比较简单的字符串处理, 根据给定的要求模拟即可.

<pre><code>class Solution {
public:
    string convert(string s, int numRows) {
        int n = numRows * 2 - 2, len = s.length(), column;
        if(len == 0)
            return string("");
        if(numRows == 1)
            return s;
        else
            column = (len / n) * 2 + 2;
        char arr[numRows][column];

        memset(arr, 0, sizeof(arr));
        for(int i = 0; i &lt; len; i++){
            if((i % n) &lt; numRows)
                arr[i % n][i / n * 2] = s[i];
            else
                arr[numRows - (i % n - numRows) - 2][i / n * 2+ 1] = s[i];
        }

        string re;
        for(int i = 0; i &lt; numRows; i++){
            for(int j = 0; j &lt; column; j++)
                if(arr[i][j] != 0)
                    re.push_back(arr[i][j]);
        }

        return re;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>345</wp:post_id>
		<wp:post_date><![CDATA[2016-07-09 18:35:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-09 10:35:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-6-zigzag-conversion]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 7. Reverse Integer</title>
		<link>http://xiadong.info/2016/07/leetcode-7-reverse-integer/</link>
		<pubDate>Sat, 09 Jul 2016 10:41:23 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=348</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Reverse digits of an integer.

Example1: x = 123, return 321

Example2: x = -123, return -321</blockquote>

问题比较简单, 关键问题在于对于int类型数据表示范围的了解和对溢出的处理.

代码:

<pre><code>class Solution {
public:
    int reverse(int x) {
        long long re = 0;
        int sign = 1;
        if(x &lt; 0){
            sign = -1;
            x = -x;
        }
        while(x &gt; 0){
            re = re * 10 + ( x % 10 );
            x /= 10;
        }

        if(re &gt; 0x7fffffff)
            return 0;

        return sign * re;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>348</wp:post_id>
		<wp:post_date><![CDATA[2016-07-09 18:41:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-09 10:41:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-7-reverse-integer]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 8. String to Integer (atoi)</title>
		<link>http://xiadong.info/2016/07/leetcode-8-string-to-integer-atoi/</link>
		<pubDate>Sat, 09 Jul 2016 10:50:48 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=350</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Implement atoi to convert a string to an integer.
  
  Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.
  
  Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
</blockquote>

比较简单的题目, 因为要转换的是整数, 因此只需要考虑前导空格和符号.

代码:

<pre><code>class Solution {
public:
    bool isNumber(char a){
        return a &gt;= '0' &amp;&amp; a &lt;= '9';
    }

    int myAtoi(string str) {
        int len = str.length(), p = 0;
        if(str[0] == ' '){
            for(int i = 0; str[i] == ' '; i++) p++;
        }
        if(!(isNumber(str[p]) || str[p] == '-' || str[p] == '+'))
            return 0;

        int sign = 1;
        if(str[p] == '-'){
            sign = -1;
        }

        if(str[p] == '-' || str[p] == '+')
            p++;

        long long re = 0;
        len = str.length();
        for(int i = p; i &lt; len &amp;&amp; isNumber(str[i]); i++){
            re *= 10;
            re += str[i] - '0';

            if(sign &gt; 0 &amp;&amp; re &gt; INT_MAX)
                return INT_MAX;
            if(sign &lt; 0 &amp;&amp; -re &lt; INT_MIN)
                return INT_MIN;
        }

        return sign * re;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>350</wp:post_id>
		<wp:post_date><![CDATA[2016-07-09 18:50:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-09 10:50:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-8-string-to-integer-atoi]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 9. Palindrome Number</title>
		<link>http://xiadong.info/2016/07/leetcode-9-palindrome-number/</link>
		<pubDate>Sat, 09 Jul 2016 11:01:14 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=355</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述

<blockquote>Determine whether an integer is a palindrome. Do this without extra space.</blockquote>

我没有太明白这个<code>without extra space</code>的具体含义, 传入数据只有一个int型, 难道是要完全不使用局部变量吗? 这个要求总觉得有点匪夷所思. 忽略这一点, 这个题目还是很简单的.

代码:

<pre><code>class Solution {
public:
    bool isPalindrome(int x) {
        if(x &lt; 0)
            return false;

        long long r = 0, t = x;
        while(t &gt; 0){
            r = r * 10 + t % 10;
            t /= 10;
        }

        if(x == r)
            return true;
        else
            return false;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>355</wp:post_id>
		<wp:post_date><![CDATA[2016-07-09 19:01:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-09 11:01:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-9-palindrome-number]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 10. Regular Expression Matching</title>
		<link>http://xiadong.info/2016/07/leetcode-10-regular-expression-matching/</link>
		<pubDate>Sun, 10 Jul 2016 12:37:24 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=357</guid>
		<description></description>
		<content:encoded><![CDATA[正则表达式匹配, 题目描述:

<blockquote>Implement regular expression matching with support for '.' and '*'.
<pre><code>'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true
</code></pre>
</blockquote>

这个题目我是用动态规划AC的, 主要思路是这样的: 数组<code>dp[i][j]</code>表示s的前i个字符(下标从0到i - 1)和p的前j个字符(下标从0到j - 1)是否匹配(p经过处理, 表示重复任意次的<code>*</code>单独保存在另一个数组里). 因此我们的随后结果就是要得到<code>dp[s.size()][p.size()]</code>. 而<code>dp[i][j]</code>的值为真有以下三种可能:

<ol>
    <li>dp[i - 1][j]为真且s[i - 1]这个字符加与不加不影响匹配成立与否. 这要求p[j - 1]这个字符是被*标记的, 并且字符s[i - 1]与p[j - 1]可以匹配, 即s[i - 1] == p[j- 1]或p[j - 1] == '.'.</li>
    <li>dp[i][j - 1]为真且p[j - 1]这个字符加与不加不影响匹配成立与否. 这要求p[j - 1]这个字符是被*标记的.</li>
    <li>dp[i - 1][j - 1]为真并且s[i - 1]与p[j - 1]可以匹配, 即s[i - 1] == p[j- 1]或p[j - 1] == '.'.</li>
</ol>

可以得到<code>dp[i][j] = (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.') &amp;&amp; star[j - 1]) || (dp[i][j - 1] &amp;&amp; (star[j - 1])) || (dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'))</code>, 其中star[i]表示p[i]是否被*标记.

<pre lang="c++"><code>class Solution {
public:
    bool isMatch(string s, string p) {
        string e;
        vector&lt;bool&gt; star;
        for(int i = 0; i &lt; p.size(); i++){
            if(p[i] == '*') star.back() = true;
            else{
                e.push_back(p[i]);
                star.push_back(false);
            }
        }
        p = e;
        vector&lt;vector&lt;bool&gt;&gt; dp(s.size() + 1, vector&lt;bool&gt;(p.size() + 1, false));
        dp[0][0] = true;
        for(int i = 1; i &lt;= p.size(); i++){
            dp[0][i] = dp[0][i - 1] &amp;&amp; star[i - 1];
        }
        for(int i = 1; i &lt;= s.size(); i++)
            for(int j = 1; j &lt;= p.size(); j++){
                dp[i][j] = (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.') &amp;&amp; star[j - 1]) || (dp[i][j - 1] &amp;&amp; (star[j - 1])) || (dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'));
            }
        return dp[s.size()][p.size()];
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>357</wp:post_id>
		<wp:post_date><![CDATA[2016-07-10 20:37:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-10 12:37:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-10-regular-expression-matching]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>使用Jetpack为Wordpress博客添加分享按钮</title>
		<link>http://xiadong.info/2016/07/%e4%bd%bf%e7%94%a8jetpack%e4%b8%bawordpress%e5%8d%9a%e5%ae%a2%e6%b7%bb%e5%8a%a0%e5%88%86%e4%ba%ab%e6%8c%89%e9%92%ae/</link>
		<pubDate>Mon, 11 Jul 2016 11:02:52 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=368</guid>
		<description></description>
		<content:encoded><![CDATA[分享按钮对于博客来说是一个很有用的小工具, Wordpress也有很多分享插件, 但是可惜都是支持国外的社交网络, 支持国内的都许久未更新了. 现在国内比较好用的分享工具就是百度家的了, 鉴于百度劣迹斑斑, 今天我决定不用百度的分享工具而转而使用WordPress.com出品的Jetpack工具包中的分享功能. 和绝大多数国外开发的插件一样, 这个工具默认没有国内的社交网络, 但是它有自定义分享连接的功能, 我就用这个工具来添加自己的分享按钮. 本文只介绍微信和微博的分享按钮设置方法, 其他网站都很类似, 就不在赘述了.

Wordpress版本: 4.5.3

JetPack版本: 4.1.1

<em>本文中所有图片都使用Google服务, 如无法显示请自备梯子或者点击图片下方链接.</em>

<h2 id="-">开启分享功能</h2>

在Jetpack后台中启用分享功能

<img src="https://lh3.googleusercontent.com/-liLebQ3iGHA/V4NwgSWebTI/AAAAAAAAD0g/bTnW9EqxTZYZFY-eOisTrVHml2p8k3JcgCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711180858.png" alt="https://lh3.googleusercontent.com/-liLebQ3iGHA/V4NwgSWebTI/AAAAAAAAD0g/bTnW9EqxTZYZFY-eOisTrVHml2p8k3JcgCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711180858.png" />
<em><small><a href="http://7xkh37.com1.z0.glb.clouddn.com/20160711180858.png">墙内链接</a></small></em>

<h2 id="-">设置</h2>

在设置=&gt;共享菜单中可以设置分享按钮的外观等属性, 设置好后就可以使用它本身自带的FB, Twitter等分享功能了. 但是我想分享到微博怎么办呢? 在这里有一个"添加一个新的服务"功能, 就是自定义分享链接啦.

<img src="https://lh3.googleusercontent.com/-7y3GiYpLU5I/V4NyFYj31MI/AAAAAAAAD04/3utLPaLzr68CKQ3qVmG68mqcgh8JneFpQCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711181616.png" alt="https://lh3.googleusercontent.com/-7y3GiYpLU5I/V4NyFYj31MI/AAAAAAAAD04/3utLPaLzr68CKQ3qVmG68mqcgh8JneFpQCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711181616.png" />
<em><small><a href="http://7xkh37.com1.z0.glb.clouddn.com/20160711181616.png">墙内链接</a></small></em>

点击连接后弹出该窗口:

<img src="https://lh3.googleusercontent.com/-Od71yJSjhow/V4NzBVJw8CI/AAAAAAAAD1I/iDly88CEai4IhYR5uJsAR8NeQpH-BzLRQCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711182011.png" alt="https://lh3.googleusercontent.com/-Od71yJSjhow/V4NzBVJw8CI/AAAAAAAAD1I/iDly88CEai4IhYR5uJsAR8NeQpH-BzLRQCCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711182011.png" />
<em><small><a href="http://7xkh37.com1.z0.glb.clouddn.com/20160711182011.png">墙内链接</a></small></em>

服务名称我们可以自己选择, 接下来的参数就是分享链接和图标了, 我们先来搞定分享链接.

<h2 id="-">微博分享链接</h2>

一般的分享链接都是通过URL参数传递的要分享的数据, 我们先来看看一个正常的微博分享链接长什么样. 首先随便打开一篇门户网站的文章, 比如这篇<a href="http://cul.qq.com/a/20160711/007865.htm">http://cul.qq.com/a/20160711/007865.htm</a>, 找到分享按钮然后点击, 打开的URL是这样的:

<code>http://service.weibo.com/share/share.php?url=http%3A%2F%2Fcul.qq.com%2Fa%2F20160711%2F007865.htm&amp;appkey=&amp;title=%A1%B6%B4%F3%D3%E3%BA%A3%CC%C4%A1%B7%B3%F6%C1%CB%CE%CA%CC%E2%A3%AC%BB%B9%CA%C7%B9%DB%D6%DA%B3%F6%C1%CB%CE%CA%CC%E2&amp;pic=http://img1.gtimg.com/cul/pics/hv1/7/145/2096/136329382.jpg||http://img1.gtimg.com/cul/pics/hv1/56/145/2096/136329431.jpg||http://img1.gtimg.com/cul/pics/hv1/83/145/2096/136329458.jpg&amp;ralateUid=&amp;language=&amp;searchPic=false</code>

它有这样几个参数:

<ul>
    <li>url: 要分享的URL</li>
    <li>appkey</li>
    <li>title: 标题</li>
    <li>pic: 应该是文章图片了</li>
    <li>relateUid</li>
    <li>language</li>
    <li>searchPic</li>
</ul>

其中我们只要关心url和title两个参数就可以了, 尝试删除其他参数, 只保留url和title

<code>http://service.weibo.com/share/share.php?url=http%3A%2F%2Fcul.qq.com%2Fa%2F20160711%2F007865.htm&amp;title=%A1%B6%B4%F3%D3%E3%BA%A3%CC%C4%A1%B7%B3%F6%C1%CB%CE%CA%CC%E2%A3%AC%BB%B9%CA%C7%B9%DB%D6%DA%B3%F6%C1%CB%CE%CA%CC%E2</code>

OK, 工作地很好. 这样我们就可以进行设置了, 把分享链接设置如下:

<code>http://service.weibo.com/share/share.php?url=%post_full_url%&amp;title=%post_title%</code>

<h2 id="-">微博分享图标</h2>

直接使用Google图片搜索, 设置图片大小为16*16, 可以找到微博官方提供的图标:

<a href="http://www.sinaimg.cn/blog/developer/wiki/LOGO_16x16.png">http://www.sinaimg.cn/blog/developer/wiki/LOGO_16x16.png</a>

<h2 id="-">微信分享</h2>

微信分享网页一般都是通过二维码扫描后在微信内置浏览器内打开后再分享, 因此分享到微信我们只要生成URL对应的二维码即可. 有许多在线二维码生成的网站, 我使用<a href="http://cli.im/api">http://cli.im/api</a>这个网站提供的API.

分享链接设置为<code>http://cli.im/api/qrcode/code?text=%post_full_url%&amp;mhid=sELPDFnok80gPHovKdI</code>, 图标设置为<a href="https://res.wx.qq.com/zh_CN/htmledition/v2/images/favicon2e4e03.ico">https://res.wx.qq.com/zh_CN/htmledition/v2/images/favicon2e4e03.ico</a>

<h2 id="-">最终效果</h2>

<img src="https://lh3.googleusercontent.com/-x44806CaDcE/V4N7foI_EMI/AAAAAAAAD1Y/dbS4bBzEs0IP1fxmDJgyCmi6Mbzsn6l6ACCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711185625.png" alt="https://lh3.googleusercontent.com/-x44806CaDcE/V4N7foI_EMI/AAAAAAAAD1Y/dbS4bBzEs0IP1fxmDJgyCmi6Mbzsn6l6ACCo/s800/QQ%25E6%2588%25AA%25E5%259B%25BE20160711185625.png" />
<em><small><a href="http://7xkh37.com1.z0.glb.clouddn.com/20160711185625.png">墙内链接</a></small></em>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>368</wp:post_id>
		<wp:post_date><![CDATA[2016-07-11 19:02:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-11 11:02:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8jetpack%e4%b8%bawordpress%e5%8d%9a%e5%ae%a2%e6%b7%bb%e5%8a%a0%e5%88%86%e4%ba%ab%e6%8c%89%e9%92%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="web"><![CDATA[WEB]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 11. Container With Most Water</title>
		<link>http://xiadong.info/2016/07/leetcode-11-container-with-most-water/</link>
		<pubDate>Tue, 12 Jul 2016 09:01:40 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=372</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container.</blockquote>

稍微优化的暴力搜索，时间复杂度比<code>O(n^2)</code>稍低。

C:

<pre><code>int maxArea(int height[], int n) {
    int max = 0, len = n;
    for(int i = 0; i &lt; len; i++){
        if(height[i] * (len - i - 1) &lt;= max)continue;
        for(int j = i + (max / height[i] &gt; 1 ? max / height[i] : 1); j &lt; len; j++){
            int area = (j - i) * (height[i] &lt; height[j] ? height[i] : height[j]);
            if(area &gt; max)max = area;
        }
    }

    return max;
}
</code></pre>

使用双指针的方法，从数组两端向中间遍历，时间复杂度约为<code>O(n)</code>。

C++:

<pre><code>class Solution {
public:
    int maxArea(vector&lt;int&gt; &amp;height) {
        int start = 0, end = height.size() - 1, max = 0, area;

        while(start &lt; end){
            if(height[start] &lt; height[end]){
                area = height[start] * (end - start);
                max = max &gt; area ? max : area;
                start++;
            }
            else{
                area = height[end] * (end - start);
                max = max &gt; area ? max : area;
                end--;
            }
        }

        return max;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>372</wp:post_id>
		<wp:post_date><![CDATA[2016-07-12 17:01:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-12 09:01:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-11-container-with-most-water]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 12. Integer to Roman</title>
		<link>http://xiadong.info/2016/07/leetcode-12-integer-to-roman/</link>
		<pubDate>Tue, 12 Jul 2016 09:52:55 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=374</guid>
		<description></description>
		<content:encoded><![CDATA[题目要求:

<blockquote>Given an integer, convert it to a roman numeral.

Input is guaranteed to be within the range from 1 to 3999.</blockquote>

关于罗马数字的表示方法参考这里<a href="https://www.wikiwand.com/en/Roman_numerals">https://www.wikiwand.com/en/Roman_numerals</a>

<table>
<tbody>
<tr>
<th>Symbol</th>
<th>Value</th>
</tr>
<tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody>
</table>

同时有以下三条规则:

<ul>
    <li>I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)</li>
    <li>X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)</li>
    <li>C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)</li>
</ul>

整数转化为罗马数字，简单模拟。

<pre><code>class Solution {
public:
    string intToRoman(int num) {
        int numArr[4] = {0};
        int numArrIndex = 3;
        while(num &gt; 0){
            numArr[numArrIndex--] = num % 10;
            num /= 10;
        }
        string ret;

        for(int i = 3, offset = 1; i &gt;= 0; i--, offset *= 10){
            if(numArr[i] == 0) continue;
            else if(numArr[i] &lt; 4){
                for(int j = 0; j &lt; numArr[i]; j++) ret.push_back(valToSymbol(1 * offset));
            }
            else if(numArr[i] == 4){
                ret.push_back(valToSymbol(5 * offset));
                ret.push_back(valToSymbol(1 * offset));
            }
            else if(numArr[i] &lt; 9){
                for(int j = 5; j &lt; numArr[i]; j++) ret.push_back(valToSymbol(1 * offset));
                ret.push_back(valToSymbol(5 * offset));
            }
            else{
                ret.push_back(valToSymbol(10 * offset));
                ret.push_back(valToSymbol(1 * offset));
            }
        }
        reverse(ret.begin(), ret.end());
        return ret;
    }

    char valToSymbol(int val){
        switch(val){
            case 1:
                return 'I';
            case 5:
                return 'V';
            case 10:
                return 'X';
            case 50:
                return 'L';
            case 100:
                return 'C';
            case 500:
                return 'D';
            case 1000:
                return 'M';
            default:
                return 0;
        }
    }
};
</code></pre>

Runtime: 28ms]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>374</wp:post_id>
		<wp:post_date><![CDATA[2016-07-12 17:52:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-12 09:52:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-12-integer-to-roman]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 13. Roman to Integer</title>
		<link>http://xiadong.info/2016/07/leetcode-13-roman-to-integer/</link>
		<pubDate>Tue, 12 Jul 2016 10:06:53 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=376</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given a roman numeral, convert it to an integer.
  
  Input is guaranteed to be within the range from 1 to 3999.
</blockquote>

与第12题相反, 同样是简单模拟:

<pre><code>class Solution {
public:
    int romanToInt(string s) {
        int ret = 0;

        int last_weight = -1;
        for(int i = s.length() - 1; i &gt;= 0; i--){
            int w = symbolToVal(s[i]);
            if(w &lt; last_weight)
                ret -= w;
            else{
                last_weight = w;
                ret += w;
            }
        }

        return ret;
    }

    int symbolToVal(char s){
        switch(s){
            case 'I':
                return 1;
            case 'V':
                return 5;
            case 'X':
                return 10;
            case 'L':
                return 50;
            case 'C':
                return 100;
            case 'D':
                return 500;
            case 'M':
                return 1000;
            default:
                return -1;
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>376</wp:post_id>
		<wp:post_date><![CDATA[2016-07-12 18:06:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-12 10:06:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-13-roman-to-integer]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 374. Guess Number Higher or Lower</title>
		<link>http://xiadong.info/2016/07/leetcode-374-guess-number-higher-or-lower/</link>
		<pubDate>Wed, 13 Jul 2016 09:58:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=387</guid>
		<description></description>
		<content:encoded><![CDATA[问题描述:

<blockquote>We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I'll tell you whether the number is higher or lower.

You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):
<pre><code>-1 : My number is lower
 1 : My number is higher
 0 : Congrats! You got it!
</code></pre>
Example:
<pre><code>n = 10, I pick 6.

Return 6.
</code></pre>
</blockquote>

二分搜索问题.

<pre lang="C++"><code>// Forward declaration of guess API.
// @param num, your guess
// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
int guess(int num);

class Solution {
public:
    int guessNumber(int n) {
        int mid = n / 2, left = 1, right = n, tmpResult;
        while((tmpResult = guess(mid)) != 0){
            if(tmpResult == -1){
                right = mid;
            }
            else if(tmpResult == 1){
                left = mid + 1;
            }
            mid = (right - left) / 2 + left;
        }
        return mid;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>387</wp:post_id>
		<wp:post_date><![CDATA[2016-07-13 17:58:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-13 09:58:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-374-guess-number-higher-or-lower]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 14. Longest Common Prefix</title>
		<link>http://xiadong.info/2016/07/leetcode-14-longest-common-prefix/</link>
		<pubDate>Wed, 13 Jul 2016 10:17:10 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=389</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Write a function to find the longest common prefix string amongst an array of strings.
</blockquote>

寻找一组字符串的最长公共前缀. 首先, 如果只有一个字符串, 那么它就是最长公共前缀, 如果有两个, 那么再跟第二个字符串逐个字符对比, 找出最长公共前缀. 再增加字符串则依次类推. 

在这个方法的基础上, 可以想到最长公共前缀一定不会比字符串数组中最短的字符串长, 因此可以先找到最短字符串, 以它为一开始的基准.

代码:

<pre lang="C++"><code>class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        if(strs.empty())
            return &quot;&quot;;

        int shortestIndex = findShortest(strs);
        int prefixLen = strs[shortestIndex].length();
        int len = strs.size();

        for(int i = 0; i &lt; len; i++){
            if(prefixLen == 0) return &quot;&quot;;
            string s = strs[i];
            int l1 = prefixLen, l2 = s.length(), j;
            for(j = 0; j &lt; l1 &amp;&amp; j &lt; l2; j++){
                if(strs[0][j] != s[j])
                    break;
            }

            if(j != l1 &amp;&amp; j != l2){
                prefixLen = j;
            }
            else if(j == l2){
                prefixLen = l2;
            }
        }

        return strs[shortestIndex].substr(0, prefixLen);
    }

    int findShortest(vector&lt;string&gt; &amp;strs){
        int minLen = INT_MAX, index;
        for(int i = 0; i &lt; strs.size(); i++){
            if(strs[i].length() &lt; minLen){
                minLen = strs[i].length();
                index = i;
            }
        }
        return index;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>389</wp:post_id>
		<wp:post_date><![CDATA[2016-07-13 18:17:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-13 10:17:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-14-longest-common-prefix]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 15. 3Sum</title>
		<link>http://xiadong.info/2016/07/leetcode-15-3sum/</link>
		<pubDate>Wed, 13 Jul 2016 12:05:32 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=397</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note: The solution set must not contain duplicate triplets.
<pre><code>For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre></blockquote>

参考<a href="http://xiadong.info/2016/07/1-two-sum/">http://xiadong.info/2016/07/1-two-sum/</a>Two Sum这道题, 我们可以先取得一个数n, 将-n作为target就变为了Two Sum问题, 代码如下:

<pre lang="C++"><code>class Solution {
    vector&lt;vector&lt;int&gt;&gt; ret;
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());

        for(int i = 0; i &lt; nums.size(); i++){
            if(i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) continue;
            if(nums[i] &gt; 0) break;
            twoSum(nums, -nums[i], i + 1, nums.size());
        }
        return ret;
    }

    void twoSum(vector&lt;int&gt;&amp; nums, int target, int left, int right) {
        int l = left, r = right - 1;
        while(l &lt; r){
            int sum = nums[l] + nums[r];
            if(sum == target){
                vector&lt;int&gt; t = {-target, nums[l], nums[r]};
                ret.push_back(t);
                do{r--;}while(nums[r] == nums[r + 1]);
                do{l++;}while(nums[l] == nums[l - 1]);
            }
            else if(sum &gt; target){
                r--;
            }
            else{
                l++;
            }
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>397</wp:post_id>
		<wp:post_date><![CDATA[2016-07-13 20:05:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-13 12:05:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-15-3sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Windows中使用Linux</title>
		<link>http://xiadong.info/2016/07/windows%e4%b8%ad%e4%bd%bf%e7%94%a8linux/</link>
		<pubDate>Thu, 14 Jul 2016 09:33:35 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=408</guid>
		<description></description>
		<content:encoded><![CDATA[对我来说, 相比于Windows, Linux更加能胜任开发的工作, 开发工具丰富, 有Terminal. 但是因为我只有一台笔记本电脑, 以前安装双系统总是被驱动问题所困扰, 显卡驱动, 网卡驱动是重灾区, 而且双系统切换需要重启, 非常繁琐. 在我增加了一块SSD后就一直没有再安装双系统.

最近微软为Windows 10提供了Ubuntu子系统, 但是到目前位置还是有Insider预览版可以安装. 我并不想去给微软当小白鼠, 况且我对于Windows系统本身也没什么兴趣, 也早就不再追逐软件的最新版. 从另一个方面来说, 我觉得这混淆了Windows和Linux, 写代码我喜欢Linux的那一套东西, 但是我觉得这拼凑出来的东西并不会好用.

虚拟机是一个不错的解决办法, 以前我都是使用VmWare运行桌面版的Linux, 但是性能是一个问题, 而且我发现我似乎用不到虚拟机Linux的桌面环境.

所以我今天用Hyper-V安装了Ubuntu Server版, 用SSH的办法登录上去, 就可以使用较低的硬件资源.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>408</wp:post_id>
		<wp:post_date><![CDATA[2016-07-14 17:33:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-14 09:33:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[windows%e4%b8%ad%e4%bd%bf%e7%94%a8linux]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 16. 3Sum Closest</title>
		<link>http://xiadong.info/2016/07/leetcode-16-3sum-closest/</link>
		<pubDate>Fri, 15 Jul 2016 09:06:33 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=411</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

<pre><code>For example, given array S = {-1 2 1 -4}, and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre>
</blockquote>

首先这是一个3Sum问题, 因此仍然先使用上一道题目的思路, 用双指针实现2Sum, 用target - nums[i]作为2Sum的target. 接下来的问题就是<strong>closest</strong>的问题了, 我的办法是遍历所有的2Sum组合(只需要遍历下标在i之后的元素), 找到最接近target - nums[i]的组合. 当三个数的和与target差距为0时也可以退出循环, 否则直到i等于nums.size() - 1为止.

<pre lang="c++"><code>class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        sort(nums.begin(), nums.end());
        int minLen = INT_MAX, ret;
        for(int i = 0; i &lt; nums.size(); i++){
            int oldMinLen = minLen;
            int sum = twoSum(nums, target - nums[i], i + 1, nums.size(), minLen);
            if(minLen &lt; oldMinLen){
                ret = sum + nums[i];
            }
            if(minLen == 0) break;
        }
        return ret;
    }

    int twoSum(vector&lt;int&gt;&amp; nums, int target, int left, int right, int &amp;minLen) {
        int l = left, r = right - 1;
        int ret;
        while(l &lt; r){
            int sum = nums[l] + nums[r];
            if(sum == target){
                ret = sum;
                minLen = 0;
                break;
            }
            else if(sum &gt; target){
                r--;
            }
            else{
                l++;
            }
            int len = lenBetweenInt(sum, target);
            if(len &lt; minLen){
                minLen = len;
                ret = sum;
            }
        }
        return ret;
    }

    int lenBetweenInt(int a, int b){
        return abs(a - b);
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>411</wp:post_id>
		<wp:post_date><![CDATA[2016-07-15 17:06:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-15 09:06:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-16-3sum-closest]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 17. Letter Combinations of a Phone Number</title>
		<link>http://xiadong.info/2016/07/leetcode-17-letter-combinations-of-a-phone-number/</link>
		<pubDate>Fri, 15 Jul 2016 09:34:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=415</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given a digit string, return all possible letter combinations that the number could represent.
  
  A mapping of digit to letters (just like on the telephone buttons) is given below.
  
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="" title="" />

<pre><code>Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
</code></pre>
  
  <strong>Note:</strong>
  Although the above answer is in lexicographical order, your answer could be in any order you want.
</blockquote>

这道题要求输入一串手机九宫格按键, 输出所有可能的字母组合. 方法是每读入一个按键, 就将原字符串数组复制数次(数量取决于这个按键上有几个字母), 然后加上当前读入的按键.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;string&gt; letterCombinations(string digits) {
        int letterNumOnButton[] = {1, 1, 3, 3 ,3, 3, 3, 4, 3, 4};
        vector&lt;string&gt; m = {
            " ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
        };

        if(digits.empty())
            return vector&lt;string&gt;();

        vector&lt;string&gt; re = {""};
        for(int i = 0; i &lt; digits.length(); i++){
            int button = digits[i] - '0';

            int size = re.size();
            for(int j = 0; j &lt; letterNumOnButton[button] - 1; j++){
                for(int k = 0; k &lt; size; k++){
                    re.push_back(re[k]);
                }
            }

            for(int j = 0; j &lt; m[button].length(); j++){
                for(int k = 0; k &lt; size; k++){
                    re[j * size + k].push_back(m[button][j]);
                }
            }
        }

        return re;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>415</wp:post_id>
		<wp:post_date><![CDATA[2016-07-15 17:34:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-15 09:34:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-17-letter-combinations-of-a-phone-number]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>STL容器学习笔记一 - 标准容器与Array</title>
		<link>http://xiadong.info/2016/07/stl%e5%ae%b9%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b8%80-%e6%a0%87%e5%87%86%e5%ae%b9%e5%99%a8%e4%b8%8earray/</link>
		<pubDate>Fri, 15 Jul 2016 10:46:14 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=417</guid>
		<description></description>
		<content:encoded><![CDATA[在做LeetCode题目的过程中, 我发现我对于STL容器的了解还是过于浅薄, 因此决定专门学习总结一下. 主要资料来源是<a href="http://www.cplusplus.com/reference/stl/">http://www.cplusplus.com/reference/stl/</a>.

<h1>标准容器</h1>

一个<strong>容器</strong>是一个保存一组其他对象(元素 <em>element</em>)的对象, 他们都是用类模板来实现的. 容器管理着保存元素的存储空间并且提供直接或通过迭代器(<em>iterators</em>)访问它们的成员函数.

stack, queue和priority_queue被实现为<strong>容器适配器(container adaptors)</strong>, 容器适配器不是完整的容器类, 而是提供依赖于容器类(如deque或list)对象的特定接口的类.

<h2>顺序容器 Sequence Containers</h2>

<ul>
    <li>array</li>
    <li>vector</li>
    <li>deque</li>
    <li>forward_list</li>
    <li>list</li>
</ul>

<h2>容器适配器 Container Adaptors</h2>

<ul>
    <li>stack</li>
    <li>queue</li>
    <li>priority_queue</li>
</ul>

<h2>关联容器 Associative Containers</h2>

<ul>
    <li>set</li>
    <li>multiset</li>
    <li>map</li>
    <li>multimap</li>
</ul>

<h2>无序关联容器 Unordered Associative Containers</h2>

<ul>
    <li>unordered_set</li>
    <li>unordered_multiset</li>
    <li>unordered_map</li>
    <li>unordered_multimap</li>
</ul>

<em>更多参考资料: <a href="http://www.cplusplus.com/reference/stl/">http://www.cplusplus.com/reference/stl/</a></em>

<h1><a href="http://www.cplusplus.com/reference/array/array/">Array</a> <em>[C++11]</em></h1>

Array是固定大小的顺序容器, 它以固定的线性顺序存储特定数量的元素(注意<strong>不是</strong>特定的大小顺序). 在内部, Array不保存除了它包含的元素以外的任何数据(包括容器大小, 它是在编译期确定的值). 不同于vector, array不能动态改变大小. 大小为0的array是合法的, 但是它不应该被解引用(front, back和data成员函数). 不同于其他STL容器, swap两个array是一个线性操作, 会对每一个元素单独进行swap, 这一般被认为是一种低效操作.

<h2>部分成员函数</h2>

绝大部分array容器的成员函数时间复杂度都是常数时间复杂度.

<h3>array::data</h3>

<pre lang="c++"><code>value_type* data() noexcept;
const value_type* data() const noexcept;</code></pre>

返回指向array对象首个元素的指针. 因为元素是连续存储的, 因此可以用偏移量(<em>offset</em>)来访问array中的元素.

<h2>array::fill</h2>

<pre lang="c++"><code>void fill (const value_type&amp; val);</code></pre>

把array中的所有元素都设置为val.

<strong>时间复杂度:</strong> 线性.

<h2>array::swap</h2>

<pre lang="c++"><code>void swap (array&amp; x) noexcept(noexcept(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;())));</code></pre>

与array x交换内容.

<strong>时间复杂度:</strong> 线性.

<strong>迭代器合法性:</strong> 所有迭代器, 引用和指针的合法性都不会改变. 它们仍然与调用前相同的容器的相同位置相关联, 但是他们指向的值会是交换后的值.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>417</wp:post_id>
		<wp:post_date><![CDATA[2016-07-15 18:46:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-15 10:46:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[stl%e5%ae%b9%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b8%80-%e6%a0%87%e5%87%86%e5%ae%b9%e5%99%a8%e4%b8%8earray]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="stl"><![CDATA[STL]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 18. 4Sum</title>
		<link>http://xiadong.info/2016/07/leetcode-18-4sum/</link>
		<pubDate>Sat, 16 Jul 2016 15:13:31 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=424</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
  
  Note: The solution set must not contain duplicate quadruplets.

<pre><code>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</code></pre>
</blockquote>

这道题可以继续使用2Sum, 3Sum题目的方法, 在3Sum外面再增加一次处理. 还有另外一种使用HashMap的方法, 但是我现在还没有完全实现它, 主要问题在于最后的去重. 更多的信息可以参考这里:<a href="http://www.sigmainfy.com/blog/summary-of-ksum-problems.html">http://www.sigmainfy.com/blog/summary-of-ksum-problems.html</a>.

我的代码, 效率并不高:

<pre lang="c++"><code>class Solution {
    vector&lt;vector&lt;int&gt;&gt; fourSumRet;
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {
        sort(nums.begin(), nums.end());
        for(int i = 0; i &lt; nums.size(); i++){
            if(i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) continue;
            if(target &gt; 0 &amp;&amp; nums[i] &gt; target) break;
            threeSum(nums, target - nums[i], i + 1, nums.size());
        }
        return fourSumRet;
    }

    void threeSum(vector&lt;int&gt;&amp; nums, int target, int left, int right) {
        for(int i = left; i &lt; right; i++){
            if(i &gt;= left + 1 &amp;&amp; nums[i] == nums[i - 1]) continue;
            twoSum(nums, target - nums[i], i + 1, right, left - 1);
        }
    }

    void twoSum(vector&lt;int&gt;&amp; nums, int target, int left, int right, int fourSumIndex) {
        int l = left, r = right - 1;
        while(l &lt; r){
            int sum = nums[l] + nums[r];
            if(sum == target){
                vector&lt;int&gt; t = {nums[fourSumIndex], nums[left - 1], nums[l], nums[r]};
                fourSumRet.push_back(t);
                do{r--;}while(nums[r] == nums[r + 1]);
                do{l++;}while(nums[l] == nums[l - 1]);
            }
            else if(sum &gt; target){
                r--;
            }
            else{
                l++;
            }
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>424</wp:post_id>
		<wp:post_date><![CDATA[2016-07-16 23:13:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-16 15:13:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-18-4sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 19. Remove Nth Node From End of List</title>
		<link>http://xiadong.info/2016/07/leetcode-19-remove-nth-node-from-end-of-list/</link>
		<pubDate>Sun, 17 Jul 2016 08:49:05 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=426</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given a linked list, remove the n<sup>th</sup> node from the end of list and return its head.
  
  For example,

<pre><code>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.

After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
</code></pre>
  
  Note:
  
  Given n will always be valid.
  
  Try to do this in one pass.
</blockquote>

要求删除链表从后往前数第n个节点, 并且只遍历一次. 所以我采用一个vector来保存每个节点的指针, 遍历一次后从vector中找到倒数第n个节点并删除之.

<pre lang="c++"><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        vector&lt;ListNode*&gt; listPointer;
        ListNode* p = head;
        while(p != nullptr){
            listPointer.push_back(p);
            p = p-&gt;next;
        }

        int len = listPointer.size(), toDeleteIndex = len - n;
        ListNode* toDelete = listPointer[toDeleteIndex];
        if(toDeleteIndex == 0){
            return head-&gt;next;
        }
        else{
            ListNode* prev = listPointer[toDeleteIndex - 1];
            prev-&gt;next = toDelete-&gt;next;
            return head;
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>426</wp:post_id>
		<wp:post_date><![CDATA[2016-07-17 16:49:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-17 08:49:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-19-remove-nth-node-from-end-of-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 20. Valid Parentheses</title>
		<link>http://xiadong.info/2016/07/leetcode-20-valid-parentheses/</link>
		<pubDate>Sun, 17 Jul 2016 09:05:53 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=428</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
  
  The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.
</blockquote>

要求判断输入字符串中的括号是否正确匹配, 因为括号要正确闭合, 因此使用计数器来记录左右括号数量是不行的. 我用栈来保存所有的左括号, 每遇到一个右括号就与栈顶端的左括号匹配, 不匹配则返回false, 匹配则将栈顶括号出栈. 循环过程中如果出现栈为空, 或者循环结束后栈不为空则返回false. 其他情况返回true.

<pre lang="c++"><code>class Solution {
public:
    bool isValid(string s) {
        vector&lt;char&gt; bracket;
        for(auto i : s){
            if(i == '(' || i == '[' | i == '{')
                bracket.push_back(i);
            else{
                if(bracket.empty())
                    return false;
                else if( (i == ')' &amp;&amp; bracket.back() == '(') || (i == ']' &amp;&amp; bracket.back() == '[') || (i == '}' &amp;&amp; bracket.back() == '{'))
                    bracket.pop_back();
                else
                    return false;
            }
        }

        return bracket.empty() ? true : false;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>428</wp:post_id>
		<wp:post_date><![CDATA[2016-07-17 17:05:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-17 09:05:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-20-valid-parentheses]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 21. Merge Two Sorted Lists</title>
		<link>http://xiadong.info/2016/07/leetcode-21-merge-two-sorted-lists/</link>
		<pubDate>Sun, 17 Jul 2016 09:58:43 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=430</guid>
		<description></description>
		<content:encoded><![CDATA[问题描述:

<blockquote>
  Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
</blockquote>

简单的链表操作。

<pre lang="c++"><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1 == NULL &amp;&amp; l2 == NULL)return NULL;
        if(l1 == NULL)return l2;
        if(l2 == NULL)return l1;
        ListNode *head = new ListNode(0), *l1Node = l1, *l2Node = l2, *p = head;
        while(l1Node || l2Node){
            if(!l1Node){
                p-&gt;next = l2Node;
                break;
            }
            else if(!l2Node){
                p-&gt;next = l1Node;
                break;
            }
            else{
                if(l1Node-&gt;val &lt; l2Node-&gt;val){
                    p-&gt;next = l1Node;
                    l1Node = l1Node-&gt;next;
                }
                else{
                    p-&gt;next = l2Node;
                    l2Node = l2Node-&gt;next;
                }
            }
            p = p-&gt;next;
        }
        return head-&gt;next;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>430</wp:post_id>
		<wp:post_date><![CDATA[2016-07-17 17:58:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-17 09:58:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-21-merge-two-sorted-lists]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>STL容器学习笔记二 - Deque</title>
		<link>http://xiadong.info/2016/07/stl%e5%ae%b9%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%ba%8c-deque/</link>
		<pubDate>Sun, 17 Jul 2016 11:06:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=432</guid>
		<description></description>
		<content:encoded><![CDATA[<h1><a href="http://www.cplusplus.com/reference/deque/deque/">Deque</a>简介</h1>

deque(读作<em>deck</em>)是双向队列的缩写(<strong>d</strong>ouble-<strong>e</strong>nded <strong>que</strong>ue), 它是可以在两端动态变更大小的顺序容器.

不同的库可能会以不同的方法来实现deque, 但不管怎样, 它们都允许通过随机访问迭代器访问特定元素, 并且根据需要自动管理存储空间.

deque提供与vector相似的功能, 但是允许首尾两端高效的插入删除元素而不是像vector一样只能在尾部. <strong>但是</strong>, deque不像vector一样保证使用顺序存储空间来保存元素, 因此如果通过指针和偏移量访问deque中的另一个元素会引发<strong>未定义行为</strong>.

Vector与deque提供相似的接口并且可以用于相似的用途, 但它们的内部实现确完全不同. Vector使用一个在元素数量增长时偶尔需要重新分配空间的数组, 而deque中的元素可以分散存储在内存中的不同位置, deque容器内部通过保存必要的信息来提供在常数时间内访问任意元素的功能, 并且通过迭代器提供一个统一的顺序访问接口. 因此, deque的内部实现比vector要复杂, 但是这使得它在特定情况下可以更高效的增长, 比如在序列非常长时, 重新分配空间会非常耗时.

对于需要在首尾以外的位置频繁插入删除的操作来说, deque比list和forward list表现要差.

<h1>容器属性</h1>

<h2>顺序</h2>

顺序容器中的元素都遵循严格的线性序列, 每个元素都可以通过他们在序列中的位置来访问.

<h2>动态数组</h2>

通常实现类似于动态数组, 提供随机访问序列中任意元素的能力并且提供在序列首尾高效插入/删除的操作.

<h2>Allocator-aware[?]</h2>

容器使用一个allocator对象来动态管理存储空间.

<h1>部分函数</h1>

一些常用的函数比如<code>size</code>, <code>back</code>, <code>push_back</code>, <code>pop_back</code>, <code>push_front</code>, <code>pop_front</code>等我就不再赘述了

<h2>构造函数</h2>

<h3>默认构造函数 <em>Default constructor</em></h3>

<pre lang="c++"><code>explicit deque (const allocator_type&amp; alloc = allocator_type());
</code></pre>

创建一个空容器.

<h3>填充构造函数 <em>Fill constructor</em></h3>

<pre lang="c++"><code>explicit deque (size_type n);
         deque (size_type n, const value_type&amp; val,
                const allocator_type&amp; alloc = allocator_type());
</code></pre>

创建一个有n个元素的容器, 如果提供了val, 则n个元素的值都为val.

<h3>范围构造函数 <em>Range constructor</em></h3>

<pre lang="c++"><code>template &lt;class InputIterator&gt;
  deque (InputIterator first, InputIterator last,
         const allocator_type&amp; alloc = allocator_type());
</code></pre>

构建一个数量与[first, last)相同的容器, 以与之相同的顺序初始化每个元素.

<h3>拷贝构造函数</h3>

<pre lang="c++"><code>deque (const deque&amp; x);
deque (const deque&amp; x, const allocator_type&amp; alloc);
</code></pre>

创建一个以x中的元素的拷贝组成的容器.

<h3>移动构造函数 <em>Move constructor</em></h3>

<pre lang="c++"><code>deque (deque&amp;&amp; x);
deque (deque&amp;&amp; x, const allocator_type&amp; alloc);
</code></pre>

创建一个由从x中取得的元素组成的容器, 下面这句话我没有太看懂:

<blockquote>If alloc is specified and is different from x's allocator, the elements are moved. Otherwise, no elements are constructed (their ownership is directly transferred).
</blockquote>

x会保持一个未定义但合法的状态.

<h3>初始化列表构造函数</h3>

<pre lang="c++"><code>deque (initializer_list&lt;value_type&gt; il,
       const allocator_type&amp; alloc = allocator_type());
</code></pre>

以il中元素的顺序用每个元素的拷贝创建一个容器.

<h3>例子</h3>

<pre lang="c++"><code>// code url: http://www.cplusplus.com/reference/deque/deque/deque/
// constructing deques
#include &lt;iostream&gt;
#include &lt;deque&gt;

int main ()
{
    unsigned int i;

    // constructors used in the same order as described above:
    std::deque&lt;int&gt; first;                                // empty deque of ints
    std::deque&lt;int&gt; second (4,100);                       // four ints with value 100
    std::deque&lt;int&gt; third (second.begin(),second.end());  // iterating through second
    std::deque&lt;int&gt; fourth (third);                       // a copy of third

    // the iterator constructor can be used to copy arrays:
    int myints[] = {16,2,77,29};
    std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) );

    std::cout &lt;&lt; "The contents of fifth are:";
    for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it)
        std::cout &lt;&lt; ' ' &lt;&lt; *it;

    std::cout &lt;&lt; '\n';

    return 0;
}
</code></pre>

输出

<pre lang="c++"><code>The contents of fifth are: 16 2 77 29
</code></pre>

<h2>deque::assign</h2>

<strong>range (1)</strong>

<pre lang="c++"><code>template &lt;class InputIterator&gt;
void assign (InputIterator first, InputIterator last);
</code></pre>

<strong>fill (2)</strong>

<pre lang="c++"><code>void assign (size_type n, const value_type&amp; val);
</code></pre>

<strong>initializer list (3)</strong>

<pre lang="c++"><code>void assign (initializer_list&lt;value_type&gt; il);
</code></pre>

重新配置deque中的内容, 并相应地调整大小. 使用方法类似于相应的构造函数.

<h2>deque::clear</h2>

<pre lang="c++"><code>void clear() noexcept;
</code></pre>

清空容器中的所有元素.

<strong>时间复杂度:</strong> 与size有关的线性(因为要执行元素的析构函数).

<h2>deque::max_size</h2>

<pre lang="c++"><code>size_type max_size() const noexcept;
</code></pre>

返回deque容器所能保存的最大元素数量. 但是deque不保证一定能达到这个数量.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>432</wp:post_id>
		<wp:post_date><![CDATA[2016-07-17 19:06:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-17 11:06:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[stl%e5%ae%b9%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%ba%8c-deque]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="stl"><![CDATA[STL]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 22. Generate Parentheses</title>
		<link>http://xiadong.info/2016/07/leetcode-22-generate-parentheses/</link>
		<pubDate>Mon, 18 Jul 2016 09:32:24 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=435</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:
<pre><code>[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
</code></pre>
</blockquote>

题目要求输出n个括号的所有组合. 每个合法的字符串的长度都是<code>2*n</code>, 其中每个位置的字符有两种可能: 左括号和右括号. 因此循环<code>2*n</code>次, 每次对于结果集ret中的每个字符串末尾添加括号, 判断两种情况哪一种合法.或者两种都合法.

<strong>左括号合法的情况</strong>

字符串中出现的左括号总数没有超过<code>n</code>, 则在尾部添加左括号总是合法的.

<strong>右括号合法的情况</strong>

字符串中含有未配对的左括号. 注意: 如果左括号总数没有超过<code>n</code>, 那么该字符串添加左右括号都是合法的, 因此要在结果集末尾增加一条; 如果已经有了<code>n</code>个左括号, 那么只能添加右括号.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; ret = {"("};
        vector&lt;int&gt; leftNum = {1};   //ret中每个字符串中左括号的数量
        vector&lt;int&gt; singleLeftNum = {1};  //ret中每个字符串中未配对的左括号数量
        int strLen = n * 2;
        for(int i = 1; i &lt; strLen; i++){
            int len = ret.size();
            for(int j = 0; j &lt; len; j++){
                if(singleLeftNum[j] &gt; 0){
                    if(leftNum[j] == n){
                        ret[j].push_back(')');
                        singleLeftNum[j]--;
                    }
                    else{
                        ret.push_back(ret[j] + ")");
                        leftNum.push_back(leftNum[j]);
                        singleLeftNum.push_back(singleLeftNum[j] - 1);
                    }
                }
                if(leftNum[j] &lt; n){
                    ret[j].push_back('(');
                    leftNum[j]++;
                    singleLeftNum[j]++;
                }
            }
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>435</wp:post_id>
		<wp:post_date><![CDATA[2016-07-18 17:32:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-18 09:32:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-22-generate-parentheses]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 23. Merge k Sorted Lists</title>
		<link>http://xiadong.info/2016/07/leetcode-23-merge-k-sorted-lists/</link>
		<pubDate>Mon, 18 Jul 2016 10:13:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=437</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</blockquote>

合并k个有序链表. 首先创建一个小顶堆(比较的是每个链表节点的值, 我直接使用了set，或者优先队列也可以), 其中的元素是k个链表的头结点, 每次取出堆顶的节点, 加入到合并后的链表中, 然后将这个节点的后一个节点放入堆中, 如果是链表尾则不放入. 重复这个步骤直到堆为空.

由于建n个元素的堆的时间复杂度为O(n)(证明见: <a href="http://blog.csdn.net/anonymalias/article/details/8807895">http://blog.csdn.net/anonymalias/article/details/8807895</a>). 假设共有n个节点, 总的时间复杂度约为<code>O(k)+O(nlogk)</code>(我并不太会算复杂度, 这个也只是估计的...).

<pre lang="c++"><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        auto comp = [=](ListNode *a, ListNode *b){
            return a-&gt;val &lt;= b-&gt;val;
        };
        ListNode *head = new ListNode(0), *p = head;
        if(lists.empty()) return head-&gt;next;
        set&lt;ListNode*, decltype(comp)&gt; s(comp);
        for(int i = 0; i &lt; lists.size(); i++){
            if(lists[i] != nullptr){
                s.insert(lists[i]);
            }
        }
        while(!s.empty()){
            ListNode *node = *(s.begin());
            s.erase(s.begin());
            if(node-&gt;next != nullptr) s.insert(node-&gt;next);
            p-&gt;next = node;
            p = p-&gt;next;
        }
        return head-&gt;next;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>437</wp:post_id>
		<wp:post_date><![CDATA[2016-07-18 18:13:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-18 10:13:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-23-merge-k-sorted-lists]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 24. Swap Nodes in Pairs</title>
		<link>http://xiadong.info/2016/07/leetcode-24-swap-nodes-in-pairs/</link>
		<pubDate>Mon, 18 Jul 2016 10:18:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=440</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given a linked list, swap every two adjacent nodes and return its head.
  
  For example,
  Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.
  
  Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
</blockquote>

交换链表相邻节点。

C++:

<pre lang="c++"><code>class Solution {
public:
    ListNode *swapPairs(ListNode *head) {
        if(head == NULL || head-&gt;next == NULL) return head;
        ListNode *first = head, *second = head-&gt;next, *prev = NULL;
        first-&gt;next = second-&gt;next;
        second-&gt;next = first;
        head = second;
        prev = first;
        first = first-&gt;next;
        while(first){
            second = first-&gt;next;
            if(second == NULL)break;
            first-&gt;next = second-&gt;next;
            second-&gt;next = first;
            prev-&gt;next = second;
            prev = first;
            first = first-&gt;next;
        }
        return head;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>440</wp:post_id>
		<wp:post_date><![CDATA[2016-07-18 18:18:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-18 10:18:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-24-swap-nodes-in-pairs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 25. Reverse Nodes in k-Group</title>
		<link>http://xiadong.info/2016/07/leetcode-25-reverse-nodes-in-k-group/</link>
		<pubDate>Wed, 20 Jul 2016 09:37:14 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=443</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.
Only constant memory is allowed.
For example,
Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>
For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code>
For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code>
</blockquote>

以k个节点为一组进行顺序颠倒. 首先实现一个从某个节点开始, 把包括它的接下来的k个节点的顺序颠倒的函数, 再不断迭代这个函数直到链表末尾. 由于如果链表长度不是k的整数倍的话, 最后的<code>m(m&lt;k)</code>个元素不进行处理, 所以先计算出链表的总长度<code>len</code>, 在每次迭代时计算已经处理过的节点数<code>reversedLen</code>, 当<code>reversedLen + k &gt; len</code>时结束循环.

<pre lang="c++"><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* reverse(ListNode* prev, int k){
        if(!prev-&gt;next) return nullptr;
        ListNode *tail = prev-&gt;next, *pPrev = tail, *pCur = pPrev-&gt;next;
        for(int i = 1; pCur &amp;&amp; i &lt; k; i++){
            ListNode *pNext = pCur-&gt;next;
            pCur-&gt;next = pPrev;
            pPrev = pCur;
            pCur = pNext;
        }
        prev-&gt;next = pPrev;
        tail-&gt;next = pCur;
        return tail;
    }

    int countListLength(ListNode *list){
        int len = 0;
        ListNode *p = list;
        while(p){
            len++;
            p = p-&gt;next;
        }
        return len;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr || k &lt;= 1)
            return head;
        ListNode *trueHead = new ListNode(0), *p = trueHead;
        trueHead-&gt;next = head;
        int listLen = countListLength(head);
        int reversedLen = 0;

        while(true){
            if(reversedLen + k &gt; listLen) break;
            p = reverse(p, k);
            reversedLen += k;
        }
        return trueHead-&gt;next;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>443</wp:post_id>
		<wp:post_date><![CDATA[2016-07-20 17:37:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-20 09:37:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-25-reverse-nodes-in-k-group]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 26. Remove Duplicates from Sorted Array</title>
		<link>http://xiadong.info/2016/07/leetcode-26-remove-duplicates-from-sorted-array/</link>
		<pubDate>Wed, 20 Jul 2016 10:13:09 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=445</guid>
		<description></description>
		<content:encoded><![CDATA[问题描述:

<blockquote>
  Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
  
  Do not allocate extra space for another array, you must do this in place with constant memory.
  
  For example,
  Given input array nums = [1,1,2],
  
  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.
</blockquote>

对一个有序数组去重, 并且要求不使用额外的存储空间. 

首先解决的是去重的问题, 如果没有额外空间的限制, 首先想到的是创建一个新的数组, 然后遍历nums, 大于新数组末尾的数则把当前的数加入新数组. 这里数组末尾的数其实就是已经遍历过的最大值, 因此可以用一个变量来保存.

接下来是存储空间的问题, 由于nums中每个数在遍历时的作用只是与当前遍历过的最大值比较, 而已经遍历过的数是没有什么作用的, 所以可以使用已经遍历过的nums数所占的空间.

<pre lang="c++"><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
        }
        return num;
    }
};
</code></pre>

这段代码的Runtime是36毫秒, 但是许多AC代码的Runtime都在32ms, 说明这个程序还有一定的优化空间.

首先循环体内部的操作已经非常简洁, 应该很难有所作为, 所以优化的目标应该在循环次数上. 先将nums中最大的数保存下来, 当遍历到与该值相等的时候, 把这个数处理完后就可以退出循环了. 所以最终代码:

<pre lang="c++"><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        int maxItem = nums.empty() ? 0 : nums.back();
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
            if(nums[i] == maxItem){
                break;
            }
        }
        return num;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>445</wp:post_id>
		<wp:post_date><![CDATA[2016-07-20 18:13:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-20 10:13:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-26-remove-duplicates-from-sorted-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 27. Remove Element</title>
		<link>http://xiadong.info/2016/07/leetcode-26-remove-duplicates-from-sorted-array-2/</link>
		<pubDate>Wed, 20 Jul 2016 10:21:42 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=447</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array and a value, remove all instances of that value in place and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example:
Given input array nums = [3,2,2,3], val = 3

Your function should return length = 2, with the first two elements of nums being 2.</blockquote>

采用与<a href="http://xiadong.info/2016/07/leetcode-26-remove-duplicates-from-sorted-array">上一题</a>类似的方法, 用已经遍历过的元素所占的空间来保存结果.

<pre lang="c++"><code>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int len = nums.size(), ret = 0;
        for(int i = 0, j = 0; i &lt; len; i++){
            if(nums[i] != val){
                nums[j++] = nums[i];
                ret++;
            }
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>447</wp:post_id>
		<wp:post_date><![CDATA[2016-07-20 18:21:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-20 10:21:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-26-remove-duplicates-from-sorted-array-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>STL容器学习笔记三 - Forward_list</title>
		<link>http://xiadong.info/2016/07/stl%e5%ae%b9%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b8%89-forward_list/</link>
		<pubDate>Wed, 20 Jul 2016 11:18:15 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=449</guid>
		<description></description>
		<content:encoded><![CDATA[<h1><a href="http://www.cplusplus.com/reference/forward_list/forward_list/">Forward list</a> 前向链表[C++11]</h1>

前向链表是提供常数复杂度的插入删除操作的容器, 它被实现为一个单链接链表.

<code>forward_list</code>与<code>list</code>的区别在于前者保存指向每个节点的后一个节点的指针, 而后者保存前后两个节点的指针. <code>forward_list</code>比<code>list</code>稍微高效, 但是缺点在于只能向前遍历.

与其他顺序容器相比主要优点在于在容器任意位置插入, 提取和移动的表现更好. 不足在于不能根据元素在容器中的位置来访问元素.

<code>forward_list</code>被设计得非常高效, 它与一个简单的C语言手写单向链表的效率相当. 实际上, <strong>它是唯一一个出于性能考虑而不提供<code>size</code>成员函数的标准容器</strong>.

<h1>部分函数</h1>

只列举一些我不太熟悉的函数.

<h2>构造函数</h2>

<h3>默认构造函数</h3>

<pre lang="c++"><code>explicit forward_list (const allocator_type&amp; alloc = allocator_type());
</code></pre>

创建一个空容器.

<h3>填充构造函数</h3>

<pre lang="c++"><code>explicit forward_list (size_type n);
explicit forward_list (size_type n, const value_type&amp; val,
                        const allocator_type&amp; alloc = allocator_type());
</code></pre>

创建一个大小为n的容器, 如果提供了val, 则n个值都初始化为val.

<h3>范围构造函数</h3>

<pre lang="c++"><code>template &lt;class InputIterator&gt;
  forward_list (InputIterator first, InputIterator last,
                const allocator_type&amp; alloc = allocator_type());
</code></pre>

用<code>[first, last)</code>中的数据初始化.

<h3>拷贝构造函数</h3>

<pre lang="c++"><code>forward_list (const forward_list&amp; fwdlst);
forward_list (const forward_list&amp; fwdlst, const allocator_type&amp; alloc);
</code></pre>

<h3>移动构造函数</h3>

<pre lang="c++"><code>forward_list (forward_list&amp;&amp; fwdlst);
forward_list (forward_list&amp;&amp; fwdlst, const allocator_type&amp; alloc);
</code></pre>

除非alloc的类型与fwdlst不一致, 否则不会构造任何一个元素, 它们的所有权被直接转移.

<h3>初始化列表</h3>

<pre lang="c++"><code>forward_list (initializer_list&lt;value_type&gt; il,
              const allocator_type&amp; alloc = allocator_type());
</code></pre>

<h2>forward_list::before<em>_</em>begin</h2>

<pre lang="c++"><code>      iterator before_begin() noexcept;
const_iterator before_begin() const noexcept;
</code></pre>

返回指向容器中首个元素之前的元素的迭代器. 该迭代器不能解引用, 主要作为成员函数<code>emplace_after</code>, <code>insert_after</code>, <code>erase_after</code>和<code>splice_after</code>的参数.

<h2>forward_list::emplace_after</h2>

<pre lang="c++"><code>template &lt;class... Args&gt;
    iterator emplace_after (const_iterator position, Args&amp;&amp;... args);
</code></pre>

在position的位置之后插入元素, args为插入的新元素的初始化参数.

<h2>forward_list::emplace_front</h2>

<pre lang="c++"><code>template &lt;class... Args&gt;
    void emplace_front (Args&amp;&amp;... args);
</code></pre>

在容器头部插入新元素, args为插入的新元素的初始化参数.

<h2>forward_list::erase_after</h2>

<pre lang="c++"><code>iterator erase_after (const_iterator position);
iterator erase_after (const_iterator position, const_iterator last);
</code></pre>

删除容器中position之后的一个元素或者(position, last)范围内的元素.

<h2>forward_list::merge</h2>

<pre lang="c++"><code>    void merge (forward_list&amp; fwdlst);
    void merge (forward_list&amp;&amp; fwdlst);
template &lt;class Compare&gt;
    void merge (forward_list&amp; fwdlst, Compare comp);
template &lt;class Compare&gt;
    void merge (forward_list&amp;&amp; fwdlst, Compare comp);
</code></pre>

根据指定顺序将fwdlst与当前容器合并.

<h2>forward_list::remove_if</h2>

<pre lang="c++"><code>template &lt;class Predicate&gt;
    void remove_if (Predicate pred);
</code></pre>

对容器中的每个元素, 执行pred(以<code>pred(*i)</code>的形式), 如果为true则删除该元素.

pred可以为函数指针或者函数对象.

<h2>forward_list::sort</h2>

<pre lang="c++"><code>    void sort();
template &lt;class Compare&gt;
    void sort (Compare comp);
</code></pre>

排序函数, 该函数是稳定排序. 整个操作不包括任何的元素构造, 析构和复制. 元素只是在容器内移动.

<strong>时间复杂度</strong>: NlogN.

<h2>forward_list::unique</h2>

<pre lang="c++"><code>void unique();
template &lt;class BinaryPredicate&gt;
    void unique (BinaryPredicate binary_pred);
</code></pre>

删除重复元素. <strong>这个操作只会删除与前一个元素相同的元素, 也就是说只能用于已经排序的容器.</strong>

第二种形式中的参数binary_pred以<code>binary_pred(*i, *(i - 1))</code>的形式调用, 此函数返回true则认为两个元素相等.

binary_pred可以为函数指针或者函数对象.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>449</wp:post_id>
		<wp:post_date><![CDATA[2016-07-20 19:18:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-20 11:18:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[stl%e5%ae%b9%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b8%89-forward_list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="stl"><![CDATA[STL]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>关于给父母分享照片</title>
		<link>http://xiadong.info/2016/07/%e5%85%b3%e4%ba%8e%e7%bb%99%e7%88%b6%e6%af%8d%e5%88%86%e4%ba%ab%e7%85%a7%e7%89%87/</link>
		<pubDate>Thu, 21 Jul 2016 09:29:07 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=454</guid>
		<description></description>
		<content:encoded><![CDATA[关于照片存储备份的问题, 我现在用的Google相册, 虽然按照Google的尿性说不定哪天就给关了, 但是现在用起来还是挺方便的. 但是本来应该是主要功能的照片分享功能却由于那说是不存在但是却是确确实实无处不在的GFW的原因而变得几乎不可用. 尤其是对于我父母这样别说搭梯子, 百度云都不会用(我也不敢给他们用百度)的, 分享照片更是非常麻烦.

我先来总结一下给我父母这样的用户分享照片所需要的服务应该有什么样的特性:

<ul>
    <li>访问方便, 便于查找; 也就是说可生成分享链接或者与社交网络绑定</li>
    <li>国内访问速度快; 这就没有了用Google相册或者Flickr之类服务的可能</li>
    <li>稳定; 谁都不想过一段时间服务就关闭了</li>
    <li>要有相册管理功能, 至少缩略图之类应该具备</li>
    <li>免费</li>
    <li>最好有权限访问控制, 因为与父母分享的照片不少是不想公开的</li>
    <li>手机访问支持比较好</li>
</ul>

出于以上的几点, 我首先排除了国内的所有网盘, 因为它们基本都没有相册管理功能; 然后把目标划定在国内大型的互联网企业上. 至于iCloud, 小米, 华为等公司推出的云相册服务因为与要与设备绑定所以也排除. 百度家的东西排除, 网易相册的iOS客户端快三年没有更新了也不知道还能挺多久, 而且初始容量只有1G, 超出后只有每月300M, 有点不太够用. 至于阿里似乎没有推出过这种服务.

剩下的考虑企鹅, 不得不说企鹅的占有率真是厉害, 我父母手机上使用频率最高的应用就是微信了. 所以我一直用朋友圈来给父母分享一些照片. 但是这问题仍然很大, 首先是一次只能选择9张, 我一次上传一千多张根本就是不可能; 其次是微信对于图片压缩地太厉害, 基本上属于放大就不能看; 然后是没有PC端, 电脑上的许多照片不可能都传到手机上. 所以我每次都是选几张照片传上去.

直到昨天, 我突然心血来潮打开了尘封已久的QQ空间, 突然发现QQ空间相册竟然支持原图上传(其实我忘记了它以前支不支持), 并且有了只允许部分好友查看的功能. 突然觉得这就是我想要的与父母分享照片的工具. 父母都有QQ号并且可以通过手机QQ客户端查看; 可以保存原图, 不压缩画质(<strong>实测分辨率不变但是体积减少100-200kB左右, 并且不提供批量下载功能, 加上下载后会丢失EXIF信息, 因此不太适合做照片备份</strong>); 有访问权限控制; 国内访问速度有保障; 可以在PC端上传图片; 服务免费, 我现在有30G容量, 虽然不大, 但也勉强够用(而且不知道它是怎么计算容量的, 我昨天上传了1000+张3M左右的照片原图, 但是现在只显示用了0.4G).

关于安全和隐私, 企鹅虽然不能说很安全, 但是也算是有底线. 而想要隐私的话, 东西还是根本不要放到网上为好.

对我来说, 目前用QQ空间的相册功能算是给父母分享照片的最佳方案了.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>454</wp:post_id>
		<wp:post_date><![CDATA[2016-07-21 17:29:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-21 09:29:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e7%bb%99%e7%88%b6%e6%af%8d%e5%88%86%e4%ba%ab%e7%85%a7%e7%89%87]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 376. Wiggle Subsequence</title>
		<link>http://xiadong.info/2016/07/leetcode-376-wiggle-subsequence/</link>
		<pubDate>Thu, 21 Jul 2016 11:26:12 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=459</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.
  
  For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.
  
  Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.
  
  Examples:

<pre><code>Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
</code></pre>
  
  Follow up:
  Can you do it in O(n) time?
</blockquote>

使用动态规划, 只需要保存当前节点与之前一个节点的信息.

<pre lang="c++"><code>class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len &lt;= 2) return len;
        int maxLen = 2, diff = nums[1] - nums[0];
        for(int i = 2; i &lt; len; i++){
            int d = nums[i] - nums[i - 1];
            if(d &amp;&amp; diff &amp;&amp; ((d ^ diff) &amp; 0x80000000)){
                maxLen++;
            }
            if(d != 0){
                diff = d;
            }
        }
        return maxLen;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>459</wp:post_id>
		<wp:post_date><![CDATA[2016-07-21 19:26:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-21 11:26:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-376-wiggle-subsequence]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 28. Implement strStr()</title>
		<link>http://xiadong.info/2016/07/leetcode-28-implement-strstr/</link>
		<pubDate>Fri, 22 Jul 2016 11:20:41 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=461</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Implement strStr().
  
  Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
</blockquote>

实现查找子串函数. 使用双重循环.

<pre lang="c++"><code>class Solution {
public:
    int strStr(string haystack, string needle) {
        int haylength = haystack.length(), needlelength = needle.length();
        if(haylength &lt; needlelength) return -1;
        for(int i = 0; i &lt;= haylength - needlelength; i++){
            int j;
            for(j = 0; j &lt; needlelength; j++){
                if(haystack[i + j] != needle[j]) break;
            }
            if(j == needlelength)
                return i;
        }

        return -1;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>461</wp:post_id>
		<wp:post_date><![CDATA[2016-07-22 19:20:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-22 11:20:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-28-implement-strstr]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 29. Divide Two Integers</title>
		<link>http://xiadong.info/2016/07/leetcode-29-divide-two-integers/</link>
		<pubDate>Sat, 23 Jul 2016 10:00:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=465</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:</p>

<blockquote>
  Divide two integers without using multiplication, division and mod operator.
  
  If it is overflow, return MAX_INT.
</blockquote>

不使用乘除和取模运算实现整数除法. 我的实现方法是使用位运算来实现二进制除法, 首先确定结果的符号位后取得被除数与除数的绝对值, 这样就可以只考虑原码不用考虑补码除法. 需要注意的是对于<code>INT_MIN</code>这个值(也就是-2147483648)要特殊处理, 因为它的值是这样的: <code>0x80000000</code>, 也就是只有最高位是1, <code>abs</code>函数无法对这个值取绝对值, 而且可能造成溢出问题.

关于二进制除法可以参考这里: <a href="http://www.tyut.edu.cn/kecheng1/2008/site08/courseware/chapter1/1.2.htm">http://www.tyut.edu.cn/kecheng1/2008/site08/courseware/chapter1/1.2.htm</a>

<blockquote>
  二进制数除法与十进制数除法很类似。可先从被除数的最高位开始，将被除数（或中间余数）与除数相比较，若被除数（或中间余数）大于除数，则用被除数（或中间余数）减去除数，商为1，并得相减之后的中间余数，否则商为0。再将被除数的下一位移下补充到中间余数的末位，重复以上过程，就可得到所要求的各位商数和最终的余数。
</blockquote>

代码:

<pre lang="c++"><code>class Solution {
public:
    int divide(int dividend, int divisor) {
        if(divisor == 0) return INT_MAX;
        int sign = (dividend ^ divisor) &amp; 0x80000000 ? -1 : 1;
        int absDividend = abs(dividend), absDivisor = abs(divisor);
        if(dividend == INT_MIN){
            if(divisor == -1) return INT_MAX;
            else absDividend = INT_MIN;
        }
        else{
            if(absDividend &lt; absDivisor) return 0;
        }

        return sign * absDivid(absDividend, absDivisor);
    }

    int absDivid(unsigned int dividend, unsigned int divisor){
        int mDividend = getBit(dividend, 31), ret = 0;
        for(int i = 31; i &gt;= 0; i--){
            if(mDividend &gt;= divisor){
                ret |= (1 &lt;&lt; i);
                mDividend = mDividend - divisor;
            }
            if(i != 0){
                mDividend = (mDividend &lt;&lt; 1) + getBit(dividend, i - 1);
            }
        }
        return ret;
    }

    int getBit(unsigned int n, int p){
        return n &amp; (1 &lt;&lt; p) ? 1 : 0;
    }
};
</code></pre>

这段代码是默认<code>int</code>类型长度是4个字节.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>465</wp:post_id>
		<wp:post_date><![CDATA[2016-07-23 18:00:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-23 10:00:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-29-divide-two-integers]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[29-divide-two-integers]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 30. Substring with Concatenation of All Words</title>
		<link>http://xiadong.info/2016/07/leetcode-30-substring-with-concatenation-of-all-words/</link>
		<pubDate>Sat, 23 Jul 2016 14:41:48 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=467</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

For example, given:

s: "barfoothefoobarman"

words: ["foo", "bar"]

You should return the indices: [0,9].

(order does not matter).</blockquote>

首先使用暴力法, 将words中的词放入一个哈希表中, 这样可以在常数时间内找到它. 然后用一个双重循环来遍历字符串s.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; ret;
        int wordsLen = words.size();
        if(wordsLen == 0)
            return ret;
        int wordLen = words[0].length(), sLen = s.length(), totalLen = wordsLen * wordLen;

        unordered_map&lt;string, int&gt; wordExistOrig;

        for(int i = 0; i &lt; wordsLen; i++){
            if(wordExistOrig.count(words[i])){
                wordExistOrig[words[i]]++;
            }
            else{
                wordExistOrig[words[i]] = 1;
            }
        }

        for(int i = 0; i &lt;= sLen - totalLen; i++){
            unordered_map&lt;string, int&gt; wordExist = wordExistOrig;
            bool valid = true;
            for(int j = i; j &lt; totalLen + i; j += wordLen){
                string str = s.substr(j, wordLen);
                if(wordExist.count(str) == 0) {
                    valid = false;
                    break;
                }
                else{
                    wordExist[str]--;
                    if(wordExist[str] &lt; 0){
                        valid = false;
                        break;
                    }
                }
            }
            if(valid) ret.push_back(i);
        }

        return ret;
    }
};
</code></pre>

还可以使用一种"滑动窗口"方法, 或者是双指针方法, 思路参考这里: <a href="http://www.2cto.com/kf/201406/311648.html">http://www.2cto.com/kf/201406/311648.html</a>. 举例来说比如题目中的例子: <code>"barfoothefoobarman"</code>和数组<code>["foo", "bar"]</code>, 首先窗口长度为0, 起始位置为0, 窗口长度和起始位置都是以单词长度的整数倍变化的, 这里是3, 首先把第一个单词放进窗口(用<code>{}</code>来表示窗口): <code>{bar}foothefoobarman</code>, 由于<code>foo</code>和<code>bar</code>每个都只出现一次, 所以把<code>bar</code>的剩余次数(这个次数保存在hash表中)减1变为0, 接下来把下一个单词放入窗口: <code>{barfoo}thefoobarman</code>, 同样把<code>foo</code>的次数减1变为0, 这时窗口中已经有两个单词, 与words数组的大小相同, 就可以把当前的窗口起始位置放入结果集中. 接下来是单词<code>the</code>, 这个单词在words数组中没有, 所以窗口可以直接跳过它, 将窗口起始位置越过的<code>bar</code>和<code>foo</code>的允许出现次数加1, 此时窗口位置位于<code>barfoothe{}foobarman</code>, 然后重复这个步骤. 为了不忽略类似<code>abarfoo</code>这种字符串中的结果, 所以要将窗口起始位置从0到单词长度3遍历一次.

代码如下, 运行时间36ms:

<pre lang="c++"><code>class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; ret;
        int wordsLen = words.size();
        if (wordsLen == 0)
            return ret;
        int wordLen = words[0].length(), sLen = s.length(), totalLen = wordsLen * wordLen;

        unordered_map&lt;string, int&gt; wordExist;

        for (int i = 0; i &lt; wordsLen; i++) {
            if (wordExist.count(words[i])) {
                wordExist[words[i]]++;
            }
            else {
                wordExist[words[i]] = 1;
            }
        }
        for (int i = 0; i &lt; wordLen; i++) {
            int slideLeft = i, j = i, wordFound = 0;

            while (slideLeft &lt;= sLen - totalLen &amp;&amp; j &lt; sLen) {
                string str = s.substr(j, wordLen);
                if (wordExist.count(str) == 0) {
                    //下一个单词不再words中时将窗口初始位置移到当前之后的位置
                    j += wordLen;
                    for (; slideLeft &lt; j; slideLeft += wordLen) {
                        string toDropStr = s.substr(slideLeft, wordLen);
                        if(wordExist.count(toDropStr))wordExist[toDropStr]++;
                    }
                    //slideLeft = j;
                    wordFound = 0;
                    continue;
                }
                if (wordFound == wordsLen) {
                    //当窗口满的时候丢弃最前端的字符串
                    string toDropStr = s.substr(slideLeft, wordLen);
                    wordExist[toDropStr]++;
                    slideLeft += wordLen;
                    wordFound--;
                }
                wordExist[str]--;
                if (wordExist[str] &lt; 0) {
                    //当前字符串出现次数已满, 要不停的丢弃窗口最前端的字符串直到出现次数为0为止
                    while (wordExist[str] &lt; 0) {
                        string toDropStr = s.substr(slideLeft, wordLen);
                        wordExist[toDropStr]++;
                        slideLeft += wordLen;
                        wordFound--;
                    }
                }
                wordFound++;
                if (wordFound == wordsLen) {//找到一个要求的位置
                    ret.push_back(slideLeft);
                }
                j += wordLen;
            }
            for (; slideLeft &lt; j; slideLeft += wordLen) {
                //恢复每个单词出现的次数
                string toDropStr = s.substr(slideLeft, wordLen);
                if (wordExist.count(toDropStr)) wordExist[toDropStr]++;
            }
        }

        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>467</wp:post_id>
		<wp:post_date><![CDATA[2016-07-23 22:41:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-23 14:41:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-30-substring-with-concatenation-of-all-words]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 31. Next Permutation</title>
		<link>http://xiadong.info/2016/07/leetcode-31-next-permutation/</link>
		<pubDate>Sun, 24 Jul 2016 09:24:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=473</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

<code>1,2,3 → 1,3,2</code>

<code>3,2,1 → 1,2,3</code>

<code>1,1,5 → 1,5,1</code></blockquote>

提要求输入一个数组, 返回下一个字典序比它大的排列, 如果不存在比它大的就返回最小的排列. 首先解决判断一个排列是不是最大的问题, 这个问题比较简单: 只要是这个序列是从大到小排列的, 那么它就是最大的序列. 然后再思考比较两个序列大小的问题: 从前到后逐个比较数组中的数字, 出现第一个不相等的位置, 较大的那一个序列就是字典序较大的. 然后再考虑给定一个序列获得它的下一个序列的方法, 因为随着数组下标增加, 该下标位置的数对于整个序列大小的影响是越来越小的, 因此要获得下一个排列, 应该修改尽量靠后位置的元素, 同时这个元素应该变为一个较大的值, 但是这个较大的值要在该元素之后, 因为要是与该位置之前的较大元素交换位置这个排列是变小了; 而且这个变换的目标值应该尽量小, 也就是找到该位置之后比该位置元素大的最小值. 然后是该位置之后的序列要最小, 把它们从小到大排序就可以了.

因此算法如下:

<ul>
    <li>判断是不是最大值</li>
    <li>从后向前查找第一个在它之后有比它大的值的元素</li>
    <li>在这个元素之后找到比它大的最小值</li>
    <li>交换之后对于该元素之后的序列从小到大排序</li>
</ul>

<pre lang="c++"><code>class Solution {
public:
    bool isBiggest(vector&lt;int&gt;&amp; nums){
        if(nums.size() &lt;= 1)
            return true;
        for(int i = 1; i &lt; nums.size(); i++){
            if(nums[i] &gt; nums[i - 1])
                return false;
        }
        return true;
    }
    int findCloestBiggerBehind(vector&lt;int&gt;&amp; nums, int pos){
        int index = pos, n = INT_MAX;
        for(int i = pos + 1; i &lt; nums.size(); i++){
            if(nums[i] &gt; nums[pos] &amp;&amp; nums[i] &lt; n){
                index = i;
                n = nums[i];
            }
        }
        return index;
    }
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        if(isBiggest(nums)){
            sort(nums.begin(), nums.end());
            return;
        }
        int maxNum = INT_MIN;
        for(int i = nums.size() - 1; i &gt;= 0; i--){
            if(nums[i] &lt; maxNum){
                int pos = findCloestBiggerBehind(nums, i);
                int t = nums[i];
                nums[i] = nums[pos];
                nums[pos] = t;
                sort(nums.begin() + i + 1, nums.end());
                break;
            }
            maxNum = nums[i];
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>473</wp:post_id>
		<wp:post_date><![CDATA[2016-07-24 17:24:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-24 09:24:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-31-next-permutation]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 32. Longest Valid Parentheses</title>
		<link>http://xiadong.info/2016/07/leetcode-32-longest-valid-parentheses/</link>
		<pubDate>Sun, 24 Jul 2016 10:34:18 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=475</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

For "(()", the longest valid parentheses substring is "()", which has length = 2.

Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.</blockquote>

求最长的合法括号的长度, 采用先求匹配, 再求长度的方法.

<pre lang="c++"><code>class Solution {
public:
    int longestValidParentheses(string s) {
        if(s.empty()) return 0;
        vector&lt;int&gt; pStack;
        vector&lt;bool&gt; pMatch(s.length(), false);
        int len = s.length();
        for(int i = 0; i &lt; len; i++){
            if(s[i] == '('){
                pStack.push_back(i);
            }
            else if(pStack.empty() || s[pStack.back()] == ')'){
                pStack.push_back(i);
            }
            else{
                pMatch[i] = pMatch[pStack.back()] = true;
                pStack.pop_back();
            }
        }
        int maxLen = 0, curLen = 0;
        for(int i = 0; i &lt; len; i++){
            if(pMatch[i]){
                curLen++;
                if(curLen &gt; maxLen) maxLen = curLen;
            }
            else{
                curLen = 0;
            }
        }
        return maxLen;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>475</wp:post_id>
		<wp:post_date><![CDATA[2016-07-24 18:34:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-24 10:34:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-32-longest-valid-parentheses]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8b%ac%e5%8f%b7%e5%8c%b9%e9%85%8d"><![CDATA[括号匹配]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 33. Search in Rotated Sorted Array</title>
		<link>http://xiadong.info/2016/07/leetcode-33-search-in-rotated-sorted-array/</link>
		<pubDate>Sun, 24 Jul 2016 10:52:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=477</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Suppose a sorted array is rotated at some pivot unknown to you beforehand.
(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
</blockquote>

首先找到有序序列平移了多少位, 然后根据target在哪个范围内使用二分搜索.

<pre lang="c++"><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty()) return -1;
        int start = 0, end = nums.size();
        for(int i = 0; i &lt; nums.size() - 1; i++){
            if(nums[i] &gt; nums[i + 1]){
                start = i + 1;
                break;
            }
        }
        if(target &lt; nums[0]){
            return binSearch(nums, start, nums.size(), target);
        }
        else{
            return binSearch(nums, 0, start ? start : nums.size(), target);
        }
    }

    int binSearch(vector&lt;int&gt; &amp;nums, int left, int right, int target){
        int low = left, high = right, mid = (low + high) / 2;
        while(low &lt; high){
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] &gt; target)
                high = mid;
            else
                low = mid + 1;

            mid = (low + high) / 2;
        }
        return -1;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>477</wp:post_id>
		<wp:post_date><![CDATA[2016-07-24 18:52:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-24 10:52:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-33-search-in-rotated-sorted-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>再一次被OneNote击退了</title>
		<link>http://xiadong.info/2016/07/%e5%86%8d%e4%b8%80%e6%ac%a1%e8%a2%abonenote%e5%87%bb%e9%80%80%e4%ba%86/</link>
		<pubDate>Sun, 24 Jul 2016 12:11:42 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=481</guid>
		<description></description>
		<content:encoded><![CDATA[印象笔记前段时间调整了收费策略, 免费账户只能同时登录两个设备, 这个就有点不爽了. 而且我也不是重度用户, 觉得并不值得为高级账户付钱, 所以想起了被传的神乎其神的OneNote.

我在装Office的时候一起装了OneNote, 所以直接打开试试, 不得不说功能可以的, 但是同步实在太过于艰难了, 在移动设备上同步更改要等很久很久, 这还是在Wi-Fi下, 在网络不好的时候岂不是完全不能用了? 而且我从印象笔记使用微软官方提供的工具导入笔记, 但是同步的时候却告诉我格式错误. Exo me? 这不是你自己导入的吗? 因为OneNote是基于OndDrive来同步的, 所以OneNote的同步问题就是OneDrive的同步问题, 我在Win10中彻底禁用OneDrive就是因为这个同步功能过于坑爹.

难道我跟微软的东西都是相性不合? 微软做的东西我就没几个是用的舒心的(少数的几个有VS, OutLook邮箱不是客户端, Windows和VS Online的Git服务), 尤其是跟网络沾边的东西, 不过这大概也不全是巨硬的锅, 毕竟我现在还生活在一个不正常国家. 另外, 相比于OneNote的类Word的编辑体验, 我更喜欢纯文本的编辑(比如Markdown), 大概是因为这给了我更大的自主性吧, 而且一些其他的高级功能我也用不上. 我现在还是用Markdown+Git来写东西和同步(BTW, 我的私人Git服务是用的微软的, 不过这该算是Git好用还是难得我用巨硬的东西用的舒服呢), 我喜欢这种每一个环节都可以彻底掌控的感觉, 只不过手机和平板上就没办法了.

最后, 折腾了几个小时OneNote最后还是<b>浪费时间</b>. 暂时还是用着印象笔记吧.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>481</wp:post_id>
		<wp:post_date><![CDATA[2016-07-24 20:11:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-24 12:11:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%86%8d%e4%b8%80%e6%ac%a1%e8%a2%abonenote%e5%87%bb%e9%80%80%e4%ba%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<category domain="post_tag" nicename="%e5%90%90%e6%a7%bd"><![CDATA[吐槽]]></category>
		<category domain="post_tag" nicename="%e5%be%ae%e8%bd%af"><![CDATA[微软]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 34. Search for a Range</title>
		<link>http://xiadong.info/2016/07/leetcode-34-search-for-a-range/</link>
		<pubDate>Mon, 25 Jul 2016 12:48:12 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=484</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a sorted array of integers, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

For example,
Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,
return <code>[3, 4]</code>.</blockquote>

先使用二分搜索查找到目标, 再向前后搜索到数值的起始位置.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0, right = nums.size();
        while(left &lt; right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target){
                vector&lt;int&gt; ret = {mid, mid};
                while(ret[0] &gt;= 0 &amp;&amp; nums[ret[0]] == target) ret[0]--;
                while(ret[1] &lt; nums.size() &amp;&amp; nums[ret[1]] == target) ret[1]++;
                ret[0]++;
                ret[1]--;
                return ret;
            }
            else if(nums[mid] &gt; target){
                right = mid;
            }
            else{
                left = mid + 1;
            }
        }
        return vector&lt;int&gt;(2, -1);
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>484</wp:post_id>
		<wp:post_date><![CDATA[2016-07-25 20:48:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-25 12:48:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-34-search-for-a-range]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 35. Search Insert Position</title>
		<link>http://xiadong.info/2016/07/leetcode-35-search-insert-position/</link>
		<pubDate>Mon, 25 Jul 2016 13:05:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=486</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
  
  You may assume no duplicates in the array.
  
  Here are few examples.
  
  <code>[1,3,5,6], 5 → 2</code>
  
  <code>[1,3,5,6], 2 → 1</code>
  
  <code>[1,3,5,6], 7 → 4</code>
  
  <code>[1,3,5,6], 0 → 0</code>
</blockquote>

二分查找先确定数组中存不存在target, 如果存在则返回它的下标, 如果不存在那么就看target是不是比nums中的所有元素都大, 如果是就返回最后一个元素的下标<code>nums.size()</code>, 接下来判断二分搜索的结束位置与target的关系, 如果比target大, 那么就返回结束位置, 如果比target小, 那么就返回结束位置 + 1.

<pre lang="c++"><code>class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int low = 0, high = nums.size();
        while(low &lt; high){
            if(nums[(low + high) / 2] == target) return (low + high) / 2;
            else if(nums[(low + high) / 2] &lt; target){
                low = (low + high) / 2 + 1;
            }else{
                high = (low + high) / 2;
            }
        }
        if(low == nums.size() || nums[low] &gt; target)return low;
        else return low + 1;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>486</wp:post_id>
		<wp:post_date><![CDATA[2016-07-25 21:05:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-25 13:05:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-35-search-insert-position]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 36. Valid Sudoku</title>
		<link>http://xiadong.info/2016/07/leetcode-36-valid-sudoku/</link>
		<pubDate>Tue, 26 Jul 2016 12:59:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=488</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.

The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

<img title="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="" />

A partially filled sudoku which is valid.

Note:
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</blockquote>

要求判断一个数独题目是否合法, 但并不要求一定有解. 一个数独题目合法有以下三个条件:

<ol>
    <li>每一行都没有重复元素</li>
    <li>每一列都没有重复元素</li>
    <li>九个3x3方格中都没有重复元素</li>
</ol>

因此验证这三个条件即可.

<pre lang="c++"><code>class Solution {
public:
    void setNumFlag(vector&lt;int&gt;&amp; v){
        for(int i = 0; i &lt; v.size(); i++) v[i] = 0;
    }
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        vector&lt;int&gt; numFlag(9);
        for(int i = 0; i &lt; 9; i++){
            setNumFlag(numFlag);
            for(int j = 0; j &lt; 9; j++){
                char t = board[i][j];
                if(t &gt;= '1' &amp;&amp; t &lt;= '9'){
                    if(numFlag[t - '1'] == 1)
                        return false;
                    else
                        numFlag[t - '1'] = 1;
                }
            }
        }

        for(int i = 0; i &lt; 9; i++){
            setNumFlag(numFlag);
            for(int j = 0; j &lt; 9; j++){
                char t = board[j][i];
                if(t &gt;= '1' &amp;&amp; t &lt;= '9'){
                    if(numFlag[t - '1'] == 1)
                        return false;
                    else
                        numFlag[t - '1'] = 1;
                }
            }
        }

        for(int i = 0; i &lt; 3; i++){
            for(int j = 0; j &lt; 3; j++){
                int x = i * 3, y = j * 3;
                setNumFlag(numFlag);
                for(int ii = 0; ii &lt; 3; ii++){
                    for(int jj = 0; jj &lt; 3; jj++){
                        char t = board[x + ii][y + jj];
                        if(t &gt;= '1' &amp;&amp; t &lt;= '9'){
                            if(numFlag[t - '1'] == 1)
                                return false;
                            else
                                numFlag[t - '1'] = 1;
                        }
                    }
                }
            }
        }

        return true;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>488</wp:post_id>
		<wp:post_date><![CDATA[2016-07-26 20:59:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-26 12:59:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-36-valid-sudoku]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 37. Sudoku Solver</title>
		<link>http://xiadong.info/2016/07/leetcode-37-sudoku-solver/</link>
		<pubDate>Wed, 27 Jul 2016 09:33:58 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=490</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Write a program to solve a Sudoku puzzle by filling the empty cells.

Empty cells are indicated by the character '.'.

You may assume that there will be only one unique solution.

<img title="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="" />

A sudoku puzzle...

<img title="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="" />

...and its solution numbers marked in red.</blockquote>

题目要求解数独, 首先想到的解法是通过递归来穷举每一种可能的解. 在<code>getValidNum</code>函数中根据数独中已经存在的数获得当前位置可能填入的数. 该解法运行时间356ms.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;char&gt; getValidNum(vector&lt;vector&lt;char&gt;&gt;&amp; board, int step) {
        int r = step / 9, c = step % 9;
        set&lt;char&gt; re = { '1', '2', '3', '4', '5', '6', '7', '8', '9' };
        for (int i = 0; i &lt; 9; i++) {
            if (board[r][i] != '.')
                re.erase(board[r][i]);
            if (board[i][c] != '.')
                re.erase(board[i][c]);
        }
        int rr = (r / 3) * 3, cc = (c / 3) * 3;
        for (int i = 0; i &lt; 3; i++) {
            for (int j = 0; j &lt; 3; j++) {
                if (board[rr + i][cc + j] != '.')
                    re.erase(board[rr + i][cc + j]);
            }
        }
        vector&lt;char&gt; rev;
        for (auto i : re)
            rev.push_back(i);
        return rev;
    }
    bool solveStep(vector&lt;vector&lt;char&gt;&gt;&amp; board, int step) {
        if (step &gt;= 81)
            return true;
        int r = step / 9, c = step % 9;
        if (board[r][c] != '.') {
            return solveStep(board, step + 1);
        }
        vector&lt;char&gt; validNum = getValidNum(board, step);
        for (auto i : validNum) {
            board[r][c] = i;
            if (solveStep(board, step + 1))
                return true;
        }
        board[r][c] = '.';
        return false;
    }
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        bool re = solveStep(board, 0);
    }
};
</code></pre>

使用位运算代替set和vector来记录合法数字, 运算时间可以降至20ms.

<pre lang="c++"><code>class Solution {
public:
    int getValidNum(vector&lt;vector&lt;char&gt;&gt;&amp; board, int step) {
        int r = step / 9, c = step % 9;
        int re = 0;
        for (int i = 0; i &lt; 9; i++) {
            if (board[r][i] != '.')
                re |= 1 &lt;&lt; (board[r][i] - '1');
            if (board[i][c] != '.')
                re |= 1 &lt;&lt; (board[i][c] - '1');
        }
        int rr = (r / 3) * 3, cc = (c / 3) * 3;
        for (int i = 0; i &lt; 3; i++) {
            for (int j = 0; j &lt; 3; j++) {
                if (board[rr + i][cc + j] != '.')
                    re |= 1 &lt;&lt; (board[rr + i][cc + j] - '1');
            }
        }
        return re;
    }
    bool solveStep(vector&lt;vector&lt;char&gt;&gt;&amp; board, int step) {
        if (step &gt;= 81)
            return true;
        int r = step / 9, c = step % 9;
        if (board[r][c] != '.') {
            return solveStep(board, step + 1);
        }
        int validNum = getValidNum(board, step);
        for (int i = 0; i &lt; 9; i++) {
            if(validNum &amp; (1 &lt;&lt; i)) continue;
            board[r][c] = i + '1';
            if (solveStep(board, step + 1))
                return true;
        }
        board[r][c] = '.';
        return false;
    }
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        bool re = solveStep(board, 0);
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>490</wp:post_id>
		<wp:post_date><![CDATA[2016-07-27 17:33:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-27 09:33:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-37-sudoku-solver]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 38. Count and Say</title>
		<link>http://xiadong.info/2016/07/leetcode-38-count-and-say/</link>
		<pubDate>Wed, 27 Jul 2016 09:49:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=492</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  The count-and-say sequence is the sequence of integers beginning as follows:
  <code>1, 11, 21, 1211, 111221, ...</code>
  
  1 is read off as "one 1" or 11.
  
  11 is read off as "two 1s" or 21.
  
  21 is read off as "one 2, then one 1" or 1211.
  
  Given an integer n, generate the nth sequence.
  
  Note: The sequence of integers will be represented as a string.
</blockquote>

题目意思要求把数字"说出来", 其实含义就是给定一个包含数字的字符串, 把它用另一种方式表示出来, 即"数字连续出现的数量 + 该数字". 这个新字符串作为下一次处理的源字符串. 因此我的解法就是模拟这种做法.

<pre lang="c++"><code>class Solution {
public:
    string countAndSay(int n) {
        string s = "1";
        for (int i = 1; i &lt; n; i++) {
            string re;
            char now = s[0];
            int num = 1;
            int len = s.size();
            for (int i = 1; i &lt; len; i++) {
                if (s[i] == now) num++;
                else {
                    re = re + to_string(num);
                    re.push_back(now);
                    num = 1;
                    now = s[i];
                }
            }
            re = re + to_string(num);
            re.push_back(now);
            s = re;
        }
        return s;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>492</wp:post_id>
		<wp:post_date><![CDATA[2016-07-27 17:49:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-27 09:49:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-38-count-and-say]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 39. Combination Sum</title>
		<link>http://xiadong.info/2016/07/leetcode-39-combination-sum/</link>
		<pubDate>Wed, 27 Jul 2016 10:37:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=494</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
  
  The same repeated number may be chosen from C unlimited number of times.
  
  Note:
  + All numbers (including target) will be positive integers.
  + The solution set must not contain duplicate combinations.
  
  For example, given candidate set [2, 3, 6, 7] and target 7, 
  A solution set is: 

<pre><code>[
  [7],
  [2, 2, 3]
]
</code></pre>
</blockquote>

在一个整数集合中取出元素(同一个元素可以选出多次)使它们的和等于<code>target</code>. 思路是先对数组排序, 然后以每个元素作为第一个元素, 从它后面的元素(包括它自己)中再继续选取元素. 使用递归来实现这个思路.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector&lt;vector&lt;int&gt;&gt; re;
        for (int i = 0; i &lt; candidates.size() &amp;&amp; candidates[i] &lt;= target; i++) {
            vector&lt;int&gt; path;
            getWithFirst(candidates, target, i, re, path);
        }
        return re;
    }

    //函数参数和返回值都应该尽量不要直接使用对象, 虽然这样会损失函数封装性.
    void getWithFirst(vector&lt;int&gt;&amp; c, int target, int first, vector&lt;vector&lt;int&gt;&gt; &amp;ret, vector&lt;int&gt; &amp;path) {
        if (c[first] == target) {
            //找到一组符合要求的元素
            path.push_back(c[first]);
            ret.push_back(path);
            path.pop_back();
            return;
        }
        int newTarget = target - c[first];
        path.push_back(c[first]);
        for (int i = first; i &lt; c.size() &amp;&amp; c[i] &lt;= newTarget; i++) {
            //继续遍历first下标及之后的元素
            getWithFirst(c, newTarget, i, ret, path);
        }
        path.pop_back();
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>494</wp:post_id>
		<wp:post_date><![CDATA[2016-07-27 18:37:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-27 10:37:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-39-combination-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 40. Combination Sum II</title>
		<link>http://xiadong.info/2016/07/leetcode-40-combination-sum-ii/</link>
		<pubDate>Thu, 28 Jul 2016 09:24:38 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=497</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
  Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
  
  Each number in C may only be used once in the combination.
  
  Note:
  + All numbers (including target) will be positive integers.
  + The solution set must not contain duplicate combinations.
  
  For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, 
  
  A solution set is: 

<pre><code>[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
</code></pre>
</blockquote>

解法参照上一题: <a href="http://xiadong.info/2016/07/leetcode-39-combination-sum/">LeetCode 39. Combination Sum</a>, 区别在于两点

<ul>
<li>输入数组中可能存在重复数字</li>
<li>每个元素只能选择一次</li>
</ul>

解决第二个问题的办法很简单, 就是在每次进入下一级递归时从下一个元素开始. 解决第一个问题的办法是当一个值已经出现在结果中的某个位置时跳过接下来与这个值相等的所有元素.

代码如下:

<pre lang="c++"><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector&lt;vector&lt;int&gt;&gt; re;
        for (int i = 0; i &lt; candidates.size(); i++) {
            if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1]) continue; //防止重复而跳过元素
            vector&lt;int&gt; path;
            getWithFirst(candidates, target, i, re, path);
        }

        return re;
    }

    void getWithFirst(vector&lt;int&gt;&amp; c, int target, int first, vector&lt;vector&lt;int&gt;&gt; &amp;ret, vector&lt;int&gt; &amp;path) {
        if (c[first] == target) {
            path.push_back(c[first]);
            ret.push_back(path);
            path.pop_back();
            return;
        }
        int newTarget = target - c[first];
        path.push_back(c[first]);
        for (int i = first + 1; i &lt; c.size() &amp;&amp; c[i] &lt;= newTarget; i++) { //从first+1开始循环
            if(i &gt; first + 1 &amp;&amp; c[i] == c[i - 1]) continue; //防止重复而跳过元素
            getWithFirst(c, newTarget, i, ret, path);
        }
        path.pop_back();
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>497</wp:post_id>
		<wp:post_date><![CDATA[2016-07-28 17:24:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-28 09:24:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-40-combination-sum-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 41. First Missing Positive</title>
		<link>http://xiadong.info/2016/07/leetcode-41-first-missing-positive/</link>
		<pubDate>Thu, 28 Jul 2016 10:22:38 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=499</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an unsorted integer array, find the first missing positive integer.

For example,

Given [1,2,0] return 3,

and [3,4,-1,1] return 2.

Your algorithm should run in O(n) time and uses constant space.</blockquote>

给定一个未排序数组, 要求找到其中缺失的最小正整数. 由于题目要求使用常数的空间, 因此只能利用输入数组中的空间. 我的思路是将正整数<code>1...n</code>与下标<code>0...n-1</code>对应起来, 假设数组大小为n, 将数值在[1, n]范围内的元素放到下标[0,n-1]的对应位置上, 然后再从头遍历一次数组, <code>nums[i] != i + 1</code>的位置就是缺失的第一个正整数. 对与<code>&lt;=0</code>和<code>&gt;n</code>的数不需要处理, 因为<code>&lt;=0</code>的数与结果无关, 而如果出现了<code>&gt;n</code>的数, 那么必然在[1,n]中有缺失的数, 也只需要处理[1,n]即可. 时间复杂度O(n).

由于交换nums中的两个元素后, 将<code>nums[i]</code>中的数放到了<code>nums[nums[i] - 1]</code>中, 因此<code>nums[i]</code>中此时仍然储存一个没有放到相应位置的数, 所以下一个循环还要处理i而不是i+1, 所以i要减1, 但是这在<code>[1,1]</code>这种输入数据中会导致死循环, 因此还要加一个判断, 即要交换的目标位置是不是已经有了对应的数, 如果有则不再需要处理.

<pre lang="c++"><code>class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        for(int i = 0; i &lt; nums.size(); i++){
            if(nums[i] &lt;= nums.size() &amp;&amp; nums[i] &gt; 0 &amp;&amp; nums[nums[i] - 1] != nums[i]){
                swap(nums[nums[i] - 1], nums[i]);
                i--;
            }
        }
        for(int i = 0; i &lt; nums.size(); i++){
            if(nums[i] != i + 1) return i + 1;
        }
        return nums.size() + 1;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>499</wp:post_id>
		<wp:post_date><![CDATA[2016-07-28 18:22:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-28 10:22:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-41-first-missing-positive]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 42. Trapping Rain Water</title>
		<link>http://xiadong.info/2016/07/leetcode-42-trapping-rain-water/</link>
		<pubDate>Thu, 28 Jul 2016 11:35:57 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=501</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example,
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.

<img title="" src="http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt="" />

The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</blockquote>

蓄水的问题，我的想法是一个凹槽能蓄水，意味着它的两边比最低处高。考虑两边的话，最高的水面高度与较矮的一边相同。所以从左到右遍历每一个高度，对每一个高度向右寻找比它高的第一个高度，得到的就是蓄水的宽度。但是也有左边高右边低的情况，所以我先找到最高的高度，该高度左边的高度的右边都必然存在一个比它高的高度（最高的）。最高高度右边的高度则从右向左遍历。

<pre lang="c++"><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int i = 0, j = 0;
        int len = height.size(), ret = 0;
        int maxPos = 0, maxHeight = INT_MIN;
        for(int i = 0; i &lt; len; i++){
            if(height[i] &gt; maxHeight){
                maxHeight = height[i];
                maxPos = i;
            }
        }
        while(i &lt; maxPos){
            for(j = i + 1; j &lt; maxPos &amp;&amp; height[j] &lt; height[i]; j++) ret += (height[i] - height[j]);
            i = j;
        }
        i = len - 1;
        while(i &gt; maxPos){
            for(j = i - 1; j &gt; maxPos &amp;&amp; height[j] &lt; height[i]; j--) ret += (height[i] - height[j]);
            i = j;
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>501</wp:post_id>
		<wp:post_date><![CDATA[2016-07-28 19:35:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-28 11:35:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-42-trapping-rain-water]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 43. Multiply Strings</title>
		<link>http://xiadong.info/2016/07/leetcode-43-multiply-strings/</link>
		<pubDate>Fri, 29 Jul 2016 09:07:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=504</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two numbers represented as strings, return multiplication of the numbers as a string.

Note:
<ul>
    <li>The numbers can be arbitrarily large and are non-negative.</li>
    <li>Converting the input string to integer is NOT allowed.</li>
    <li> You should NOT use internal library such as BigInteger.</li>
</ul>
</blockquote>

输入两个用数组表示的非负数, 输出它们相乘的结果. 使用模拟手算的方法:

<pre lang="c++"><code>class Solution {
public:
    void multiplyWithOneDigit(string&amp; num1, char num2, vector&lt;string&gt;&amp; v){
        int jw = 0;
        string re;
        for(int i = num1.size() - 1; i &gt;= 0; i--){
            int t = (num2) * (num1[i]) + jw;
            re.push_back((t % 10));
            jw = t / 10;
        }
        if(jw)
            re.push_back(jw);
        v.push_back(re);
    }
    void plusString(string&amp; a, string&amp; b){
        if(a.size() &lt; b.size()){
            swap(a, b);
        }
        string re;
        int jw = 0;
        for(int i = 0; i &lt; b.size(); i++){
            int t = a[i] + b[i] + jw;
            re.push_back((t % 10));
            jw = t / 10;
        }
        for(int i = b.size(); i &lt; a.size(); i++){
            int t = a[i] + jw;
            re.push_back((t % 10));
            jw = t / 10;
        }
        if(jw)
            re.push_back(jw);
        a = re;
    }
    string plusAll(vector&lt;string&gt;&amp; v){
        string re = {0};
        for(int i = 0; i &lt; v.size(); i++){
            plusString(re, v[i]);
        }
        while(!re.empty() &amp;&amp; re.back() == 0) re.pop_back();
        if(re.empty())
            re = {0};
        return re;
    }
    string multiply(string num1, string num2) {
        for(auto &amp;i : num1) i -= '0';
        for(auto &amp;i : num2) i -= '0';
        vector&lt;string&gt; v;
        if(num2.size() &gt; num1.size()) swap(num1, num2);
        for(int i = num2.size() - 1; i &gt;= 0; i--){
            multiplyWithOneDigit(num1, num2[i], v);
            v.back().insert(v.back().begin(), num2.size() - i - 1, 0);
        }
        string ret = plusAll(v);
        reverse(ret.begin(), ret.end());
        for(auto &amp;i : ret) i += '0';
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>504</wp:post_id>
		<wp:post_date><![CDATA[2016-07-29 17:07:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-29 09:07:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-43-multiply-strings]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 44. Wildcard Matching</title>
		<link>http://xiadong.info/2016/07/leetcode-44-wildcard-matching/</link>
		<pubDate>Fri, 29 Jul 2016 10:51:07 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=507</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Implement wildcard pattern matching with support for '?' and '*'.
<pre><code>'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
</code></pre>
</blockquote>

与<a href="http://xiadong.info/2016/07/leetcode-10-regular-expression-matching/">LeetCode 10. Regular Expression Matching</a>这道题看起来十分相似, 但是使用相同的方法的话会超时. 然后我参考了这篇文章: <a href="http://yucoding.blogspot.jp/2013/02/leetcode-question-123-wildcard-matching.html">http://yucoding.blogspot.jp/2013/02/leetcode-question-123-wildcard-matching.html</a>. 主要思路如下:

<ul>
    <li>用两个指针i,j或下标分别指向字符串s和p的开头</li>
    <li><code>s[i] == p[j]</code>或<code>p[j] == '?'</code>, 字符匹配, i和j都加1</li>
    <li><code>p[j] == '*'</code>, 也匹配, 记录下该<code>*</code>出现的位置<code>lastStar</code>和此时匹配的s中的位置<code>lastPosAfterStarMatch</code>, 这种情况下先认为<code>*</code>符号匹配空串, 所以只有j++</li>
    <li>剩下的情况就是不匹配, 先看p串之前有没有位置<code>lastStar</code>, 如果有, 就将该位置的<code>*</code>所匹配的串长度加1(初始为0), 也就是把i变为<code>++lastPosAfterStarMatch</code>, j变为<code>lastStar + 1</code></li>
    <li>如果之前没有<code>*</code>, 那么就返回不匹配</li>
    <li>整个循环要处理完s, 然后查看p中剩下的字符是不是都是<code>*</code>, 如果是就返回true</li>
</ul>

这个方法实际是回溯法, 只不过只回溯到上一个<code>*</code>而不再往前回溯.
代码:

<pre lang="c++"><code>class Solution {
public:
    bool isMatch(string s, string p) {
        int i = 0, j = 0, lastStar = -1, lastPosAfterStarMatch = -1;
        while(i &lt; s.size()){
            if(j &lt; p.size() &amp;&amp; (s[i] == p[j] || p[j] == '?')){
                i++;j++;
            }
            else if(j &lt; p.size() &amp;&amp; p[j] == '*'){
                lastStar = j++;
                lastPosAfterStarMatch = i;
            }
            else if(lastStar != -1){
                i = ++lastPosAfterStarMatch;
                j = lastStar + 1;
            }
            else return false;
        }
        for(; j &lt; p.size(); j++){
            if(p[j] != '*') return false;
        }
        return true;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>507</wp:post_id>
		<wp:post_date><![CDATA[2016-07-29 18:51:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-29 10:51:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-44-wildcard-matching]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%ba%af"><![CDATA[回溯]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 377. Combination Sum IV</title>
		<link>http://xiadong.info/2016/07/leetcode-377-combination-sum-iv/</link>
		<pubDate>Fri, 29 Jul 2016 11:36:09 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=509</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:
<pre><code>nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
</code></pre>
Follow up:
<ul>
    <li>What if negative numbers are allowed in the given array?</li>
    <li>How does it change the problem?</li>
    <li>What limitation we need to add to the question to allow negative numbers?</li>
</ul>
</blockquote>

这是一道比较明显的动态规划题, 但是我一开始还是直接用了递归, 无悬念的超时.

和等于target的组合数量等于target减去nums中每一个元素后的所有新target的组合数量之和. 如果target与nums中某个值相等则再加1.

<pre lang="c++"><code>class Solution {
public:
    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; dp(target + 1);
        for(int i = 0; i &lt;= target; i++){
            for(int j = 0; j &lt; nums.size(); j++){
                if(i == nums[j]) dp[i]++;
                else if(i &gt; nums[j]){
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
</code></pre>

关于Follow up: 如果nums中出现了负数, 那么问题在于新的<code>target</code>值是通过<code>target - nums[i]</code>来得到的, 如果nums[i]为负, 那么新的<code>target</code>将会大于旧的<code>target</code>, 这会有两个问题

<ol>
    <li>动态规划只保存了小于旧<code>target</code>的值</li>
    <li>如果动态规划不以<code>target</code>为终点而继续到新的<code>target</code>值, 那么又会产生更大的<code>target</code>, <code>target</code>会无穷增长下去.</li>
</ol>

在题目中要求每个数只能选择一次就可以避免<code>target</code>的无限增长, 从而使求解成为可能.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>509</wp:post_id>
		<wp:post_date><![CDATA[2016-07-29 19:36:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-29 11:36:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-377-combination-sum-iv]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 45. Jump Game II</title>
		<link>http://xiadong.info/2016/07/leetcode-45-jump-game-ii/</link>
		<pubDate>Sat, 30 Jul 2016 08:22:20 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=514</guid>
		<description></description>
		<content:encoded><![CDATA[问题描述:

<blockquote>Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

For example:
Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

Note:

You can assume that you can always reach the last index.</blockquote>

当走到<code>nums[i]</code>时, 遍历<code>[i + 1, i + nums[i]]</code>范围内的元素, 找到其中最大的值, 作为下一次循环的<code>i</code>. 对于只有一个元素的nums单独处理.

<pre lang="c++"><code>class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 1) return 0;
        int p = 0,step = 0;
        while(p + nums[p] &lt; nums.size() - 1){
            step++;
            int nextP = -1, nextPPos = 0;
            for(int j = 1; j &lt;= nums[p] &amp;&amp; p + j &lt; nums.size(); j++){
                if(nums[p + j] + p + j &gt; nextP){
                    nextP = nums[p + j] + p + j;
                    nextPPos = p + j;
                }
            }
            p = nextPPos;
        }
        return step + 1;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>514</wp:post_id>
		<wp:post_date><![CDATA[2016-07-30 16:22:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-30 08:22:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-45-jump-game-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 46. Permutations</title>
		<link>http://xiadong.info/2016/07/leetcode-46-permutations/</link>
		<pubDate>Sat, 30 Jul 2016 08:45:22 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=517</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a collection of distinct numbers, return all possible permutations.

For example,
<pre><code>[1,2,3] have the following permutations:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>
</blockquote>

使用递归来创建所有排列.

<pre lang="c++"><code>class Solution {
    vector&lt;vector&lt;int&gt;&gt; ret;
    int numsLen;
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        vector&lt;bool&gt; flag(nums.size(), false);
        vector&lt;int&gt; p;
        numsLen = nums.size();
        for(int i = 0; i &lt; numsLen; i++){
            flag[i] = true;
            p.push_back(nums[i]);
            permute(nums, flag, p, nums.size() - 1);
            p.pop_back();
            flag[i] = false;
        }
        return ret;
    }

    void permute(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt; &amp;flag, vector&lt;int&gt; &amp;p, int lastLen){
        if(lastLen == 0){
            ret.push_back(p);
            return;
        }
        for(int i = 0; i &lt; numsLen; i++){
            if(flag[i]) continue;
            flag[i] = true;
            p.push_back(nums[i]);
            permute(nums, flag, p, lastLen - 1);
            p.pop_back();
            flag[i] = false;
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>517</wp:post_id>
		<wp:post_date><![CDATA[2016-07-30 16:45:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-30 08:45:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-46-permutations]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 47. Permutations II</title>
		<link>http://xiadong.info/2016/07/leetcode-47-permutations-ii/</link>
		<pubDate>Sat, 30 Jul 2016 08:56:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=519</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example,
<code>[1,1,2]</code> have the following unique permutations:
<pre><code>[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre>
</blockquote>

与上一题<a href="http://xiadong.info/2016/07/leetcode-46-permutations/">46. Permutations</a>类似, 只不过输入集合中可能有重复数字, 而输出要求没有重复. 所以先对输入序列进行排序, 然后每次递归时跳过多次出现的数字中除了第一个数字以外的数.

<pre lang="c++"><code>class Solution {
    vector&lt;vector&lt;int&gt;&gt; ret;
    int numsLen;
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        vector&lt;bool&gt; flag(nums.size(), false);
        vector&lt;int&gt; p;
        numsLen = nums.size();
        for(int i = 0; i &lt; numsLen; i++){
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            flag[i] = true;
            p.push_back(nums[i]);
            permute(nums, flag, p, nums.size() - 1);
            p.pop_back();
            flag[i] = false;
        }
        return ret;
    }

    void permute(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt; &amp;flag, vector&lt;int&gt; &amp;p, int lastLen){
        if(lastLen == 0){
            ret.push_back(p);
            return;
        }
        for(int i = 0; i &lt; numsLen; i++){
            if(flag[i]) continue;
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !flag[i - 1]) continue;
            flag[i] = true;
            p.push_back(nums[i]);
            permute(nums, flag, p, lastLen - 1);
            p.pop_back();
            flag[i] = false;
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>519</wp:post_id>
		<wp:post_date><![CDATA[2016-07-30 16:56:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-30 08:56:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-47-permutations-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>STL容器学习笔记四 - List</title>
		<link>http://xiadong.info/2016/07/stl%e5%ae%b9%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e5%9b%9b-list/</link>
		<pubDate>Sat, 30 Jul 2016 10:11:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=521</guid>
		<description></description>
		<content:encoded><![CDATA[<h1 id="-list-http-www-cplusplus-com-reference-list-list-"><a href="http://www.cplusplus.com/reference/list/list/">List</a> 双向链表</h1>

list是允许在容器内任意位置以常数时间进行插入删除操作的顺序容器, 它的迭代器也是双向的.

list被实现为双向链表, 它与<code>forward_list</code>的主要区别在于<code>forward_list</code>是单向链表, 迭代器只能向前.

与其他顺序容器相比主要优点在于在容器任意位置插入, 提取和移动的表现更好. 不足在于不能根据元素在容器中的位置来访问元素.

<h1 id="-">部分函数</h1>

list没有随机访问方法, 没有<code>at</code>成员函数或者<code>[]</code>运算符.

<h2 id="-">构造函数</h2>

与其他顺序容器类似

<table>
<tbody>
<tr>
<th>类型</th>
<th>原型</th>
</tr>
<tr>
<td>default (1)</td>
<td><code>explicit list (const allocator_type&amp; alloc = allocator_type());</code></td>
</tr>
<tr>
<td>fill (2)</td>
<td><code>explicit list (size_type n);
list (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());</code></td>
</tr>
<tr>
<td>range (3)</td>
<td><code>template &lt;class InputIterator&gt;
list (InputIterator first, InputIterator last,
const allocator_type&amp; alloc = allocator_type());</code></td>
</tr>
<tr>
<td>copy (4)</td>
<td><code>list (const list&amp; x);
list (const list&amp; x, const allocator_type&amp; alloc);</code></td>
</tr>
<tr>
<td>move (5)</td>
<td><code>list (list&amp;&amp; x);
list (list&amp;&amp; x, const allocator_type&amp; alloc);</code></td>
</tr>
<tr>
<td>initializer list (6)</td>
<td><code>list (initializer_list il,
const allocator_type&amp; alloc = allocator_type());</code></td>
</tr>
</tbody>
</table>

<h2 id="list-merge">list::merge</h2>

<pre><code>void merge (list&amp; x);
  void merge (list&amp;&amp; x);
template &lt;class Compare&gt;
  void merge (list&amp; x, Compare comp);
template &lt;class Compare&gt;
  void merge (list&amp;&amp; x, Compare comp);
</code></pre>

将x中的元素按照相应的顺序放入容器中, 两个容器都应有序. 该操作移除x中的所有元素, 但不会析构或构造任何对象.

该函数的模板版本使用comp作为比较元素大小的方法. 结果得到的list是稳定的. 当<code>&amp;x == this</code>时不会做任何事.

<h2 id="list-splice">list::splice</h2>

将元素从x中转移到当前容器中, 插入到position指定的位置.

元素会从x中移除, 两个容器的大小都会改变. 该操作不会析构或构造任何对象.

<pre><code>void splice (const_iterator position, list&amp; x);
void splice (const_iterator position, list&amp;&amp; x);
</code></pre>

x中的所有元素都转移到list中.

<pre><code>void splice (const_iterator position, list&amp; x, const_iterator i);
void splice (const_iterator position, list&amp;&amp; x, const_iterator i);
</code></pre>

只有迭代器<code>i</code>指定的元素被移动.

<pre><code>void splice (const_iterator position, list&amp; x,
            const_iterator first, const_iterator last);
void splice (const_iterator position, list&amp;&amp; x,
            const_iterator first, const_iterator last);
</code></pre>

<code>[first, last)</code>范围内的元素被移动.

<h2 id="list-unique">list::unique</h2>

<pre><code>void unique();
</code></pre>

删除除了第一个元素以外的重复元素. <strong>注意:</strong>只有与前一个元素相等的元素才会被移除, 所以该函数只能用于有序list.

<pre><code>template &lt;class BinaryPredicate&gt;
    void unique (BinaryPredicate binary_pred);
</code></pre>

使用一个比较函数来决定两个元素是否相等. <code>unique</code>会对每个相邻元素调用<code>binary_pred(*i, *(i - 1))</code>, 如果返回true则删除<code>i</code>.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>521</wp:post_id>
		<wp:post_date><![CDATA[2016-07-30 18:11:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-30 10:11:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[stl%e5%ae%b9%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e5%9b%9b-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="%e7%ac%94%e8%ae%b0"><![CDATA[笔记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 48. Rotate Image</title>
		<link>http://xiadong.info/2016/07/leetcode-48-rotate-image/</link>
		<pubDate>Sun, 31 Jul 2016 07:40:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=524</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Follow up:
Could you do this in-place?</blockquote>

题目要求将一个n*n数组顺时针旋转90度, 并且最好不使用额外空间. 所以用对角线将矩阵分为四个区域, 对于每个区域内的每个元素依次放入上一个区域的值.

<pre lang="c++"><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for(int i = 0; i &lt; n / 2; i++){
            for(int j = i; j &lt; n - 1 - i; j++){
                int swap_t = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = swap_t;
            }
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>524</wp:post_id>
		<wp:post_date><![CDATA[2016-07-31 15:40:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-31 07:40:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-48-rotate-image]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 49. Group Anagrams</title>
		<link>http://xiadong.info/2016/07/leetcode-49-group-anagrams/</link>
		<pubDate>Sun, 31 Jul 2016 08:07:19 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=526</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array of strings, group anagrams together.

For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"],
Return:
<pre><code>[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]
</code></pre>
</blockquote>

anagram的意思是"颠倒字母而成的词句", 也就是要把由相同字母组成的但顺序不同的字符串放到一起. 使用hash表, 对每个字符串中的字符排序后得到的新字符串作为hash表的key, value则是对应的原字符串集合.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        unordered_map&lt;string, vector&lt;string&gt;&gt; m;
        vector&lt;vector&lt;string&gt;&gt; ret;
        for(int i = 0; i &lt; strs.size(); i++){
            string s = strs[i];
            sort(s.begin(), s.end());
            if(m.count(s)){
                m[s].push_back(strs[i]);
            }
            else{
                m[s] = vector&lt;string&gt;(1, strs[i]);
            }
        }
        ret.resize(m.size()); //预先扩展ret的大小, 避免在循环中push_back频繁分配新的内存空间
        int cnt = 0;
        for(auto i = m.begin(); i != m.end(); i++){
            ret[cnt++] = (i-&gt;second);
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>526</wp:post_id>
		<wp:post_date><![CDATA[2016-07-31 16:07:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-31 08:07:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-49-group-anagrams]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 50. Pow(x, n)</title>
		<link>http://xiadong.info/2016/07/leetcode-50-powx-n/</link>
		<pubDate>Sun, 31 Jul 2016 08:23:32 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=529</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Implement pow(x, n).
</blockquote>

题目要求实现pow函数. 首先n若小于0, 则可以先把x取倒数, 然后n取相反数, 从而变为n大于0的情况(但是由于int表示范围的问题, 所以新的n应该使用long long来存储), 所以只要考虑n大于0的情况. x<sup>n</sup> = (x<sup>2</sup>)<sup>n/2</sup>(n为偶数); x<sup>n</sup> = x*(x<sup>2</sup>)<sup>(n - 1)/2</sup>(n为奇数), 所以循环次数可以降低至logn次.

<pre lang="c++"><code>class Solution {
public:
    double myPow(double x, int n) {
        long long nn = n;
        double re = 1;
        if(nn == 0) return 1;
        if(nn &lt; 0){
            x = 1 / x;
            nn = -nn;
        }
        while(nn &gt; 1){
            if(nn % 2 == 0){
                x *= x;
                nn = nn &gt;&gt; 1;
            }
            else{
                re *= x;
                nn -= 1;
            }
        }
        return re * x;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>529</wp:post_id>
		<wp:post_date><![CDATA[2016-07-31 16:23:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-31 08:23:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-50-powx-n]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 378. Kth Smallest Element in a Sorted Matrix</title>
		<link>http://xiadong.info/2016/08/leetcode-378-kth-smallest-element-in-a-sorted-matrix/</link>
		<pubDate>Mon, 01 Aug 2016 10:01:53 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=534</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
Example:
<pre><code>matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
</code></pre>Note: 
You may assume k is always valid, 1 ≤ k ≤ n<sup>2</sup>.
</blockquote>

首先的想法是每次从n行中取最前端的n个值中的最小值, 然后这个值从该行删除, 重复k次. 时间复杂度O(nk). 实际运行时间280ms.

<pre lang="c++"><code>class Solution {
public:
    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int n = matrix.size();
        vector&lt;int&gt; matrixPos(n, 0);
        int ret;
        for(int i = 0; i &lt; k; i++){
            int minNum = INT_MAX, minPos = 0;
            for(int j = 0; j &lt; n; j++){
                if(matrixPos[j] == n) continue;
                if(matrix[j][matrixPos[j]] &lt; minNum){
                    minNum = matrix[j][matrixPos[j]];
                    minPos = j;
                }
            }
            matrixPos[minPos]++;
            ret = minNum;
        }
        return ret;
    }
};
</code></pre>

使用二分搜索, 不过搜索范围是<code>int</code>类型的整个表示范围, 为避免溢出, 使用long long来保存左右边界. Runtime: 80ms.

<pre lang="c++"><code>class Solution {
public:
    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int n = matrix.size();
        long long l = INT_MIN, r = INT_MAX, mid;
        while(l &lt; r){
            mid = (l + r) &gt;&gt; 1;
            int kth = 0;
            for(int i = 0; i &lt; n; i++){
                for(int j = 0; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++){
                    kth++;
                }
            }
            if(kth &lt; k) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
</code></pre>

另一种使用堆的方法, 先按从上往下, 从左往右的顺序将k个元素放入堆中. 对于剩下的元素, 每一行从头开始与堆顶比较, 如果小于堆顶, 就把它放入堆中, 把原堆顶弹出. 该行中出现&gt;=堆顶的元素时即可停止对这一行的处理. 运行时间112ms.

<pre lang="c++"><code>class Solution {
public:
    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int n = matrix.size();
        priority_queue&lt;int&gt; heap;
        for(int i = 0; i &lt; n; i++){
            if(heap.size() &lt; k){
                int j;
                for(j = 0; j &lt; n &amp;&amp; heap.size() &lt; k; j++){
                    heap.push(matrix[i][j]);
                }
                for(; j &lt; n &amp;&amp; heap.top() &gt; matrix[i][j]; j++){
                    heap.pop();
                    heap.push(matrix[i][j]);
                }
            }
            else{
                for(int j = 0; j &lt; n &amp;&amp; heap.top() &gt; matrix[i][j]; j++){
                    heap.pop();
                    heap.push(matrix[i][j]);
                }
            }
        }
        return heap.top();
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>534</wp:post_id>
		<wp:post_date><![CDATA[2016-08-01 18:01:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-01 10:01:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-378-kth-smallest-element-in-a-sorted-matrix]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 51. N-Queens</title>
		<link>http://xiadong.info/2016/08/leetcode-51-n-queens/</link>
		<pubDate>Mon, 01 Aug 2016 10:54:41 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=537</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.

<img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt="" />

Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

For example,
There exist two distinct solutions to the 4-queens puzzle:
<pre><code>[
    [".Q..",  // Solution 1
    "...Q",
    "Q...",
    "..Q."],

    ["..Q.",  // Solution 2
    "Q...",
    "...Q",
    ".Q.."]
]
</code></pre>
</blockquote>

N皇后问题, 采用递归+回溯的方法, 依次穷举每一种情况.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        vector&lt;vector&lt;int&gt;&gt; board(n, vector&lt;int&gt;(n, 0));
        vector&lt;vector&lt;string&gt;&gt; re;
        NQueensRow(n, board, 0, re);
        return re;
    }

    void NQueensRow(int n, vector&lt;vector&lt;int&gt;&gt; &amp;board, int row, vector&lt;vector&lt;string&gt;&gt; &amp;re) {
        if (row == n) {
            reItem(board, re);
            return;
        }
        for (int i = 0; i &lt; n; i++) {
            if (validPos(board, row, i)) {
                board[row][i] = 1;
                NQueensRow(n, board, row + 1, re);
                board[row][i] = 0;
            }
        }
    }

    bool validPos(vector&lt;vector&lt;int&gt;&gt; &amp;board, int x, int y) {
        int n = board.size();
        for (int i = 0; i &lt; n; i++) {
            if (board[x][i] &amp;&amp; i != y)
                return false;
            else if (board[i][y] &amp;&amp; i != x)
                return false;
        }

        int xt, yt;
        for (xt = x - 1, yt = y - 1; xt &gt;= 0 &amp;&amp; yt &gt;= 0; xt--, yt--){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y + 1; xt &lt; n &amp;&amp; yt &lt; n; xt++, yt++) {
            if (board[xt][yt])
                return false;
        }
        for (xt = x - 1, yt = y + 1; xt &gt;= 0 &amp;&amp; yt &lt; n; xt--, yt++){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y - 1; xt &lt; n &amp;&amp; yt &gt;= 0; xt++, yt--) {
            if (board[xt][yt])
                return false;
        }

        return true;
    }

    void reItem(vector&lt;vector&lt;int&gt;&gt; &amp;board, vector&lt;vector&lt;string&gt;&gt; &amp;ret) {
        int n = board.size();
        vector&lt;string&gt; re(n, string(n, '.'));
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if(board[i][j]) re[i][j] = 'Q';
            }
        }
        ret.push_back(re);
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>537</wp:post_id>
		<wp:post_date><![CDATA[2016-08-01 18:54:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-01 10:54:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-51-n-queens]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%ba%af"><![CDATA[回溯]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 52. N-Queens II</title>
		<link>http://xiadong.info/2016/08/leetcode-52-n-queens-ii/</link>
		<pubDate>Mon, 01 Aug 2016 11:19:25 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=539</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Follow up for N-Queens problem.
Now, instead outputting board configurations, return the total number of distinct solutions.
</blockquote>

与上一题<a href="http://xiadong.info/2016/08/leetcode-51-n-queens/">51. N-Queens</a>基本类似, 但是要求返回共有多少个解, 对上一个程序稍加改动即可. <del>当然, 最投机取巧的做法是算出n=1到9的结果然后直接返回</del>.

<pre lang="c++"><code>class Solution {
public:
    int totalNQueens(int n) {
        vector&lt;vector&lt;int&gt;&gt; board(n, vector&lt;int&gt;(n, 0));
        int re = 0;
        NQueensRow(n, board, 0, re);
        return re;
    }
    void NQueensRow(int n, vector&lt;vector&lt;int&gt;&gt; &amp;board, int row, int &amp;re) {
        if (row == n) {
            re++;
            return;
        }
        for (int i = 0; i &lt; n; i++) {
            if (validPos(board, row, i)) {
                board[row][i] = 1;
                NQueensRow(n, board, row + 1, re);
                board[row][i] = 0;
            }
        }
    }

    bool validPos(vector&lt;vector&lt;int&gt;&gt; &amp;board, int x, int y) {
        int n = board.size();
        for (int i = 0; i &lt; n; i++) {
            if (board[x][i] &amp;&amp; i != y)
                return false;
            else if (board[i][y] &amp;&amp; i != x)
                return false;
        }

        int xt, yt;
        for (xt = x - 1, yt = y - 1; xt &gt;= 0 &amp;&amp; yt &gt;= 0; xt--, yt--){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y + 1; xt &lt; n &amp;&amp; yt &lt; n; xt++, yt++) {
            if (board[xt][yt])
                return false;
        }
        for (xt = x - 1, yt = y + 1; xt &gt;= 0 &amp;&amp; yt &lt; n; xt--, yt++){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y - 1; xt &lt; n &amp;&amp; yt &gt;= 0; xt++, yt--) {
            if (board[xt][yt])
                return false;
        }

        return true;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>539</wp:post_id>
		<wp:post_date><![CDATA[2016-08-01 19:19:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-01 11:19:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-52-n-queens-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%ba%af"><![CDATA[回溯]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 53. Maximum Subarray</title>
		<link>http://xiadong.info/2016/08/leetcode-53-maximum-subarray/</link>
		<pubDate>Tue, 02 Aug 2016 11:00:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=545</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6.
</blockquote>

题目要求找出最大的连续子序列的和, 首先采用一种分治法. 对于一个数组, 把它中中间分成两半, 和最大的连续子序列可能出现在左半边, 可能出现在右半边, 也有可能出现跨越左右的情况. 对于在左半边或右半边的情况, 可以使用递归缩小问题, 对于跨越左右的情况, 可以使用线性算法来获得结果. 最后返回三个值中的最大值.

<pre lang="c++"><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        return maxSub(nums, 0, nums.size());
    }

    int maxSub(vector&lt;int&gt;&amp; nums, int left, int right) {
        if (right - left == 1) {
            return nums[left];
        }
        int leftSum, rightSum, mid = (left + right) / 2;
        leftSum = maxSub(nums, left, mid);
        rightSum = maxSub(nums, mid, right);

        int midLeftSum = 0, midLeftMaxSum = INT_MIN, midRightSum = 0, midRightMaxSum = INT_MIN;
        for (int i = mid - 1; i &gt;= left; i--) {
            midLeftSum += nums[i];
            if (midLeftSum &gt; midLeftMaxSum) midLeftMaxSum = midLeftSum;
        }
        for (int i = mid; i &lt; right; i++) {
            midRightSum += nums[i];
            if (midRightSum &gt; midRightMaxSum) midRightMaxSum = midRightSum;
        }
        int midSum = midRightMaxSum + midLeftMaxSum;

        return max(midSum, max(leftSum, rightSum));
    }
};
</code></pre>

还可以使用动态规划法. 使用<code>dp[i]</code>来表示包含<code>nums[i]</code>的和最大的连续子串的和. 如果<code>dp[i-1]</code>是大于0的, 那么就可以加上<code>dp[i-1]</code>, 因为<code>nums[i]</code>是必须有的. 用另一种方式来说, 这个题目的主要问题在于和最大的连续子串中可能出现负数, 要考虑的是负数及负数之前的子串要不要加到当前子串中来, 而这个判断就是看以该负数结尾的连续子串的和是否大于0, 如果小于0则不能加进来, 大于0则可以.

<pre lang="c++"><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; dp(nums.size(), 0);
        int ret = nums[0];
        dp[0] = nums[0];
        for(int i = 1; i &lt; nums.size(); i++){
            dp[i] = dp[i - 1] &gt; 0 ? dp[i - 1] + nums[i] : nums[i];
            if(ret &lt; dp[i])
                ret = dp[i];
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>545</wp:post_id>
		<wp:post_date><![CDATA[2016-08-02 19:00:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-02 11:00:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-53-maximum-subarray]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e6%b2%bb"><![CDATA[分治]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 54. Spiral Matrix</title>
		<link>http://xiadong.info/2016/08/leetcode-54-spiral-matrix/</link>
		<pubDate>Tue, 02 Aug 2016 11:29:11 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=548</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

For example,
Given the following matrix:
<pre><code>[
  [ 1, 2, 3 ],
  [ 4, 5, 6 ],
  [ 7, 8, 9 ]
]
</code></pre>
You should return <code>[1,2,3,6,9,8,7,4,5]</code>.</blockquote>

螺旋形输出一个矩阵, 我的方法就是螺旋形地遍历这个矩阵. 用一个变量来表示方向, 到达矩阵边缘的时候就更改方向.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt; re;
        if (matrix.size() == 0 || matrix[0].size() == 0)
            return re;
        int m = matrix.size(), n = matrix[0].size(), num = m * n;
        vector&lt;int&gt; row(n, 0);
        vector&lt;vector&lt;int&gt;&gt; visited(m, row);
        int direction = 0;// 0 =&gt; right, 1 =&gt; down, 2 =&gt; left, 3 =&gt; up
        int posRow = 0, posCol = 0, cnt = 0;
        while (cnt &lt; num) {
            int nextPosRow, nextPosCol;
            if(!visited[posRow][posCol]){
                re.push_back(matrix[posRow][posCol]);
                visited[posRow][posCol] = 1;
                cnt++;
            }
            bool nextPosValid = true;
            switch (direction) {
            case 0:
                nextPosRow = posRow;
                nextPosCol = posCol + 1;
                if (nextPosCol &gt;= n || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 1:
                nextPosRow = posRow + 1;
                nextPosCol = posCol;
                if (nextPosRow &gt;= m || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 2:
                nextPosRow = posRow;
                nextPosCol = posCol - 1;
                if (nextPosCol &lt; 0 || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 3:
                nextPosRow = posRow - 1;
                nextPosCol = posCol;
                if (nextPosRow &lt; 0 || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            }
            if(nextPosValid){
                posRow = nextPosRow;
                posCol = nextPosCol;
            }
            else{
                direction = (direction + 1) % 4;
            }
        }
        return re;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>548</wp:post_id>
		<wp:post_date><![CDATA[2016-08-02 19:29:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-02 11:29:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-54-spiral-matrix]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 55. Jump Game</title>
		<link>http://xiadong.info/2016/08/leetcode-55-jump-game/</link>
		<pubDate>Wed, 03 Aug 2016 08:52:12 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=550</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
For example:
A = [2,3,1,1,4], return true.
A = [3,2,1,0,4], return false.
</blockquote>

数组中的每个元素表示从当前下标可以向前跳的距离, 返回能不能到达最后一个下标. 从第一个元素开始记录从当前元素能到达的最远的下标值, 对之后的每个元素更新这个值, 如果该值小于当前下标则说明该下标无法到达.

<pre lang="c++"><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        int farthest = nums[0], i;
        for(i = 1; i &lt; nums.size() &amp;&amp; farthest &gt;= i; i++){
            farthest = max(farthest, nums[i] + i);
        }
        if(farthest &gt;= nums.size() - 1)
            return true;
        else
            return false;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>550</wp:post_id>
		<wp:post_date><![CDATA[2016-08-03 16:52:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-03 08:52:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-55-jump-game]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 56. Merge Intervals</title>
		<link>http://xiadong.info/2016/08/leetcode-56-merge-intervals/</link>
		<pubDate>Wed, 03 Aug 2016 09:25:03 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=552</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given a collection of intervals, merge all overlapping intervals.
For example,
Given <code>[1,3],[2,6],[8,10],[15,18]</code>,
return <code>[1,6],[8,10],[15,18]</code>.
</blockquote>

合并(闭)区间, 区间以对象的形式给出. 首先将输入的区间数组按照<code>start</code>从小到大排序, 然后先取第一个元素放入结果集中, 从第二个元素开始遍历. 取当前区间为<code>cur</code>, 结果集中的最后一个元素为<code>pre</code>. 如果<code>cur.start &gt; pre.end</code>, 说明<code>cur</code>与<code>pre</code>并无交集, 由于有序, 所以<code>cur</code>以后的区间与<code>pre</code>也都没有交集, 所以可以将<code>cur</code>放入结果集中. 如果<code>cur.start &lt;= pre.end</code>, 说明有交集, 由于必然存在<code>cur.start &gt;= pre.start</code>, 所以新区间的<code>start</code>等于<code>pre.start</code>, 只要考虑<code>cur.end</code>与<code>pre.end</code>的大小关系, 如果<code>cur.end &lt;= pre.end</code>, 那么新区间与<code>pre</code>相同; 如果<code>cur.end &gt; pre.end</code>那么要把<code>pre</code>也就是结果集的最后一个区间的<code>end</code>修改为<code>cur.end</code>.

<pre lang="c++"><code>/**
* Definition for an interval.
* struct Interval {
*     int start;
*     int end;
*     Interval() : start(0), end(0) {}
*     Interval(int s, int e) : start(s), end(e) {}
* };
*/
class Solution {
public:
    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) {
        vector&lt;Interval&gt; ret;
        if(intervals.empty()) return ret;
        sort(intervals.begin(), intervals.end(), [=](Interval &amp;a, Interval &amp;b){
            return a.start &lt; b.start;
        });
        ret.push_back(intervals[0]);
        for(int i = 1; i &lt; intervals.size(); i++){
            Interval cur = intervals[i], pre = ret.back();
            if(cur.start &gt; pre.end){
                ret.push_back(cur);
            }
            else{
                if(cur.end &gt; pre.end){
                    ret.back().end = cur.end;
                }
            }
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>552</wp:post_id>
		<wp:post_date><![CDATA[2016-08-03 17:25:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-03 09:25:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-56-merge-intervals]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 57. Insert Interval</title>
		<link>http://xiadong.info/2016/08/leetcode-57-insert-interval/</link>
		<pubDate>Wed, 03 Aug 2016 10:04:10 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=554</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.
Example 1:
Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.
Example 2:
Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.
This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.
</blockquote>

向一个已经按照start排好序的区间数组中插入新区间, 问题分为两个部分:

<ol>
<li>找到插入位置</li>
<li>确定区间是否需要合并, 如何合并</li>
</ol>

用语言来说还是不太好说清楚, 还是看注释吧.

<pre lang="c++"><code>/**
* Definition for an interval.
* struct Interval {
*     int start;
*     int end;
*     Interval() : start(0), end(0) {}
*     Interval(int s, int e) : start(s), end(e) {}
* };
*/
class Solution {
public:
    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) {
        vector&lt;Interval&gt; ret;
        if(intervals.empty()){ // 如果intervals为空就返回只包含newInterval的数组
            ret.push_back(newInterval);
            return ret;
        }
        int i;
        // 以下循环用于跳过所有end小于newInterval.start, 也就是所有小于newInterval并且
        // 与newInterval没有交集的区间
        for(i = 0; i &lt; intervals.size() &amp;&amp; intervals[i].end &lt; newInterval.start; i++);
        // 如果i == intervals.size(), 说明所有元素都小于newInterval, 把它插入到最后即可
        if(i == intervals.size()){
            intervals.push_back(newInterval);
            return intervals;
        }
        int j = i;
        // 将要插入的新区间
        Interval t;
        // 此时j = i, intervals[j]是end &gt;= newInterval.start的第一个元素,但它们的start
        // 关系还不确定, 因此要插入的start值是intervals[j].start和newInterval.start中较
        // 小的一个
        t.start = min(intervals[j].start, newInterval.start);
        // 寻找start &gt; newInterval.end的元素, 该元素之前的元素是要与newInterval合并的区间
        for(; j &lt; intervals.size() &amp;&amp; intervals[j].start &lt;= newInterval.end; j++);
        // 如果j == intervals.size()说明i之后的所有区间都要与newInterval合并,
        // 所以t.end是newInterval.end和intervals.back().end中较大的值.
        // 然后删除intervals中i之后的元素(包括i, 因为i也与newInterval有交集),
        // 最后插入t
        if(j == intervals.size()){
            t.end = max(newInterval.end, intervals.back().end);
            intervals.erase(intervals.begin() + i, intervals.end());
            intervals.push_back(t);
            return intervals;
        }
        // 否则intervals[j - 1]是start &lt;= newInterval.end的最后一个元素, 也就是与newInterval
        // 有交集的最后一个元素, t.end的值是newInterval.end和intervals[j - 1].end中较大的.
        // 从intervals中移除下标在[i, j-1]范围内的元素, 在i位置插入新区间t.
        else{
            t.end = max(newInterval.end, intervals[j - 1].end);
            intervals.erase(intervals.begin() + i, intervals.begin() + j);
            intervals.insert(intervals.begin() + i, t);
        }
        return intervals;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>554</wp:post_id>
		<wp:post_date><![CDATA[2016-08-03 18:04:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-03 10:04:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-57-insert-interval]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 58. Length of Last Word</title>
		<link>http://xiadong.info/2016/08/leetcode-58-length-of-last-word/</link>
		<pubDate>Thu, 04 Aug 2016 08:59:03 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=558</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string.
If the last word does not exist, return 0.
Note: A word is defined as a character sequence consists of non-space characters only.
For example, 
Given s = &quot;Hello World&quot;,
return 5.
</blockquote>

找出一个字符串中最后一个单词的长度, 没有什么好说的, 从后往前搜索.

<pre lang="c++"><code>class Solution {
public:
    int lengthOfLastWord(string s) {
        int end = s.size();
        if(end == 0)
            return 0;
        for(; end &gt;= 1 &amp;&amp; s[end - 1] == &#39; &#39;; end--); // 跳过结尾的空格
        int i;
        for(i = end - 1; i &gt;= 0 &amp;&amp; s[i] != &#39; &#39;; i--);
        return end - i - 1;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>558</wp:post_id>
		<wp:post_date><![CDATA[2016-08-04 16:59:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-04 08:59:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-58-length-of-last-word]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 59. Spiral Matrix II</title>
		<link>http://xiadong.info/2016/08/leetcode-59-spiral-matrix-ii/</link>
		<pubDate>Thu, 04 Aug 2016 09:38:11 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=561</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.
For example,
Given n = 3,
You should return the following matrix:
<pre><code>[
  [ 1, 2, 3 ],
  [ 8, 9, 4 ],
  [ 7, 6, 5 ]
]
</code></pre></blockquote>

螺旋输出序列. 首先用一个循环, 在循环体内填充一圈数字, 直到所有位置填满.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) {
        vector&lt;vector&lt;int&gt; &gt; ret(n, vector&lt;int&gt;(n, 0));
        if(n == 0)return ret;
        int a = 1;
        for(int i = n; i &gt; 0; i-=2){ // 圈数应为n/2
            if(i == 1 &amp;&amp; n % 2 == 1){ // 当n为奇数时, 最内圈只有一个元素
                ret[(n - i) / 2][(n - i) / 2] = a++;
                break;
            }
            for(int j = (n - i) / 2; j &lt; n - (n - i) / 2 - 1; j++) // 填充上边的行
                ret[(n - i) / 2][j] = a++;
            for(int j = (n - i) / 2; j &lt; n - (n - i) / 2 - 1; j++) // 填充右边的列
                ret[j][n - (n - i) / 2 - 1] = a++;
            for(int j = n - (n - i) / 2 - 1; j &gt; (n - i) / 2; j--) // 填充下边的行
                ret[n - (n - i) / 2 - 1][j] = a++;
            for(int j = n - (n - i) / 2 - 1; j &gt; (n - i) / 2; j--) // 填充左边的列
                ret[j][(n - i) / 2] = a++;
        }

        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>561</wp:post_id>
		<wp:post_date><![CDATA[2016-08-04 17:38:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-04 09:38:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-59-spiral-matrix-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 60. Permutation Sequence</title>
		<link>http://xiadong.info/2016/08/leetcode-60-permutation-sequence/</link>
		<pubDate>Thu, 04 Aug 2016 10:12:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=566</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):
<ol>
    <li>"123"</li>
    <li>"132"</li>
    <li>"213"</li>
    <li>"231"</li>
    <li>"312"</li>
    <li>"321"</li>
</ol>
Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.</blockquote>

返回[1,n]n个数字的全排列按照字典序排序后的第k个排列, n在[1,9]的范围内.

通过观察题目给出的<code>n = 3</code>的全排列可以看出, 以1, 2, 3开头的排列各有两个. n的全排列有<code>n!</code>种, 而以[1,n]中某个数字开头的排列种数有<code>(n - 1)!</code>种, 所以第k个排列的第一个数为<code>(k - 1) / (n - 1)! + 1</code>. 将k更新为<code>k % (n - 1)!</code>, 把第一个已经确定的数从数字集合中去掉(该集合应有序), 就可以以类似递归的方法确定整个序列.

实际上每一次确定数字在集合数组中的下标比直接确定数字要更加有效. 而且由于n在1到9之间, 因此可以先把<code>n!</code>计算出来放到数组中.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;int&gt; arr = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
    string getPermutation(int n, int k) {
        int kk = k - 1;
        vector&lt;int&gt; nums;
        for(int i = 1; i &lt;= n; i++){
            nums.push_back(i); //nums[i]的值实际是i + 1
        }
        string ret;
        for(int i = 0; i &lt; n; i++){
            if(i == n - 1){
                ret.push_back(nums[0] + '0'); //i = n - 1时下方会出现除零错误
                break;
            }
            int t = kk / arr[n - 1 - i];
            ret.push_back(nums[t] + '0'); //因为nums[i] = i + 1, 所以不需要再加1
            nums.erase(nums.begin() + t); //把已经确定的元素删除
            kk = kk % arr[n - i - 1];
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>566</wp:post_id>
		<wp:post_date><![CDATA[2016-08-04 18:12:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-04 10:12:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-60-permutation-sequence]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[60-permutation-sequence]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 61. Rotate List</title>
		<link>http://xiadong.info/2016/08/leetcode-61-rotate-list/</link>
		<pubDate>Fri, 05 Aug 2016 08:50:35 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=568</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given a list, rotate the list to the right by k places, where k is non-negative.
For example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,
return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.
</blockquote>

最简单的方法是把所有节点指针保存在一个数组中, 设总长度为<code>len</code>, 然后找到第<code>len - k</code>个节点为新链表的头结点, 它之前的节点是新链表的尾节点. 把原链表的尾节点指向头结点即可. 要注意<code>k</code>可能会大于<code>len</code>, 所以可以先把<code>k</code>对<code>len</code>取余.

<pre lang="c++"><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return head;
        vector&lt;ListNode*&gt; l;
        ListNode* p = head, *reHead;
        while(p){
            l.push_back(p);
            p = p-&gt;next;
        }

        k = k % l.size();
        if(k == 0)
            return head;
        auto iter = l.end() - k;
        (*(iter - 1))-&gt;next = NULL;
        (*(l.end() - 1))-&gt;next = *(l.begin());
        return *iter;
    }
};
</code></pre>

不使用额外空间的方法需要多遍历几次链表:

<pre lang"c++"><code>class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return head;
        int len = 0;
        ListNode *p = head, *newHead = nullptr, *tail = nullptr, *newTail = nullptr;
        while(p){
            len++;
            if(!p-&gt;next)
                tail = p;
            p = p-&gt;next;
        }
        k = k % len;
        if(!k) return head;
        newHead = head;
        for(int i = 0; i &lt; len - k; i++){
            newTail = newHead;
            newHead = newHead-&gt;next;
        }
        newTail-&gt;next = nullptr;
        tail-&gt;next = head;
        return newHead;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>568</wp:post_id>
		<wp:post_date><![CDATA[2016-08-05 16:50:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-05 08:50:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-61-rotate-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 62. Unique Paths</title>
		<link>http://xiadong.info/2016/08/leetcode-62-unique-paths/</link>
		<pubDate>Fri, 05 Aug 2016 09:01:51 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=571</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

<img src="http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png" alt="" />

Above is a 3 x 7 grid. How many possible unique paths are there?

Note: m and n will be at most 100.</blockquote>

经典的动态规划题目, 由于每一个格子只能从上面的格子和左面的格子到达, 所以到达每个格子的路线数量等于到达上面格子的路线数量+到达左面格子的路线数量.

<pre lang="c++"><code>class Solution {
public:
    int uniquePaths(int m, int n) {
        int arr[m][n];
        int i, j;
        for(i = 0; i &lt; m; i++)
            arr[i][0] = 1;
        for(i = 0; i &lt; n; i++)
            arr[0][i] = 1;
        for(i = 1; i &lt; m; i++){
            for(j = 1; j &lt; n; j++){
                arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
            }
        }

        return arr[m - 1][n - 1];
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>571</wp:post_id>
		<wp:post_date><![CDATA[2016-08-05 17:01:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-05 09:01:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-62-unique-paths]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[leetcode-60-permutation-sequence-2]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 63. Unique Paths II</title>
		<link>http://xiadong.info/2016/08/leetcode-63-unique-paths-ii/</link>
		<pubDate>Fri, 05 Aug 2016 09:15:23 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=574</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述

<blockquote>
Follow up for &quot;Unique Paths&quot;:
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.
For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.
<pre><code>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
</code></pre>The total number of unique paths is 2.
Note: m and n will be at most 100.
</blockquote>

紧跟着上一题<a href="http://xiadong.info/2016/08/leetcode-62-unique-paths/">Unique Paths</a>, 这一题增加了条件, 在地图上会出现障碍物(用1表示), 障碍物不能出现在路线上. 仍然采用上一题的动态规划法, 只不过多了一条:

<ul>
<li>所有障碍物的位置到达的路线数量都为0</li>
</ul>

<pre lang="c++"><code>class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0)
            return 0;
        int n = obstacleGrid[0].size();
        vector&lt;vector&lt;int&gt;&gt; arr(m, vector&lt;int&gt;(n, 0));
        int i, j;
        for(i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] != 1; i++)
            arr[i][0] = 1;
        for(i = 0; i &lt; n &amp;&amp; obstacleGrid[0][i] != 1; i++)
            arr[0][i] = 1;
        for(i = 1; i &lt; m; i++){
            for(j = 1; j &lt; n; j++){
                if(obstacleGrid[i][j])
                    continue;

                arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
            }
        }

        return arr[m - 1][n - 1];
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>574</wp:post_id>
		<wp:post_date><![CDATA[2016-08-05 17:15:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-05 09:15:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-63-unique-paths-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 64. Minimum Path Sum</title>
		<link>http://xiadong.info/2016/08/leetcode-64-minimum-path-sum/</link>
		<pubDate>Sat, 06 Aug 2016 08:39:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=577</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
</blockquote>

动态规划问题, 到达每个格子的最小的路径和等于到达左边左边格子的路径和与到达上面的格子的路径和中的较小值加上当前格子的值.

<pre lang="c++"><code>class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) {
        int height = grid.size(), width = grid[0].size();

        for(int i = 1; i &lt; height; i++)
            grid[i][0] += grid[i - 1][0];
        for(int i = 1; i &lt; width; i++)
            grid[0][i] += grid[0][i - 1];

        for(int i = 1; i &lt; height; i++){
            for(int j = 1; j &lt; width; j++){
                grid[i][j] += (grid[i - 1][j] &lt; grid[i][j - 1] ? grid[i - 1][j] : grid[i][j - 1]);
            }
        }

        return grid[height - 1][width - 1];
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>577</wp:post_id>
		<wp:post_date><![CDATA[2016-08-06 16:39:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-06 08:39:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-64-minimum-path-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 65. Valid Number</title>
		<link>http://xiadong.info/2016/08/leetcode-65-valid-number/</link>
		<pubDate>Sat, 06 Aug 2016 12:44:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=580</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Validate if a given string is numeric.

Some examples:

<code>"0"</code> =&gt; <code>true</code>

<code>" 0.1 "</code> =&gt; <code>true</code>

<code>"abc"</code> =&gt; <code>false</code>

<code>"1 a"</code> =&gt; <code>false</code>

<code>"2e10"</code> =&gt; <code>true</code>

Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</blockquote>

判断一个输入字符串是否是数字, 这道题的要求并不是很明确, 一下子很难想的全面, 并且也不容易跟出题人想到一块去. 实际上主要有以下几点:

<ul>
    <li>字符串前后可以有空格, 但是数字中间不能出现空格</li>
    <li>允许出现的字符有<code>+</code>, <code>-</code>, <code>.</code>, <code>e</code>和阿拉伯数字</li>
    <li>数字可以以<code>.</code>开头或结尾</li>
    <li>e后面的指数部分只能是整数</li>
</ul>

<pre lang="c++"><code>class Solution {
public:
    bool isNumber(string s) {
        delSpace(s);
        for(int i = 0; i &lt; s.length(); i++){ // 检查除e, ., 和数字以外的字符
            if((s[i] &lt; '0' || s[i] &gt; '9')  &amp;&amp; s[i] != 'e' &amp;&amp; s[i] != '.' &amp;&amp; s[i] != '-' &amp;&amp; s[i] != '+') return false;
        }
        int eCnt = 0;
        for(int i = 0; i &lt; s.length(); i++){ // 计算e的个数
            if(s[i] == 'e') eCnt++;
        }
        //printf("%d\n", eCnt);
        if(eCnt &gt; 1) return false; // e多于1个则返回false
        if(eCnt == 1){
            // 如果有e出现, 前后都有不含e的数字
            int i;
            for(i = 0; s[i] != 'e'; i++);
            // e的前面可以是小数, 但是后面不可以
            if(!isNumberWithoutE(s.substr(0, i)) || !isNumberWithoutEAndDot(s.substr(i + 1, s.length() - i - 1))){
                return false;
            }
            else return true;
        }
        else{
            // 如果没有e
            return isNumberWithoutE(s);
        }
    }

    bool isNumberWithoutE(string s){ // 判断是不是不包含e的数字
        if(s.empty()) return false;
        if(s.length() == 1 &amp;&amp; (s[0] == '.' || s[0] == '-' || s[0] == '+')) return false; // 只有符号或小数点
        int dashPos = -1, dotCnt = 0, plusSignPos = -1;
        for(int i = 0; i &lt; s.length(); i++){ // 查找是否有不位于开头的正负号
            if(s[i] == '-') dashPos = i;
            else if(s[i] == '+') plusSignPos = i;
        }
        if(dashPos &gt; 0 || plusSignPos &gt; 0) return false;
        if(s[0] == '+' || s[0] == '-'){ // 清除开头的正负号
            s.erase(s.begin(), s.begin() + 1);
        }
        if(s.length() == 1 &amp;&amp; s[0] == '.') return false; // 如果去掉符号后只有小数点了, 那么不是数字
        for(int i = 0; i &lt; s.length(); i++){ // 计算小数点的数量
            if(s[i] == '.') dotCnt++;
        }
        if(dotCnt &gt; 1) return false;
        else return true;
    }

    bool isNumberWithoutEAndDot(string s){ //判断是不是不包含e的整数
        if(s.empty()) return false;
        if(s.length() == 1 &amp;&amp; (s[0] == '.' || s[0] == '-' || s[0] == '+')) return false;
        int dashPos = -1, plusSignPos = -1;
        for(int i = 0; i &lt; s.length(); i++){ // 查找是否有不位于开头的正负号
            if(s[i] == '-') dashPos = i;
            else if(s[i] == '+') plusSignPos = i;
            else if(s[i] == '.') return false; // 如果有小数点则返回false
        }
        if(dashPos &gt; 0 || plusSignPos &gt; 0) return false;
        else return true;
    }

    void delSpace(string &amp;s){ //删除前后空格
        int i;
        for(i = 0; i &lt; s.size() &amp;&amp; s[i] == ' '; i++);
        s.erase(s.begin(), s.begin() + i);
        for(i = 0; i &lt; s.size() &amp;&amp; s[s.size() - i - 1] == ' '; i++);
        s.erase(s.end() - i, s.end());
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>580</wp:post_id>
		<wp:post_date><![CDATA[2016-08-06 20:44:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-06 12:44:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-65-valid-number]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 66. Plus One</title>
		<link>http://xiadong.info/2016/08/leetcode-66-plus-one/</link>
		<pubDate>Sun, 07 Aug 2016 14:52:01 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=582</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given a non-negative number represented as an array of digits, plus one to the number.
The digits are stored such that the most significant digit is at the head of the list.
</blockquote>

数组模拟计算, 由于只加1, 所以比较简单.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) {
        vector&lt;int&gt; ret = digits;
        int jw = 1;
        for(int i = ret.size() - 1; i &gt;= 0 &amp;&amp; jw; i--){
            ret[i]++;
            if(ret[i] == 10){
                jw = 1;
                ret[i] = 0;
            }
            else{
                jw = 0;
            }
        }
        if(jw){
            ret.insert(ret.begin(), 1);
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>582</wp:post_id>
		<wp:post_date><![CDATA[2016-08-07 22:52:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-07 14:52:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-66-plus-one]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 67. Add Binary</title>
		<link>http://xiadong.info/2016/08/leetcode-67-add-binary/</link>
		<pubDate>Mon, 08 Aug 2016 09:01:38 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=584</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two binary strings, return their sum (also a binary string).

For example,

a = <code>"11"</code>

b = <code>"1"</code>

Return <code>"100"</code>.</blockquote>

模拟加法计算, 只不过是使用二进制格式.

<pre lang="c++"><code>class Solution {
public:
    string addBinary(string a, string b) {
        if(a.length() &lt; b.length()) swap(a, b);
        int pa = a.length() - 1, pb = b.length() - 1, jw = 0;
        while(pb &gt;= 0){
            a[pa] = a[pa] - '0' + b[pb] - '0' + jw + '0';
            if(a[pa] &gt;= '2'){
                a[pa] = a[pa] % '2' + '0';
                jw = 1;
            }
            else{
                jw = 0;
            }
            pa--, pb--;
        }
        while(pa &gt;= 0){
            a[pa] = a[pa] + jw;
            if(a[pa] &gt;= '2'){
                a[pa] = a[pa] % '2' + '0';
                jw = 1;
            }
            else{
                jw = 0;
            }
            pa--;
        }
        if(jw){
            a.insert(a.begin(), '1');
        }
        return a;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>584</wp:post_id>
		<wp:post_date><![CDATA[2016-08-08 17:01:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-08 09:01:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-67-add-binary]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 68. Text Justification</title>
		<link>http://xiadong.info/2016/08/leetcode-68-text-justification/</link>
		<pubDate>Mon, 08 Aug 2016 10:46:31 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=586</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.
You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces &#39; &#39; when necessary so that each line has exactly L characters.
Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.
For the last line of text, it should be left justified and no extra space is inserted between words.
For example,
words: <code>[&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</code>
L: <code>16</code>.
Return the formatted lines as:
<pre><code>[
   &quot;This    is    an&quot;,
   &quot;example  of text&quot;,
   &quot;justification.  &quot;
]
</code></pre>Note: Each word is guaranteed not to exceed L in length.
</blockquote>

细节比较多, 难度倒也不是很大, 但是这种题在面试的时候我觉得更难, 因为考虑许多情况, 人肉调试还是比较困难的.

<pre lang="c++"><code>class Solution {
public:
    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) {
        vector&lt;string&gt; ret;
        if(maxWidth == 0) { // 因为每个单词长度都不会超过maxWidth, 所以可以直接返回
            ret.push_back(string(&quot;&quot;));
            return ret;
        }
        // start保存每行单词的起始下标, end表示结束下标, 单词的下标范围为[start, end)
        // lenInLine保存每一行的长度
        int start = 0, end = 0, lenInLine = 0;
        while (start &lt; words.size()) {
            // 计算这一行能放多少个单词, 把第一个单词放进去, +1是因为后面还有一个空格
            lenInLine = words[start].length() + 1; 
            end = start + 1; 
            while (end &lt; words.size() &amp;&amp; lenInLine &lt; maxWidth) {
                lenInLine += words[end++].length();
                lenInLine += 1; // 计算空格
            }
            if(lenInLine - 1 &gt; maxWidth){ // 去掉尾部空格后如果还是大于maxWidth, 那么应该少放一个单词
                end--;
            }
            if (end == words.size()) { // 根据题目, 最后一行要单独处理, 使用左对齐而不是两端对齐
                string line = words[start];
                for (int i = start + 1; i &lt; end; i++) {
                    line += &quot; &quot;;
                    line += words[i];
                }
                line.insert(line.end(), maxWidth - line.length(), &#39; &#39;);
                ret.push_back(line);
            }
            else {
                createLine(words, start, end, ret, maxWidth); // 创建行
            }
            start = end;
        }
        return ret;
    }

    void createLine(vector&lt;string&gt; &amp;words, int start, int end, vector&lt;string&gt; &amp;ret, int maxWidth) {
        string line;
        int wordCnt = end - start, spacePerInterval = 0, spaceCnt = maxWidth;
        if (wordCnt == 0) return; // end == start, 没有单词
        for (int i = start; i &lt; end; i++) { // 计算总空格数
            spaceCnt -= words[i].length();
        }
        // 如果spaceCnt不能平均分配, 那么左边的一个或多个间隔就要增加一个空格
        // moreSpaceLen保存左边的多少个间隔需要多的空格
        int moreSpaceLen = spaceCnt % (wordCnt - 1 ? wordCnt - 1 : 1);
        spacePerInterval = spaceCnt / (wordCnt - 1 ? wordCnt - 1 : 1);
        line += words[start];
        if(wordCnt == 1){
            // 因为下面的循环从start + 1开始, 所以如果行内只有一个单词,
            // 就要在其之后填充空格直到长度达到maxWidth
            line.insert(line.end(), maxWidth - line.length(), &#39; &#39;);
        }
        else{
            for (int i = start + 1; i &lt; end; i++) {
                if (i &lt;= start + moreSpaceLen) {
                    line.insert(line.end(), spacePerInterval + 1, &#39; &#39;);
                }
                else {
                    line.insert(line.end(), spacePerInterval, &#39; &#39;);
                }
                line += words[i];
            }
        }
        ret.push_back(line);
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>586</wp:post_id>
		<wp:post_date><![CDATA[2016-08-08 18:46:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-08 10:46:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-68-text-justification]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 69. Sqrt(x)</title>
		<link>http://xiadong.info/2016/08/leetcode-69-sqrtx/</link>
		<pubDate>Mon, 08 Aug 2016 10:59:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=588</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>
Implement <code>int sqrt(int x)</code>.
Compute and return the square root of x.
</blockquote>

实现整数的开平方运算, 使用二分搜索, 也就是方程求根的二分法来计算. 因为计算结果为整数, 所以最后如果没有平方根的准确值, 要把最后的结果减1.

<pre lang="c++"><code>class Solution {
public:
    int mySqrt(int x) {
        if(x == 1) return 1;
        long long left = 1, right = x, mid = (left + right) / 2;
        while(left &lt; right){
            long long m = mid * mid;
            if(m &gt; x) 
                right = mid;
            else if(m &lt; x)
                left = mid + 1;
            else 
                return mid;
            mid = (left + right) / 2;
        }
        return left - 1;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>588</wp:post_id>
		<wp:post_date><![CDATA[2016-08-08 18:59:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-08 10:59:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-69-sqrtx]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 70. Climbing Stairs</title>
		<link>http://xiadong.info/2016/08/leetcode-70-climbing-stairs/</link>
		<pubDate>Tue, 09 Aug 2016 08:40:53 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=591</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</blockquote>

斐波那契数列, 到达第n层的路径数量等于到达第n - 1层的路径数量加到达第n - 2层的路径数量.

<pre lang="c++"><code>class Solution {
public:
    int climbStairs(int n) {
        if(n == 1)return 1;
        if(n == 2)return 2;
        int a = 1, b = 2, t;
        for(int i = 2; i &lt; n; i++){
            t = b;
            b = a + b;
            a = t;
        }
        return b;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>591</wp:post_id>
		<wp:post_date><![CDATA[2016-08-09 16:40:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-09 08:40:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-70-climbing-stairs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 71. Simplify Path</title>
		<link>http://xiadong.info/2016/08/leetcode-71-simplify-path/</link>
		<pubDate>Tue, 09 Aug 2016 09:23:24 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=595</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an absolute path for a file (Unix-style), simplify it.
For example,
<strong>path</strong> = <code>"/home/"</code>, =&gt; <code>"/home"</code>
<strong>path</strong> = <code>"/a/./b/../../c/"</code>, =&gt; <code>"/c"</code>
<strong>Corner Cases:</strong>
<ul>
    <li>Did you consider the case where <strong>path</strong> = <code>"/../"</code>?
In this case, you should return <code>"/"</code>.</li>
    <li>Another corner case is the path might contain multiple slashes <code>'/'</code> together, such as <code>"/home//foo/"</code>.
In this case, you should ignore redundant slashes and return <code>"/home/foo"</code>.</li>
</ul>
</blockquote>

题目要求简化一个路径, 要做到两点:

<ol>
    <li>去掉无效的<code>/</code>, 比如连续的<code>/</code>和结尾的<code>/</code></li>
    <li>把<code>.</code>和<code>..</code>这种相对路径转换为绝对路径</li>
</ol>

先使用栈保存<code>/</code>分割的每个节点, 在处理过程中分为三种情况:

<ol>
    <li>节点为<code>.</code>: 不做任何处理</li>
    <li>节点为<code>..</code>: 若栈不为空则弹出栈顶元素</li>
    <li>否则将节点入栈</li>
</ol>

最后把栈变为字符串输出.

<pre lang="c++">class Solution {
public:
    string simplifyPath(string path) {
        vector&lt;string&gt; pathStack = splitPath(path);
        return getFinPath(pathStack);
    }

    string getFinPath(vector&lt;string&gt; &amp;finStack){
        string re = "";
        for(int i = 0 ; i &lt; finStack.size(); i++){
            re += "/";
            re += finStack[i];
        }
        if(re == "")
            re = "/";
        return re;
    }

    vector&lt;string&gt; splitPath(string path){
        vector&lt;string&gt; re;
        for(int i = 0; i &lt; path.size(); i++){
            if(path[i] != '/'){
                int end = getEnd(path, i);
                string node = string(path.begin() + i, path.begin() + end);
                if(node == string(".")){
                    // do nothing
                }
                else if(node == string("..")){
                    if(!re.empty()) re.pop_back();
                }
                else{
                    re.push_back(node);
                }
                i = end;
            }
        }
        return re;
    }

    int getEnd(string path, int start){
        int i = start;
        for(; i &lt; path.size() &amp;&amp; path[i] != '/'; i++);
        return i;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>595</wp:post_id>
		<wp:post_date><![CDATA[2016-08-09 17:23:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-09 09:23:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-71-simplify-path]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 72. Edit Distance</title>
		<link>http://xiadong.info/2016/08/leetcode-72-edit-distance/</link>
		<pubDate>Tue, 09 Aug 2016 10:15:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=597</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)
You have the following 3 operations permitted on a word:
a) Insert a character
b) Delete a character
c) Replace a character
</blockquote>

题目要求计算两个单词(word1, word2)的&quot;距离&quot;, 就是说最少经过多少步可以从word1变幻到word2. 可以使用的操作有三种:

<ol><li>
插入一个字符</li>
<li>
删除一个字符</li>
<li>
替换一个字符</li>
</ol>

这道题目使用动态规划来解决. 

数组<code>dp[i][j]</code>表示<code>word1[0:i-1]</code>(包括i-1)与<code>word2[0:j-1]</code>之间的距离.

根据最后一次操作的类型分为三类:

<ol><li>
word1插入字符, 此时<code>dp[i][j] = dp[i][j - 1] + 1</code>, 因为这是在<code>word1[0:i-1]=&gt;word2[0:j-2]</code>需要<code>dp[i][j - 1]</code>的基础上, word2最后又增加了一个字符, 因此<code>word1[0:i-1]=&gt;word2[0:j-2]</code>之后再增加一步插入字符的操作(也可以看作word2=&gt;word1最后多删除了一个字符)</li>
<li>
word2插入字符, 此时<code>dp[i][j] = dp[i - 1][j] + 1</code>, 因为这是在<code>word2[0:j-1]=&gt;word1[0:i-2]</code>需要<code>dp[i - 1][j]</code>的基础上, word1最后又增加了一个字符, 因此<code>word2[0:j-1]=&gt;word1[0:i-2]</code>之后再增加一步插入字符的操作(也可以看作word1=&gt;word2最后多删除了一个字符)</li>
<li>
替换操作, 如果<code>word1[i - 1] == word2[j - 1]</code>, 那么<code>dp[i][j] = dp[i - 1][j - 1]</code>, 否则<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li>
</ol>

因此递推方程为

<code>dp[i][j] = min(dp[i-1][j-1] + (word1[i-1] == word2[j-1] ? 0 : 1), dp[i][j - 1] + 1, dp[i - 1][j] + 1)</code>

初始条件为<code>dp[i][0] = i; dp[0][j] = j;</code>(全部为插入操作)



<pre lang="c++">
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.length(), len2 = word2.length();
        int arr[len1 + 1][len2 + 1];
        arr[0][0] = 0;
        for(int i = 1; i &lt;= len2; i++){
            arr[0][i] = i;
        }
        for(int i = 1; i &lt;= len1; i++){
            arr[i][0] = i;
        }
        for(int i = 1; i &lt;= len1; i++){
            for(int j = 1; j &lt;= len2; j++){
                int tmp1 = arr[i - 1][j] + 1, tmp2 = arr[i][j - 1] + 1, tmp3;
                if(word1[i - 1] == word2[j - 1]) tmp3 = arr[i - 1][j - 1];
                else tmp3 = arr[i - 1][j - 1] + 1;
                arr[i][j] = min(tmp1, min(tmp2, tmp3));
            }
        }
        return arr[len1][len2];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>597</wp:post_id>
		<wp:post_date><![CDATA[2016-08-09 18:15:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-09 10:15:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-72-edit-distance]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 382. Linked List Random Node</title>
		<link>http://xiadong.info/2016/08/leetcode-382-linked-list-random-node/</link>
		<pubDate>Wed, 10 Aug 2016 08:56:45 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=600</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a singly linked list, return a random node&#39;s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.
<strong>Follow up:</strong>
What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?
<strong>Example:</strong>
<pre>
// Init a singly linked list [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom() should return either 1, 2, or 3 randomly. Each element &gt;should have equal probability of returning.
solution.getRandom();
</pre>
</blockquote>

要求设计一个类, 根据一个未知长度的单链表进行构造, 每次调用<code>getRandom</code>成员函数时返回一个随机节点. 

O(n)空间复杂度, O(1)时间复杂度的方法就是用一个顺序容器保存所有节点的指针, 然后每次调用<code>getRandom</code>都根据下标来访问.

<pre lang="c++">
class Solution {
    vector&lt;ListNode*&gt; nodes;
public:
    /** @param head The linked list&#39;s head. Note that the head is guanranteed to be not null, so it contains at least one node. */
    Solution(ListNode* head) {
        srand(time(NULL));
        ListNode *p = head;
        while(p){
            nodes.push_back(p);
            p = p-&gt;next;
        }
    }
    
    /** Returns a random node&#39;s value. */
    int getRandom() {
        int r = rand() % nodes.size();
        return nodes[r]-&gt;val;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */
</pre>

对于题目中的Follow up部分, 要使用O(1)空间复杂度, O(n)时间复杂度. 在类中只保存链表头结点和当前访问节点, 每次生成的随机数是下一个节点与当前节点的距离.

<pre lang="c++">
class Solution {
    ListNode *head, *mp;
    int listLen;
public:
    /** @param head The linked list&#39;s head. Note that the head is guanranteed to be not null, so it contains at least one node. */
    Solution(ListNode* h) {
        srand(time(NULL));
        this-&gt;head = h;
        this-&gt;mp = this-&gt;head;
        listLen = 0;
        ListNode *p = h;
        while(p){
            listLen++;
            p = p-&gt;next;
        }
    }
    
    /** Returns a random node&#39;s value. */
    int getRandom() {
        int r = rand() % listLen;
        for(int i = 0; i &lt; r; i++){
            mp = mp-&gt;next;
            if(mp == nullptr) mp = head;
        }
        return mp-&gt;val;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>600</wp:post_id>
		<wp:post_date><![CDATA[2016-08-10 16:56:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-10 08:56:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-382-linked-list-random-node]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 73. Set Matrix Zeroes</title>
		<link>http://xiadong.info/2016/08/leetcode-73-set-matrix-zeroes/</link>
		<pubDate>Wed, 10 Aug 2016 09:20:42 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=602</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a <em>m</em> x <em>n</em> matrix, if an element is 0, set its entire row and column to 0. Do it in place.
<strong>Follow up:</strong>Did you use extra space?
A straight forward solution using O(<em>mn</em>) space is probably a bad idea.
A simple improvement uses O(<em>m + n</em>) space, but still not the best solution.
Could you devise a constant space solution?
</blockquote>

这道题主要的要求在于空间复杂度, O(mn)的复杂度就是使用另一个m×n的矩阵来保存结果. O(m+n)的复杂度则是用两个数组分别保存要设置为0的行数和列数:

<pre lang="c++">
class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int m = matrix.size();
        if(!m){
            return;
        }
        int n = matrix[0].size();
        vector&lt;int&gt; rowFlag(m, 1), colFlag(n, 1);
        for(int i = 0; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                if(matrix[i][j] == 0){
                    rowFlag[i] = 0;
                    colFlag[j] = 0;
                }
            }
        }
        for(int i = 0; i &lt; m; i++){
            if(!rowFlag[i]){
                setZeroRow(matrix, i, n);
            }
        }
        for(int i = 0; i &lt; n; i++){
            if(!colFlag[i]){
                setZeroCol(matrix, i, m);
            }
        }
    }
    
    void setZeroRow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int row, int n){
        for(int i = 0; i &lt; n; i++)
            matrix[row][i] = 0;
    }
    
    void setZeroCol(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int col, int m){
        for(int i = 0; i &lt; m; i++)
            matrix[i][col] = 0;
    }
};
</pre>

而不使用额外空间的方法不是那么直观, 我的方法是先找到一个为0的位置(r,c), 然后使用它所在的行和列来保存要置为0的行数和列数, 最后再把该行和该列置为0.

<pre lang="c++">
class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int x = -1, y = -1, m = matrix.size();
        if(!m){
            return;
        }
        int n = matrix[0].size();
        // 以下找到第一个0所在的位置
        for(int i = 0; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                if(matrix[i][j] == 0){
                    y = j;
                    break;
                }
            }
            if(y != -1){
                x = i;
                break;
            }
        }
        if(x == -1 &amp;&amp; y == -1)
            return;
        // 因为之前的位置不存在0, 所以可以从x开始遍历
        for(int i = x; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                if(matrix[i][j] == 0){
                    matrix[x][j] = 0;
                    matrix[i][y] = 0;
                }
            }
        }
        
        for(int i = 0; i &lt; m; i++){
            if(i == x)
                continue; // 跳过x, 要在最后处理
            if(matrix[i][y] == 0){
                setZeroRow(matrix, i, n);
            }
        }
        
        for(int i = 0; i &lt; n; i++){
            if(i == y)
                continue;
            if(matrix[x][i] == 0){
                setZeroCol(matrix, i, m);
            }
        }
        
        setZeroRow(matrix, x, n);
        setZeroCol(matrix, y, m);
    }
    
    void setZeroRow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int row, int n){
        for(int i = 0; i &lt; n; i++)
            matrix[row][i] = 0;
    }
    
    void setZeroCol(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int col, int m){
        for(int i = 0; i &lt; m; i++)
            matrix[i][col] = 0;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>602</wp:post_id>
		<wp:post_date><![CDATA[2016-08-10 17:20:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-10 09:20:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-73-set-matrix-zeroes]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 74. Search a 2D Matrix</title>
		<link>http://xiadong.info/2016/08/leetcode-74-search-a-2d-matrix/</link>
		<pubDate>Wed, 10 Aug 2016 09:26:42 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=604</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:
<ul><li>
Integers in each row are sorted from left to right.</li>
<li>
The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
For example,
Consider the following matrix:
<pre>
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</pre>
</blockquote>

对矩阵应用两次二分搜索, 第一次确定元素所在行, 第二次在行内确定元素.

<pre lang="c++">
class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        int row = getRow(matrix, target) - 1;
        if(row == -1){
            if(matrix[0][0] != target)
                return false;
            else
                return true;
        }
        return getTarget(matrix, target, row);
    }
    
    int getRow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target){
        int n = matrix.size();
        int left = 0, right = n, mid = (left + right) / 2;
        while(left &lt; right){
            if(matrix[mid][0] == target)
                return mid + 1;
            if(matrix[mid][0] &lt; target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
            mid = (left + right) / 2;
        }
        return mid;
    }
    
    bool getTarget(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target, int row){
        int n = matrix[row].size();
        int left = 0, right = n, mid = (left + right) / 2;
        while(left &lt; right){
            if(matrix[row][mid] == target)
                return true;
            if(matrix[row][mid] &lt; target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
            mid = (left + right) / 2;
        }
        return false;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>604</wp:post_id>
		<wp:post_date><![CDATA[2016-08-10 17:26:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-10 09:26:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-74-search-a-2d-matrix]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 383. Ransom Note</title>
		<link>http://xiadong.info/2016/08/leetcode-383-ransom-note/</link>
		<pubDate>Thu, 11 Aug 2016 08:28:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=606</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. 
Each letter in the magazine string can only be used once in your ransom note.
<strong>Note:</strong>
You may assume that both strings contain only lowercase letters.
<pre>
canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false
canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false
canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true
</pre>
</blockquote>

Ransom note的意思是勒索信或者绑架信, 题目要求判断是不是所有绑架信上的字母都可以用magazines中的字母拼出来. 使用的方法是类似hash表, 不过hash值就是字母在字母表中的位置.

<pre lang="c++">
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        vector&lt;int&gt; flag(26, 0);
        for(int i = 0; i &lt; magazine.length(); i++){
            flag[magazine[i] - &#39;a&#39;]++;
        }
        for(int i = 0; i &lt; ransomNote.length(); i++){
            if(flag[ransomNote[i] - &#39;a&#39;] == 0){
                return false;
            }
            else{
                flag[ransomNote[i] - &#39;a&#39;]--;
            }
        }
        return true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>606</wp:post_id>
		<wp:post_date><![CDATA[2016-08-11 16:28:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-11 08:28:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-383-ransom-note]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 75. Sort Colors</title>
		<link>http://xiadong.info/2016/08/leetcode-75-sort-colors/</link>
		<pubDate>Thu, 11 Aug 2016 09:15:56 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=608</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array with <em>n</em> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
<strong>Note:</strong>
You are not suppose to use the library&#39;s sort function for this problem.
<strong>Follow up:</strong>
A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0&#39;s, 1&#39;s, and 2&#39;s, then overwrite array with total number of 0&#39;s, then 1&#39;s and followed by 2&#39;s.
Could you come up with an one-pass algorithm using only constant space?
</blockquote>

由于数组中元素的值只有三种, 所以可以先遍历一遍数组, 分别记录下三种值的出现次数, 然后再按照值的大小和数量填充到数组中.

<pre lang="c++">
class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        int colorNum[3] = {0,0,0};
        for(int i = 0; i &lt; nums.size(); i++){
            colorNum[nums[i]]++;
        }
        int k = 0;
        for(int i = 0; i &lt; 3; i++){
            for(int j = 0; j &lt; colorNum[i]; j++){
                nums[k++] = i;
            }
        }
    }
};
</pre>

关于Follow up中的单次遍历, 可以使用两个指针分别指向red(0)和blue(2)的结尾和开头位置, 然后遍历中间的元素, 通过交换把对应的值放到相应的位置.

<pre lang="c++">
class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        int redIndex = 0, blueIndex = nums.size() - 1;
        while(nums[redIndex] == 0) redIndex++;
        while(nums[blueIndex] == 2) blueIndex--;
        int i = redIndex;
        while(i &lt;= blueIndex){
            if(nums[i] == 0){
                swap(nums[redIndex++], nums[i]);
                i = max(redIndex, i); // 由于i有可能落后于redIndex, 所以要选择一个较大的值
            }
            else if(nums[i] == 2){
                swap(nums[blueIndex--], nums[i]);
            }
            else{
                i++;
            }
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>608</wp:post_id>
		<wp:post_date><![CDATA[2016-08-11 17:15:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-11 09:15:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-75-sort-colors]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 384. Shuffle an Array</title>
		<link>http://xiadong.info/2016/08/leetcode-384-shuffle-an-array/</link>
		<pubDate>Fri, 12 Aug 2016 09:26:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=611</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Shuffle a set of numbers without duplicates.

<strong>Example:</strong>
<pre>// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();
</pre>
</blockquote>

实现一个洗牌类, 实际的要求是生成1到n个不重复的随机数, 范围在[1,n]之间.

其实我不太明白为什么要有一个reset方法, 因为这种随机的排列中这个一开始的原始序列并没有什么特殊性, 也不会影响下一次调用shuffle时的概率.

在LeetCode的Discuss中有貌似题目作者的回复<a href="https://discuss.leetcode.com/topic/53984/reset-makes-no-sense/2" target="_blank">https://discuss.leetcode.com/topic/53984/reset-makes-no-sense/2</a>:

<blockquote>The reason I designed it that way is to increase the likelihood that when <code>shuffle</code> is called it is shuffling based on the original array, not the previously shuffled array. This will increase the chance of detecting bugs in the main algorithm in <code>shuffle</code>.</blockquote>

关于生成随机排列, 我的方法是下标从低到高依次确定每个位置的元素, 假设下标范围为[0,n), 当前下标为i, 那么从[i,n)中取得一个随机数r, 交换下标i与r中的元素, 然后i增加1.

运行时间300多ms. 这个算法实际上叫做<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle?oldformat=true">Fisher–Yates shuffle</a>, Knuth在<em>TAOCP</em>中也介绍过.

<pre lang="c++">class Solution {
    vector&lt;int&gt; orignalNums, ret;
public:
    Solution(vector&lt;int&gt; nums) {
        srand((unsigned)time(NULL));
        ret = orignalNums = nums;
    }
    
    /** Resets the array to its original configuration and return it. */
    vector&lt;int&gt; reset() {
        ret = orignalNums; // 这条语句其实没什么影响
        return orignalNums;
    }
    
    /** Returns a random shuffling of the array. */
    vector&lt;int&gt; shuffle() {
        for(int i = 0; i &lt; ret.size(); i++){
            int index = rand() % (ret.size() - i);
            swap(ret[i], ret[i + index]);
        }
        return ret;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * vector&lt;int&gt; param_1 = obj.reset();
 * vector&lt;int&gt; param_2 = obj.shuffle();
 */
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>611</wp:post_id>
		<wp:post_date><![CDATA[2016-08-12 17:26:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-12 09:26:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-384-shuffle-an-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 76. Minimum Window Substring</title>
		<link>http://xiadong.info/2016/08/leetcode-76-minimum-window-substring/</link>
		<pubDate>Fri, 12 Aug 2016 10:28:24 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=613</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
For example,
<strong>S</strong> = <code>&quot;ADOBECODEBANC&quot;</code>
<strong>T</strong> = <code>&quot;ABC&quot;</code>
Minimum window is <code>&quot;BANC&quot;</code>.
<strong>Note:</strong>
If there is no such window in S that covers all characters in T, return the empty string <code>&quot;&quot;</code>.
If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.
</blockquote>

这道题叫做<em>MInimum Window Substring</em>, 很容易想到使用滑动窗口. 使用一个ASCII码做索引的数组来保存每个字符出现的次数, 然后先找到以S的第一个字符为开头的满足条件的子串, 然后跳过子串的前部字符直到子串不满足条件, 此时得到的便是第一个最小值. 显然一个子串如果包含T中的所有元素并且尽量短, 那么它的两端字符肯定都在T中(因为如果不在, 那么删掉它们可得到更短的子串), 

从刚才得到的第一个子串开始, 去掉开头的字符, 把子串向后延伸, 直到再次出现该字符为止, 然后不断去掉开头的字符, 直到子串尽可能短, 便可以得到下一个子串. 窗口以&quot;伸-缩-伸-缩...&quot;的方式前进, 算法是线性的(不考虑判断是否符合条件). 记录整个过程中最短的子串开始位置与长度.

另一个重要问题是如何判断一个子串是否符合条件, 即是否包含T中的所有字符. 最直接的方法是循环比较每个字符出现的次数(子串首尾移动时同时更新子串中字符的出现次数), 这样的话复杂度大约为<code>O(CHAR_MAX*s.length())</code>. 一般来说CHAR_MAX = 127, 这个系数还是比较大的.

因为除了第一个子串外, 后续的子串都以前一个子串为基础变化而来, 子串开头的下标start在前进时子串始终是处于符合要求的状态, 当不符合要求时start才停下, 所以每当start扫过一个字符, 就把它在子串中的出现次数减1, 然后只比较该字符与T中该字符的出现次数, 当小于时则子串不符合要求. 对于子串结尾end, 则只要找到上一个符合条件的子串的第一个元素就可以了.

说起来还是比较混乱, 其实代码写起来也比较混乱, 双指针start与end的++, --操作很多, 很容易出错...

<pre lang="c++">
class Solution {
public:
    vector&lt;int&gt; tFlag = vector&lt;int&gt;(CHAR_MAX + 1, 0);
    string minWindow(string s, string t) {
        if (t.empty() || s.empty() || s.length() &lt; t.length()) return &quot;&quot;;

        for (int i = 0; i &lt; t.length(); i++) {
            tFlag[t[i]]++;
        }
        vector&lt;int&gt; flag(CHAR_MAX + 1, 0);

        int start = 0, end = start;
        int minLen = INT_MAX, minStart;

        for (; end &lt;= s.length() &amp;&amp; !matchEnd(flag, s[end - 1]); end++) {
            flag[s[end]]++;
        }
        if (end &gt; s.length()) return &quot;&quot;;
        while (matchStart(flag, s[start - 1])) {
            flag[s[start]]--;
            start++;
        }
        start--;
        flag[s[start]]++;
        
        minLen = end - start;
        minStart = start;
        end--;
        
        while (true) {
            char ch = s[start];
            flag[ch]--;
            
            end++;
            while (end &lt; s.length() &amp;&amp; s[end] != ch) {
                flag[s[end]]++;
                end++;
            }
            if (end == s.length()) break;
            flag[ch]++;

            start++;
            while (matchStart(flag, s[start - 1])) {
                flag[s[start]]--;
                start++;
            }
            start--;
            flag[s[start]]++;
            if (minLen &gt; end - start + 1) {
                minLen = end - start + 1;
                minStart = start;
            }
        }

        if (minLen == INT_MAX) return &quot;&quot;;
        return s.substr(minStart, minLen);
    }

    bool matchEnd(vector&lt;int&gt; &amp;flag, int index) {
        if(flag[index] &lt; tFlag[index]){
            return false;
        }
        for (int i = 0; i &lt; CHAR_MAX + 1; i++) {
            if (flag[i] &lt; tFlag[i]) return false;
        }
        return true;
    }
    
    bool matchStart(vector&lt;int&gt; &amp;flag, int index) {
        return flag[index] &gt;= tFlag[index];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>613</wp:post_id>
		<wp:post_date><![CDATA[2016-08-12 18:28:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-12 10:28:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-76-minimum-window-substring]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 77. Combinations</title>
		<link>http://xiadong.info/2016/08/leetcode-77-combinations/</link>
		<pubDate>Fri, 12 Aug 2016 10:52:07 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=615</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 ... <em>n</em>.
For example,
If <em>n</em> = 4 and <em>k</em> = 2, a solution is:
<pre>
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre>
</blockquote>

从[1,n]中选出k个数, 这道题只要求组合, 不要求排列, 因此用递归可以比较容易的解决.

<pre lang="c++">
class Solution {
    vector&lt;vector&lt;int&gt;&gt; kElement;
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
        vector&lt;int&gt; v;
        getKElement(n, k, 1, v);
        return kElement;
    }
    
    void getKElement(int n, int k, int start, vector&lt;int&gt; &amp;v){
        if(k == 1){
            for(int i = start; i &lt;= n; i++){
                v.push_back(i);
                kElement.push_back(v);
                v.pop_back();
            }
            return;
        }
        for(int i = start; i &lt;= n - k + 1; i++){
            v.push_back(i);
            getKElement(n, k - 1, i + 1, v);
            v.pop_back();
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>615</wp:post_id>
		<wp:post_date><![CDATA[2016-08-12 18:52:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-12 10:52:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-77-combinations]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 78. Subsets</title>
		<link>http://xiadong.info/2016/08/leetcode-78-subsets/</link>
		<pubDate>Sat, 13 Aug 2016 08:50:13 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=619</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a set of distinct integers, <em>nums</em>, return all possible subsets.
<strong>Note:</strong> The solution set must not contain duplicate subsets.
For example,
If <strong>nums</strong> = <code>[1,2,3]</code>, a solution is:
<pre>
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</pre>
</blockquote>

取得一个数组的所有子集, 这道题可以直接使用上一道题<a href='http://xiadong.info/2016/08/leetcode-77-combinations/'>LeetCode 77. Combinations</a>的方法, 上一题是从[1,n]中取得k个数, 只要把它们当作下标, 然后n从1遍历到nums.size()即可, 然后再插入一个空集.

<pre lang="c++">
class Solution {
    vector&lt;vector&lt;int&gt;&gt; kElement;
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; ret(1, vector&lt;int&gt;());
        for(int i = 1; i &lt;= nums.size(); i++){
            kElement.clear();
            combine(nums.size(), i);
            for(int i = 0; i &lt; kElement.size(); i++){
                vector&lt;int&gt; t(kElement[i].size());
                for(int j = 0; j &lt; kElement[i].size(); j++){
                    t[j] = nums[kElement[i][j] - 1];
                }
                ret.push_back(t);
            }
        }
        return ret;
    }
    
    void combine(int n, int k) {
        vector&lt;int&gt; v;
        getKElement(n, k, 1, v);
    }
    
    void getKElement(int n, int k, int start, vector&lt;int&gt; &amp;v){
        if(k == 1){
            for(int i = start; i &lt;= n; i++){
                v.push_back(i);
                kElement.push_back(v);
                v.pop_back();
            }
            return;
        }
        for(int i = start; i &lt;= n - k + 1; i++){
            v.push_back(i);
            getKElement(n, k - 1, i + 1, v);
            v.pop_back();
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>619</wp:post_id>
		<wp:post_date><![CDATA[2016-08-13 16:50:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-13 08:50:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-78-subsets]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 79. Word Search</title>
		<link>http://xiadong.info/2016/08/leetcode-79-word-search/</link>
		<pubDate>Sat, 13 Aug 2016 09:02:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=621</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
For example,
Given <strong>board</strong> =
<pre>
[
  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],
  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],
  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]
]
</pre>
word = <code>&quot;ABCCED&quot;</code>, -&gt; returns <code>true</code>,
word = <code>&quot;SEE&quot;</code>, -&gt; returns <code>true</code>,
word = <code>&quot;ABCB&quot;</code>, -&gt; returns <code>false</code>.
</blockquote>

一个搜索问题, 使用回溯+递归, 先遍历二维数组, 找到目标字符串的开头字母, 然后向上下左右四个方向搜索下一个字母, 同时标记该位置已访问, 直到找到整个字符串为止.

<pre lang="c++">
class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if(board.empty()){
            return false;
        }
        else if(board[0].empty()){
            return false;
        }
        int row = board.size(), col = board[0].size();
        vector&lt;vector&lt;int&gt;&gt; flag(row, vector&lt;int&gt;(col, 0));
        int str_p = 0;
        for(int i = 0; i &lt; row; i++){
            for(int j = 0; j &lt; col; j++){
                if(board[i][j] == word[str_p] &amp;&amp; existNext(board, i, j, word, str_p + 1, flag, row, col)){
                    return true;
                }
            }
        }
        return false;
    }
    
    bool existNext(vector&lt;vector&lt;char&gt;&gt;&amp; board, int r, int c, string &amp;word, int p, vector&lt;vector&lt;int&gt;&gt; &amp;flag, int row, int col){
        flag[r][c] = 1;
        bool re = false;
        if(p == word.size()){
            flag[r][c] = 0;
            return true;
        }
        if(r - 1 &gt;= 0 &amp;&amp; flag[r - 1][c] == 0 &amp;&amp; board[r - 1][c] == word[p]){
            re = existNext(board, r - 1, c, word, p + 1, flag, row, col);
        }
        if(!re &amp;&amp; c - 1 &gt;= 0 &amp;&amp; flag[r][c - 1] == 0 &amp;&amp; board[r][c - 1] == word[p]){
            re = existNext(board, r, c - 1, word, p + 1, flag, row, col);
        }
        if(!re &amp;&amp; r + 1 &lt; row &amp;&amp; flag[r + 1][c] == 0 &amp;&amp; board[r + 1][c] == word[p]){
            re = existNext(board, r + 1, c, word, p + 1, flag, row, col);
        }
        if(!re &amp;&amp; c + 1 &lt; col &amp;&amp; flag[r][c + 1] == 0 &amp;&amp; board[r][c + 1] == word[p]){
            re = existNext(board, r, c + 1, word, p + 1, flag, row, col);
        }

        flag[r][c] = 0;
        return re;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>621</wp:post_id>
		<wp:post_date><![CDATA[2016-08-13 17:02:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-13 09:02:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-79-word-search]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%ba%af"><![CDATA[回溯]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 80. Remove Duplicates from Sorted Array II</title>
		<link>http://xiadong.info/2016/08/leetcode-80-remove-duplicates-from-sorted-array-ii/</link>
		<pubDate>Sat, 13 Aug 2016 09:30:25 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=623</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Follow up for &quot;Remove Duplicates&quot;:
What if duplicates are allowed at most <em>twice</em>?
For example,
Given sorted array <em>nums</em> = <code>[1,1,1,2,2,3]</code>,
Your function should return length = <code>5</code>, with the first five elements of <em>nums</em> being <code>1</code>, <code>1</code>, <code>2</code>, <code>2</code> and <code>3</code>. It doesn&#39;t matter what you leave beyond the new length.
</blockquote>

O(n)空间复杂度, O(n)时间复杂度的方法是使用另一个数组来保存去除超过两个重复元素之后的结果.

<pre>
class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if(nums.size() &lt; 2)
            return nums.size();
        int tp = 1;
        vector&lt;int&gt; t = {nums[0], nums[1]};
        t.resize(nums.size());
        for(int np = 2; np &lt; nums.size(); np++){
            if(t[tp] &lt; nums[np] || (t[tp] == nums[np] &amp;&amp; t[tp - 1] &lt; nums[np])){
                t[++tp] = (nums[np]);
            }
        }
        swap(nums, t);
        return tp + 1;
    }
};
</pre>

而不使用辅助空间则是直接删除vector中对应位置的元素, 虽然这会使vector中之后的元素都前移一位, 但是在实际的测试中这种方法还快一点, 上一种方法是20ms, 而这种是16ms.....

<pre lang="c++">
class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if(nums.size() &lt; 2)
            return nums.size();
        int val = nums[0], dup = 1;
        for(int i = 1; i &lt; nums.size(); i++){
            if(nums[i] &gt; nums[i - 1]){
                val = nums[i];
                dup = 1;
            }
            else if(dup == 2){
                nums.erase(nums.begin() + i);
                i--;
            }
            else{
                dup++;
            }
        }
        return nums.size();
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>623</wp:post_id>
		<wp:post_date><![CDATA[2016-08-13 17:30:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-13 09:30:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-80-remove-duplicates-from-sorted-array-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 81. Search in Rotated Sorted Array II</title>
		<link>http://xiadong.info/2016/08/leetcode-81-search-in-rotated-sorted-array-ii/</link>
		<pubDate>Sun, 14 Aug 2016 08:15:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=625</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Follow up for &quot;Search in Rotated Sorted Array&quot;:
What if <em>duplicates</em> are allowed?
Would this affect the run-time complexity? How and why?
Write a function to determine if a given target is in the array.
</blockquote>

仍然使用二分搜索, 数组中可能出现重复元素并没有什么影响.

<pre lang="c++">
class Solution {
public:
    bool search(vector&lt;int&gt;&amp; nums, int target) {
        int mid = nums.size();
        for(int i = 0; i &lt; nums.size() - 1; i++){
            if(nums[i] &gt; nums[i + 1]){
                mid = i + 1;
                break;
            }
        }
        if(target == nums[0]) return true;
        else if(target &gt; nums[0]) return binSearch(nums, 0, mid, target);
        else return binSearch(nums, mid, nums.size(), target);
    }
    
    bool binSearch(vector&lt;int&gt; &amp;nums, int left, int right, int target){
        int mid = (left + right) / 2;
        while(left &lt; right){
            if(nums[mid] == target){
                return true;
            }
            else if(nums[mid] &lt; target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
            mid = (left + right) / 2;
        }
        return false;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>625</wp:post_id>
		<wp:post_date><![CDATA[2016-08-14 16:15:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-14 08:15:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-81-search-in-rotated-sorted-array-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 82. Remove Duplicates from Sorted List II</title>
		<link>http://xiadong.info/2016/08/leetcode-82-remove-duplicates-from-sorted-list-ii/</link>
		<pubDate>Sun, 14 Aug 2016 08:37:11 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=628</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.
For example,
Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.
Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.
</blockquote>

删除一个有序序列中的所有出现重复的元素. 与去除重复元素相比, 问题在于头节点的问题, 在这个问题中头结点可能会发生变化, 因此先创建一个临时头结点指向真正的头结点. 出现初伏元素的时候就把所有相同的元素删除.

<pre lang="c++">
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* p1, *p2 = head;
        ListNode *re = new ListNode(0);
        re-&gt;next = head;
        p1 = re;
        
        while(p2 != nullptr){
            if(p2-&gt;next != nullptr &amp;&amp; p2-&gt;val == p2-&gt;next-&gt;val){
                int dup_val = p2-&gt;val;
                while(p2 != nullptr &amp;&amp; p2-&gt;val == dup_val){
                    ListNode *toDel = p2;
                    p2 = p2-&gt;next;
                    delete toDel;
                }
                p1-&gt;next = p2;
            }
            else{
                p1 = p2;
                p2 = p2-&gt;next;
            }
        }
        return re-&gt;next;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>628</wp:post_id>
		<wp:post_date><![CDATA[2016-08-14 16:37:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-14 08:37:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-82-remove-duplicates-from-sorted-list-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 83. Remove Duplicates from Sorted List</title>
		<link>http://xiadong.info/2016/08/leetcode-83-remove-duplicates-from-sorted-list/</link>
		<pubDate>Sun, 14 Aug 2016 08:43:51 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=630</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.
For example,
Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.
Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.
</blockquote>

删除连表中的重复元素, 比较简单. 要注意不能造成内存泄漏.

<pre lang="c++">
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        ListNode *node = head, *true_next;
        
        while(node){
            while(node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;val == node-&gt;val){
                ListNode *toDel = node-&gt;next;
                node-&gt;next = node-&gt;next-&gt;next;
                delete toDel;
            }
            node = node-&gt;next;
        }
        
        return head;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>630</wp:post_id>
		<wp:post_date><![CDATA[2016-08-14 16:43:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-14 08:43:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-83-remove-duplicates-from-sorted-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 84. Largest Rectangle in Histogram</title>
		<link>http://xiadong.info/2016/08/leetcode-84-largest-rectangle-in-histogram/</link>
		<pubDate>Mon, 15 Aug 2016 11:47:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=633</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given <em>n</em> non-negative integers representing the histogram&#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
<img src='http://www.leetcode.com/wp-content/uploads/2012/04/histogram.png' alt='img' />
Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.
<img src='http://www.leetcode.com/wp-content/uploads/2012/04/histogram_area.png' alt='img' />
The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.
For example,
Given heights = <code>[2,1,5,6,2,3]</code>,
return <code>10</code>.
</blockquote>

这道题目使用栈来解决, 方法是每读入一个高度就判断该高度左边有哪些高度所组成的矩形到此为止, 最终得到的是一个单调递增的序列.

这篇解答写的比较详细: <a href='http://www.cnblogs.com/boring09/p/4231906.html' target='_blank' >http://www.cnblogs.com/boring09/p/4231906.html</a>

<pre lang="c++">
class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        vector&lt;int&gt; s;
        heights.push_back(0);
        int ret = 0;
        for(int i = 0; i &lt; heights.size(); i++){
            if(s.empty() || heights[i] &gt; heights[s.back()]){
                s.push_back(i);
            }
            else{
                while(!s.empty() &amp;&amp; heights[s.back()] &gt;= heights[i]){
                    int h = heights[s.back()];
                    s.pop_back();
                    int w = s.empty() ? i : i - s.back() - 1;
                    ret = max(ret, w * h);
                }
                s.push_back(i);
            }
        }
        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>633</wp:post_id>
		<wp:post_date><![CDATA[2016-08-15 19:47:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-15 11:47:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-84-largest-rectangle-in-histogram]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 385. Mini Parser</title>
		<link>http://xiadong.info/2016/08/leetcode-385-mini-parser/</link>
		<pubDate>Tue, 16 Aug 2016 15:19:24 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=635</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a nested list of integers represented as a string, implement a parser to deserialize it.
Each element is either an integer, or a list -- whose elements may also be integers or other lists.
<strong>Note:</strong> You may assume that the string is well-formed:
<ul><li>
String is non-empty.</li>
<li>
String does not contain white spaces.</li>
<li>
String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li>
</ul>
<strong>Example 1:</strong>
<pre>
Given s = &quot;324&quot;,

You should return a NestedInteger object which contains a single integer 324.
</pre>
<strong>Example 2:</strong>
<pre>
Given s = &quot;[123,[456,[789]]]&quot;,

Return a NestedInteger object containing a nested list with 2 elements:

1. An integer containing value 123.
2. A nested list containing two elements:
    i.  An integer containing value 456.
    ii. A nested list with one element:
         a. An integer containing value 789.
</pre>
</blockquote>

题目要求把一个合法的字符串转换为对应的嵌套的数据格式, 一开始我想使用递归, 但是在处理嵌套的问题上遇到了麻烦, 所以改为使用栈来做.

把每一层嵌套视为栈的一个元素, 每遇到一个<code>[</code>就入栈一个新的NestedInteger, 然后遇到数字就把它加入到栈顶的NestedInteger中去, 遇到<code>]</code>就把栈顶的元素弹出, 加入到新的栈顶中, 如果弹出栈顶后栈为空说明处理结束.

<pre lang="c++">
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Constructor initializes an empty nested list.
 *     NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     NestedInteger(int value);
 *
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Set this NestedInteger to hold a single integer.
 *     void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     void add(const NestedInteger &amp;ni);
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector&lt;NestedInteger&gt; &amp;getList() const;
 * };
 */
class Solution {
public:
    NestedInteger deserialize(string s) {
        vector&lt;NestedInteger&gt; nestedIntSt;
        for(int i = 0; i &lt; s.length(); i++){
            if(s[i] == &#39;[&#39;){
                NestedInteger tmp;
                nestedIntSt.push_back(tmp);
            }
            else if(s[i] == &#39;]&#39;){
                NestedInteger tmp = nestedIntSt.back();
                nestedIntSt.pop_back();
                if(!nestedIntSt.empty()) nestedIntSt.back().add(tmp);
                else return tmp;
            }
            else if((s[i] == &#39;-&#39; || isDigit(s[i])) &amp;&amp; !nestedIntSt.empty()){
                int start = i, end = i + 1;
                while(isDigit(s[end])){
                    end++;
                }
                nestedIntSt.back().add(stoi(s.substr(start, end - start)));
                i = end - 1;
            }
        }
        return NestedInteger(stoi(s)); // 如果循环中没有返回, 说明字符串中只包含一个数字
    }
    
    bool isDigit(char ch){
        return ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>635</wp:post_id>
		<wp:post_date><![CDATA[2016-08-16 23:19:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-16 15:19:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-385-mini-parser]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 85. Maximal Rectangle</title>
		<link>http://xiadong.info/2016/08/leetcode-85-maximal-rectangle/</link>
		<pubDate>Wed, 17 Aug 2016 08:48:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=637</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest rectangle containing only 1&#39;s and return its area.
For example, given the following matrix:
<pre>
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
</pre>
Return 6.
</blockquote>

本来我想直接用动态规划, 但是做起来非常麻烦. 然后想起了上一道题<a href='http://xiadong.info/2016/08/leetcode-84-largest-rectangle-in-histogram/'>Largest Rectangle in Histogram</a>是本题解决的步骤之一, 先用动态规划法计算出matrix中每个元素的高(就是该元素和该元素之上的1的个数), 然后以行为单位计算最大的矩形面积.

<pre lang="c++">
class Solution {
public:
    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        int row = matrix.size(), col;
        if(row == 0) return 0;
        col = matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt; heights(row, vector&lt;int&gt;(col, 0));
        for(int j = 0; j &lt; col; j++){
            heights[0][j] = (matrix[0][j] == &#39;1&#39; ? 1 : 0);
        }
        for(int i = 1; i &lt; row; i++){
            for(int j = 0; j &lt; col; j++){
                heights[i][j] = (matrix[i][j] == &#39;1&#39; ? heights[i - 1][j] + 1 : 0);
            }
        }
        int maxArea = 0;
        for(int i = 0; i &lt; row; i++){
            maxArea = max(maxArea, largestRectangleArea(heights[i]));
        }
        return maxArea;
    }
    
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        vector&lt;int&gt; s;
        heights.push_back(0);
        int ret = 0;
        for(int i = 0; i &lt; heights.size(); i++){
            if(s.empty() || heights[i] &gt; heights[s.back()]){
                s.push_back(i);
            }
            else{
                while(!s.empty() &amp;&amp; heights[s.back()] &gt;= heights[i]){
                    int h = heights[s.back()];
                    s.pop_back();
                    int w = s.empty() ? i : i - s.back() - 1;
                    ret = max(ret, w * h);
                }
                s.push_back(i);
            }
        }
        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>637</wp:post_id>
		<wp:post_date><![CDATA[2016-08-17 16:48:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-17 08:48:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-85-maximal-rectangle]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 86. Partition List</title>
		<link>http://xiadong.info/2016/08/leetcode-86-partition-list/</link>
		<pubDate>Wed, 17 Aug 2016 08:56:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=640</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.
You should preserve the original relative order of the nodes in each of the two partitions.
For example,
Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,
return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.
</blockquote>

使用两个临时的链表分别保存小于x和大于等于x的值, 最后再把它们连接到一起.

<pre lang="c++">
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *less = new ListNode(0), *greater = new ListNode(0), *p1 = less, *p2 = greater, *p = head;
        while(p){
            if(p-&gt;val &lt; x){
                p1-&gt;next = new ListNode(p-&gt;val);
                p1 = p1-&gt;next;
            }
            else{
                p2-&gt;next = new ListNode(p-&gt;val);
                p2 = p2-&gt;next;
            }
            p = p-&gt;next;
        }
        p1-&gt;next = greater-&gt;next;
        return less-&gt;next;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>640</wp:post_id>
		<wp:post_date><![CDATA[2016-08-17 16:56:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-17 08:56:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-86-partition-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 87. Scramble String</title>
		<link>http://xiadong.info/2016/08/leetcode-87-scramble-string/</link>
		<pubDate>Thu, 18 Aug 2016 11:11:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=642</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.
Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:
<pre>
    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
</pre>
To scramble the string, we may choose any non-leaf node and swap its two children.
For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.
<pre>
    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
</pre>
We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.
Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.
<pre>
    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
</pre>
We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.
Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.
</blockquote>

看完这道题, 首先想到的是使用递归, 但是思维惯性让我觉得递归可能超时, 所以按照tag中的动态规划方法来做, 我是使用了三维数组来进行动态规划, 有四重循环, 所以可能还有优化空间. <code>dp[i][j][k]</code>表示s1[i]和s2[j]开始的长度为k的子串是不是scramble的, 最后要返回的结果是<code>dp[0][0][s1.length()]</code>, 所以i和j要从大到小遍历.

<pre lang="c++">
class Solution {
public:
    bool isScramble(string s1, string s2) {
        if(s1.length() != s2.length()) return false;
        int len = s1.length();
        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(len, vector&lt;vector&lt;int&gt;&gt;(len, vector&lt;int&gt;(len + 1, 0)));
        
        for(int i = 0; i &lt; len; i++){
            for(int j = 0; j &lt; len; j++){
                if(s1[i] == s2[j]){
                    dp[i][j][1] = 1;
                }
            }
        }
        
        for(int i = len - 1; i &gt;= 0; i--){
            for(int j = len - 1; j &gt;= 0; j--){
                for(int k = 2; i + k &lt;= len &amp;&amp; j + k &lt;= len; k++){
                    for(int r = 1; r &lt; k &amp;&amp; !dp[i][j][k]; r++){
                        dp[i][j][k] = (dp[i][j][r] &amp;&amp; dp[i + r][j + r][k - r]) || (dp[i][j + k - r][r] &amp;&amp; dp[i + r][j][k - r]);
                    }
                }
            }
        }

        return dp[0][0][len];
    }
};
</pre>

但是这个方法速度并不是很理想, 比较快的方法反而是递归+剪枝, 在递归前先判断字符串中字母数量是不是相同, 如果不相同则可以直接返回false.

<pre lang="c++">
class Solution {
public:
    bool isScramble(string s1, string s2) {
        if(s1.length() != s2.length()) return false;
        return isScrambleImpl(s1, s2, 0, 0, s1.length());
    }
    
    bool isScrambleImpl(string &amp;s1, string &amp;s2, int start1, int start2, int len){
        vector&lt;int&gt; charTimes(26, 0);
        for(int i = start1; i &lt; start1 + len; i++){
            charTimes[s1[i] - &#39;a&#39;]++;
        }
        int flag  = true;
        for(int i = start2; i &lt; start2 + len; i++){
            charTimes[s2[i] - &#39;a&#39;]--;
            if(charTimes[s2[i] - &#39;a&#39;] &lt; 0){
                flag = false;
                break;
            }
        }
        if(!flag) return false;
        if(len == 1) return true; // 只有一个字母并且相同
        for(int i = 1; i &lt; len; i++){
            if((isScrambleImpl(s1, s2, start1, start2, i) &amp;&amp; isScrambleImpl(s1, s2, start1 + i, start2 + i, len - i))
                || (isScrambleImpl(s1, s2, start1, start2 + len - i, i) &amp;&amp; isScrambleImpl(s1, s2, start1 + i, start2, len - i))){
                    return true;
                }
        }
        return false;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>642</wp:post_id>
		<wp:post_date><![CDATA[2016-08-18 19:11:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-18 11:11:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-87-scramble-string]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 88. Merge Sorted Array</title>
		<link>http://xiadong.info/2016/08/leetcode-88-merge-sorted-array/</link>
		<pubDate>Fri, 19 Aug 2016 07:43:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=648</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.
<strong>Note:</strong>
You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.
</blockquote>

合并两个有序数组, 合并的结果放在第一个数组中, 数组长度通过函数参数给出, 所以不能使用<code>size()</code>成员函数来获得数组长度.

使用另一个数组nums3来保存原来nums1的元素, 然后再逐个比较nums2和nums3中的元素大小, 放入nums1中.

<pre lang="c++">
class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        vector&lt;int&gt; nums3;
        for(int i = 0; i &lt; m; i++){
            nums3.push_back(nums1[i]);
        }
        int p = m + n - 1;
        while(!nums2.empty() || !nums3.empty()){
            if(nums2.empty()){
                nums1[p--] = nums3.back();
                nums3.pop_back();
            }
            else if(nums3.empty()){
                nums1[p--] = nums2.back();
                nums2.pop_back();
            }
            else if(nums2.back() &gt; nums3.back()){
                nums1[p--] = nums2.back();
                nums2.pop_back();
            }
            else{
                nums1[p--] = nums3.back();
                nums3.pop_back();
            }
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>648</wp:post_id>
		<wp:post_date><![CDATA[2016-08-19 15:43:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-19 07:43:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-88-merge-sorted-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 89. Gray Code</title>
		<link>http://xiadong.info/2016/08/leetcode-89-gray-code/</link>
		<pubDate>Fri, 19 Aug 2016 09:03:01 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=650</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>The gray code is a binary numeral system where two successive values differ in only one bit.
Given a non-negative integer <em>n</em> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.
For example, given <em>n</em> = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:
<pre>
00 - 0
01 - 1
11 - 3
10 - 2
</pre>
<strong>Note:</strong>
For a given <em>n</em>, a gray code sequence is not uniquely defined.
For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.
For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.
</blockquote>

计算Gray code, 两个数的二进制表示只有一位不同, 则这两个数为gray code. 这个题有多个可能的解, 但是LeetCode只判断一种正确解, 就是每次变换尽可能低位的二进制位.

变换一个数中的某一位可以通过位运算实现, 所以主要问题就在如何判断一个数是否已经出现, 我使用<code>unordered_set</code>来保存已经选出来的gray code. 因为测试数据只有12组, 所以也可以使用一个2^12 + 1大小的数组来保存数字有没有出现过.

<pre lang="c++">
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ret = {0};
        int bits = 0;
        unordered_set<int> codes;
        codes.insert(0);
        int i = 0;
        while(i < n){
            int tmpBits = bits ^ (1 << i);
            if(codes.count(tmpBits)){
                i++;
            }
            else{
                codes.insert(tmpBits);
                ret.push_back(tmpBits);
                bits = tmpBits;
                i = 0;
            }
        }
        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>650</wp:post_id>
		<wp:post_date><![CDATA[2016-08-19 17:03:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-19 09:03:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-89-gray-code]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 90. Subsets II</title>
		<link>http://xiadong.info/2016/08/leetcode-90-subsets-ii/</link>
		<pubDate>Fri, 19 Aug 2016 10:02:07 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=653</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets.
<strong>Note:</strong> The solution set must not contain duplicate subsets.
For example,
If <strong>nums</strong> = <code>[1,2,2]</code>, a solution is:
<pre>
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</pre>
</blockquote>

返回一个包含重复元素的集合的所有子集, 要求不能重复. 获得子集的思路都是使用回溯法, 如果不考虑重复问题, 那么整个的实现过程可以分为两步:

<ol><li>
实现从nums中获得n个元素的所有情况函数, 使用递归, 即先取一个元素, 然后从之后的数组中再取n-1个元素.</li>
<li>
从nums中取得1个到nums.size()个元素</li>
</ol>

对于去除重复的情况, 在选择元素的时候跳过之后的与该元素相等的元素就可以避免重复, 为此, 要先对nums排序.

<pre lang="c++">
class Solution {
    vector&lt;vector&lt;int&gt;&gt; ret;
    int len;
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        vector&lt;int&gt; path;
        ret.push_back(path);
        len = nums.size();
        for(int i = 1; i &lt;= len; i++){
            subsetWithN(nums, 0, i, path);
        }
        return ret;
    }
    
    // 从nums中从start开始取得n个元素并放入ret中
    void subsetWithN(vector&lt;int&gt; &amp;nums, int start, int n, vector&lt;int&gt; &amp;path){
        if(n == 0){
            ret.push_back(path);
            return;
        }
        for(int i = start; i &lt;= len - n; i++){
            path.push_back(nums[i]);
            subsetWithN(nums, i + 1, n - 1, path); // 递归调用
            path.pop_back();
            while(i + 1 &lt;= len - n &amp;&amp; nums[i] == nums[i + 1]){
                i++;
            }
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>653</wp:post_id>
		<wp:post_date><![CDATA[2016-08-19 18:02:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-19 10:02:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-90-subsets-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 91. Decode Ways</title>
		<link>http://xiadong.info/2016/08/leetcode-91-decode-ways/</link>
		<pubDate>Sat, 20 Aug 2016 11:05:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=655</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:
<pre>
&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26
</pre>
Given an encoded message containing digits, determine the total number of ways to decode it.
For example,
Given encoded message <code>&quot;12&quot;</code>, it could be decoded as <code>&quot;AB&quot;</code> (1 2) or <code>&quot;L&quot;</code> (12).
The number of ways decoding <code>&quot;12&quot;</code> is 2.
</blockquote>

动态规划, 最后一个字母可以是一位数字或者两位数字. 在最后一位不是0时可以是一位数字, 在倒数第二位为1, 或倒数第二位为2且最后一位小于等于6时可以为两位数字, 解码的不同方法数量为这两种情况之和.

<pre lang="c++">
class Solution {
public:
    int numDecodings(string s) {
        if(s.empty()) return 0;
        if(s[0] == &#39;0&#39;) return 0;
        int num[2] = {1, 0};
        for(int i = 1; i &lt; s.size(); i++){
            int one;
            if(s[i] != &#39;0&#39;)
                one = num[0] + num[1];
            else
                one = 0;
                
            int two = 0;
            if(s[i - 1] == &#39;1&#39;){
                two = num[0];
            }
            else if(s[i - 1] == &#39;2&#39; &amp;&amp; s[i] &lt;= &#39;6&#39;){
                two = num[0];
            }
            num[0] = one;
            num[1] = two;
        }
        return num[0] + num[1];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>655</wp:post_id>
		<wp:post_date><![CDATA[2016-08-20 19:05:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-20 11:05:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-91-decode-ways]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 92. Reverse Linked List II</title>
		<link>http://xiadong.info/2016/08/leetcode-92-reverse-linked-list-ii/</link>
		<pubDate>Sun, 21 Aug 2016 09:17:57 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=658</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.
For example:
Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,
return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.
<strong>Note:</strong>
Given <em>m</em>, <em>n</em> satisfy the following condition:
1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.
</blockquote>

在只遍历一次并且不使用额外存储空间的情况下反转单向链表中第m个节点到第n个节点中的节点. 这道题目要求只遍历一次并且不使用额外空间, 那么就要用两个指针来记录当前节点与前一节点, 对于m与n之间的节点, 将当前节点指向前一节点. 第m-1个节点和第n+1个节点在最后处理.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode *start, *end, *p = head, *prev = nullptr, *startPrev = nullptr;
        int i = 0;
        while(p != nullptr){ // 查找翻转开始的节点
            i++;
            if(i == m){
                start = p;
                startPrev = prev;
                break;
            }
            prev = p;
            p = p-&gt;next;
        }
        
        p = start;
        ListNode *pp = p-&gt;next;
        
        while(i != n){ // 翻转节点
            ListNode *tmp = pp-&gt;next;
            pp-&gt;next = p;
            p = pp;
            pp = tmp;
            i++;
        }
        
        start-&gt;next = pp; // 翻转后的头结点
        if(startPrev){ // 判断是不是从第一个节点开始翻转
            startPrev-&gt;next = p;
            return head;
        }
        else
            return p;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>658</wp:post_id>
		<wp:post_date><![CDATA[2016-08-21 17:17:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-21 09:17:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-92-reverse-linked-list-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 93. Restore IP Addresses</title>
		<link>http://xiadong.info/2016/08/leetcode-93-restore-ip-addresses/</link>
		<pubDate>Sun, 21 Aug 2016 10:27:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=660</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string containing only digits, restore it by returning all possible valid IP address combinations.
For example:
Given <code>&quot;25525511135&quot;</code>,
return <code>[&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code>. (Order does not matter)
</blockquote>

返回从一个字符串中可以得到多少个合法的IP地址, 使用回溯法遍历所有可能的组合. 由于最多只能有四个数字组成IP地址, 所以可以用四重循环来实现.

<pre lang='c++'>
class Solution {
public:
    vector&lt;string&gt; restoreIpAddresses(string s) {
        int p = 0;
        vector&lt;string&gt; re;
        if(s.length() &gt; 12 || s.length() &lt; 4) return re;
        string a, b, c, d;
        for(int i = 1; i &lt;= 3 &amp;&amp; i &lt;= s.size() - 3; i++){
            a = s.substr(0, i);
            if(!checkValid(a)) continue;
            for(int j = 1; j &lt;= 3 &amp;&amp; i + j &lt;= s.size() - 2; j++){
                b = s.substr(i, j);
                if(!checkValid(b)) continue;
                for(int k = 1; k &lt;= 3 &amp;&amp; i + j + k &lt;= s.size() - 1; k++){
                    c = s.substr(i + j, k);
                    if(!checkValid(c)) continue;
                    for(int l = 1; l &lt;= 3 &amp;&amp; i + j + k + l &lt;= s.size(); l++){
                        if(i + j + k + l != s.size())
                            continue;
                        d = s.substr(i + j + k, l);
                        if(checkValid(d)){
                            string t;
                            t = a + &quot;.&quot; + b + &quot;.&quot; + c + &quot;.&quot; + d;
                            re.push_back(t);
                        }
                    }
                }
            }
        }
        return re;
    }
    
    bool checkValid(string s){
        if(s[0] == &#39;0&#39; &amp;&amp; s.size() != 1)
            return false;
        int n = std::stoi(s);
        return n &gt; 255 ? false : true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>660</wp:post_id>
		<wp:post_date><![CDATA[2016-08-21 18:27:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-21 10:27:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-93-restore-ip-addresses]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%ba%af"><![CDATA[回溯]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>安装YCM中遇到的问题</title>
		<link>http://xiadong.info/2016/08/%e5%ae%89%e8%a3%85ycm%e4%b8%ad%e9%81%87%e5%88%b0%e7%9a%84%e9%97%ae%e9%a2%98/</link>
		<pubDate>Mon, 22 Aug 2016 03:08:01 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=662</guid>
		<description></description>
		<content:encoded><![CDATA[说到VIM的代码补全, YouCompleteMe算是一个非常有名的插件了, 只不过由于它提供的功能已经大大超过了一个文本编辑器的功能, 所以安装起来相当复杂. 在这里记录自己在安装过程中遇到的问题, 安装步骤参考官方手册: <a href="http://valloric.github.io/YouCompleteMe/" target="_blank">http://valloric.github.io/YouCompleteMe/</a>

操作系统Ubuntu 14.04

<h4>YouCompleteMe unavailable: requires Vim compiled with Python (2.6+ or 3.3+) support</h4>

当前的VIM版本不支持Python脚本, 我通过安装<a href="http://packages.ubuntu.com/Trusty/editors/vim-nox">vim-nox</a>解决.

<h4>编译<code>ycm_core</code> library时提示'stdexcept' file not found</h4>

通过<code>sudo apt-get install clang</code>安装clang.

<h4>运行时提示: The ycmd server SHUT DOWN (restart with ':YcmRestartServer'). YCM core library compiled for Python 2 but loaded in Python 3. Set the 'g:ycm_server_python_interpreter' option to a Python 2 interpreter path.</h4>

在vimrc中加入<code>let g:ycm_server_python_interpreter='/usr/bin/python'</code>来指定python2.x的程序路径.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>662</wp:post_id>
		<wp:post_date><![CDATA[2016-08-22 11:08:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-22 03:08:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%ae%89%e8%a3%85ycm%e4%b8%ad%e9%81%87%e5%88%b0%e7%9a%84%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="post_tag" nicename="vim"><![CDATA[VIM]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 94. Binary Tree Inorder Traversal</title>
		<link>http://xiadong.info/2016/08/leetcode-94-binary-tree-inorder-traversal/</link>
		<pubDate>Mon, 22 Aug 2016 13:09:52 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=664</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, return the <em>inorder</em> traversal of its nodes' values.

For example:
Given binary tree <code>[1,null,2,3]</code>,
<pre lang="undefined">   1
    \
     2
    /
   3
</pre>
return <code>[1,3,2]</code>.

<strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</blockquote>

返回一个树的中序遍历序列, 既然题目要求不用递归用迭代, 那么就可以使用栈来模拟递归. 因为使用栈来模拟无法直到栈顶的节点的左子树有没有访问过, 所以还要同时记录每个节点的状态. 我用-1表示未访问左子树, 0表示已访问左子树未访问右子树, 1表示左右子树都已经访问过.

一开始我用vector来作为栈使用, 运行时间4ms, 查看discuss后换用deque运行时间变为0ms. vector在分配的内存不够的情况下的扩充操作真的开销很大.

<pre lang="c++">/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode *root) {
        deque&lt;TreeNode*&gt; path;
        deque&lt;int&gt; nodeState;
        vector&lt;int&gt; ret;
        if(root == NULL) return ret;
        
        path.push_back(root);
        nodeState.push_back(-1);
        
        TreeNode *node;
        while(!path.empty()){
            node = path.back();
            if(nodeState.back() == 1){
                path.pop_back();
                nodeState.pop_back();
            }
            else if(node-&gt;left &amp;&amp; nodeState.back() == -1){
                nodeState.back() = 0;
                path.push_back(node-&gt;left);
                nodeState.push_back(-1);
            }
            else if(!node-&gt;left &amp;&amp; nodeState.back() == -1){
                nodeState.back() = 0;
            }
            else if(node-&gt;right &amp;&amp; nodeState.back() == 0){
                ret.push_back(node-&gt;val);
                nodeState.back() = 1;
                path.push_back(node-&gt;right);
                nodeState.push_back(-1);
            }
            else{
                ret.push_back(node-&gt;val);
                nodeState.back() = 1;
            }
            
        }

        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>664</wp:post_id>
		<wp:post_date><![CDATA[2016-08-22 21:09:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-22 13:09:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-94-binary-tree-inorder-traversal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 388. Longest Absolute File Path</title>
		<link>http://xiadong.info/2016/08/leetcode-388-longest-absolute-file-path/</link>
		<pubDate>Tue, 23 Aug 2016 13:16:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=667</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Suppose we abstract our file system by a string in the following manner:

The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents:

dir
<pre lang="undefined">subdir1
subdir2
    file.ext
</pre>
The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.

The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" represents:

dir
<pre lang="undefined">subdir1
    file1.ext
    subsubdir1
subdir2
    subsubdir2
        file2.ext
</pre>
The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.

We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes).

Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.

Note:
The name of a file contains at least a . and an extension.
The name of a directory or sub-directory will not contain a ..
Time complexity required: O(n) where n is the size of the input string.

Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.</blockquote>

虽然题目描述非常的长, 但是实际的难度并不大. 目录结构是一个树形结构, 使用栈可以模拟深度优先搜索, 遍历根目录到每一个叶子节点的路径, 从中找出总长度最长的一条路径. 每个节点通过<code>\n</code>分割, 而每个节点前的<code>\t</code>的个数就是该节点所的层次.

要注意输入字符串中<code>\n</code>和<code>\t</code>都只是<strong>一个字符</strong>而不是两个字符.

<pre lang="c++">class Solution {
public:
    int lengthLongestPath(string input) {
        vector&lt;int&gt; pathLevel; // 记录path中节点的层次
        vector&lt;string&gt; path; // 记录路径
        int pos = 0, nextPos = 0, maxLen = 0;
        while(true){
            nextPos = input.find("\n", pos);
            string node = input.substr(pos, nextPos - pos); // 获取当前节点的字符串
            
            int level = getLevel(node);

            while(!pathLevel.empty() &amp;&amp; pathLevel.back() &gt;= level){ // 路径退回到当前节点的上一层
                pathLevel.pop_back();
                path.pop_back();
            }
            
            path.push_back(node);
            pathLevel.push_back(level);
            
            if(isFile(node)){
                maxLen = max(maxLen, getTotalLen(path) - 1);
            }
            
            if(nextPos == string::npos) break;
            pos = nextPos + 1;
        }
        return maxLen;
    }
    
    bool isFile(string &amp;s){ // 判断是不是file
        int index = s.find('.');
        if(index == string::npos || index == s.length() - 1) return false;
        else return true;
    }
    
    int getTotalLen(vector&lt;string&gt; &amp;v){ // 根据path计算总长度
        int len = 0;
        for(auto s : v){
            len += s.length();
            len++;
        }
        return len;
    }
    
    int getLevel(string &amp;s){ // 计算字符串头部\t的个数
        if(s.length() &lt; 2) return 0;
        int level = 0;
        for(int i = 0; i &lt; s.length(); i++){
            if(s[i] == '\t' ){
                level++;
            }
        }
        s = s.substr(level); // 清除头部的\t
        return level;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>667</wp:post_id>
		<wp:post_date><![CDATA[2016-08-23 21:16:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-23 13:16:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-388-longest-absolute-file-path]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 95. Unique Binary Search Trees II</title>
		<link>http://xiadong.info/2016/08/leetcode-95-unique-binary-search-trees-ii/</link>
		<pubDate>Wed, 24 Aug 2016 08:08:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=669</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an integer <em>n</em>, generate all structurally unique <strong>BST&#39;s</strong> (binary search trees) that store values 1...<em>n</em>.
For example,
Given <em>n</em> = 3, your program should return all 5 unique BST&#39;s shown below.
<pre lang='undefined'>
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>
</blockquote>

返回由1-n组成的所有可能的二叉搜索树. 先来复习一下二叉搜索树BST的定义:

<ol><li>
任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>
任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>
任意节点的左、右子树也分别为二叉查找树；</li>
<li>
没有键值相等的节点。</li>
</ol>

根据定义, 很容易想到通过递归的方法来产生所有可能的BST, 对于[1,n]n个节点, 从中取一个值1&lt;=r&lt;=n, 则属于[1, r)的值在左子树, 属于(r,n]的值在右子树, 再分别调用递归函数生成相应的左右子树.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;TreeNode*&gt; generateTrees(int n) {
        return buildBST(1, n + 1);
    }
    
    vector&lt;TreeNode*&gt; buildBST(int left, int right){
        vector&lt;TreeNode*&gt; re;
        if(left &gt;= right){
            return re;
        }
        for(int i = left; i &lt; right; i++){
            auto leftVector = buildBST(left, i);
            auto rightVector = buildBST(i + 1, right);
            for(int j = 0; j &lt; leftVector.size(); j++){
                if(rightVector.empty()){
                    TreeNode* node = new TreeNode(i);
                    node-&gt;left = leftVector[j];
                    node-&gt;right = nullptr;
                    re.push_back(node);
                }
                else{
                    for(int k = 0; k &lt; rightVector.size(); k++){
                        TreeNode* node = new TreeNode(i);
                        node-&gt;left = leftVector[j];
                        node-&gt;right = rightVector[k];
                        re.push_back(node);
                    }
                }
            }
            if(leftVector.empty()){
                if(rightVector.empty()){
                    TreeNode* node = new TreeNode(i);
                    node-&gt;left = nullptr;
                    node-&gt;right = nullptr;
                    re.push_back(node);
                }
                else{
                    for(int k = 0; k &lt; rightVector.size(); k++){
                        TreeNode* node = new TreeNode(i);
                        node-&gt;left = nullptr;
                        node-&gt;right = rightVector[k];
                        re.push_back(node);
                    }
                }
            }
        }
        return re;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>669</wp:post_id>
		<wp:post_date><![CDATA[2016-08-24 16:08:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-24 08:08:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-95-unique-binary-search-trees-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 96. Unique Binary Search Trees</title>
		<link>http://xiadong.info/2016/08/leetcode-96-unique-binary-search-trees/</link>
		<pubDate>Wed, 24 Aug 2016 08:22:28 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=671</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given <em>n</em>, how many structurally unique <strong>BST&#39;s</strong> (binary search trees) that store values 1...<em>n</em>?
For example,
Given <em>n</em> = 3, there are a total of 5 unique BST&#39;s.
<pre lang='undefined'>
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>
</blockquote>

采用递归+动态规划来解决.

首先一颗n个节点的BST, 假设它的根节点值为r(1&lt;=r&lt;=n), 那么它的不同形态数量等于所有左子树的形态数量(r-1个节点)×所有右子树的形态数量(n-r个节点), 而因为一颗BST的形态数量只与节点数量有关而与节点的具体值无关, 所以可以用一个数组来记录已经计算过数量的n来减少计算.

<pre lang='c++'>
class Solution {
public:
    int numTrees(int n) {
        vector&lt;int&gt; nums(n + 1, -1);
        return numsTrees(n, nums);
    }
    
    int numsTrees(int n, vector&lt;int&gt; &amp;nums){
        int num = 0;
        if(n == 0 || n == 1){
            return 1;
        }
        for(int i = 1; i &lt;= n; i++){
            num += ((nums[i - 1] == -1 ? numsTrees(i - 1, nums) : nums[i - 1]) * (nums[n - i] == -1 ? numsTrees(n - i, nums) : nums[n - i]));
        }
        nums[n] = num;
        return num;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>671</wp:post_id>
		<wp:post_date><![CDATA[2016-08-24 16:22:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-24 08:22:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-96-unique-binary-search-trees]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 97. Interleaving String</title>
		<link>http://xiadong.info/2016/08/leetcode-97-interleaving-string/</link>
		<pubDate>Wed, 24 Aug 2016 11:44:12 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=673</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.
For example,
Given:
<em>s1</em> = <code>&quot;aabcc&quot;</code>,
<em>s2</em> = <code>&quot;dbbca&quot;</code>,
When <em>s3</em> = <code>&quot;aadbbcbcac&quot;</code>, return true.
When <em>s3</em> = <code>&quot;aadbbbaccc&quot;</code>, return false.
</blockquote>

使用动态规划, <code>dp[i][j]</code>代表s1的前i个字符与s2的前j个字符是否能组成s3的前i+j个字符. 

显然<code>dp[0][0]</code>能组成空字符串, 所以<code>dp[0][0]</code>为真. 而对于<code>i=0</code>和<code>j=0</code>的情况来说, 直接比较s1的前i个字符或s2的前j个字符与s3是否相同就可以了.

接下来的<code>dp[i][j]</code>分为两种情况:

<ol><li>
<code>s3[i+j-1]</code>的字符与<code>s1[i-1]</code>相同, 代表<code>s3[i+j-1]</code>的字符可以从s1中取得. 此时<code>dp[i][j]</code>为真则要求<code>dp[i-1][j]</code>为真.</li>
<li>
<code>s3[i+j-1]</code>的字符与<code>s2[j-1]</code>相同, 代表<code>s3[i+j-1]</code>的字符可以从s2中取得. 此时<code>dp[i][j]</code>为真则要求<code>dp[i][j-1]</code>为真.</li>
</ol>

递推方程为

<pre lang='undefined'>
dp[i][j] = (dp[i - 1][j] &amp;&amp; s3[i + j - 1] == s1[i - 1]) || (dp[i][j - 1] &amp;&amp; s3[i + j - 1] == s2[j - 1])
</pre>

<pre lang='c++'>
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        if(s1.length() + s2.length() != s3.length()) return false;
        vector&lt;vector&lt;int&gt;&gt; dp(s1.size() + 1, vector&lt;int&gt;(s2.size() + 1, 0));
        dp[0][0] = 1;
        for(int i = 1; i &lt;= s1.size(); i++){
            if(!dp[i - 1][0]) break;
            if(s1[i - 1] == s3[i - 1]) dp[i][0] = 1;
        }
        for(int i = 1; i &lt;= s2.size(); i++){
            if(!dp[0][i - 1]) break;
            if(s2[i - 1] == s3[i - 1]) dp[0][i] = 1;
        }
        for(int i = 1; i &lt;= s1.size(); i++){
            for(int j = 1; j &lt;= s2.size(); j++){
                if((dp[i - 1][j] &amp;&amp; s3[i + j - 1] == s1[i - 1]) || (dp[i][j - 1] &amp;&amp; s3[i + j - 1] == s2[j - 1])) dp[i][j] = 1;
            }
        }
        return dp[s1.size()][s2.size()];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>673</wp:post_id>
		<wp:post_date><![CDATA[2016-08-24 19:44:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-24 11:44:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-97-interleaving-string]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 98. Validate Binary Search Tree</title>
		<link>http://xiadong.info/2016/08/leetcode-98-validate-binary-search-tree/</link>
		<pubDate>Sun, 28 Aug 2016 07:51:28 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=675</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, determine if it is a valid binary search tree (BST).
Assume a BST is defined as follows:
<ul><li>
The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
<li>
The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
<li>
Both the left and right subtrees must also be binary search trees.</li>
</ul>
<strong>Example 1:</strong>
<pre lang='undefined'>
    2
   / \
  1   3
</pre>
Binary tree 
<pre lang='undefined'>
[2,1,3]
</pre>
, return true.
<strong>Example 2:</strong>
<pre lang='undefined'>
    1
   / \
  2   3
</pre>
Binary tree 
<pre lang='undefined'>
[1,2,3]
</pre>
, return false.
</blockquote>

验证一个二叉搜索树是否合法, 使用递归的方法来依次遍历左右子树.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if(!root) return true;
        if(root-&gt;left &amp;&amp; BSTMax(root-&gt;left) &gt;= root-&gt;val){
            return false;
        }
        if(root-&gt;right &amp;&amp; BSTMin(root-&gt;right) &lt;= root-&gt;val){
            return false;
        }
        return isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);
    }
    
    int BSTMax(TreeNode* root){
        if(!root-&gt;right){
            return root-&gt;val;
        }
        return BSTMax(root-&gt;right);
    }
    
    int BSTMin(TreeNode* root){
        if(!root-&gt;left){
            return root-&gt;val;
        }
        return BSTMin(root-&gt;left);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>675</wp:post_id>
		<wp:post_date><![CDATA[2016-08-28 15:51:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-28 07:51:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-98-validate-binary-search-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 99. Recover Binary Search Tree</title>
		<link>http://xiadong.info/2016/08/leetcode-99-recover-binary-search-tree/</link>
		<pubDate>Sun, 28 Aug 2016 10:20:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=677</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Two elements of a binary search tree (BST) are swapped by mistake.
Recover the tree without changing its structure.
Note:
A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?
</blockquote>

使用O(n)辅助空间的方法就是使用中序遍历从BST中获得一个有序递增的序列, 但是其中有两个元素的位置交换了. 被交换的元素的特征就是前一个元素大于后一个元素, 找到这样两个元素再把它们交换回来即可, 如果只找到了一个这样的元素, 说明是相邻的两个元素交换了.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    deque&lt;TreeNode*&gt; seq;
public:
    void recoverTree(TreeNode* root) {
        inOrder(root);
        vector&lt;int&gt; mistakeNodes;
        for(int i = 0; i &lt; seq.size() - 1; i++){
            if(seq[i]-&gt;val &gt; seq[i + 1]-&gt;val){
                mistakeNodes.push_back(i);
            }
        }
        if(mistakeNodes.size() == 1){
            swap(seq[mistakeNodes[0]]-&gt;val, seq[mistakeNodes[0] + 1]-&gt;val);
        }
        else{
            swap(seq[mistakeNodes[0]]-&gt;val, seq[mistakeNodes[1] + 1]-&gt;val);
        }
    }
    
    void inOrder(TreeNode *root){
        if(root == nullptr) return;
        inOrder(root-&gt;left);
        seq.push_back(root);
        inOrder(root-&gt;right);
    }
};
</pre>

而把这一思路推广到不使用辅助空间, 很容易就可以发现我们并不需要一个完整的序列, 只需要相邻两个值的大小关系, 所以我们只要在遍历过程中维持两个节点值即可. 另外由于我们没有完整的序列, 所以在mistakeNodes中要同时保存前一个元素比后一个元素大的这两个元素, 因为对于被交换的较小值来说, 它在后一个元素的位置, 而对于较大值来说, 它位于前一个元素的位置. 当然也可以通过判断mistakeNodes中是否已经有元素来避免同时保存.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    vector&lt;TreeNode*&gt; mistakeNodes;
    vector&lt;TreeNode*&gt; tmpNodes;
public:
    void recoverTree(TreeNode* root) {
        tmpNodes.resize(2);
        inOrder(root);
        if(mistakeNodes.size() == 2){
            swap(mistakeNodes[0]-&gt;val, mistakeNodes[1]-&gt;val);
        }
        else{
            swap(mistakeNodes[0]-&gt;val, mistakeNodes[3]-&gt;val);
        }
    }
    
    void inOrder(TreeNode *root){
        if(root == nullptr || mistakeNodes.size() == 4) return ;
        inOrder(root-&gt;left);
        tmpNodes[0] = tmpNodes[1];
        tmpNodes[1] = root;
        if(tmpNodes[0] &amp;&amp; tmpNodes[0]-&gt;val &gt; tmpNodes[1]-&gt;val){
            mistakeNodes.push_back(tmpNodes[0]);
            mistakeNodes.push_back(tmpNodes[1]);
        }
        inOrder(root-&gt;right);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>677</wp:post_id>
		<wp:post_date><![CDATA[2016-08-28 18:20:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-28 10:20:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-99-recover-binary-search-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 100. Same Tree</title>
		<link>http://xiadong.info/2016/08/leetcode-100-same-tree/</link>
		<pubDate>Sun, 28 Aug 2016 10:26:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=680</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two binary trees, write a function to check if they are equal or not.
Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
</blockquote>

很简单, 使用递归来判断每个节点是否相等.

<pre lang='c++'>
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if(p == NULL &amp;&amp; q == NULL) return true;
        if((p == NULL &amp;&amp; q != NULL) || (p != NULL &amp;&amp; q == NULL))return false;
        if(p-&gt;val != q-&gt;val)return false;
        
        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>680</wp:post_id>
		<wp:post_date><![CDATA[2016-08-28 18:26:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-28 10:26:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-100-same-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 389. Find the Difference</title>
		<link>http://xiadong.info/2016/08/leetcode-389-find-the-difference/</link>
		<pubDate>Mon, 29 Aug 2016 08:00:40 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=682</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two strings <strong>s</strong> and <strong>t</strong> which consist of only lowercase letters.
String <strong>t</strong> is generated by random shuffling string <strong>s</strong> and then add one more letter at a random position.
Find the letter that was added in <strong>t</strong>.
<strong>Example:</strong>
<pre lang='undefined'>
Input:
s = &quot;abcd&quot;
t = &quot;abcde&quot;

Output:
e

Explanation:
&#39;e&#39; is the letter that was added.
</pre>
</blockquote>

使用哈希表来记录每个字母出现的次数, 多出现的字符就是增加的字符.

<pre lang='c++'>
class Solution {
public:
    char findTheDifference(string s, string t) {
        vector&lt;int&gt; nums(26, 0);
        for(int i = 0; i &lt; s.length(); i++){
            nums[s[i] - &#39;a&#39;]++;
        }
        for(int i = 0; i &lt; t.length(); i++){
            if(--nums[t[i] - &#39;a&#39;] &lt; 0) return t[i];
        }
        return 0;
    }
};
</pre>

还可以使用异或. 由于s与t除了一个元素以外其他都相同, 所以使用0分别于s与t的每个元素异或, 得到的就是多余的那一个字符.

<pre lang='c++'>
class Solution {
public:
    char findTheDifference(string s, string t) {
        char ch = 0;
        for(int i = 0; i &lt; s.length(); i++){
            ch ^= s[i];
        }
        for(int i = 0; i &lt; t.length(); i++){
            ch ^= t[i];
        }
        return ch;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>682</wp:post_id>
		<wp:post_date><![CDATA[2016-08-29 16:00:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-29 08:00:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-389-find-the-difference]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 391. Perfect Rectangle</title>
		<link>http://xiadong.info/2016/08/leetcode-391-perfect-rectangle/</link>
		<pubDate>Tue, 30 Aug 2016 10:14:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=684</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given N axis-aligned rectangles where N &gt; 0, determine if they all together form an exact cover of a rectangular region.

Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).

<img src="https://leetcode.com/static/images/problemset/rectangle_perfect.gif" alt="img" />

<strong>Example 1:</strong>
<pre lang="undefined">rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [3,2,4,4],
  [1,3,2,4],
  [2,3,3,4]
]

Return true. All 5 rectangles together form an exact cover of a rectangular region.
</pre>
<img src="https://leetcode.com/static/images/problemset/rectangle_separated.gif" alt="img" />

<strong>Example 2:</strong>
<pre lang="undefined">rectangles = [
  [1,1,2,3],
  [1,3,2,4],
  [3,1,4,2],
  [3,2,4,4]
]

Return false. Because there is a gap between the two rectangular regions.
</pre>
<img src="https://leetcode.com/static/images/problemset/rectangle_hole.gif" alt="img" />

<strong>Example 3:</strong>
<pre lang="undefined">rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [3,2,4,4]
]

Return false. Because there is a gap in the top center.
</pre>
<img src="https://leetcode.com/static/images/problemset/rectangle_intersect.gif" alt="img" />

<strong>Example 4:</strong>
<pre lang="undefined">rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [2,2,4,4]
]

Return false. Because two of the rectangles overlap with each other.
</pre>
</blockquote>

一开始我对于这道题的思路是这样的:

<ul>
    <li>第一步, 遍历所有小的矩形计算它们的面积之和并且计算出最终应该拼成的大矩形的端点位置(左下角和右上角), 如果面积之和与大矩形的面积不相等, 那么就肯定不可能拼成.</li>
    <li>第二步, 判断小矩形之间是不是有重叠.</li>
</ul>

问题在于第二步, 判断矩形是否有重叠比较容易, 但是两两比较要求O(n<sup>2</sup>)的时间复杂度, 超时了.

如果不对小矩形两两判断是否有重叠而使用累积的办法看某个小矩形与之前所有小矩形拼成的多边形是否有重合的话, 实现起来相当复杂, 所以应该有更好的方法.

在Discuss中看到了一个相当妙的办法<a href="https://discuss.leetcode.com/topic/56081/easy-understanding-o-n-python-solution" target="_blank">https://discuss.leetcode.com/topic/56081/easy-understanding-o-n-python-solution</a>, 基本思想就是如果最终能拼成大矩形, 那么除了大矩形的四个顶点只出现一次外, 其他的每个小矩形的顶点只能出现两次或者四次. 所以就可以用一个map来记录小矩形的每个顶点出现的次数, 然后再遍历这个map判断其中的顶点是不是都满足条件. 时间复杂度(O(nlogn + n)).

<pre lang="c++">class Solution {
public:
    bool isRectangleCover(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) {
        int n = rectangles.size(), areaSum = 0;
        vector&lt;int&gt; finalRect(4);
        map&lt;pair&lt;int, int&gt;, int&gt; corners;
        finalRect[0] = finalRect[1] = INT_MAX, finalRect[2] = finalRect[3] = INT_MIN;
        vector&lt;int&gt; areas(n, 0);
        for(int i = 0; i &lt; n; i++){
            areas[i] = (rectangles[i][2] - rectangles[i][0]) * (rectangles[i][3] - rectangles[i][1]);
            vector&lt;pair&lt;int, int&gt;&gt; corner = {{rectangles[i][0], rectangles[i][1]}, {rectangles[i][2], rectangles[i][3]}, {rectangles[i][0], rectangles[i][3]}, {rectangles[i][2], rectangles[i][1]}};
            for(int j = 0; j &lt; 4; j++){
                if(corners.count(corner[j])){
                    corners[corner[j]]++;
                }
                else{
                    corners[corner[j]] = 1;
                }
            }
            finalRect[0] = min(finalRect[0], rectangles[i][0]);
            finalRect[1] = min(finalRect[1], rectangles[i][1]);
            finalRect[2] = max(finalRect[2], rectangles[i][2]);
            finalRect[3] = max(finalRect[3], rectangles[i][3]);
            areaSum += areas[i];
        }
        int finalArea = (finalRect[2] - finalRect[0]) * (finalRect[3] - finalRect[1]);
        if(areaSum != finalArea) return false;
        
        for(auto i = corners.begin(); i != corners.end(); i++){
            if(((i-&gt;first.first == finalRect[0] &amp;&amp; i-&gt;first.second == finalRect[1]) || (i-&gt;first.first == finalRect[2] &amp;&amp; i-&gt;first.second == finalRect[3]) || (i-&gt;first.first == finalRect[0] &amp;&amp; i-&gt;first.second == finalRect[3]) || (i-&gt;first.first == finalRect[2] &amp;&amp; i-&gt;first.second == finalRect[1]))){
                if(i-&gt;second != 1){
                    return false;
                }
            }
            else if(i-&gt;second == 2 || i-&gt;second == 4){
                continue;
            }
            else{
                return false;
            }
        }
        return true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>684</wp:post_id>
		<wp:post_date><![CDATA[2016-08-30 18:14:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-30 10:14:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-391-perfect-rectangle]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 101. Symmetric Tree</title>
		<link>http://xiadong.info/2016/08/leetcode-101-symmetric-tree/</link>
		<pubDate>Tue, 30 Aug 2016 11:29:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=686</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:
<pre lang='undefined'>
    1
   / \
  2   2
 / \ / \
3  4 4  3
</pre>
But the following <code>[1,2,2,null,3,null,3]</code> is not:
<pre lang='undefined'>
    1
   / \
  2   2
   \   \
   3    3
</pre>
<strong>Note:</strong>
Bonus points if you could solve it both recursively and iteratively.
</blockquote>

最直观的方法就是先把二叉树翻转, 然后再判断两棵二叉树是否相同.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void copyTree(TreeNode* root, TreeNode *copy){
        if(!root){
            return;
        }
        if(root-&gt;left)
            copy-&gt;left = new TreeNode(root-&gt;left-&gt;val);
        else
            copy-&gt;left = NULL;
        copyTree(root-&gt;left, copy-&gt;left);
        if(root-&gt;right)
            copy-&gt;right = new TreeNode(root-&gt;right-&gt;val);
        else
            copy-&gt;right = NULL;
        copyTree(root-&gt;right, copy-&gt;right);
    }
    void reverseTree(TreeNode *root){
        if(!root)
            return;
        TreeNode *tmp = root-&gt;left;
        root-&gt;left = root-&gt;right;
        root-&gt;right = tmp;
        reverseTree(root-&gt;left);
        reverseTree(root-&gt;right);
    }
    bool sameTree(TreeNode* root1, TreeNode* root2){
        if(root1 == NULL &amp;&amp; root2 == NULL)
            return true;
        if(root1 == NULL || root2 == NULL)
            return false;
        if(root1-&gt;val != root2-&gt;val)
            return false;
        return sameTree(root1-&gt;left, root2-&gt;left) &amp;&amp; sameTree(root1-&gt;right, root2-&gt;right);
    }
    bool isSymmetric(TreeNode* root) {
        if(!root)
            return true;
        TreeNode *mirrorRoot = new TreeNode(root-&gt;val);
        copyTree(root, mirrorRoot);
        reverseTree(mirrorRoot);
        return sameTree(root, mirrorRoot);
    }
};
</pre>

非递归的方法就是使用迭代而不是递归来分别从<strong>不同的方向</strong>遍历左右子树, <strong>注意</strong>, 不能用先序遍历或者后序遍历, 比如这组数据<code>[1,2,2,null,3,null,3]</code>使用先序遍历它的左右子树是互为镜像的. 

另外说一句, 直到这里我才去看非递归遍历二叉树的标准方法, 我以前都是用另一个栈来保存节点状态...很有力地证明了我的数据结构课听得很水= =.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isMirror(root-&gt;left, root-&gt;right);
    }
    
    bool isMirror(TreeNode* left, TreeNode *right){
        stack&lt;TreeNode*&gt; leftPath, rightPath;
        while((!leftPath.empty() || left != nullptr) &amp;&amp; (!rightPath.empty() || right != nullptr)){
            TreeNode *curLeftNode = nullptr, *curRightNode = nullptr;
            if(left != nullptr){
                leftPath.push(left);
                left = left-&gt;left;
            }
            else{
                left = leftPath.top();
                curLeftNode = left;
                leftPath.pop();
                left = left-&gt;right;
            }
            if(right != nullptr){
                rightPath.push(right);
                right = right-&gt;right;
            }
            else{
                right = rightPath.top();
                curRightNode = right;
                rightPath.pop();
                right = right-&gt;left;
            }
            if((curLeftNode &amp;&amp; curRightNode &amp;&amp; curLeftNode-&gt;val != curRightNode-&gt;val) || (!(curLeftNode &amp;&amp; curRightNode) &amp;&amp; !(curLeftNode == nullptr &amp;&amp; curRightNode == nullptr))) {
                // 这个布尔表达式的意思是当前的左右节点都不为null并且值不等, 或者其中有且只有
                // 一个null
                return false;
            }
        }
        if(leftPath.empty() &amp;&amp; left == nullptr &amp;&amp; rightPath.empty() &amp;&amp; right == nullptr) return true;
        else return false;
    }
};
</pre>

附上标准的非递归遍历方法:

<pre lang='c++'>
// 先序遍历
void preOrderIter(struct node *root)  
{  
    stack&lt;struct node *&gt; s;  
    while (root != NULL || !s.empty()) {  
        if (root != NULL) {  
            cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;; //访问结点并入栈  
            s.push(root);                
            root = root-&gt;left;         //访问左子树  
        } else {  
            root = s.top();            //回溯至父亲结点  
            s.pop();  
            root = root-&gt;right;        //访问右子树  
        }  
    }  
    cout &lt;&lt; endl;  
}

// 中序遍历
void inOrderIter(struct node *root)  
{  
    stack&lt;struct node *&gt; s;  
    while (root != NULL || !s.empty()) {  
        if (root != NULL) {  
            s.push(root);  
            root = root-&gt;left;  
        }  
        else {  
            root = s.top();  
            cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;  //访问完左子树后才访问根结点  
            s.pop();  
            root = root-&gt;right;        //访问右子树  
        }  
    }  
    cout &lt;&lt; endl;  
}

// 后序遍历
void postOrderIter(struct node *root)  
{  
    if (!root) return;  
    stack&lt;struct node*&gt; s, output;  
    s.push(root);  
    while (!s.empty()) {  
        struct node *curr = s.top();  
        output.push(curr);  
        s.pop();  
        if (curr-&gt;left)  
            s.push(curr-&gt;left);  
        if (curr-&gt;right)  
            s.push(curr-&gt;right);  
    }  
      
    while (!output.empty()) {  
        cout &lt;&lt; output.top()-&gt;data &lt;&lt; &quot; &quot;;  
        output.pop();  
    }  
    cout &lt;&lt; endl;  
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>686</wp:post_id>
		<wp:post_date><![CDATA[2016-08-30 19:29:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-30 11:29:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-101-symmetric-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 102. Binary Tree Level Order Traversal</title>
		<link>http://xiadong.info/2016/08/leetcode-102-binary-tree-level-order-traversal/</link>
		<pubDate>Wed, 31 Aug 2016 08:43:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=688</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, return the <em>level order</em> traversal of its nodes&#39; values. (ie, from left to right, level by level).
For example:
Given binary tree <code>[3,9,20,null,null,15,7]</code>,
<pre lang='undefined'>
    3
   / \
  9  20
    /  \
   15   7
</pre>
return its level order traversal as:
<pre lang='undefined'>
[
  [3],
  [9,20],
  [15,7]
]
</pre>
</blockquote>

我的方法是使用广度优先搜索遍历每一个节点并计算出每一个节点的level值, 然后再遍历一次节点把节点放到相应的level中去. 时间和空间复杂度都是O(n).

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if(!root){
            return vector&lt;vector&lt;int&gt;&gt;();
        }
        // 用于BFS的队列, qLevel用于保存BFS中相应节点的level
        queue&lt;TreeNode*&gt; BFS;
        queue&lt;int&gt; qLevel;
        // 把遍历到的每一个节点都放到vector中保存, 用于最后汇总
        vector&lt;int&gt; level;
        vector&lt;TreeNode*&gt; nodes;
        
        BFS.push(root);
        qLevel.push(0);
        int maxLevel = 0;
        nodes.push_back(root);
        level.push_back(0);
        while(!BFS.empty()){
            TreeNode* node = BFS.front();
            int currentLevel = qLevel.front();
            if(node-&gt;left){
                BFS.push(node-&gt;left);
                qLevel.push(currentLevel + 1);
                nodes.push_back(node-&gt;left);
                level.push_back(currentLevel + 1);
            }
            if(node-&gt;right){
                BFS.push(node-&gt;right);
                qLevel.push(currentLevel + 1);
                nodes.push_back(node-&gt;right);
                level.push_back(currentLevel + 1);
            }
            if(currentLevel + 1 &gt; maxLevel) maxLevel = currentLevel + 1;
            BFS.pop();
            qLevel.pop();
        }
        // 再次遍历节点并放到相应的level中去
        vector&lt;vector&lt;int&gt;&gt; re(maxLevel);
        for(int i = 0; i &lt; nodes.size(); i++){
            re[level[i]].push_back(nodes[i]-&gt;val);
        }
        return re;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>688</wp:post_id>
		<wp:post_date><![CDATA[2016-08-31 16:43:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-31 08:43:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-102-binary-tree-level-order-traversal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 103. Binary Tree Zigzag Level Order Traversal</title>
		<link>http://xiadong.info/2016/08/leetcode-103-binary-tree-zigzag-level-order-traversal/</link>
		<pubDate>Wed, 31 Aug 2016 08:50:16 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=690</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes&#39; values. (ie, from left to right, then right to left for the next level and alternate between).
For example:
Given binary tree <code>[3,9,20,null,null,15,7]</code>,
<pre lang='undefined'>
    3
   / \
  9  20
    /  \
   15   7
</pre>
return its zigzag level order traversal as:
<pre lang='undefined'>
[
  [3],
  [20,9],
  [15,7]
]
</pre>
</blockquote>

这道题与上一题<a href='http://xiadong.info/2016/08/leetcode-102-binary-tree-level-order-traversal/'>Binary Tree Level Order Traversal</a>非常相似, 只需要在BFS之后汇总的时候以正反方向间隔的形式放入level中即可. 我是全部正向放入之后再对偶数行颠倒来完成的.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        if(!root) return vector&lt;vector&lt;int&gt;&gt;();
        vector&lt;int&gt; vals, level;
        generateMap(root, vals, level);
        int maxLevel = 0;
        for(int i = 0; i &lt; level.size(); i++) if(maxLevel &lt; level[i]) maxLevel = level[i];
        vector&lt;vector&lt;int&gt;&gt; re(maxLevel + 1);
        for(int i = 0; i &lt; vals.size(); i++){
            re[level[i]].push_back(vals[i]);
        }
        
        for(int i = 1; i &lt;= maxLevel; i += 2){
            reverse(re[i].begin(), re[i].end());
        }
        return re;
    }
    
    void generateMap(TreeNode* root, vector&lt;int&gt; &amp;vals, vector&lt;int&gt; &amp;level){
        queue&lt;TreeNode*&gt; nodes;
        queue&lt;int&gt; levels;
        nodes.push(root);
        levels.push(0);
        while(!nodes.empty()){
            TreeNode* p = nodes.front();
            int l = levels.front();
            vals.push_back(p-&gt;val);
            level.push_back(l);
            if(p-&gt;left){
                nodes.push(p-&gt;left);
                levels.push(l + 1);
            }
            if(p-&gt;right){
                nodes.push(p-&gt;right);
                levels.push(l + 1);
            }
            nodes.pop();
            levels.pop();
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>690</wp:post_id>
		<wp:post_date><![CDATA[2016-08-31 16:50:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-31 08:50:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-103-binary-tree-zigzag-level-order-traversal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 104. Maximum Depth of Binary Tree</title>
		<link>http://xiadong.info/2016/08/leetcode-104-maximum-depth-of-binary-tree/</link>
		<pubDate>Wed, 31 Aug 2016 10:43:18 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=692</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
</blockquote>

递归递归递.

<pre lang='c++'>
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode *root) {
        if(root == NULL) return 0;
        int left_depth = 1, right_depth = 1;
        if(root-&gt;left != NULL)
            left_depth = maxDepth(root-&gt;left) + 1;
        if(root-&gt;right != NULL)
            right_depth = maxDepth(root-&gt;right) + 1;
            
        return left_depth &gt; right_depth ? left_depth : right_depth;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>692</wp:post_id>
		<wp:post_date><![CDATA[2016-08-31 18:43:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-31 10:43:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-104-maximum-depth-of-binary-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>在Hyper-V为Linux扩大分区</title>
		<link>http://xiadong.info/2016/09/%e5%9c%a8hyper-v%e4%b8%balinux%e6%89%a9%e5%a4%a7%e5%88%86%e5%8c%ba/</link>
		<pubDate>Thu, 01 Sep 2016 05:56:24 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=695</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>问题来源</h1>

我在Hyper-V里安装的虚拟机一开始只分配了10G的虚拟硬盘, 今天编译RISC-V Toolchain的时候硬盘空间耗尽了(顺带吐槽一下编译的时候下载源代码再次被网速折磨), 所以就要扩大虚拟磁盘的空间.

<h1 data-breakpage>Hyper-V中的设置</h1>

首先就是在Hyper-V中的磁盘编辑中修改虚拟磁盘的大小. 这一步没有任何问题, 下一步是修改分区表.

<h1 data-breakpage>修改分区表</h1>

在Linux中要修改一个分区的大小, 必须要把它<code>umount</code>, 但是我要扩展的是整个系统分区, 所以需要用Linux的系统安装光盘启动. 然后运行gparted程序来修改分区大小.

<h1 data-breakpage>回到Linux中的设置</h1>

到了上一步还是不行, 因为我要扩展的是一个逻辑分区 <em>logical volume</em>, 需要在原来的系统中扩展逻辑分区和启用新的分区空间才可以.

<pre lang='shell'>
$ lvresize -l 100%VG [your device]
</pre>

<code>100%VG</code>的意思是使用全部空闲空间. 然后启用空间.

<pre lang='shell'>
$ resize2fs [your device]
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>695</wp:post_id>
		<wp:post_date><![CDATA[2016-09-01 13:56:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-01 05:56:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9c%a8hyper-v%e4%b8%balinux%e6%89%a9%e5%a4%a7%e5%88%86%e5%8c%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<category domain="post_tag" nicename="%e5%b7%a5%e5%85%b7"><![CDATA[工具]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
		<link>http://xiadong.info/2016/09/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
		<pubDate>Thu, 01 Sep 2016 07:36:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=697</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given preorder and inorder traversal of a tree, construct the binary tree.
<strong>Note:</strong>
You may assume that duplicates do not exist in the tree.
</blockquote>

通过中序遍历序列和先序遍历序列来还原一颗二叉树. 由于题目指出可以假设树中不存在重复元素, 所以先序序列的第一个元素就是根节点的值, 然后在中序序列中找到这个值就可以把中序序列划分为左子树的中序序列和右子树的中序序列, 并且得到左右子树的节点数量, 根据节点数量就可以把先序序列划分开来. 然后就可以通过递归来分别构建左右子树.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        if(preorder.empty()) return nullptr;
        return buildBinaryTree(preorder, 0, preorder.size(), inorder, 0, inorder.size());
    }
    
    TreeNode* buildBinaryTree(vector&lt;int&gt; &amp;preorder, int preLeft, int preRight, vector&lt;int&gt; &amp;inorder, int inLeft, int inRight){
        if(preLeft &gt;= preRight || inLeft &gt;= inRight) return nullptr;
        TreeNode *node = new TreeNode(preorder[preLeft]);
        int rootPosInOrder;
        for(int i = inLeft; i &lt; inRight; i++){
            if(inorder[i] == node-&gt;val){
                rootPosInOrder = i;
                break;
            }
        }
        int leftNum = rootPosInOrder - inLeft, rightNum = inRight - rootPosInOrder - 1;
        node-&gt;left = buildBinaryTree(preorder, preLeft + 1, preLeft + 1 + leftNum, inorder, inLeft, inLeft + leftNum);
        node-&gt;right = buildBinaryTree(preorder, preLeft + 1 + leftNum, preRight, inorder, inLeft + leftNum + 1, inRight);
        return node;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>697</wp:post_id>
		<wp:post_date><![CDATA[2016-09-01 15:36:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-01 07:36:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal</title>
		<link>http://xiadong.info/2016/09/leetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
		<pubDate>Thu, 01 Sep 2016 08:24:48 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=700</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given inorder and postorder traversal of a tree, construct the binary tree.
<strong>Note:</strong>
You may assume that duplicates do not exist in the tree.
</blockquote>

与上一题<a href='http://xiadong.info/2016/09/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/'>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</a>非常相似, 只不过先序序列变成了后序序列, 实质上并没有什么变化, 仍然使用相同的方法.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        return buildTreeImpl(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
    
    TreeNode* buildTreeImpl(vector&lt;int&gt; &amp;inorder, int inStart, int inEnd, vector&lt;int&gt; &amp;postorder, int postStart, int postEnd){
        if(inStart == inEnd || postStart == postEnd) return nullptr;
        int rootVal = postorder[postEnd - 1];
        TreeNode *root = new TreeNode(rootVal);
        int leftLen, rightLen;
        for(int i = inStart; i &lt; inEnd; i++){
            if(inorder[i] == rootVal){
                leftLen = i - inStart;
                break;
            }
        }
        rightLen = (inEnd - inStart - leftLen - 1);
        root-&gt;left = buildTreeImpl(inorder, inStart, inStart + leftLen, postorder, postStart, postStart + leftLen);
        root-&gt;right = buildTreeImpl(inorder, inStart + leftLen + 1, inEnd, postorder, postStart + leftLen, postEnd - 1);
        return root;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>700</wp:post_id>
		<wp:post_date><![CDATA[2016-09-01 16:24:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-01 08:24:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 107. Binary Tree Level Order Traversal II</title>
		<link>http://xiadong.info/2016/09/leetcode-107-binary-tree-level-order-traversal-ii/</link>
		<pubDate>Thu, 01 Sep 2016 08:51:20 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=702</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root).
For example:
Given binary tree <code>[3,9,20,null,null,15,7]</code>,
<pre lang='undefined'>
    3
   / \
  9  20
    /  \
   15   7
</pre>
return its bottom-up level order traversal as:
<pre lang='undefined'>
[
  [15,7],
  [9,20],
  [3]
]
</pre>
</blockquote>

先层次遍历, 然后将得到的二维数组颠倒顺序.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    vector&lt;vector&lt;int&gt;&gt; ret;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
        if(!root) return ret;
        BFS(root);
        reverse(ret.begin(), ret.end());
        return ret;
    }
    
    void BFS(TreeNode *root){
        queue&lt;TreeNode*&gt; nodeQueue;
        queue&lt;int&gt; levelQueue;
        
        nodeQueue.push(root);
        levelQueue.push(0);
        
        while(!nodeQueue.empty()){
            TreeNode *node = nodeQueue.front();
            int nodeLevel = levelQueue.front();
            nodeQueue.pop();
            levelQueue.pop();
            
            if(nodeLevel &gt;= ret.size()){
                ret.resize(nodeLevel + 1);
            }
            ret[nodeLevel].push_back(node-&gt;val);
            
            if(node-&gt;left){
                nodeQueue.push(node-&gt;left);
                levelQueue.push(nodeLevel + 1);
            }
            if(node-&gt;right){
                nodeQueue.push(node-&gt;right);
                levelQueue.push(nodeLevel + 1);
            }
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>702</wp:post_id>
		<wp:post_date><![CDATA[2016-09-01 16:51:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-01 08:51:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-107-binary-tree-level-order-traversal-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 108. Convert Sorted Array to Binary Search Tree</title>
		<link>http://xiadong.info/2016/09/leetcode-108-convert-sorted-array-to-binary-search-tree/</link>
		<pubDate>Sun, 04 Sep 2016 07:31:18 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=704</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述;

<blockquote>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
</blockquote>

根据有序数组来构建一颗平衡二叉搜索树. 比较直观的方法就是选择给定数组的中间位置的元素作为根节点的值, 然后把左边和右边的元素分别递归地生成左右子树, 这样可以保证高度平衡.

<pre lang='c++'>
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *sortedArrayToBST(vector&lt;int&gt; &amp;num) {
        if(num.size() == 0)return NULL;
        
        return sortedArrayToBSTImpl(num, 0, num.size());
    }
    
    TreeNode* sortedArrayToBSTImpl(vector&lt;int&gt; &amp;num, int start, int end){
        if(end &lt;= start)return NULL;
        int mid = (start + end) / 2;
        TreeNode *root = new TreeNode(num[mid]);
        
        root-&gt;left = sortedArrayToBSTImpl(num, start, mid);
        root-&gt;right = sortedArrayToBSTImpl(num, mid + 1, end);
        
        return root;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>704</wp:post_id>
		<wp:post_date><![CDATA[2016-09-04 15:31:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-04 07:31:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-108-convert-sorted-array-to-binary-search-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 109. Convert Sorted List to Binary Search Tree</title>
		<link>http://xiadong.info/2016/09/leetcode-109-convert-sorted-list-to-binary-search-tree/</link>
		<pubDate>Sun, 04 Sep 2016 07:45:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=706</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
</blockquote>

最简单的方法就是遍历一次链表, 把每个节点的值放入一个数组中, 然后就变成了<a href='http://xiadong.info/2016/09/leetcode-108-convert-sorted-array-to-binary-search-tree/'>上一题</a>. 

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        deque&lt;int&gt; nums;
        ListNode *p = head;
        while(p){
            nums.push_back(p-&gt;val);
            p = p-&gt;next;
        }
        return buildBST(nums, 0, nums.size());
    }
    
    TreeNode* buildBST(deque&lt;int&gt; &amp;nums, int left, int right){
        if(left &gt;= right) return nullptr;
        
        int mid = (left + right) / 2;
        TreeNode* node = new TreeNode(nums[mid]);
        node-&gt;left = buildBST(nums, left, mid);
        node-&gt;right = buildBST(nums, mid + 1, right);
        return node;
    }
};
</pre>

如果不使用辅助空间, 就要实现一个根据节点距头结点的距离来获取节点的函数. 这样的话每次访问节点都要遍历一部分链表.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        int len = 0;
        ListNode *p = head;
        while(p){
            len++;
            p = p-&gt;next;
        }
        return buildBST(head, len);
    }
    
    TreeNode* buildBST(ListNode *head, int len){
        if(len &lt;= 0) return nullptr;
        
        int mid = len / 2;
        ListNode *n = getNode(head, mid);
        
        TreeNode* node = new TreeNode(n-&gt;val);
        node-&gt;left = buildBST(head, mid);
        node-&gt;right = buildBST(n-&gt;next, len - mid - 1);
        return node;
    }
    
    ListNode* getNode(ListNode *head, int index){
        int i = index;
        while(head &amp;&amp; index &gt; 0){
            head = head-&gt;next;
            index--;
        }
        return head;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>706</wp:post_id>
		<wp:post_date><![CDATA[2016-09-04 15:45:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-04 07:45:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-109-convert-sorted-list-to-binary-search-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 392. Is Subsequence</title>
		<link>http://xiadong.info/2016/09/leetcode-392-is-subsequence/</link>
		<pubDate>Mon, 05 Sep 2016 08:17:35 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=708</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string <strong>s</strong> and a string <strong>t</strong>, check if <strong>s</strong> is subsequence of <strong>t</strong>.
You may assume that there is only lower case English letters in both <strong>s</strong> and <strong>t</strong>. <strong>t</strong> is potentially a very long (length ~= 500,000) string, and <strong>s</strong> is a short string (&lt;=100).
A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).
<strong>Example 1:</strong>
<strong>s</strong> = <code>&quot;abc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code>
Return <code>true</code>.
<strong>Example 2:</strong>
<strong>s</strong> = <code>&quot;axc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code>
Return <code>false</code>.
</blockquote>

双指针, O(n)时间复杂度.

<pre lang='c++'>
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int sLen = s.length(), tLen = t.length();
        if(sLen == 0 &amp;&amp; tLen == 0) return true;
        int sp = 0;
        for(int i = 0; i &lt; tLen; i++){
            if(s[sp] == t[i]) sp++;
            if(sp == sLen) return true;
        }
        return false;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>708</wp:post_id>
		<wp:post_date><![CDATA[2016-09-05 16:17:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-05 08:17:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-392-is-subsequence]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 393. UTF-8 Validation</title>
		<link>http://xiadong.info/2016/09/leetcode-393-utf-8-validation/</link>
		<pubDate>Mon, 05 Sep 2016 10:02:31 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=710</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
<ol><li>
For 1-byte character, the first bit is a 0, followed by its unicode code.</li>
<li>
For n-bytes character, the first n-bits are all one&#39;s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.</li>
</ol>
This is how the UTF-8 encoding would work:
<pre lang='undefined'>
   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
</pre>
Given an array of integers representing the data, return whether it is a valid utf-8 encoding.
<strong>Note:</strong>
The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.
<strong>Example 1:</strong>
<pre lang='undefined'>
data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.

Return true.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.

Return false.
The first 3 bits are all one&#39;s and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that&#39;s correct.
But the second continuation byte does not start with 10, so it is invalid.
</pre>
</blockquote>

这道题使用位运算就可以了, 前几天刚刚做完18600的第一个datalab, 位运算还是挺easy的.

<pre lang='c++'>
class Solution {
public:
    bool validUtf8(vector&lt;int&gt;&amp; data) {
        int i = 0;
        while(i &lt; data.size()){
            if(data[i] &amp; 0x80){
                int oneLen = 0;
                while((0x80 &gt;&gt; oneLen) &amp; data[i]){
                    oneLen++;
                }
                if(oneLen &lt;= 1 || oneLen &gt; 4) return false;
                int j;
                for(j = 1; j &lt; oneLen; j++){
                    if((data[i + j] &amp; 0xc0) != 0x80) return false;
                }
                i = i + j;
            }
            else{
                i++;
            }
        }
        return true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>710</wp:post_id>
		<wp:post_date><![CDATA[2016-09-05 18:02:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-05 10:02:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-393-utf-8-validation]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 394. Decode String</title>
		<link>http://xiadong.info/2016/09/leetcode-394-decode-string/</link>
		<pubDate>Mon, 05 Sep 2016 11:42:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=712</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an encoded string, return it&#39;s decoded string.
The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em>is guaranteed to be a positive integer.
You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won&#39;t be input like <code>3a</code> or<code>2[4]</code>.
<strong>Examples:</strong>
<pre lang='undefined'>
s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.
s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.
s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.
</pre>
</blockquote>

对一个字符串进行解码, 该字符串的编码规则是这样的<code>重复次数[重复内容]</code>, 由于有可能出现嵌套, 所以我使用递归来处理这个字符串.

对于括号匹配来说, 使用栈来确定与相应左括号匹配的右括号. 要注意可能会出现不重复的串, 这时要直接把它加到返回串的后面而不处理重复次数.

<pre lang='c++'>
class Solution {
    string s;
public:
    string decodeString(string str) {
        s = str;
        return decodeStringImpl(0, s.length());
    }

    string decodeStringImpl(int start, int end) {
        string ret;
        int index = start;
        while(index &lt; end &amp;&amp; !isDigit(s[index]) &amp;&amp; s[index] != &#39;]&#39;){
            index++;
        }
        ret += s.substr(start, index - start);
        while (index &lt; end) {
            if(!isDigit(s[index])){
                int j = index;
                while(j &lt; end &amp;&amp; !isDigit(s[j])) j++;
                ret += s.substr(index, j - index);
                index = j;
            }
            else{
                int leftBracket = getInt(index);
                int repeat = stoi(s.substr(index, leftBracket - index));
                int rightBracket = findRightBracket(leftBracket);
                string s = decodeStringImpl(leftBracket + 1, rightBracket);
                for (int i = 0; i &lt; repeat; i++) {
                    ret += s;
                }
                index = rightBracket + 1;
            }
        }
        return ret;
    }

    int findRightBracket(int index) {
        vector&lt;int&gt; st;
        st.push_back(index);
        int i = index;
        while (!st.empty() &amp;&amp; i &lt; s.length() - 1) {
            i++;
            if (s[i] == &#39;[&#39;) st.push_back(i);
            else if (s[i] == &#39;]&#39;) st.pop_back();
        }
        return i;
    }

    int getInt(int index) {
        while (index &lt; s.length() &amp;&amp; isDigit(s[index])) {
            index++;
        }
        return index;
    }
    
    bool isDigit(char ch){
        return ch &lt;= &#39;9&#39; &amp;&amp; ch &gt;= &#39;0&#39;;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>712</wp:post_id>
		<wp:post_date><![CDATA[2016-09-05 19:42:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-05 11:42:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-394-decode-string]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 395. Longest Substring with At Least K Repeating Characters</title>
		<link>http://xiadong.info/2016/09/leetcode-395-longest-substring-with-at-least-k-repeating-characters/</link>
		<pubDate>Tue, 06 Sep 2016 12:47:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=714</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Find the length of the longest substring <strong>T</strong> of a given string (consists of lowercase letters only) such that every character in <strong>T</strong> appears no less than <em>k</em> times.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input:
s = &quot;aaabb&quot;, k = 3

Output:
3

The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input:
s = &quot;ababbc&quot;, k = 2

Output:
5

The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times.
</pre>
</blockquote>

第一眼看到这道题我是想用动态规划的, 可是凭我的弱鸡DP功底做不出来. 第二眼我又想用双指针, 可是又觉得有超时的危险(暴力双循环必然超时, 我写的双指针复杂度降低不多). 所以我最后采用了分治+递归的方法.

总体思想如下

<ol><li>
先遍历一遍字符串, 记录每个字符的出现次数, 在这一步中同时记录出现大于等于k次的字母个数, 如果根本就没有大于等于k次的字母, 那么可以直接返回0.</li>
<li>
通过出现次数不足k次的字母来把字符串分割成多个子串, 因为在原字符串中出现次数不足k次的字母必然不会出现在结果串中.</li>
<li>
递归的处理每个子串. 递归结束条件为字符串长度不足k.</li>
</ol>

<pre lang='c++'>
class Solution {
public:
    int longestSubstring(string s, int k) {
        return longestSubstringImpl(s, k, 0, s.length());
    }
    
    int longestSubstringImpl(string &amp;s, int k, int start, int end){
        if(end - start &lt; k) return 0; // 递归结束条件
        vector&lt;int&gt; letters(26, 0);
        int biggerThanK = 0;
        for(int i = start; i &lt; end; i++){ // 记录每个字母出现的次数
            if(++letters[s[i] - &#39;a&#39;] &gt;= k) biggerThanK++;
        }
        if(biggerThanK == 0) return 0; // 没有出现达到k次的字母
        int l = start, r = l, maxLen = 0;
        while(r &lt; end){
            while(r &lt; end &amp;&amp; letters[s[r] - &#39;a&#39;] &gt;= k){ // 跳过出现次数达到k次的字母
                r++;
            }
            if(r == l){ // r == l说明第一个字母就没有到达k次, 所以处理下一个字母
                l++;
                r++;
            }
            else if(r == end &amp;&amp; l == start){
                // 这里比较重要, 如果不单独处理整个字符串都符合
                // 要求的情况的话, 就会出现无穷递归.
                maxLen = max(maxLen, r - l);
            }
            else{
                // 递归处理子串
                maxLen = max(maxLen, longestSubstringImpl(s, k, l, r));
                l = r;
            }
        }
        return maxLen;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>714</wp:post_id>
		<wp:post_date><![CDATA[2016-09-06 20:47:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-06 12:47:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-395-longest-substring-with-at-least-k-repeating-characters]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e6%b2%bb"><![CDATA[分治]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 110. Balanced Binary Tree</title>
		<link>http://xiadong.info/2016/09/leetcode-110-balanced-binary-tree/</link>
		<pubDate>Tue, 06 Sep 2016 12:57:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=716</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.
</blockquote>

题目中二叉树平衡的定义为: 每个节点的左右子树的高度相差都不超过1. 因此可以用递归的方式依次遍历每个节点同时计算每个节点左右子树的高度. 用一个bool变量来保存是否出现了不平衡的节点.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        bool re = true;
        height(root, re);
        return re;
    }
    
    int height(TreeNode *node, bool &amp;re){
        if(node == nullptr) return 0;
        int leftHeight = height(node-&gt;left, re), rightHeight = height(node-&gt;right, re);
        if(abs(leftHeight - rightHeight) &gt; 1) re = false;
        return max(leftHeight, rightHeight) + 1;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>716</wp:post_id>
		<wp:post_date><![CDATA[2016-09-06 20:57:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-06 12:57:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-110-balanced-binary-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 111. Minimum Depth of Binary Tree</title>
		<link>http://xiadong.info/2016/09/leetcode-111-minimum-depth-of-binary-tree/</link>
		<pubDate>Wed, 07 Sep 2016 07:12:22 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=718</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
</blockquote>

DFS/BFS都可以, 但是我觉得大概BFS会快一点, 因为在最坏的情况下DFS需要遍历完所有节点才能知道最短的高度.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        queue&lt;TreeNode*&gt; BFS;
        queue&lt;int&gt; depth;
        BFS.push(root);
        depth.push(1);
        while(!BFS.empty()){
            TreeNode *p = BFS.front();
            int d = depth.front();
            if(!p-&gt;left &amp;&amp; !p-&gt;right){
                return d;
            }
            if(p-&gt;left){
                BFS.push(p-&gt;left);
                depth.push(d + 1);
            }
            if(p-&gt;right){
                BFS.push(p-&gt;right);
                depth.push(d + 1);
            }
            BFS.pop();
            depth.pop();
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>718</wp:post_id>
		<wp:post_date><![CDATA[2016-09-07 15:12:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-07 07:12:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-111-minimum-depth-of-binary-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 112. Path Sum</title>
		<link>http://xiadong.info/2016/09/leetcode-112-path-sum/</link>
		<pubDate>Wed, 07 Sep 2016 07:47:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=721</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
For example:
Given the below binary tree and 
<pre lang='undefined'>
sum = 22
</pre>
,
<pre lang='undefined'>
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</pre>
return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.
</blockquote>

深度优先搜索就可以了.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        return DFS(root, 0, sum);
    }
    
    bool DFS(TreeNode *node, int n, int sum){
        if(!node){
            return false;
        }
        if(!node-&gt;left &amp;&amp; !node-&gt;right){
            if(n + node-&gt;val == sum)
                return true;
            else
                return false;
        }
        if(!node-&gt;left &amp;&amp; node-&gt;right){
            return DFS(node-&gt;right, node-&gt;val + n, sum);
        }
        if(node-&gt;left &amp;&amp; !node-&gt;right){
            return DFS(node-&gt;left, node-&gt;val + n, sum);
        }
        if(node-&gt;left &amp;&amp; node-&gt;right){
            return DFS(node-&gt;left, node-&gt;val + n, sum) || DFS(node-&gt;right, node-&gt;val + n, sum);
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>721</wp:post_id>
		<wp:post_date><![CDATA[2016-09-07 15:47:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-07 07:47:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-112-path-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 113. Path Sum II</title>
		<link>http://xiadong.info/2016/09/leetcode-113-path-sum-ii/</link>
		<pubDate>Wed, 07 Sep 2016 07:58:48 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=723</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given sum.
For example:
Given the below binary tree and 
<pre lang='undefined'>
sum = 22
</pre>
,
<pre lang='undefined'>
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
</pre>
return
<pre lang='undefined'>
[
   [5,4,11,2],
   [5,8,4,5]
]
</pre>
</blockquote>

与<a href='http://xiadong.info/2016/09/leetcode-112-path-sum/'>上一题</a>类似, 只不过在DFS的过程中维护一个路径path, 保存从根节点到当前节点的值, 抵达叶子节点并且path中元素的和与sum相等时就把它加到结果中.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    vector&lt;vector&lt;int&gt;&gt; ret;
public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;int&gt; path;
        DFS(root, 0, sum, path);
        return ret;
    }
    
    void DFS(TreeNode *node, int n, int sum, vector&lt;int&gt; &amp;path){
        if(!node){
            return;
        }
        path.push_back(node-&gt;val);
        if(!node-&gt;left &amp;&amp; !node-&gt;right){
            if(n + node-&gt;val == sum){
                ret.push_back(path);
            }
        }
        else if(!node-&gt;left &amp;&amp; node-&gt;right){
            DFS(node-&gt;right, node-&gt;val + n, sum, path);
        }
        else if(node-&gt;left &amp;&amp; !node-&gt;right){
            DFS(node-&gt;left, node-&gt;val + n, sum, path);
        }
        else{
            DFS(node-&gt;left, node-&gt;val + n, sum, path);
            DFS(node-&gt;right, node-&gt;val + n, sum, path);
        }
        path.pop_back();
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>723</wp:post_id>
		<wp:post_date><![CDATA[2016-09-07 15:58:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-07 07:58:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-113-path-sum-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 114. Flatten Binary Tree to Linked List</title>
		<link>http://xiadong.info/2016/09/leetcode-114-flatten-binary-tree-to-linked-list/</link>
		<pubDate>Thu, 08 Sep 2016 07:53:41 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=725</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, flatten it to a linked list in-place.
For example,
Given
<pre lang='undefined'>
         1
        / \
       2   5
      / \   \
     3   4   6
</pre>
The flattened tree should look like:
<pre lang='undefined'>
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
</pre>
</blockquote>

题目中其实并没有说清楚怎么flatten的, 但是观察给的例子后可以发现是把一个节点的左子树插到右子树之前, 原来的右子树放到左子树的最右端叶子节点的右子树位置.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode *p = root;
        while(p){
            if(p-&gt;left){
                TreeNode *right = p-&gt;right;
                p-&gt;right = p-&gt;left;
                p-&gt;left = nullptr;
                leftNode(p)-&gt;right = right;
            }
            p = p-&gt;right;
        }
    }
    
    TreeNode* leftNode(TreeNode *root){
        if(!root) return nullptr;
        TreeNode *p = root;
        while(p-&gt;right){
            p = p-&gt;right;
        }
        return p;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>725</wp:post_id>
		<wp:post_date><![CDATA[2016-09-08 15:53:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-08 07:53:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-114-flatten-binary-tree-to-linked-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 115. Distinct Subsequences</title>
		<link>http://xiadong.info/2016/09/leetcode-115-distinct-subsequences/</link>
		<pubDate>Thu, 08 Sep 2016 09:56:51 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=727</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>T</strong> in <strong>S</strong>.
A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).
Here is an example:
<strong>S</strong> = <code>&quot;rabbbit&quot;</code>, <strong>T</strong> = <code>&quot;rabbit&quot;</code>
Return <code>3</code>.
</blockquote>

这道题第一反应是动态规划, 使用<code>dp[i][j]</code>表示从<code>s[0]</code>到<code>s[i]</code>(含, 以下用<code>s[0:i]</code>表示)这个字符串中包含多少个<code>t[0:j]</code>字符串. 但是递推公式不太好想, 所以我先把例子中给出的<code>&quot;rabbbit&quot;</code>和<code>&quot;rabbit&quot;</code>的dp数组写出来:

<pre lang='undefined'>
  r a b b i t
r 1 0 0 0 0 0
a 1 1 0 0 0 0
b 1 1 1 0 0 0
b 1 1 2 1 0 0
b 1 1 3 3 0 0
i 1 1 3 3 3 0
t 1 1 3 3 3 3
</pre>

通过观察这个数组我们可以发现, 递推公式可能为:

<pre lang='c++'>
dp[i][j] = (s[i] == t[j]) ? dp[i - 1][j - 1] + dp[i - 1][j] : dp[i - 1][j]
</pre>

那么为什么会是这个公式呢? 首先, 如果<code>s[i]</code>与<code>t[j]</code>不相等, 那么说明没有增加新的子串, 所以<code>s[0:i]</code>中包含的<code>t[0:j]</code>数量与<code>s[0:i-1]</code>相同. 而如果<code>s[i] == t[j]</code>, 那么说明增加了新的子串, 就要在<code>s[0:i-1]</code>中包含<code>t[0:j]</code>的基础上加上<code>s[0:i-1]</code>中包含<code>t[0:j-1]</code>的数量.

<pre lang='c++'>
class Solution {
public:
    int numDistinct(string s, string t) {
        vector&lt;vector&lt;int&gt;&gt; dp(s.length(), vector&lt;int&gt;(t.length(), 0));
        if(s.empty() || t.empty()) return 0;
        if(s[0] == t[0]) dp[0][0] = 1;
        for(int i = 1; i &lt; s.length(); i++){ //初始化第一列
            if(s[i] == t[0]) dp[i][0] = dp[i - 1][0] + 1;
            else dp[i][0] = dp[i - 1][0];
        }
        for(int j = 1; j &lt; t.length(); j++){
            for(int i = j; i &lt; s.length(); i++){ // s的长度一定大于等于t的长度
                if(s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j];
            }
        }
        return dp[s.length() - 1][t.length() - 1];
    }
};
</pre>

以上的代码的运行效率有问题, 大家都知道受到Cache命中的影响, 遍历二维数组时, 按行列比按列行的效率更高, 所以把行列代表的含义交换一下, 得到按行列遍历的数组. 同时进行一些剪枝和dp初始化的优化.

<pre lang='c++'>
class Solution {
public:
    int numDistinct(string s, string t) {
        // s的长度应该大于等于t长度
        if(s.empty() || t.empty() || s.length() &lt; t.length()) return 0;
        int dp[t.length()][s.length()];
        memset(dp, 0, sizeof(dp));
        if(s[0] == t[0]) dp[0][0] = 1;
        // 记录t中是否有s中不存在的元素
        vector&lt;int&gt; chars(128, 0);
        chars[s[0]]++;
        for(int i = 1; i &lt; s.length(); i++){
            if(s[i] == t[0]) dp[0][i] = dp[0][i - 1] + 1;
            else dp[0][i] = dp[0][i - 1];
            chars[s[i]]++;
        }
        for(int i = 0; i &lt; t.length(); i++){
            // 如果t中含有s中不存在的元素则直接返回0
            if(--chars[t[i]] &lt; 0) return 0;
        }
        
        for(int i = 1; i &lt; t.length(); i++){
            for(int j = i; j &lt; s.length(); j++){
                if(s[j] == t[i]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];
                }
                else dp[i][j] = dp[i][j - 1];
            }
        }
        return dp[t.length() - 1][s.length() - 1];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>727</wp:post_id>
		<wp:post_date><![CDATA[2016-09-08 17:56:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-08 09:56:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-115-distinct-subsequences]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 116. Populating Next Right Pointers in Each Node</title>
		<link>http://xiadong.info/2016/09/leetcode-116-populating-next-right-pointers-in-each-node/</link>
		<pubDate>Fri, 09 Sep 2016 07:28:58 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=734</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree
<pre lang='undefined'>
    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
</pre>
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.
Initially, all next pointers are set to <code>NULL</code>.
<strong>Note:</strong>
<ul><li>
You may only use constant extra space.</li>
<li>
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
For example,
Given the following perfect binary tree,
<pre lang='undefined'>
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
</pre>
After calling your function, the tree should look like:
<pre lang='undefined'>
         1 -&gt; NULL
       /  \
      2 -&gt; 3 -&gt; NULL
     / \  / \
    4-&gt;5-&gt;6-&gt;7 -&gt; NULL
</pre>
</blockquote>

给一颗完全二叉树的每一个节点确定它同层中的下一个节点. 规则比较简单:

<ul><li>
如果一个节点是父节点的左孩子, 那么它的next就是父节点的右孩子
</li>
<li>
如果一个节点是父节点的右孩子, 那么分两种情况:
<ul><li>
父节点的next为null, 则该节点的next为null</li>
<li>
父节点的next不为null, 则该节点的next为父节点next节点的左孩子</li>
</ul>
</li>
</ul>

为了知道一个节点的父节点, 在函数参数中要同时把节点的父节点传入.

<pre lang='c++'>
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root, TreeLinkNode *parent = NULL) { // 与题目提供的函数原型略有不同S
        if(root == NULL)return;
        if(parent != NULL){
            if(root == parent-&gt;left){
                root-&gt;next = parent-&gt;right;
            }else if(root == parent-&gt;right){
                if(parent-&gt;next != NULL)root-&gt;next = parent-&gt;next-&gt;left;
                else root-&gt;next = NULL;
            }
        }
        connect(root-&gt;left, root);
        connect(root-&gt;right, root);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>734</wp:post_id>
		<wp:post_date><![CDATA[2016-09-09 15:28:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-09 07:28:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-116-populating-next-right-pointers-in-each-node]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 117. Populating Next Right Pointers in Each Node II</title>
		<link>http://xiadong.info/2016/09/leetcode-117-populating-next-right-pointers-in-each-node-ii/</link>
		<pubDate>Fri, 09 Sep 2016 07:43:17 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=738</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Follow up for problem &quot;<em>Populating Next Right Pointers in Each Node</em>&quot;.
What if the given tree could be any binary tree? Would your previous solution still work?
<strong>Note:</strong>
<ul><li>
You may only use constant extra space.</li>
</ul>
For example,
Given the following binary tree,
<pre lang='undefined'>
         1
       /  \
      2    3
     / \    \
    4   5    7
</pre>
After calling your function, the tree should look like:
<pre lang='undefined'>
         1 -&gt; NULL
       /  \
      2 -&gt; 3 -&gt; NULL
     / \    \
    4-&gt; 5 -&gt; 7 -&gt; NULL
</pre>
</blockquote>

这个问题仍然沿用<a href='http://xiadong.info/2016/09/leetcode-116-populating-next-right-pointers-in-each-node/'>上一题</a>的思路, 先对一个节点是父节点的左节点还是右节点分类. 然后再细分接下来的情况.

<ul><li>
一个节点是父节点的左孩子:
<ul><li>
如果父节点有右孩子, 那么next就是右孩子</li>
<li>
如果父节点没有右孩子并且next为null, 那么该节点的next也为null</li>
<li>
如果父节点next不为null, 那么遍历父节点接下来的每一个next节点, 直到找到一个节点有孩子节点, 这个孩子节点是该节点的next. 如果找不到, 该节点的next节点为null</li>
</ul>
</li>
<li>
一个节点是父节点的右孩子
<ul><li>
父节点的next为null, 则该节点的next为null</li>
<li>
如果父节点next不为null, 那么遍历父节点接下来的每一个next节点, 直到找到一个节点有孩子节点, 这个孩子节点是该节点的next. 如果找不到, 该节点的next节点为null</li>
</ul>
</li>
</ul>

由于对于每一层节点都是从左往右遍历的, 所以每一个父节点的所有后续next节点在处理孩子节点的时候都必须固定下来, 所以要采取从上到下, 从右到左的顺序来遍历二叉树.

<pre lang='c++'>
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root, TreeLinkNode *parent = NULL) {
        if(root == NULL)return;
        if(parent != NULL){
            if(root == parent-&gt;left){
                if(parent-&gt;right) root-&gt;next = parent-&gt;right;
                else if(!parent-&gt;next){
                    root-&gt;next = nullptr;
                }
                else{
                    TreeLinkNode* t = parent-&gt;next;
                    while(t &amp;&amp; !(t-&gt;left || t-&gt;right)) t = t-&gt;next;
                    if(!t) root-&gt;next = nullptr;
                    else root-&gt;next = (t-&gt;left ? t-&gt;left : t-&gt;right);
                }
            }else if(root == parent-&gt;right){
                if(!parent-&gt;next){
                    root-&gt;next = nullptr;
                }
                else{
                    TreeLinkNode* t = parent-&gt;next;
                    while(t &amp;&amp; !(t-&gt;left || t-&gt;right)) t = t-&gt;next;
                    if(!t) root-&gt;next = nullptr;
                    else root-&gt;next = (t-&gt;left ? t-&gt;left : t-&gt;right);
                }
            }
        }
        connect(root-&gt;right, root);
        connect(root-&gt;left, root);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>738</wp:post_id>
		<wp:post_date><![CDATA[2016-09-09 15:43:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-09 07:43:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-117-populating-next-right-pointers-in-each-node-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 118. Pascal&#039;s Triangle</title>
		<link>http://xiadong.info/2016/09/leetcode-118-pascals-triangle/</link>
		<pubDate>Fri, 09 Sep 2016 08:01:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=740</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal&#39;s triangle.
For example, given <em>numRows</em> = 5,
Return
<pre lang='undefined'>
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</pre>
</blockquote>

Pascal三角形就是每一行除了开头和结尾的数是1, 其他数都等于它的左上方与右上方的数之和.

<pre lang='c++'>
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; result(numRows, vector&lt;int&gt;());

        for(int i = 0; i &lt; numRows; i++){
            for(int j = 0; j &lt;= i; j++){
                if(j == 0 || j == i) result[i].push_back(1);
                else{
                    result[i].push_back(result[i - 1][j - 1] + result[i - 1][j]);
                }
            }
        }
        return result;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>740</wp:post_id>
		<wp:post_date><![CDATA[2016-09-09 16:01:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-09 08:01:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-118-pascals-triangle]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 119. Pascal&#039;s Triangle II</title>
		<link>http://xiadong.info/2016/09/leetcode-119-pascals-triangle-ii/</link>
		<pubDate>Fri, 09 Sep 2016 08:33:18 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=742</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an index <em>k</em>, return the <em>k</em>th row of the Pascal&#39;s triangle.
For example, given <em>k</em> = 3,
Return <code>[1,3,3,1]</code>.
<strong>Note:</strong>
Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?
</blockquote>

与<a href='http://xiadong.info/2016/09/leetcode-118-pascals-triangle/'>上一题</a>类似, 只不过现在是要求某一行的结果. 每计算一行只需要上一行的数据, 所以只需要保存一行.

<pre lang='c++'>
class Solution {
public:
    vector&lt;int&gt; getRow(int rowIndex) {
        vector&lt;int&gt; ret = {1};
        vector&lt;int&gt; last = {1};
        for(int i = 1; i &lt;= rowIndex; i++){
            ret.clear();
            ret.push_back(last[0]);
            auto j = last.begin() + 1;
            for(; j != last.end(); j++){
                ret.push_back(*j + *(j - 1));
            }
            ret.push_back(*(j - 1));
            last = ret;
        }
        
        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>742</wp:post_id>
		<wp:post_date><![CDATA[2016-09-09 16:33:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-09 08:33:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-119-pascals-triangle-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 120. Triangle</title>
		<link>http://xiadong.info/2016/09/leetcode-120-triangle/</link>
		<pubDate>Sun, 11 Sep 2016 09:27:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=744</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle
<pre><code>[
   [2],
  [3,4],
 [6,5,7],
[4,1,8,3]
]</code></pre>
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</blockquote>

比较简单的动态规划题, 每次需要的数据就是上一行到达每个位置的最小路径和. 只要比较左上方与右上方的两个和然后选择较小的一个就可以了.

<pre><code lang="c++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
        if(triangle.empty()) return 0;
        vector&lt;int&gt; lastRow, rowSum;
        lastRow = triangle[0];
        for(int i = 1; i &lt; triangle.size(); i++){
            rowSum.resize(triangle[i].size());
            rowSum[0] = lastRow[0] + triangle[i][0];
            for(int j = 1; j &lt; triangle[i].size() - 1; j++){
                rowSum[j] = min(lastRow[j - 1], lastRow[j]) + triangle[i][j];
            }
            rowSum.back() = lastRow.back() + triangle[i].back();
            lastRow = rowSum;
        }
        int ret = INT_MAX;
        for(int i = 0; i &lt; lastRow.size(); i++){
            ret = min(lastRow[i], ret);
        }
        return ret;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>744</wp:post_id>
		<wp:post_date><![CDATA[2016-09-11 17:27:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-11 09:27:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-120-triangle]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 121. Best Time to Buy and Sell Stock</title>
		<link>http://xiadong.info/2016/09/leetcode-121-best-time-to-buy-and-sell-stock/</link>
		<pubDate>Sun, 11 Sep 2016 09:58:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=747</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.
</pre>
</blockquote>

这道题我一开始看错了题意. 它的意思是只允许一次买入卖出操作或者没有操作, 所以只要找到相差最大的两个价格并且低价在高价之前就可以了. 从前往后遍历一次数组, 记录到目前为止的最低价格, 然后再记录一个差额的最大值就可以了. 时间复杂度O(n)

<pre lang='c++'>
class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if(prices.size() &lt; 2) return 0;
        int lowest = prices[0];
        int profit = 0;
        for(int i = 1; i &lt; prices.size(); i++){
            if(lowest &gt; prices[i]){
                lowest = prices[i];
            }
            else{
                profit = max(profit, prices[i] - lowest);
            }
        }
        return profit;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>747</wp:post_id>
		<wp:post_date><![CDATA[2016-09-11 17:58:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-11 09:58:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-121-best-time-to-buy-and-sell-stock]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 122. Best Time to Buy and Sell Stock II</title>
		<link>http://xiadong.info/2016/09/leetcode-122-best-time-to-buy-and-sell-stock-ii/</link>
		<pubDate>Sun, 11 Sep 2016 10:28:56 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=749</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
</blockquote>

这道题与<a href='http://xiadong.info/2016/09/leetcode-121-best-time-to-buy-and-sell-stock/'>上一题</a>相比不同点在于可以多次买入卖出股票但是不能同时持有多份股票, 所以整个的操作流程必须是&quot;买入-卖出-买入-卖出...-买入-卖出&quot;. 考虑一个简单的情况:

<code>1,4,2,10</code>

显然有两种策略, 分别的利润为<code>(4-1)+(10-2)=11</code>和<code>10-1=9</code>, 应选择第一种. 而另一种情况:

<code>1,2,4,10</code>

两种策略的利润为<code>(2-1)+(10-4)=8</code>和<code>10-1=9</code>, 此时应该选择第二种. 对于一般情况来说:

<code>a1,a2,a3...,ap,...,aq,...,an</code>

如果在a1买入ap卖出然后再aq买入an卖出的话, 利润为<code>(an-aq)+(ap-a1)</code>, 如果在a1买入an卖出的话, 利润为<code>an-a1</code>, 两者之差为<code>(an-a1)-[(an-aq)+(ap-a1)]=aq-ap</code>, 所以如果<code>ap&gt;aq</code>, 那么应该选择前者, 反之选择后者. 从编程策略上来说就应该是搜索一个从低价位开始的递增序列, 在不能再保持递增的时候就是应该卖出的时候.

<pre lang='c++'>
class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if(prices.size() &lt; 2) return 0;
        int low = prices[0], profit = 0;
        for(int i = 1; i &lt; prices.size() - 1; i++){
            if(prices[i] &lt; low) low = prices[i];
            else if(prices[i] &gt; prices[i + 1]){
                profit += (prices[i] - low);
                low = prices[i + 1];
            }
        }
        if(prices.back() &gt; low) profit += (prices.back() - low);
        return profit;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>749</wp:post_id>
		<wp:post_date><![CDATA[2016-09-11 18:28:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-11 10:28:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-122-best-time-to-buy-and-sell-stock-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 396. Rotate Function</title>
		<link>http://xiadong.info/2016/09/leetcode-396-rotate-function/</link>
		<pubDate>Mon, 12 Sep 2016 07:49:04 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=751</guid>
		<description></description>
		<content:encoded><![CDATA[问题描述:

<blockquote>Given an array of integers <code>A</code> and let <em>n</em> to be its length.
Assume <code>Bk</code> to be an array obtained by rotating the array <code>A</code> <em>k</em> positions clock-wise, we define a &quot;rotation function&quot; <code>F</code> on <code>A</code> as follow:
<code>F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]</code>.
Calculate the maximum value of <code>F(0), F(1), ..., F(n-1)</code>.
<strong>Note:</strong>
<em>n</em> is guaranteed to be less than 105.
<strong>Example:</strong>
<pre lang='undefined'>
A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
</pre>
</blockquote>

按照题目要求的步骤来计算一个数组的每个元素与下标乘积的和, 然后每次循环右移一位, 找出所有的和中的最大值. 不需要在每次右移后都计算一次数组的和, 只要把上一次得到的结果减去最后一项<code>(n-1) * Bk[n-1]</code>再加上所有元素的和(不乘下标)再减去<code>Bk[n-1]</code>即可.

<pre lang='c++'>
class Solution {
public:
    int maxRotateFunction(vector&lt;int&gt;&amp; A) {
        int sum = 0, stepSum = 0, maxSum = INT_MIN, n = A.size();
        for(int i = 0; i &lt; n; i++){
            sum += A[i];
            stepSum += (i * A[i]);
        }
        maxSum = stepSum;
        for(int i = 1; i &lt; n; i++){
            stepSum = stepSum - A[n - i] * (n - 1) + sum - A[n - i];
            maxSum = max(maxSum, stepSum);
        }
        return maxSum;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>751</wp:post_id>
		<wp:post_date><![CDATA[2016-09-12 15:49:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-12 07:49:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-396-rotate-function]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 397. Integer Replacement</title>
		<link>http://xiadong.info/2016/09/leetcode-397-integer-replacement/</link>
		<pubDate>Mon, 12 Sep 2016 09:40:10 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=754</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a positive integer <em>n</em> and you can do operations as follow:
<ol><li>
If <em>n</em> is even, replace <em>n</em> with <code>n/2</code>.</li>
<li>
If <em>n</em> is odd, you can replace <em>n</em> with either <code>n + 1</code> or <code>n - 1</code>.</li>
</ol>
What is the minimum number of replacements needed for <em>n</em> to become 1?
<strong>Example 1:</strong>
<pre lang='undefined'>
Input:
8

Output:
3

Explanation:
8 -&gt; 4 -&gt; 2 -&gt; 1
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input:
7

Output:
4

Explanation:
7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1
or
7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1
</pre>
</blockquote>

我一开始想用动态规划, 但是这个题的测试数据有INT_MAX这么大, 根本开不了这么大的数组, 所以不行. 说明这道题有一些小窍门. 仔细想想, n为偶数是直接除以2没有什么问题, 问题在于奇数时有两种情况, <code>(n+1)/2</code>与<code>(n-1)/2</code>恰好是相邻的两个数, 一个奇数一个偶数, 对于其中的偶数还是直接除以2, 但是奇数就要多一步加1或减1, 所以在选择加1还是减1时应该选择的是除以2后还是偶数的那一个. 

这道题因为数据是指数下降的, 所以最多迭代几十次, 递归与循环的性能差距不大, 用递归更好理解一点. 

当n等于INT_MAX时, 再加1会导致溢出, 所以下次递归选择次数相同的INT_MAX-1.

还有一个问题在于n等于3时的情况, <code>(n+1)</code>与<code>(n-1)/2</code>分别是4和2, 按照先前的规则应该选择4, 但实际上应该选择2, 我对于这种情况单独处理.

<pre lang='c++'>
class Solution {
public:
    int integerReplacement(int n) {
        if(n == 1) return 0;
        else if(n == 2) return 1;
        else if(n == 4 || n == 3) return 2;
        else if(n % 2 == 0) return integerReplacement(n / 2) + 1;
        else if(n == INT_MAX) return integerReplacement(n - 1);
        else{
            return integerReplacement(((n - 1) / 2) % 2 ? (n + 1) : (n - 1)) + 1;
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>754</wp:post_id>
		<wp:post_date><![CDATA[2016-09-12 17:40:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-12 09:40:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-397-integer-replacement]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 398. Random Pick Index</title>
		<link>http://xiadong.info/2016/09/leetcode-398-random-pick-index/</link>
		<pubDate>Wed, 14 Sep 2016 07:36:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=757</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.
<strong>Note:</strong>
The array size can be very large. Solution that uses too much extra space will not pass the judge.
<strong>Example:</strong>
<pre lang='undefined'>
int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(3);

// pick(1) should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(1);
</pre>
</blockquote>

这道题的内存要求相当严, 对我来说比较容易想到的方法都超内存了. 最后还是看tag才知道要用一种叫作<em>reservoir sampling 水塘抽样</em>(<a href='https://en.wikipedia.org/wiki/Reservoir_sampling' target='_blank' >https://en.wikipedia.org/wiki/Reservoir_sampling</a>)的算法来做.

这个算法可以用于从n个数据(n很大且未知)中随机抽取k个样本, 具体思路如下(下标从0开始):

<ol><li>
首先取取数组a前k个元素放入结果r中</li>
<li>
对于第i个元素(n&gt;i&gt;=k), 取一个随机数j(0&lt;=j&lt;i), 如果j&lt;k, 那么就把r[j]换成a[i].</li>
</ol>

至于等概率的具体证明可以看wiki. 具体到这道题, 就是k=1的情况, 我们只需要在r中保存一个元素, 并且同时记录已经遍历到第几个target即可..

<pre lang='c++'>
class Solution {
    vector&lt;int&gt; n;
public:
    Solution(vector&lt;int&gt; nums) {
        n = nums;
        srand((unsigned int)time(NULL));
    }
    
    int pick(int target) {
        int retIndex, totalTarget = 1;
        for(int i = 0; i &lt; n.size(); i++){
            if(n[i] != target) continue;
            if(totalTarget == 1){
                retIndex = i;
            }
            else{
                if(rand() % totalTarget == 0){
                    retIndex = i;
                }
            }
            totalTarget++;
        }
        return retIndex;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int param_1 = obj.pick(target);
 */
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>757</wp:post_id>
		<wp:post_date><![CDATA[2016-09-14 15:36:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-14 07:36:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-398-random-pick-index]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%9a%8f%e6%9c%ba%e6%95%b0"><![CDATA[随机数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 399. Evaluate Division</title>
		<link>http://xiadong.info/2016/09/leetcode-399-evaluate-division/</link>
		<pubDate>Wed, 14 Sep 2016 10:35:37 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=759</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.
<strong>Example:</strong>
Given <code>a / b = 2.0, b / c = 3.0.</code> 
queries are: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .</code> 
return <code>[6.0, 0.5, -1.0, 1.0, -1.0 ].</code>
The input is: 
<code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries</code>
, where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code>vector</code>.
According to the example above:
<pre lang='undefined'>
equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],
values = [2.0, 3.0],
queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ]. 
</pre>
The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.
</blockquote>

这道题一看起来没啥思路, 但是看到tags里的Graph就一下子豁然开朗了. 其实每一个除法就是定义了有向图的一条边(实际上是来回两条)以及这条边的权值. 这样一来每一个查询就是判断给定的两个节点是否连通, 并且计算出路径上每条边的权值的乘积.

首先构建邻接矩阵或邻接表, 然后对每个查询使用DFS或者BFS来搜索是否有两点之间的通路, 并且计算乘积.

在计算过程中, 如果两个点是间接相连的, 实际上我们就可以直接在两点之间增加一条边, 权值为连接通路的权值乘积. 这样的话在剩下的查询中BFS中就可能更快地抵达目标节点.

<pre lang='c++'>
class Solution {
    // 由于对于string的比较等操作很费时, 所以用一个map把string与int对应起来.
    unordered_map&lt;string, int&gt; nodes; 
public:
    vector&lt;double&gt; calcEquation(vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries) {
        for(int i = 0; i &lt; equations.size(); i++){
            // 给每一个string分配一个下标
            // 注意这里有个隐藏bug, 假如map/unordered_map对象m中不包含a, 
            // 那么在使用m[a]时实际上是已经创建一个a的key和对应的value, 导致size加1
            // 所以如果我们想让第n个加入的元素的value为n-1的话, 
            // 需要赋值m.size() - 1而不是m.size()
            if(!nodes.count(equations[i].first)){
                nodes[equations[i].first] = nodes.size() - 1;
            }
            if(!nodes.count(equations[i].second)){
                nodes[equations[i].second] = nodes.size() - 1;
            }
        }
        vector&lt;vector&lt;double&gt;&gt; g(nodes.size(), vector&lt;double&gt;(nodes.size(), -1.0));
        for(int i = 0; i &lt; equations.size(); i++){
            // 构建邻接矩阵
            g[getNode(equations[i].first)][getNode(equations[i].second)] = values[i];
            g[getNode(equations[i].second)][getNode(equations[i].first)] = 1 / values[i];
        }
        vector&lt;double&gt; ret(queries.size());
        for(int i = 0; i &lt; queries.size(); i++){
            string a = queries[i].first, b = queries[i].second;
            if(!nodes.count(a) || !nodes.count(b)){
                // 如果出现了不存在的节点
                ret[i] = -1.0;
            }
            else{
                // 使用BFS来搜索路径
                ret[i] = BFS(g, getNode(a), getNode(b));
            }
        }
        return ret;
    }
    
    int getNode(string s){
        return nodes[s];
    }
    
    double BFS(vector&lt;vector&lt;double&gt;&gt; &amp;g, int a, int b){
        // 如果是同一个节点就直接返回
        if(a == b) return 1.0;
        int n = g.size();
        vector&lt;int&gt; visited(n, 0); // 用于保存是否访问过节点
        queue&lt;int&gt; q; // BFS队列, 保存节点下标
        queue&lt;double&gt; v; // 用于保存从a到BFS队列中相应的节点的路径乘积
        q.push(a);
        visited[a] = 1;
        v.push(1.0);
        while(!q.empty()){
            int node = q.front();
            double value = v.front();
            for(int i = 0; i &lt; n; i++){
                if(visited[i] || g[node][i] == -1.0) continue; // 节点i已经访问过或者没有边到达i
                visited[i] = 1;
                q.push(i);
                double len = value * g[node][i]; // 从a到i的路径权值乘积
                // 添加新的边
                g[a][i] = len;
                g[i][a] = 1 / len;
                if(i == b){ // 抵达b点
                    return len;
                }
                v.push(len);
            }
            q.pop();
            v.pop();
        }
        return -1.0;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>759</wp:post_id>
		<wp:post_date><![CDATA[2016-09-14 18:35:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-14 10:35:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-399-evaluate-division]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 123. Best Time to Buy and Sell Stock III</title>
		<link>http://xiadong.info/2016/09/leetcode-123-best-time-to-buy-and-sell-stock-iii/</link>
		<pubDate>Thu, 15 Sep 2016 10:34:31 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=762</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.
Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.
<strong>Note:</strong>
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
</blockquote>

这道题可以用一种我也不知道算不算动态规划的方法来解. 首先我们可以进行零次, 一次或者两次买入卖出操作, 零次或一次是之前的题目, 比较容易解决. 问题在于两次交易, 由于不能同时持有多个stock, 所以两次交易必须是前后发生的, 那么就可以用两个数组来分别记录[0,i]中获得能获得的最大收益和[i+1, n]中能获得的最大收益, 通过遍历i就可以得到前后两次交易的最大收益.

第一个数组通过遍历一次prices得到, 而第二个数组通过反向遍历一次prices得到.

<pre lang='c++'>
class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int n = prices.size();
        if(n &lt; 2) return 0;
        vector&lt;int&gt; profit1(n, 0), profit2(n, 0);
        int lowest = prices[0];
        for(int i = 1; i &lt; n; i++){
            lowest = min(lowest, prices[i]);
            profit1[i] = max(profit1[i - 1], prices[i] - lowest);
        }

        int highest = prices.back();
        for(int i = n - 2; i &gt;= 0; i--){
            highest = max(highest, prices[i]);
            profit2[i] = max(profit2[i + 1], highest - prices[i]);
        }

        int maxProfit = profit1.back();
        for(int i = 0; i &lt; n - 1; i++){
            maxProfit = max(maxProfit, profit1[i] + profit2[i + 1]);
        }
        return maxProfit;
    }
};
</pre>

而最后两个循环可以合并为一个.

<pre lang='c++'>
class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int n = prices.size();
        if(n &lt; 2) return 0;
        vector&lt;int&gt; profit1(n, 0), profit2(n, 0);
        int lowest = prices[0];
        for(int i = 1; i &lt; n; i++){
            lowest = min(lowest, prices[i]);
            profit1[i] = max(profit1[i - 1], prices[i] - lowest);
        }

        int highest = prices.back(), maxProfit = profit1.back();
        for(int i = n - 2; i &gt;= 0; i--){
            highest = max(highest, prices[i]);
            profit2[i] = max(profit2[i + 1], highest - prices[i]);
            maxProfit = max(maxProfit, profit1[i] + profit2[i + 1]);
        }
        return maxProfit;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>762</wp:post_id>
		<wp:post_date><![CDATA[2016-09-15 18:34:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-15 10:34:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-123-best-time-to-buy-and-sell-stock-iii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 124. Binary Tree Maximum Path Sum</title>
		<link>http://xiadong.info/2016/09/leetcode-124-binary-tree-maximum-path-sum/</link>
		<pubDate>Sat, 17 Sep 2016 08:04:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=764</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.

For example:
Given the below binary tree,
<pre lang="undefined">       1
      / \
     2   3
</pre>
Return <code>6</code>.</blockquote>

这道题我一开始是先用DFS来搜索出所有节点到根节点的路径, 然后再用双重循环来计算出每对节点的路径和. 如果有n个节点的话, 这个方法的时间复杂度是O(n<sup>2</sup>), 所以超时了.

后来发现了递归的方法. 对于一个二叉树的根节点来说, 这棵树中的最长路径和要么经过它, 要么经过它的后代, 所以我们就可以算出经过根节点的最长路径和是多少, 然后对每一个节点都计算一遍就可以找出最长的路径和.

在递归过程中, 除了维护一个最终的最长路径和以外, 我们还要知道每个节点的左右子树到该节点的最长路径和(注意, 这里的路径必须有一端是该节点)才能找出经过该节点的最长路径和.

同时还要注意路径和与0的大小关系, 如果到某节点的路径和小于0, 那么就不应该把这部分路径包含进去.

<pre lang="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int maxPath = INT_MIN;
public:
    int maxPathSum(TreeNode* root) {
        DFS(root);
        return maxPath;
    }
    
    int DFS(TreeNode *root){
        if(!root) return 0;
        int leftPath = DFS(root-&gt;left), rightPath = DFS(root-&gt;right);
        // 经过root节点的路径的四种情况, 选择最大的.
        maxPath = max(maxPath, (leftPath + rightPath + root-&gt;val));
        maxPath = max(maxPath, root-&gt;val);
        maxPath = max(maxPath, root-&gt;val + leftPath);
        maxPath = max(maxPath, root-&gt;val + rightPath);
        // 如果左右子树都小于0, 那么应该只返回root节点的值
        return root-&gt;val + max(0, max(leftPath, rightPath));
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>764</wp:post_id>
		<wp:post_date><![CDATA[2016-09-17 16:04:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-17 08:04:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-124-binary-tree-maximum-path-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 125. Valid Palindrome</title>
		<link>http://xiadong.info/2016/09/leetcode-125-valid-palindrome/</link>
		<pubDate>Sat, 17 Sep 2016 08:19:27 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=766</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
For example,
<code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.
<code>&quot;race a car&quot;</code> is <em>not</em> a palindrome.
<strong>Note:</strong>
Have you consider that the string might be empty? This is a good question to ask during an interview.
For the purpose of this problem, we define empty string as valid palindrome.
</blockquote>

双指针从两端向中间遍历即可.

<pre lang='c++'>
class Solution {
public:
    bool isPalindrome(string s) {
        int i = 0, j = s.length() - 1;
        while(i &lt; j){
            if(!isValid(s[i])){
                i++;
            }
            else if(!isValid(s[j])){
                j--;
            }
            else{
                if(s[i] &gt;= &#39;A&#39; &amp;&amp; s[i] &lt;= &#39;Z&#39;) s[i] -= (&#39;A&#39; - &#39;a&#39;);
                if(s[j] &gt;= &#39;A&#39; &amp;&amp; s[j] &lt;= &#39;Z&#39;) s[j] -= (&#39;A&#39; - &#39;a&#39;);
                if(s[i] != s[j]) return false;
                i++;
                j--;
            }
        }
        return true;
    }
    
    bool isValid(char ch){
        return (ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>766</wp:post_id>
		<wp:post_date><![CDATA[2016-09-17 16:19:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-17 08:19:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-125-valid-palindrome]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 400. Nth Digit</title>
		<link>http://xiadong.info/2016/09/leetcode-400-nth-digit/</link>
		<pubDate>Sun, 18 Sep 2016 08:25:54 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=768</guid>
		<description></description>
		<content:encoded><![CDATA[

题目描述:

<blockquote>Find the <em>n</em>th digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...
<strong>Note:</strong>
<em>n</em> is positive and will fit within the range of a 32-bit signed integer (<em>n</em> &lt; 231).
<strong>Example 1:</strong>
<pre lang='undefined'>
Input:
3

Output:
3
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input:
11

Output:
0

Explanation:
The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
</pre>
</blockquote>

LeetCode现在每周的比赛都要出四道新题, 像我这种一边做老题一边追新题还要上课(自己选的统计学习, 跪着也要上完)的人来说还真是有点觉得追不上.

这道题算是比较简单, 就是算出1位数有多少个阿拉伯数字, 2位数有多少阿拉伯数字, 3位数有多少个阿拉伯数字......n位数有9×10^(n-1)×n个阿拉伯数字, 然后对于输入的n, 我们就可以通过前面得到的数据确定它有多少位, 进而确定是哪个数, 最终确定要找的数字.

1位数到n位数共有多少个数字可以先计算出来写在程序中, 

<pre lang='c++'>
int main () {
    long long sum = 0;
    for(int i = 0;; i++){
        long long t = 9 * (long long)pow(10, i) * (i + 1);
        if(t &gt; INT_MAX) break;
        sum += t;
        cout&lt;&lt;i&lt;&lt;&#39;:&#39;&lt;&lt;t&lt;&lt;&quot; sum:&quot;&lt;&lt;sum&lt;&lt;endl;
    }
    return 0;
}
</pre>

输出:

<pre lang='undefined'>
0:9 sum:9
1:180 sum:189
2:2700 sum:2889
3:36000 sum:38889
4:450000 sum:488889
5:5400000 sum:5888889
6:63000000 sum:68888889
7:720000000 sum:788888889
</pre>

这个结果还是挺有规律的. 接下来就是解题的代码:

<pre lang='c++'>
class Solution {
    int arr[9] = {0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889};
public:
    int findNthDigit(int n) {
        int index;
        for(index = 0; index &lt; 9 &amp;&amp; arr[index] &lt; n; index++); // 确定位数
        int t = (n - arr[index - 1] - 1);
        int num = (t / index) + (int)pow(10, index - 1); // 确定数
        int p = index - (t % index) - 1; // 确定第几位
        for(int i = 0; i &lt; p; i++){ // 找出该位
            num /= 10;
        }
        return num % 10; // 个位为我们要找的数
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>768</wp:post_id>
		<wp:post_date><![CDATA[2016-09-18 16:25:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-18 08:25:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-400-nth-digit]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 401. Binary Watch</title>
		<link>http://xiadong.info/2016/09/leetcode-401-binary-watch/</link>
		<pubDate>Sun, 18 Sep 2016 09:21:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=770</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).
Each LED represents a zero or one, with the least significant bit on the right.
<img src='https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg' alt='' />
For example, the above binary watch reads &quot;3:25&quot;.
Given a non-negative integer <em>n</em> which represents the number of LEDs that are currently on, return all possible times the watch could represent.
<strong>Example:</strong>
<pre lang='undefined'>
Input: n = 1
Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]
</pre>
<strong>Note:</strong>
<ul><li>
The order of output does not matter.</li>
<li>
The hour must not contain a leading zero, for example &quot;01:00&quot; is not valid, it should be &quot;1:00&quot;.</li>
<li>
The minute must be consist of two digits and may contain a leading zero, for example &quot;10:2&quot; is not valid, it should be &quot;10:02&quot;.</li>
</ul>
</blockquote>

由于数据量相当的小, 所以这道题最简单粗暴的方法就是把每种小时和分钟的可能都列出来, 正常一点的思路就是从n个数中选择k个不同的数出来, 对于这道题来说还要加上一个对于是否是合法地时间数据的判断.

我对于小时采用写出所有可能的办法, 对于分钟采用正常的方法. 至于为啥分钟不写, 大概是因为手算有点烦= =.

这道题我还遇到了[无符号数-有符号数=无符号数]的坑, 就是第64行的<code>i &lt;= v.size() - n</code>, 在n&gt;6的情况下是会溢出的. 所以要么把n移到不等式的左边, 要么在第8行就规避n&gt;6的情况.

<pre lang='c++'>
class Solution {
    vector&lt;int&gt; hourNum = {1,2,4,8};
    vector&lt;int&gt; minuteNum = {1,2,4,8,16,32};
    vector&lt;string&gt; hours, minutes;
public:
    vector&lt;string&gt; readBinaryWatch(int num) {
        vector&lt;string&gt; ans;
        for(int i = num - 6; i &lt;= num; i++){
            possibleHour(i);
            possibleMinute(num - i);
            for(auto i : hours){
                for(auto j : minutes){
                    ans.push_back(i + &quot;:&quot; + j);
                }
            }
        }
        return ans;
    }
    
    void possibleHour(int n){
        hours.clear();
        switch(n){
            case 0:
                hours = vector&lt;string&gt;({&quot;0&quot;});
                return;
            case 1:
                hours = vector&lt;string&gt;({&quot;1&quot;, &quot;2&quot;, &quot;4&quot;, &quot;8&quot;});
                return;
            case 2:
                hours = vector&lt;string&gt;({&quot;3&quot;, &quot;5&quot;, &quot;9&quot;, &quot;6&quot;, &quot;10&quot;});
                return;
            case 3:
                hours = vector&lt;string&gt;({&quot;7&quot;, &quot;11&quot;});
                return;
            default:
                hours = vector&lt;string&gt;();
                return;
        }
    }
    
    void possibleMinute(int n){
        minutes.clear();
        if(n == 0){
            minutes.push_back(&quot;00&quot;);
            return;
        }
        vector&lt;vector&lt;int&gt;&gt; ret;
        vector&lt;int&gt; path;
        selectNFromVector(minuteNum, 0, n, path, ret);
        for(int i = 0; i &lt; ret.size(); i++){
            int sum = 0;
            for(int j = 0; j &lt; n; j++){
                sum += ret[i][j];
            }
            if(sum &lt; 60){
                string str = to_string(sum);
                if(sum &lt; 10) str.insert(str.begin(), &#39;0&#39;);
                minutes.push_back(str);
            }
        }
    }
    
    void selectNFromVector(vector&lt;int&gt; &amp;v, int start, int n, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;ret){
        for(int i = start; i &lt;= v.size() - n; i++){
            path.push_back(v[i]);
            if(n == 1){
                ret.push_back(path);
                path.pop_back();
                continue;
            }
            selectNFromVector(v, i + 1, n - 1, path, ret);
            path.pop_back();
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>770</wp:post_id>
		<wp:post_date><![CDATA[2016-09-18 17:21:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-18 09:21:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-401-binary-watch]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88"><![CDATA[排列组合]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 402. Remove K Digits</title>
		<link>http://xiadong.info/2016/09/leetcode-402-remove-k-digits/</link>
		<pubDate>Mon, 19 Sep 2016 09:02:06 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=772</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a non-negative integer <em>num</em> represented as a string, remove <em>k</em> digits from the number so that the new number is the smallest possible.
<strong>Note:</strong>
<ul><li>
The length of <em>num</em> is less than 10002 and will be ≥ <em>k</em>.</li>
<li>
The given <em>num</em> does not contain any leading zero.</li>
</ul>
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: num = &quot;1432219&quot;, k = 3
Output: &quot;1219&quot;
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: num = &quot;10200&quot;, k = 1
Output: &quot;200&quot;
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
</pre>
<strong>Example 3:</strong>
<pre lang='undefined'>
Input: num = &quot;10&quot;, k = 2
Output: &quot;0&quot;
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
</pre>
</blockquote>

这道题的主要思想就是&quot;如果遇到了一个较小的值, 那么就把已得到的字符串中尾部所有比它大的值删除, 再把它放入末尾; 如果比末尾元素大, 那么就把它直接添加到末尾&quot;. 这是一个栈的问题, 但是除了主要的思路以外还有另一个问题: 最终栈的大小必须是<code>num.size()-k</code>, 所以在添加和删除时必须要考虑栈的大小.

在元素比栈顶元素大的情况下还要增加一个条件: 栈的大小还没有达到<code>num.size()-k</code>.

而元素比栈顶元素小的情况下, 在弹出栈顶元素时要求num中剩下的元素数量&gt;=栈的目标大小-栈目前的大小, 这样才能保证栈能被填满.

<pre lang='c++'>
class Solution {
public:
    string removeKdigits(string num, int k) {
        string ans;
        int target = num.size() - k, size = num.size(), i;
        if(target == 0) return &quot;0&quot;;
        ans.push_back(num[0]);
        for(i = 1; i &lt; k + ans.size(); i++){
            if(num[i] &gt; ans.back() &amp;&amp; ans.size() &lt; target) ans.push_back(num[i]);
            else{
                while(!ans.empty() &amp;&amp; ans.back() &gt; num[i] &amp;&amp; size - i - 1 &gt;= target - ans.size()) ans.pop_back();
                if(ans.size() &lt; target) ans.push_back(num[i]);
            }
        }
        for(; ans.size() &lt; target; i++){
            ans.push_back(num[i]);
        }
        for(i = 0; ans[i] == &#39;0&#39;; i++);
        if(ans.empty() || i == ans.size()) return &quot;0&quot;;
        return ans.substr(i);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>772</wp:post_id>
		<wp:post_date><![CDATA[2016-09-19 17:02:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-19 09:02:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-402-remove-k-digits]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 403. Frog Jump</title>
		<link>http://xiadong.info/2016/09/leetcode-403-frog-jump/</link>
		<pubDate>Mon, 19 Sep 2016 10:13:02 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=774</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.

Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.

If the frog's last jump was <em>k</em> units, then its next jump must be either <em>k</em> - 1, <em>k</em>, or <em>k</em> + 1 units. Note that the frog can only jump in the forward direction.

<strong>Note:</strong>
<ul>
    <li>The number of stones is ≥ 2 and is &lt; 1,100.</li>
    <li>Each stone's position will be a non-negative integer &lt; 231.</li>
    <li>The first stone's position is always 0.</li>
</ul>
<strong>Example 1:</strong>
<pre lang="undefined">[0,1,3,5,6,8,12,17]

There are a total of 8 stones.
The first stone at the 0th unit, second stone at the 1st unit,
third stone at the 3rd unit, and so on...
The last stone at the 17th unit.

Return true. The frog can jump to the last stone by jumping 
1 unit to the 2nd stone, then 2 units to the 3rd stone, then 
2 units to the 4th stone, then 3 units to the 6th stone, 
4 units to the 7th stone, and 5 units to the 8th stone.
</pre>
<strong>Example 2:</strong>
<pre lang="undefined">[0,1,2,3,4,8,9,11]

Return false. There is no way to jump to the last stone as 
the gap between the 5th and 6th stone is too large.
</pre>
</blockquote>

虽然tag里说这是个DP题, 但是我觉得更像个图论题. 每个stone是一个node, 根据能否到达来判断有没有边相连, 最终要判断第一个节点与最后一个节点是否连通.

那么既然是这样, 就有DFS和BFS两派了. 用BFS的话要记录抵达每个node的上一跳可能有多远, 同时要记录一个node有没有访问过, 所以比较复杂.

<pre lang="c++">class Solution {
public:
    bool canCross(vector&lt;int&gt;&amp; stones) {
        int n = stones.size();
        unordered_map&lt;int, unordered_set&lt;int&gt;&gt; dp;
        unordered_map&lt;int, int&gt; visited;
        for(int i = 0; i &lt; n; i++){
            dp[stones[i]] = unordered_set&lt;int&gt;();
            visited[stones[i]] = 0;
        }
        if(!dp.count(1)) return false;
        if(stones.size() == 2) return true;
        dp[1] = unordered_set&lt;int&gt;({1});
        visited[0] = visited[1] = 1;
        queue&lt;int&gt; BFS;
        BFS.push(1);
        while(!BFS.empty()){
            int stn = BFS.front();
            unordered_set&lt;int&gt; &amp;v = dp[stn];
            for(auto i : v){
                for(int j = i - 1; j &lt;= i + 1; j++){
                    if(j == 0) continue;
                    if(dp.count(stn + j)){
                        if(!visited[stn + j]) {
                            visited[stn + j] = 1;
                            BFS.push(stn + j);
                        }
                        if(stn + j == stones.back() &amp;&amp; visited[stn + j]) return true;
                        dp[stn + j].insert(j);
                    }
                }
            }
            
            BFS.pop();
        }
        return false;
    }
};
</pre>

这个解法的Runtime有近500ms. DFS就不用保存维护这些数据. 在目前的测试数据上DFS只需要6ms.

<pre lang="c++">class Solution {
public:
    bool canCross(vector&lt;int&gt;&amp; stones) {
        return canCrossImpl(stones, 0, 0);
    }
    
    bool canCrossImpl(vector&lt;int&gt;&amp; stones, int index, int lastStep){
        for(int i = index + 1; i &lt; stones.size(); i++){
            if(stones[i] - stones[index] &lt; lastStep - 1) continue;
            if(stones[i] - stones[index] &gt; lastStep + 1) return false;
            if(canCrossImpl(stones, i, stones[i] - stones[index])) return true;
        }
        return index == stones.size() - 1;
    }
};
</pre>

<strong>Update: LeetCode已经更新了测试数据</strong>, 所以像上面那样单纯的DFS已经会超时了, 要使用一些DP的方法. 用一个二维数组来保存第i个节点的前一步为s步时能否到达. 因为步数s和节点编号i都未知且可能很大, 所以用unordered_map来实现二维数组.

<pre lang="c++">class Solution {
    unordered_map&lt;int, unordered_map&lt;int, bool&gt;&gt; m;
public:
    bool canCross(vector&lt;int&gt;&amp; stones) {
        return canCrossImpl(stones, 0, 0);
    }
    
    bool canCrossImpl(vector&lt;int&gt;&amp; stones, int index, int lastStep){
        if(m.count(index) &amp;&amp; m[index].count(lastStep)){
            return m[index][lastStep];
        }
        for(int i = index + 1; i &lt; stones.size(); i++){
            if(stones[i] - stones[index] &lt; lastStep - 1) continue;
            if(stones[i] - stones[index] &gt; lastStep + 1) {
                m[index][lastStep] = false;
                return false;
            }
            if(canCrossImpl(stones, i, stones[i] - stones[index])) {
                return true;
            }
        }
        return index == stones.size() - 1;
    }
};
</pre>

由于节点最多有1099个, 在步长每次都+1的情况下步数是一个从1开始的公差为1的等差数列, 所以虽然stone的编号是&lt;2<sup>31</sup>的, 但是大于0+1+2+...+1099=604450的stone是肯定抵达不了的. 而604450占20个二进制位, 一个32位数剩下的12位正好可以存储步数, 所以上面的二维数组可以变为一维.

<pre lang="c++">class Solution {
    unordered_map&lt;int, bool&gt; m;
public:
    bool canCross(vector&lt;int&gt;&amp; stones) {
        return canCrossImpl(stones, 0, 0);
    }
    
    bool canCrossImpl(vector&lt;int&gt;&amp; stones, int index, int lastStep){
        if(index &gt; 604450) return false;
        int mi = index &lt;&lt; 12 | lastStep;
        if(m.count(mi)){
            return m[mi];
        }
        for(int i = index + 1; i &lt; stones.size(); i++){
            if(stones[i] - stones[index] &lt; lastStep - 1) continue;
            if(stones[i] - stones[index] &gt; lastStep + 1) {
                m[mi] = false;
                return false;
            }
            if(canCrossImpl(stones, i, stones[i] - stones[index])) {
                return true;
            }
        }
        return index == stones.size() - 1;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>774</wp:post_id>
		<wp:post_date><![CDATA[2016-09-19 18:13:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-19 10:13:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-403-frog-jump]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>22</wp:comment_id>
			<wp:comment_author><![CDATA[Ken]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[savic475@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.81]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-22 00:46:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-21 16:46:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[dfs我写成c++,leetcode过不了大数据啊Time Limit Exceeded

<pre><code>
class Solution {
public:
    bool helper(int position, int speed, vector &amp;stones) {
        int size = stones.size();

        for (int i = position + 1; i &lt; size; i++) {
            int requiredSpeed = stones[i] - stones[position];

            if (requiredSpeed &lt; speed - 1) continue;
            if (requiredSpeed &gt; speed + 1) return false;
            if (helper(i, requiredSpeed, stones)) return true;
        }

        return position == size - 1;
    }


    bool canCross(vector&lt;int&gt; &amp;stones) {
        return helper(0, 0, stones);
    }
};
</code></pre>]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1474476370.66275;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1474498932.7242041;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>23</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.33]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-22 07:53:47]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-21 23:53:47]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[看样子LeetCode更新了数据.....]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>22</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1474502027.5169749;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>24</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.33]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-09-22 08:45:24]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-09-22 00:45:24]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[代码已经更新]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>22</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1474505124.225353;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>LeetCode 127. Word Ladder</title>
		<link>http://xiadong.info/2016/09/leetcode-127-word-ladder/</link>
		<pubDate>Tue, 20 Sep 2016 10:00:13 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=776</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary&#39;s word list, find the length of shortest transformation sequence from<em>beginWord</em> to <em>endWord</em>, such that:
<ol><li>
Only one letter can be changed at a time</li>
<li>
Each intermediate word must exist in the word list</li>
</ol>
For example,
Given:
<em>beginWord</em> = <code>&quot;hit&quot;</code>
<em>endWord</em> = <code>&quot;cog&quot;</code>
<em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code>
As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,
return its length <code>5</code>.
<strong>Note:</strong>
<ul><li>
Return 0 if there is no such transformation sequence.</li>
<li>
All words have the same length.</li>
<li>
All words contain only lowercase alphabetic characters.</li>
</ul>
</blockquote>

使用广度优先搜索, 判断是否连接是通过穷举一个单词的所有可能变化来完成的.

<pre lang='c++'>
class Solution {
public:
    int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList) {
        queue&lt;string&gt; BFS;
        queue&lt;int&gt; length;
        BFS.push(beginWord);
        length.push(1);
        int maxLen = INT_MIN;
        while (!BFS.empty()) {
            string &amp;c = BFS.front();
            int l = length.front();
            if (maxLen &lt; l) maxLen = l;

            if(c == endWord) return maxLen;
            for(int i = 0; i &lt; c.length(); i++){
                string tmp = c;
                for(char j = &#39;a&#39;; j &lt;= &#39;z&#39;; j++){
                    tmp[i] = j;
                    if(wordList.count(tmp)){
                        BFS.push(tmp);
                        length.push(l + 1);
                        wordList.erase(tmp);
                    }
                }
            }
            BFS.pop();
            length.pop();
        }
        return 0;
    }

};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>776</wp:post_id>
		<wp:post_date><![CDATA[2016-09-20 18:00:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-20 10:00:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-127-word-ladder]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 126. Word Ladder II</title>
		<link>http://xiadong.info/2016/09/leetcode-126-word-ladder-ii/</link>
		<pubDate>Tue, 20 Sep 2016 10:16:38 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=778</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary&#39;s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to<em>endWord</em>, such that:
<ol><li>
Only one letter can be changed at a time</li>
<li>
Each intermediate word must exist in the word list</li>
</ol>
For example,
Given:
<em>beginWord</em> = <code>&quot;hit&quot;</code>
<em>endWord</em> = <code>&quot;cog&quot;</code>
<em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code>
Return
<pre lang='undefined'>
  [
    [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],
    [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
  ]
</pre>
<strong>Note:</strong>
<ul><li>
All words have the same length.</li>
<li>
All words contain only lowercase alphabetic characters.</li>
</ul>
</blockquote>

这道题使用BFS的问题在于BFS无法保存路径, 所以可以用对于路径的BFS, 也就是在队列中保存的是路径而不是节点. 这样的代码虽然可以AC, 但是非常慢.....

<pre lang='c++'>
class Solution {
    vector&lt;vector&lt;string&gt;&gt; ans;
public:
    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, unordered_set&lt;string&gt; &amp;wordList) {
        queue&lt;vector&lt;string&gt;&gt; BFS;
        BFS.push(vector&lt;string&gt;({ beginWord }));
        vector&lt;string&gt; visited;
        int curLevel = 1;

        while (!BFS.empty()) {
            vector&lt;string&gt; lastPath = BFS.front();
            if (lastPath.size() &gt; curLevel) { // 每一层遍历过的节点必须在进入下一层时才能删除
                for (auto i : visited) {
                    wordList.erase(i);
                }
                visited.clear();
                curLevel = lastPath.size();
            }

            if (!ans.empty() &amp;&amp; lastPath.size() &gt; ans[0].size()) break;

            if (lastPath.back() == endWord) {
                ans.push_back(lastPath);
            }
            else {
                string &amp;c = lastPath.back();
                for (int i = 0; i &lt; c.length(); i++) {
                    string tmp = c;
                    for (char j = &#39;a&#39;; j &lt;= &#39;z&#39;; j++) {
                        tmp[i] = j;
                        if (tmp == c) continue;
                        if (tmp == endWord || wordList.count(tmp)) {
                            vector&lt;string&gt; newPath = lastPath;
                            newPath.push_back(tmp);
                            BFS.push(newPath);
                            visited.push_back(tmp);
                        }                       
                    }
                }
            }
            BFS.pop();
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>778</wp:post_id>
		<wp:post_date><![CDATA[2016-09-20 18:16:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-20 10:16:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-126-word-ladder-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 128. Longest Consecutive Sequence</title>
		<link>http://xiadong.info/2016/09/leetcode-128-longest-consecutive-sequence/</link>
		<pubDate>Thu, 22 Sep 2016 09:02:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=786</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
For example,
Given <code>[100, 4, 200, 1, 3, 2]</code>,
The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.
Your algorithm should run in O(<em>n</em>) complexity.
</blockquote>

从一个无序的数组中找出最长的连续数字序列. 每读入一个数字, 就要判断能否加入到一个已经存在的区间中去, 而如何在常数时间内判断能否加入到某个区间中就是主要的问题. 我的方法是使用两个map, key的值分别为区间的开始和结束, 这样就可以在常数时间内确定能否加入到已经存在的区间的开头或结尾. 当一个值既能插入到某个区间的开头, 也能插入到某个区间的结尾时, 这两个区间就可以合并. 但是这个解法的效率并不是很高.

<pre lang='c++'>
class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return 0;
        int maxLen = 1;
        unordered_map&lt;int, int&gt; SE, ES; //SE = start&lt;-&gt;end, ES = end&lt;-&gt;start
        unordered_set&lt;int&gt; included; // 保存区间中已经包含的数
        for(int i = 0; i &lt; nums.size(); i++){
            if(included.count(nums[i])) continue;
            bool SEext = SE.count(nums[i] + 1), ESext = ES.count(nums[i] - 1);
            if(SEext &amp;&amp; ESext){
                int newStart = ES[nums[i] - 1], newEnd = SE[nums[i] + 1];
                SE.erase(nums[i] + 1);
                ES.erase(nums[i] - 1);
                SE[newStart] = newEnd;
                ES[newEnd] = newStart;
                maxLen = max(maxLen, newEnd - newStart + 1);
            }
            else if(SEext){
                SE[nums[i]] = SE[nums[i] + 1];
                SE.erase(nums[i] + 1);
                ES[SE[nums[i]]] = nums[i];
                maxLen = max(maxLen, SE[nums[i]] - nums[i] + 1);
            }
            else if(ESext){
                ES[nums[i]] = ES[nums[i] - 1];
                ES.erase(nums[i] - 1);
                SE[ES[nums[i]]] = nums[i];
                maxLen = max(maxLen, nums[i] - ES[nums[i]] + 1);
            }
            else{
                SE[nums[i]] = nums[i];
                ES[nums[i]] = nums[i];
            }
            included.insert(nums[i]);
        }
        
        return maxLen;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>786</wp:post_id>
		<wp:post_date><![CDATA[2016-09-22 17:02:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-22 09:02:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-128-longest-consecutive-sequence]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 129. Sum Root to Leaf Numbers</title>
		<link>http://xiadong.info/2016/09/leetcode-129-sum-root-to-leaf-numbers/</link>
		<pubDate>Thu, 22 Sep 2016 09:09:44 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=788</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.
An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.
Find the total sum of all root-to-leaf numbers.
For example,
<pre lang='undefined'>
    1
   / \
  2   3
</pre>
The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.
The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.
Return the sum = 12 + 13 = <code>25</code>.
</blockquote>

简单的DFS获取所有从根节点到叶子节点的路径的问题.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        if(!root) return 0;
        vector&lt;int&gt; sums;
        string path;
        getPath(root, path, sums);
        int sum = 0;
        for(int i = 0; i &lt; sums.size(); i++){
            sum += sums[i];
        }
        return sum;
    }
    
    void getPath(TreeNode* root, string &amp;path, vector&lt;int&gt; &amp;sums){
        if(!root-&gt;left &amp;&amp; !root-&gt;right){
            path.push_back(root-&gt;val + &#39;0&#39;);
            sums.push_back(stoi(path));
            path.pop_back();
            return;
        }
        path.push_back(root-&gt;val + &#39;0&#39;);
        if(root-&gt;left){
            getPath(root-&gt;left, path, sums);
        }
        if(root-&gt;right){
            getPath(root-&gt;right, path, sums);
        }
        path.pop_back();
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>788</wp:post_id>
		<wp:post_date><![CDATA[2016-09-22 17:09:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-22 09:09:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-129-sum-root-to-leaf-numbers]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 130. Surrounded Regions</title>
		<link>http://xiadong.info/2016/09/leetcode-130-surrounded-regions/</link>
		<pubDate>Fri, 23 Sep 2016 08:18:48 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=790</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (the <strong>letter</strong> O), capture all regions surrounded by <code>&#39;X&#39;</code>.
A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.
For example,
<pre lang='undefined'>
X X X X
X O O X
X X O X
X O X X
</pre>
After running your function, the board should be:
<pre lang='undefined'>
X X X X
X X X X
X X X X
X O X X
</pre>
</blockquote>

这道题可以使用并查集或者BFS的方法. 基本思想都是把没有接触边缘的元素归为一类, 然后设置为X. 我使用BFS的方法, 由于查找所有没有接触边缘的区块要遍历整个二维数组, 而查找与边缘有接触的区块只要遍历四条边, 所以我选择找出与边缘有接触的O组成的区块, 把它们使用另一种符号标记(比如T), 然后再遍历整个数组, 把O变为X, T变为O即可得到最终的结果.

<pre lang='c++'>
class Solution {
    int row, col;
public:
    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        if(board.empty() || board[0].empty()) return;
        row = board.size();
        col = board[0].size();
        for(int i = 0; i &lt; col; i++){
            if(board[0][i] == &#39;O&#39;) BFS(board, 0, i);
        }
        for(int i = 1; i &lt; row - 1; i++){
            if(board[i][0] == &#39;O&#39;) BFS(board, i, 0);
            if(board[i][col - 1] == &#39;O&#39;) BFS(board, i, col - 1);
        }
        for(int i = 0; i &lt; col; i++){
            if(board[row - 1][i] == &#39;O&#39;) BFS(board, row - 1, i);
        }
        
        for(int i = 0; i &lt; row; i++){
            for(int j = 0; j &lt; col; j++){
                if(board[i][j] == &#39;O&#39;) board[i][j] = &#39;X&#39;;
                else if(board[i][j] == &#39;T&#39;) board[i][j] = &#39;O&#39;;
            }
        }
    }
    
    void BFS(vector&lt;vector&lt;char&gt;&gt; &amp;b, int x, int y){
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push(pair&lt;int, int&gt;(x, y));
        b[x][y] = &#39;T&#39;;
        while(!q.empty()){
            int cx = q.front().first, cy = q.front().second;
            if(cx &gt; 0 &amp;&amp; b[cx - 1][cy] == &#39;O&#39;){
                b[cx - 1][cy] = &#39;T&#39;;
                q.push(pair&lt;int, int&gt;(cx - 1, cy));
            }
            if(cy &gt; 0 &amp;&amp; b[cx][cy - 1] == &#39;O&#39;){
                b[cx][cy - 1] = &#39;T&#39;;
                q.push(pair&lt;int, int&gt;(cx, cy - 1));
            }
            if(cx &lt; row - 1 &amp;&amp; b[cx + 1][cy] == &#39;O&#39;){
                b[cx + 1][cy] = &#39;T&#39;;
                q.push(pair&lt;int, int&gt;(cx + 1, cy));
            }
            if(cy &lt; col - 1 &amp;&amp; b[cx][cy + 1] == &#39;O&#39;){
                b[cx][cy + 1] = &#39;T&#39;;
                q.push(pair&lt;int, int&gt;(cx, cy + 1));
            }
            q.pop();
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>790</wp:post_id>
		<wp:post_date><![CDATA[2016-09-23 16:18:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-23 08:18:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-130-surrounded-regions]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 131. Palindrome Partitioning</title>
		<link>http://xiadong.info/2016/09/leetcode-131-palindrome-partitioning/</link>
		<pubDate>Fri, 23 Sep 2016 08:54:44 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=792</guid>
		<description></description>
		<content:encoded><![CDATA[问题描述:

<blockquote>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.
Return all possible palindrome partitioning of <em>s</em>.
For example, given <em>s</em> = <code>&quot;aab&quot;</code>,
Return
<pre lang='undefined'>
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
</pre>
</blockquote>

使用回溯法遍历每一种可能的情况.

<pre lang='c++'>
class Solution {
    vector&lt;vector&lt;string&gt;&gt; ans;
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        vector&lt;string&gt; path;
        partitionImpl(s, 0, s.size(), path);
        return ans;
    }
    
    void partitionImpl(string &amp;s, int start, int end, vector&lt;string&gt; &amp;path){
        if(end &lt;= start){
            return;
        }
        if(isPalindrome(s, start, end)){
            path.push_back(s.substr(start, end - start));
            ans.push_back(path);
            path.pop_back();
        }
        for(int i = start + 1; i &lt;= end; i++){
            if(!isPalindrome(s, start, i)) continue;
            path.push_back(s.substr(start, i - start));
            partitionImpl(s, i, end, path);
            path.pop_back();
        }
    }
    
    bool isPalindrome(string &amp;s, int start, int end){
        if(end - start &lt;= 1) return true;
        for(int i = 0; i &lt; (end - start) / 2; i++){
            if(s[start + i] != s[end - i - 1]) return false;
        }
        return true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>792</wp:post_id>
		<wp:post_date><![CDATA[2016-09-23 16:54:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-23 08:54:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-131-palindrome-partitioning]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%ba%af"><![CDATA[回溯]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 132. Palindrome Partitioning II</title>
		<link>http://xiadong.info/2016/09/leetcode-132-palindrome-partitioning-ii/</link>
		<pubDate>Sat, 24 Sep 2016 12:07:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=795</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.
For example, given <em>s</em> = <code>&quot;aab&quot;</code>,
Return <code>1</code> since the palindrome partitioning <code>[&quot;aa&quot;,&quot;b&quot;]</code> could be produced using 1 cut.
</blockquote>

这道题可以用两次DP来解, 第一个二维数组<code>palindrome[i][j]</code>表示s从i到j的子串是不是回文串, 第二个数组<code>dp[i]</code>保存从0到i的子串有几种分割方法. 对于<code>dp[i]</code>来说, 它有几种分割方法取决于以<code>s[i]</code>为结尾的回文串有多少个. 由于使用普通的遍历比较方法来判断所有的回文串是一个三重循环, 而用DP+从中间向两边比较的方法可以用双重循环解决. 所以总的复杂度是O(n<sup>2</sup>).

<pre lang='c++'>
class Solution {
public:
    int minCut(string s) {
        int len = s.length();
        vector&lt;int&gt; dp(len + 1);
        vector&lt;vector&lt;int&gt;&gt; palindrome(len, vector&lt;int&gt;(len, 0));
        for(int i = 0; i &lt; len - 1; i++){
            palindrome[i][i] = 1;
            if(s[i] == s[i + 1]) palindrome[i][i + 1] = 1;
        }
        palindrome[len - 1][len - 1] = 1;
        for(int l = 2; l &lt; len; l++){
            for(int i = 0; i + l &lt; len; i++){
                if(s[i] == s[i + l]) palindrome[i][i + l] = palindrome[i + 1][i + l - 1];
            }
        }
      
        dp[0] = dp[1] = 0;
        for(int i = 2; i &lt;= len; i++){
            if(palindrome[0][i - 1]) dp[i] = 0;
            else{
                int minCut = INT_MAX;
                for(int j = i - 1; j &gt; 0 &amp;&amp; minCut &gt; 1; j--){
                    if(palindrome[j][i - 1]){
                        minCut = min(minCut, dp[j] + 1);
                    }
                }
                dp[i] = minCut;
            }
        }
        return dp[len];
    }
};
</pre>

其实可以把第二个循环的内容也放到第一个循环中去. 为了按行列的顺序来访问数组, 我把<code>palindrome[i][j]</code>的含义改为从j到i的字串是否为回文串.

<pre lang='c++'>
class Solution {
public:
    int minCut(string s) {
        int len = s.length();
        if(len &lt; 2) return 0;
        vector&lt;int&gt; dp(len);
        vector&lt;vector&lt;int&gt;&gt; palindrome(len, vector&lt;int&gt;(len, 0));
        for(int i = 0; i &lt; len - 1; i++){
            palindrome[i][i] = 1;
            if(s[i] == s[i + 1]) palindrome[i + 1][i] = 1;
        }
        palindrome[len - 1][len - 1] = 1;
        dp[0] = 0;
        dp[1] = palindrome[1][0] ? 0 : 1;
        for(int i = 2; i &lt; len; i++){
            int minCut = dp[i - 1] + 1;
            if(palindrome[i][i - 1]){
                minCut = min(dp[i - 2] + 1, minCut);
            }
            for(int j = i - 2; j &gt;= 0; j--){
                if(s[j] == s[i]) palindrome[i][j] = palindrome[i - 1][j + 1];
                if(j &gt; 0 &amp;&amp; palindrome[i][j]){
                    minCut = min(minCut, dp[j - 1] + 1);
                }
            }
            dp[i] = palindrome[i][0] ? 0 : minCut;
        }
        return dp[len - 1];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>795</wp:post_id>
		<wp:post_date><![CDATA[2016-09-24 20:07:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-24 12:07:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-132-palindrome-partitioning-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 133. Clone Graph</title>
		<link>http://xiadong.info/2016/09/leetcode-133-clone-graph/</link>
		<pubDate>Sun, 25 Sep 2016 08:17:56 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=797</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.
<strong>OJ&#39;s undirected graph serialization:</strong>Nodes are labeled uniquely.We use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.First node is labeled as <code>0</code>. Connect node <code>0</code> to both nodes <code>1</code> and <code>2</code>.Second node is labeled as <code>1</code>. Connect node <code>1</code> to node <code>2</code>.Third node is labeled as <code>2</code>. Connect node <code>2</code> to node <code>2</code> (itself), thus forming a self-cycle.Visually, the graph looks like the following:
<pre lang='undefined'>
       1
      / \
     /   \
    0 --- 2
         / \
         \_/
</pre>
</blockquote>

使用DFS或者BFS来进行复制就可以了. 有一个要注意的问题就是在新的图中, 连接到已经遍历过的节点的边也要连接到新的图中的节点, 所以不仅要记录原图中节点有没有访问过, 也要记录对应的新的图中的节点. 由于输入数据中节点是用编号来区分的, 因此我用一个map来把节点编号与节点指针对应起来记录访问过的节点, 这样就可以同时记录新的图的节点与原图访问过的节点了(原图用节点编号, 新的图用节点指针).

<pre lang='c++'>
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector&lt;UndirectedGraphNode *&gt; neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
class Solution {
public:
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        if(!node) return node;
        UndirectedGraphNode *re = new UndirectedGraphNode(node-&gt;label);
        queue&lt;UndirectedGraphNode*&gt; BFS, reBFS;
        unordered_map&lt;int, UndirectedGraphNode*&gt; visited;
        BFS.push(node);
        reBFS.push(re);
        visited[re-&gt;label] = re;
        while(!BFS.empty()){
            UndirectedGraphNode *p = BFS.front(), *r = reBFS.front();
            for(int i = 0; i &lt; p-&gt;neighbors.size(); i++){
                UndirectedGraphNode *next = p-&gt;neighbors[i];
                if(visited.count(next-&gt;label)){
                    r-&gt;neighbors.push_back(visited[next-&gt;label]);
                    continue;
                }
                else{
                    UndirectedGraphNode *reNext = new UndirectedGraphNode(next-&gt;label);
                    r-&gt;neighbors.push_back(reNext);
                    BFS.push(next);
                    reBFS.push(reNext);
                    visited[reNext-&gt;label] = reNext;
                }
            }
            BFS.pop();
            reBFS.pop();
        }
        return re;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>797</wp:post_id>
		<wp:post_date><![CDATA[2016-09-25 16:17:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-25 08:17:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-133-clone-graph]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 134. Gas Station</title>
		<link>http://xiadong.info/2016/09/leetcode-134-gas-station/</link>
		<pubDate>Sun, 25 Sep 2016 08:40:18 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=800</guid>
		<description></description>
		<content:encoded><![CDATA[ 题目描述:

<blockquote>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.
You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.
Return the starting gas station&#39;s index if you can travel around the circuit once, otherwise return -1.
<strong>Note:</strong>
The solution is guaranteed to be unique.
</blockquote>

环路上分布着n个加油站, 输入数据是每个加油站可以加多少油和到下一个加油站耗费多少油, 要求找出能不能走完这个环. 

首先要证明一个情况: 如果从a点出发无法抵达c点(c之前的一点可以到达), 那么从a到c之间的任何一点b出发都是无法到达c点的. 这是因为从a出发到b的时候最坏的情况是正好没有油, 所以从b点继续的时候油是&gt;=在b点加的油的, 而如果一开始就从b出发, 油就等于在b加的油, 是不可能比从a出发开的远的.

因此可以在O(n)的时间复杂度内解决. 从第一个点开始, 搜索能到达的最远的点, 如果不能走完一圈, 那么这之间的点就不用再试了, 可以直接从最远点的下一个点开始尝试.

<pre lang='c++'>
class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        int newStart, i = 0;
        while(true){
            if(impl(gas, cost, i, newStart)){
                return i;
            }
            else if(newStart &gt;= gas.size()){
                break;
            }
            else{
                i = newStart;
            }
        }
        return -1;
    }
    
    bool impl(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost, int start, int &amp;newStart){
        int carGas = 0;
        for(int i = start; i &lt; start + gas.size(); i++){
            int index = i % gas.size();
            carGas += gas[index];
            carGas -= cost[index];
            if(carGas &lt; 0) {
                newStart = i + 1;
                return false;
            }
        }
        return true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>800</wp:post_id>
		<wp:post_date><![CDATA[2016-09-25 16:40:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-25 08:40:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-134-gas-station]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 404. Sum of Left Leaves</title>
		<link>http://xiadong.info/2016/09/leetcode-404-sum-of-left-leaves/</link>
		<pubDate>Mon, 26 Sep 2016 08:00:42 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=802</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Find the sum of all left leaves in a given binary tree.
<strong>Example:</strong>
<pre lang='undefined'>
    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
</pre>
</blockquote>

用DFS找出所有左叶子节点再求和即可.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int sum;
public:
    int sumOfLeftLeaves(TreeNode* root) {
        sum = 0;
        DFS(root, false);
        return sum;
    }
    
    void DFS(TreeNode *node, bool left){
        if(!node) return;
        if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; left){
            sum += node-&gt;val;
            return;
        }
        DFS(node-&gt;left, true);
        DFS(node-&gt;right, false);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>802</wp:post_id>
		<wp:post_date><![CDATA[2016-09-26 16:00:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-26 08:00:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-404-sum-of-left-leaves]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 405. Convert a Number to Hexadecimal</title>
		<link>http://xiadong.info/2016/09/leetcode-405-convert-a-number-to-hexadecimal/</link>
		<pubDate>Mon, 26 Sep 2016 08:27:54 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=804</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href='https://en.wikipedia.org/wiki/Two%27s_complement'>two’s complement</a> method is used.
<strong>Note:</strong>
<ol><li>
All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li>
<li>
The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>&#39;0&#39;</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li>
<li>
The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>
You <strong>must not use any method provided by the library</strong> which converts/formats the number to hex directly.</li>
</ol>
<strong>Example 1:</strong>
<pre lang='undefined'>
Input:
26

Output:
&quot;1a&quot;
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input:
-1

Output:
&quot;ffffffff&quot;
</pre>
</blockquote>

由于传入的数据是int型, 所以其实负数就已经是用补码来表示了. 因此只要每次取四位二进制位出来然后把它们转换为16进制即可.

<pre lang='c++'>
class Solution {
public:
    string toHex(int num) {
        int n = num;
        string hex;
        for(int i = 0; i &lt; 8; i++){
            hex.push_back(toCharHex(n &amp; 0xf));
            n &gt;&gt;= 4;
        }
        while(hex.size() &gt; 1 &amp;&amp; hex.back() == &#39;0&#39;) hex.pop_back();
        reverse(hex.begin(), hex.end());
        return hex;
    }
    
    char toCharHex(int num){
        if(num &lt; 10){
            return num + &#39;0&#39;;
        }
        else{
            return num - 10 + &#39;a&#39;;
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>804</wp:post_id>
		<wp:post_date><![CDATA[2016-09-26 16:27:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-26 08:27:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-405-convert-a-number-to-hexadecimal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 406. Queue Reconstruction by Height</title>
		<link>http://xiadong.info/2016/09/leetcode-406-queue-reconstruction-by-height/</link>
		<pubDate>Mon, 26 Sep 2016 09:11:40 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=806</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers <code>(h, k)</code>, where <code>h</code> is the height of the person and <code>k</code> is the number of people in front of this person who have a height greater than or equal to <code>h</code>. Write an algorithm to reconstruct the queue.
<strong>Note:</strong>
The number of people is less than 1,100.
<strong>Example</strong>
<pre lang='undefined'>
Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
</pre>
</blockquote>

输入数据中的k表示这个人之前有几个大于等于自己的h的人. 比较容易想到对于h最小的人来说, 他的k值就是他在最终队列中的位置, 因为排在他前面的所有人都是大于等于他的h的. 如果去掉h最小的人, 此时h次小的人就成为了最小的, 他在队列中的位置就是从开头数起, 跳过已经确定位置的h更小的人的第k个位置. 这样不断重复就可以确定最终的序列.

但是<em>从开头数起, 跳过已经确定位置的h更小的人的第k个位置</em>是需要遍历数组的, 效率不高, 所以我用一个deque来保存还没有被占用的位置, 当一个位置确定之后就从其中删除, 这样对于之后的人来说, 用k作为索引从deque中取得的位置就是最终的位置. 但是这会造成一个问题, 就是h相同的人如果排在前面的已经确定了位置, 那么排在后面的人会由于已经删除一个位置而偏后一位, 解决方法是排序的时候就把h相同的人中k较大的排在前面.

<pre lang='c++'>
class Solution {
public:
    vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) {
        sort(people.begin(), people.end(), [&amp;](pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b){
            if(a.first == b.first){
                return a.second &gt; b.second;
            }
            return a.first &lt; b.first;
        });
        int sz = people.size();
        vector&lt;pair&lt;int, int&gt;&gt; ans(sz);
        deque&lt;int&gt; indexes(sz);
        for(int i = 0; i &lt; sz; i++) indexes[i] = i;
        for(int i = 0; i &lt; sz; i++){
            int index = people[i].second;
            ans[indexes[index]] = people[i];
            indexes.erase(indexes.begin() + index);
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>806</wp:post_id>
		<wp:post_date><![CDATA[2016-09-26 17:11:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-26 09:11:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-406-queue-reconstruction-by-height]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 135. Candy</title>
		<link>http://xiadong.info/2016/09/leetcode-135-candy/</link>
		<pubDate>Wed, 28 Sep 2016 08:00:19 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=808</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>There are <em>N</em> children standing in a line. Each child is assigned a rating value.
You are giving candies to these children subjected to the following requirements:
<ul><li>
Each child must have at least one candy.</li>
<li>
Children with a higher rating get more candies than their neighbors.</li>
</ul>
What is the minimum candies you must give?
</blockquote>

分糖果的问题, 有两条规则:

<ul><li>
每个孩子必须至少有一个糖果.</li>
<li>
如果rating比相邻的孩子高, 那么也必须有更多的糖果. 也就是说<strong>相等的rating是没有要求的, 跟小于一样</strong>.</li>
</ul>

我所采用的思路是类似双指针的方法:

<ol><li>
扫描一遍ratings, 找到所有<strong>小于等于相邻元素的元素</strong>的rating, 这些rating是可以直接设为1的.</li>
<li>
在上一步的到的数组中每两个相邻的rating中间找到rating的最大值</li>
<li>
比较这个最大值与相邻的两个最小rating的距离, 使用等差数列来算出所需要的总rating值.</li>
</ol>

对于最后一步为什么可以使用等差数列, 因为对于两个candy值为1的孩子中间的孩子, 按照索引顺序的话他们各自的candy值是先增后减的趋势, 为了保证总得candy最小每次增加或减少1是唯一方法, 是两个等差数列. 但是由于最大rating的孩子与两边candy为1的孩子的距离不同, 这两个数列也不同. 比如对于以下的ratings

<code>[6,8,9,10,2,1]</code>

对应的最小candy值应为:

<code>[1,2,3,4,2,1]</code>

左边数列是一个从左边的candy为1的孩子到rating最大的孩子共4个, 而右边则是到2就结束了. 把输入数据颠倒一下:

<code>[1,2,10,9,8,6]</code>

对应的结果应为:

<code>[1,2,4,3,2,1]</code>

数列的形式也颠倒了, 所以要根据rating最大的孩子到左右两边的距离来分别求和.

还有一些其他问题:

<ol><li>
关于最左边与最右边的值, 因为他们只有一边有邻居, 所以不能像中间的节点一样计算. 我的方法是在前后各插入一个INT_MIN, 这样就可以把两端节点当作中间节点来处理了. 最后再从结果中减去.</li>
<li>
rating的最大值有多个. 这种情况只有一种可能, 就是两个连续的最大rating值(从我的方法来说, 其他情况都是不可能的), 由于相等的两个值没有大小要求, 因此也应该分别计算.</li>
</ol>

<pre lang='c++'>
class Solution {
public:
    int candy(vector&lt;int&gt;&amp; ratings) {
        int n = ratings.size();
        if(n &lt; 2) return 1;
        
        vector&lt;int&gt; oneIndex;
        oneIndex.push_back(-1);
        if(ratings[0] &lt;= ratings[1]) oneIndex.push_back(0);
        for(int i = 1; i &lt; n - 1; i++){
            if(ratings[i] &lt;= ratings[i - 1] &amp;&amp; ratings[i] &lt;= ratings[i + 1]) 
                oneIndex.push_back(i);
        }
        if(ratings[n - 1] &lt;= ratings[n - 2]) oneIndex.push_back(n - 1);
        
        oneIndex.push_back(n);
        
        int ans = oneIndex.size() - 2, i = 0;
        while(i &lt; oneIndex.size()){
            while(i &lt; oneIndex.size() - 1 &amp;&amp; oneIndex[i + 1] == oneIndex[i] + 1) i++; // 跳过连续的相等值
            if(i == oneIndex.size() - 1) break;
            int left = oneIndex[i], right = oneIndex[i + 1];
            int maxRating = INT_MIN, maxIndex;
            for(int j = left + 1; j &lt; right; j++){ // 找出最大rating值
                if(ratings[j] &gt;= maxRating){
                    maxRating = ratings[j];
                    maxIndex = j;
                }
            }
            if((ratings[maxIndex - 1] == ratings[maxIndex] &amp;&amp; maxIndex - 1 != left)){
                // 有两个最大rating值
                ans += (2 + maxIndex - left) * (maxIndex - left - 1) / 2;
                ans += (right - maxIndex) * (3 + right - maxIndex) / 2;
            }
            else if(right - maxIndex &lt; maxIndex - left){
                // 距左边较远
                ans += (3 + maxIndex - left) * (maxIndex - left) / 2;
                ans += (right - maxIndex - 1) * (2 + right - maxIndex) / 2;
            }
            else{ // 距右边较远
                ans += (2 + maxIndex - left) * (maxIndex - left - 1) / 2;
                ans += (right - maxIndex) * (3 + right - maxIndex) / 2;
            }
            i++;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>808</wp:post_id>
		<wp:post_date><![CDATA[2016-09-28 16:00:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-28 08:00:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-135-candy]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[135-candy]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 136. Single Number</title>
		<link>http://xiadong.info/2016/09/leetcode-136-single-number/</link>
		<pubDate>Wed, 28 Sep 2016 08:06:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=811</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.
<strong>Note:</strong>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
</blockquote>

使用异或.

<pre lang='c++'>
class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int ans = 0;
        for(auto i : nums){
            ans ^= i;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>811</wp:post_id>
		<wp:post_date><![CDATA[2016-09-28 16:06:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-28 08:06:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-136-single-number]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 407. Trapping Rain Water II</title>
		<link>http://xiadong.info/2016/09/leetcode-407-trapping-rain-water-ii/</link>
		<pubDate>Wed, 28 Sep 2016 11:04:27 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=813</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.
<strong>Note:</strong>
Both <em>m</em> and <em>n</em> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.
<strong>Example:</strong>
<pre lang='undefined'>
Given the following 3x6 height map:
[
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
]

Return 4.
</pre>
<img src='https://leetcode.com/static/images/problemset/rainwater_empty.png' alt='img' />
The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.
<img src='https://leetcode.com/static/images/problemset/rainwater_fill.png' alt='img' />
After the rain, water are trapped between the blocks. The total volume of water trapped is 4.
</blockquote>

这道题对于时间复杂度要求比较高, 轻易就会超时. 我的解法Runtime也不是很短, 有100多ms, 所以权当参考吧.

首先简单的对三维空间进行BFS是绝对超时, 因为最多有110*110*20000个坐标. 我一开始是使用分层进行BFS的办法, 确定每一层中不能装水的位置有多少. 之所以是搜索哪些不能装水而不是哪些能装水是因为搜索与边缘连通的位置只要从四条边开始搜索, 而搜索不与边缘连通的位置要从每个非边缘位置搜索, 数量要多得多.

有两种坐标是不能装水的:

<ol><li>
与边缘连通的</li>
<li>
该位置的高度比层数高的</li>
</ol>

拿总的面积减去不能装水的面积就是有水的面积, 把每一层的面积加起来就是最终的装水的体积. 但是这个办法是超时了, 我总结的超时原因是对每一层都从边缘开始BFS, 实际上并不需要每次都从最初始的情况开始BFS, 而可以在上一层的基础上进行BFS.

当层数为level的时候, 我们要检查的是<code>height==level-1</code>的坐标, 因为<code>height&gt;=level</code>的坐标不能装水, 而<code>height&lt;level-1</code>的坐标在之前的level已经计算过了, 那么对于所有的<code>height==level-1</code>的坐标有两种情况: 能存水和不能存水. 而区分条件是是否与边缘连通, 在知道上一层每个坐标与边缘连通情况(一个二维数组)的时候, 只要判断四周的坐标是否与边缘连通即可(因为已经不能存水的位置随着高度增加永远不能存水), 如果出现了一个<code>height==level-1</code>的坐标与边缘连通的情况, 那么就从这个点开始BFS, 能到达的坐标都是不能存水的.

在这种方法中, 二维平面上的每个点只有一次被BFS遍历到的机会, 大大降低了时间复杂度.

关于二维坐标表示: 二维坐标可以用pair来表示, 但是处理一个对象总没有用int来的快, 这道题由于长宽最大只有110, 所以完全可以把x,y坐标保存在一个int型中, 前16位保存x, 后16位保存y. <code>int xy=x&lt;&lt;16|y</code>, <code>int x = xy&gt;&gt;16, y=xy&amp;0xff</code>.

<pre lang='c++'>
class Solution {
    int m, n, area;
public:
    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) {
        int ans = 0;
        m = heightMap.size();
        if(m == 0) return 0;
        n = heightMap[0].size();
        area = n * m; // 每一层的总面积
        
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; // 保存所有的高度
        unordered_map&lt;int, vector&lt;int&gt;&gt; hm; // 保存每一个高度对应的所有坐标
        for(int i = 0; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                pq.push(heightMap[i][j]);
                hm[heightMap[i][j]].push_back(xy2int(i, j));
            }
        }
        // 以下处理最底层, 生成初始的visited数组
        vector&lt;vector&lt;int&gt;&gt; visited(m, vector&lt;int&gt;(n, 0));
        int edgeArea = 0;
        for(int i = 0; i &lt; n; i++){
            if(!visited[0][i]) edgeArea += BFS(heightMap, 0, i, pq.top() + 1, visited);
            if(!visited[m - 1][i]) edgeArea += BFS(heightMap, m - 1, i, pq.top() + 1, visited);
        }
        for(int i = 0; i &lt; m; i++){
            if(!visited[i][0]) edgeArea += BFS(heightMap, i, 0, pq.top() + 1, visited);
            if(!visited[i][n - 1]) edgeArea += BFS(heightMap, i, n - 1, pq.top() + 1, visited);
        }
        // 以下先得到下一层的高度, 然后用高度差乘本层的装水面积得到两层之间总得装水体积
        // 下面的循环中对每一层都做这样的处理
        int t = pq.top();
        while(!pq.empty() &amp;&amp; pq.top() == t) pq.pop(); 
        if(!pq.empty()){
            int higherArea = pq.size();
            // higherArea表示的是高度比当前层高的格子数
            // edgeArea是与边缘连通的格子数
            // pq.top() - t得到高度差
            ans += (area - higherArea - edgeArea) * (pq.top() - t);
        }
        // 处理上层
        while(!pq.empty()){
            int level = pq.top() + 1;
            vector&lt;int&gt; &amp;h = hm[level - 1];
            for(auto i : h){
                int x = i &gt;&gt; 16, y = i &amp; 0xff;
                if(!visited[x][y] &amp;&amp; (besideEdge(x, y, visited) || onEdge(x, y))){
                    // 没有被标记与边缘连通但是四周有与边缘连通的坐标或者自己就在边上
                    edgeArea += BFS(heightMap, x, y, level, visited);
                }
            }
            
            while(!pq.empty() &amp;&amp; pq.top() == level - 1) pq.pop();
            if(pq.empty()) break;
            int higherArea = pq.size();
            ans += (area - higherArea - edgeArea) * (pq.top() - level + 1);
        }
        
        return ans;
    }
    
    int xy2int(int x, int y){
        return x &lt;&lt; 16 | y;
    }
    
    bool besideEdge(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;visited){
        // 判断四周是否被标记为与边缘连通
        return ((x &gt; 0 &amp;&amp; visited[x - 1][y]) || 
           (x &lt; m - 1 &amp;&amp; visited[x + 1][y]) || 
           (y &gt; 0 &amp;&amp; visited[x][y - 1]) ||
           (y &lt; n - 1 &amp;&amp; visited[x][y + 1]));
    }
    
    int BFS(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap, int i, int j, int k, vector&lt;vector&lt;int&gt;&gt; &amp;visited){
        // 广度优先搜索
        int ans = 0;
        if(heightMap[i][j] &gt;= k) return 0;
        queue&lt;int&gt; q;
        q.push(xy2int(i, j));
        visited[i][j] = 1;
        while(!q.empty()){
            int curi = q.front() &gt;&gt; 16, curj = q.front() &amp; 0xff;
            ans++;
            if(curi &gt; 0 &amp;&amp; !visited[curi - 1][curj] &amp;&amp; heightMap[curi - 1][curj] &lt; k){
                q.push(xy2int(curi - 1, curj));
                visited[curi - 1][curj] = 1;
            }
            if(curi &lt; m - 1 &amp;&amp; !visited[curi + 1][curj] &amp;&amp; heightMap[curi + 1][curj] &lt; k){
                q.push(xy2int(curi + 1, curj));
                visited[curi + 1][curj] = 1;
            }
            if(curj &gt; 0 &amp;&amp; !visited[curi][curj - 1] &amp;&amp; heightMap[curi][curj - 1] &lt; k){
                q.push(xy2int(curi, curj - 1));
                visited[curi][curj - 1] = 1;
            }
            if(curj &lt; n - 1 &amp;&amp; !visited[curi][curj + 1] &amp;&amp; heightMap[curi][curj + 1] &lt; k){
                q.push(xy2int(curi, curj + 1));
                visited[curi][curj + 1] = 1;
            }
            q.pop();
        }
        return ans;
    }
    
    bool onEdge(int i, int j){
        return i == 0 || j == 0 || i == m - 1 || j == n - 1;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>813</wp:post_id>
		<wp:post_date><![CDATA[2016-09-28 19:04:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-28 11:04:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-407-trapping-rain-water-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 137. Single Number II</title>
		<link>http://xiadong.info/2016/09/leetcode-137-single-number-ii/</link>
		<pubDate>Thu, 29 Sep 2016 09:05:33 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=817</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array of integers, every element appears <em>three</em> times except for one. Find that single one.
<strong>Note:</strong>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
</blockquote>

最简单的方法是使用哈希表. 但是要不使用额外空间就要用位运算的方法, 思路是除了要找的元素外, 每个数字都重复了三次, 所以32-bit整数中的每一位出现1的总次数是3的倍数, 找出出现次数不是3的倍数的位, 就是要找的数.

<pre lang='c++'>
class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        return useBit(nums);
    }
    
    int useMap(vector&lt;int&gt; &amp;nums){
        // 使用哈希表的方法
        unordered_map&lt;int, int&gt; m;
        for(int i = 0; i &lt; nums.size(); i++){
            if(++m[nums[i]] == 3) m.erase(nums[i]);
        }
        return m.begin()-&gt;first;
    }
    
    int useBit(vector&lt;int&gt; &amp;nums){
        // 使用位运算的方法
        int re = 0;
        for(int i = 0; i &lt; 32; i++){
            int b = 1 &lt;&lt; i;
            int n = 0;
            for(int i = 0; i &lt; nums.size(); i++){
                if(nums[i] &amp; b) n++;
            }
            if(n % 3) re |= b;
        }
        return re;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>817</wp:post_id>
		<wp:post_date><![CDATA[2016-09-29 17:05:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-29 09:05:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-137-single-number-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 138. Copy List with Random Pointer</title>
		<link>http://xiadong.info/2016/09/leetcode-138-copy-list-with-random-pointer/</link>
		<pubDate>Thu, 29 Sep 2016 09:20:17 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=819</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.
</blockquote>

这是一个单纯的哈希表问题, 不知道为什么归类为hard. 首先遍历一次链表进行拷贝, 同时建立原链表节点到新链表节点的映射关系, 再遍历一次新链表更新random的值即可.

<pre lang='c++'>
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        unordered_map&lt;RandomListNode*, RandomListNode*&gt; m;
        if(!head) return nullptr;
        RandomListNode *p = head, *newHead = new RandomListNode(head-&gt;label), *np = newHead;
        while(p){
            if(p-&gt;next)
                np-&gt;next = new RandomListNode(p-&gt;next-&gt;label);
            np-&gt;random = p-&gt;random;
            m[p] = np;
            p = p-&gt;next;
            np = np-&gt;next;
        }
        
        p = newHead;
        while(p){
            if(p-&gt;random){
                p-&gt;random = m[p-&gt;random];
            }
            p = p-&gt;next;
        }
        
        return newHead;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>819</wp:post_id>
		<wp:post_date><![CDATA[2016-09-29 17:20:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-29 09:20:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-138-copy-list-with-random-pointer]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 139. Word Break</title>
		<link>http://xiadong.info/2016/09/leetcode-139-word-break/</link>
		<pubDate>Thu, 29 Sep 2016 09:49:15 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=822</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string <em>s</em> and a dictionary of words <em>dict</em>, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.
For example, given
<em>s</em> = <code>&quot;leetcode&quot;</code>,
<em>dict</em> = <code>[&quot;leet&quot;, &quot;code&quot;]</code>.
Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.
</blockquote>

使用DP, 从前到后遍历字符串, 记录下可以分割的坐标(也就是从开头到该坐标的子串是可以被分割的). 对于每增加一个字母, 判断每个被记录的坐标到该字母所组成的子串是否在dict中, 如果在, 那么这个坐标也是可以分割的. 最后判断所记录的坐标的最后一个是不是字符串的结尾.

<pre lang='c++'>
class Solution {
public:
    bool wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) {
        vector&lt;int&gt; trueIndex;
        for(int i = 0; i &lt; s.size(); i++){
            for(auto j = trueIndex.rbegin(); j != trueIndex.rend(); j++){
                if(wordDict.count(s.substr(*j + 1, i - *j))){
                    trueIndex.push_back(i);
                    break;
                }
            }
            if((trueIndex.empty() || trueIndex.back() != i) &amp;&amp; wordDict.count(s.substr(0, i + 1))) trueIndex.push_back(i);
        }
        return !trueIndex.empty() &amp;&amp; trueIndex.back() == (s.length() - 1);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>822</wp:post_id>
		<wp:post_date><![CDATA[2016-09-29 17:49:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-09-29 09:49:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-139-word-break]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 140. Word Break II</title>
		<link>http://xiadong.info/2016/10/leetcode-140-word-break-ii/</link>
		<pubDate>Sun, 02 Oct 2016 11:30:54 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=828</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string <em>s</em> and a dictionary of words <em>dict</em>, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word.
Return all such possible sentences.
For example, given
<em>s</em> = <code>&quot;catsanddog&quot;</code>,
<em>dict</em> = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code>.
A solution is <code>[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]</code>.
</blockquote>

这道题是上一题的升级版. 这道题的主要问题在于在特定情况下解空间很大, 呈指数增长但是最后却无法到达字符串结尾, 这种情况下会超时. 所以可以先用类似上一道题的办法来先确定以第i-1个字符为结尾的子串是否能被分割, 保存在dp[i]中. 这一步之后就可以知道有没有解. 然后再通过从后向前DFS的方法搜索每一个解. 之所以不采用从前向后是因为从前向后搜索的话有可能在最后一步无法正好到达结尾, 而从后往前可以保证这一点.

<pre lang='c++'>
class Solution {
    vector&lt;string&gt; ans;
    int sLen, maxWordLen;
public:
    vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) {
        sLen = s.length();
        
        for(auto i : wordDict){
            maxWordLen = max(maxWordLen, (int)i.length());
        }
        
        vector&lt;int&gt; dp(sLen + 1, 0);
        dp[0] = 1;
        for(int i = 0; i &lt;= s.size(); i++){
            for(int j = i - 1; j &gt;= 0 &amp;&amp; i - j &lt;= maxWordLen; j--){
                string str = s.substr(j, i - j);
                if(dp[j] &amp;&amp; wordDict.count(str)){
                    dp[i] = 1;
                    break;
                }
            }
        }

        if(!dp[sLen]) return ans;
        vector&lt;int&gt; path;
        DFS(dp, path, sLen, s, wordDict);
        return ans;
    }
    
    void DFS(vector&lt;int&gt; &amp;dp, vector&lt;int&gt; &amp;path, int index, string &amp;s, unordered_set&lt;string&gt;&amp; wordDict){
        if(index == 0){
            string str;
            int lastIndex = 0;
            for(auto i = path.rbegin(); i != path.rend(); i++){
                str += s.substr(lastIndex, (*i) - lastIndex);
                str += &quot; &quot;;
                lastIndex = *i;
            }
            if(!str.empty())str.pop_back();
            ans.push_back(str);
            return;
        }
        path.push_back(index);
        for(int j = index - 1; j &gt;= 0 &amp;&amp; index - j &lt;= maxWordLen; j--){
            if(dp[j] &amp;&amp; wordDict.count(s.substr(j, index - j))){
                DFS(dp, path, j, s, wordDict);
            }
        }
        path.pop_back();
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>828</wp:post_id>
		<wp:post_date><![CDATA[2016-10-02 19:30:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-02 11:30:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-140-word-break-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 141. Linked List Cycle</title>
		<link>http://xiadong.info/2016/10/leetcode-141-linked-list-cycle/</link>
		<pubDate>Sun, 02 Oct 2016 11:33:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=830</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a linked list, determine if it has a cycle in it.
Follow up:
Can you solve it without using extra space?
</blockquote>

经典题, 使用快慢指针.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head) return false;
        ListNode *p1 = head, *p2 = head-&gt;next;
        while(p1 &amp;&amp; p2){
            if(p1 == p2) return true;
            p1 = p1-&gt;next;
            if(!p2-&gt;next){
                return false;
            }
            p2 = p2-&gt;next-&gt;next;
        }
        return false;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>830</wp:post_id>
		<wp:post_date><![CDATA[2016-10-02 19:33:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-02 11:33:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-141-linked-list-cycle]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 142. Linked List Cycle II</title>
		<link>http://xiadong.info/2016/10/leetcode-142-linked-list-cycle-ii/</link>
		<pubDate>Sun, 02 Oct 2016 11:52:35 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=832</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.
<strong>Note:</strong> Do not modify the linked list.
<strong>Follow up</strong>:
Can you solve it without using extra space?
</blockquote>

同样是使用双指针, 不过要比上一题更进一步. 假设链表有环, 环的长度为m, 去掉环的长度为n(这些节点都一定在环之前),  相遇时快慢指针走过的长度为k和2k. 那么慢指针在环上走过的距离为<code>k-n</code>, 快指针为<code>2k-n</code>, 因为它们指向同一个节点, 所以它们的差<code>k</code>一定是m的整数倍. 因此慢指针只要再走n个节点就会回到进入环的那个节点(<code>k-n+n=k</code>). 

虽然我们并不知道m和n的值, 但n是环之前的节点数量, 只要再让一个指针从头结点开始与慢指针同步向前, 当他们相遇时就正好走过了n个节点, 而他们指向的节点就是进入环的节点.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(!head || !head-&gt;next) return nullptr;
        ListNode *p1 = head-&gt;next, *p2 = head-&gt;next-&gt;next;
        while(p1 &amp;&amp; p2 &amp;&amp; p2-&gt;next){
            if(p1 == p2){
                while(true){
                    if(p1 == head) return p1;
                    p1 = p1-&gt;next;
                    head = head-&gt;next;
                }
            }
            
            p1 = p1-&gt;next;
            p2 = p2-&gt;next-&gt;next;
        }
        return nullptr;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>832</wp:post_id>
		<wp:post_date><![CDATA[2016-10-02 19:52:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-02 11:52:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-142-linked-list-cycle-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>写了个舰C肝度计算器</title>
		<link>http://xiadong.info/2016/10/%e5%86%99%e4%ba%86%e4%b8%aa%e8%88%b0c%e8%82%9d%e5%ba%a6%e8%ae%a1%e7%ae%97%e5%99%a8/</link>
		<pubDate>Mon, 03 Oct 2016 04:29:43 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=835</guid>
		<description></description>
		<content:encoded><![CDATA[今天突然想看看自己算不算肝, 但是却没怎么找到在线的计算器, 于是就扒拉了几个公式写了个在线计算器. 纯属娱乐.

<a href="https://xiadong1994.github.io/KanColleHairDensity/KanColleHairDensity.html" target="_blank">https://xiadong1994.github.io/KanColleHairDensity/KanColleHairDensity.html</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>835</wp:post_id>
		<wp:post_date><![CDATA[2016-10-03 12:29:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-03 04:29:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%86%99%e4%ba%86%e4%b8%aa%e8%88%b0c%e8%82%9d%e5%ba%a6%e8%ae%a1%e7%ae%97%e5%99%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acg"><![CDATA[ACG]]></category>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 409. Longest Palindrome</title>
		<link>http://xiadong.info/2016/10/leetcode-409-longest-palindrome/</link>
		<pubDate>Tue, 04 Oct 2016 07:53:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=838</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.

This is case sensitive, for example <code>"Aa"</code> is not considered a palindrome here.

<strong>Note:</strong>
Assume the length of given string will not exceed 1,010.

<strong>Example:</strong>
<pre lang="undefined">Input:
"abccccdd"

Output:
7

Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
</pre>
</blockquote>

给出一个字符数组, 问从中取出字符拼成的回文串最长是多少. 这道题比较简单, 回文串中的字符都是成对出现的, 因此如果一个字母的数量超过了2, 那么它就一定可以放在回文串中, 数量则是必须是偶数奇数的话则减1. 最后看是否还有剩下的字母, 如果有就可以选一个放在中间.

<pre lang="c++">class Solution {
public:
    int longestPalindrome(string s) {
        vector&lt;int&gt; letters(52, 0);
        for(auto i : s){
            if(i &gt;= 'a' &amp;&amp; i &lt;= 'z'){
                letters[i - 'a']++;
            }
            else{
                letters[i - 'A' + 26]++;
            }
        }
        int ans = 0;
        for(auto i : letters){
            if(i &gt; 1){
                ans += i % 2 ? i - 1 : i;
            }
        }
        if(ans &lt; s.length()) ans++;
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>838</wp:post_id>
		<wp:post_date><![CDATA[2016-10-04 15:53:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-04 07:53:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-409-longest-palindrome]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 143. Reorder List</title>
		<link>http://xiadong.info/2016/10/leetcode-143-reorder-list/</link>
		<pubDate>Wed, 05 Oct 2016 07:18:09 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=840</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>Ln</em>-1→<em>L</em>n,
reorder it to: <em>L</em>0→<em>Ln</em>→<em>L</em>1→<em>Ln</em>-1→<em>L</em>2→<em>Ln</em>-2→…
You must do this in-place without altering the nodes&#39; values.
For example,
Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.
</blockquote>

这道题如果不用辅助空间的话分成三步: 1. 分割链表; 2. 颠倒第二个链表; 3. 合并链表. 其中分割链表通过快慢指针来找到链表的中间节点.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode *fast = head, *low = head, *preLow = nullptr;;
        if(!head || !head-&gt;next) return;
        while(fast &amp;&amp; fast-&gt;next){
            fast = fast-&gt;next-&gt;next;
            preLow = low;
            low = low-&gt;next;
        }
        preLow-&gt;next = nullptr;
        ListNode *h1 = head, *h2 = low;
        h2 = reverseList(h2);
        while(h1){
            if(!h1-&gt;next){
                h1-&gt;next = h2;
                break;
            }
            else{
                ListNode *h2next = h2-&gt;next;
                h2-&gt;next = h1-&gt;next;
                h1-&gt;next = h2;
                h1 = h1-&gt;next-&gt;next;
                h2 = h2next;
            }
        }
    }
    
    ListNode* reverseList(ListNode* head){
        if(!head) return head;
        ListNode *p1 = nullptr, *p2;
        p2 = head;
        while(p2){
            ListNode *next = p2-&gt;next;
            p2-&gt;next = p1;
            p1 = p2;
            p2 = next;
        }
        return p1;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>840</wp:post_id>
		<wp:post_date><![CDATA[2016-10-05 15:18:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-05 07:18:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-143-reorder-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 144. Binary Tree Preorder Traversal</title>
		<link>http://xiadong.info/2016/10/leetcode-144-binary-tree-preorder-traversal/</link>
		<pubDate>Wed, 05 Oct 2016 07:41:32 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=842</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, return the <em>preorder</em> traversal of its nodes&#39; values.
For example:
Given binary tree <code>{1,#,2,3}</code>,
<pre lang='undefined'>
   1
    \
     2
    /
   3
</pre>
return <code>[1,2,3]</code>.
<strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?
</blockquote>

二叉树非递归前序遍历. 需要背下来的代码了......

<pre lang='c++'>
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode *root) {
        vector&lt;TreeNode*&gt; path;
        vector&lt;int&gt; ret;
        if(root == NULL) return ret;
        TreeNode *node = root;

        while(node || !path.empty()){
            if(node){
                ret.push_back(node-&gt;val);
                path.push_back(node);
                node = node-&gt;left;
            }
            else{
                node = path.back();
                path.pop_back();
                node = node-&gt;right;
            }
        }

        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>842</wp:post_id>
		<wp:post_date><![CDATA[2016-10-05 15:41:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-05 07:41:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-144-binary-tree-preorder-traversal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 410. Split Array Largest Sum</title>
		<link>http://xiadong.info/2016/10/leetcode-410-split-array-largest-sum/</link>
		<pubDate>Wed, 05 Oct 2016 08:45:06 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=844</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array which consists of non-negative integers and an integer <em>m</em>, you can split the array into <em>m</em> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <em>m</em> subarrays.
<strong>Note:</strong>
Given <em>m</em> satisfies the following constraint: 1 ≤ m ≤ length(nums) ≤ 14,000.
<strong>Examples:</strong>
<pre lang='undefined'>
Input:
nums = [7,2,5,10,8]
m = 2

Output:
18

Explanation:
There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8],
where the largest sum among the two subarrays is only 18.
</pre>
</blockquote>

这道题我是采用二分搜索的方法解的. 虽然要想到对整个int型范围进行二分搜索还是不太容易, 但是只要想到这一点, 问题就基本解决了, 剩下的就可以通过贪心来判断数组能不能被分成m个并且保证最大的和不超过一个给定的值. 二分搜索上界是INT_MAX, 而下界是数组中的最大值.

<pre lang='c++'>
class Solution {
public:
    int splitArray(vector&lt;int&gt;&amp; nums, int m) {
        int len = nums.size();
        int maxElement = 0;
        for(auto i : nums){
            maxElement = max(maxElement, i);
        }
        long long left = maxElement, right = INT_MAX, mid = (left + right) / 2;
        while(left &lt; right){
            if(canSplit(nums, mid, m)){
                right = mid;
            }
            else{
                left = mid + 1;
            }
            mid = (left + right) / 2;
        }
        return left;
    }
    
    bool canSplit(vector&lt;int&gt; &amp;nums, long long target, int m){
        long long sum = 0;
        int splitArrs = 0;
        for(int i = 0; i &lt; nums.size() &amp;&amp; splitArrs &lt;= m; i++){
            if(sum + nums[i] &gt; target){
                sum = nums[i];
                splitArrs++;
            }
            else if(sum + nums[i] == target){
                sum = 0;
                splitArrs++;
            }
            else{
                sum += nums[i];
            }
        }
        if(sum &gt; 0) splitArrs++;
        return splitArrs &lt;= m;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>844</wp:post_id>
		<wp:post_date><![CDATA[2016-10-05 16:45:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-05 08:45:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-410-split-array-largest-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 145. Binary Tree Postorder Traversal</title>
		<link>http://xiadong.info/2016/10/leetcode-145-binary-tree-postorder-traversal/</link>
		<pubDate>Thu, 06 Oct 2016 07:57:30 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=846</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, return the <em>postorder</em> traversal of its nodes&#39; values.
For example:
Given binary tree <code>{1,#,2,3}</code>,
<pre lang='undefined'>
   1
    \
     2
    /
   3
</pre>
return <code>[3,2,1]</code>.
<strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?
</blockquote>

非递归后序遍历.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; ans;
        if(!root) return ans;
        vector&lt;TreeNode*&gt; stack = {root};
        
        while(!stack.empty()){
            TreeNode* n = stack.back();
            stack.pop_back();
            ans.push_back(n-&gt;val);
            if(n-&gt;left) stack.push_back(n-&gt;left);
            if(n-&gt;right) stack.push_back(n-&gt;right);
        }
        reverse(ans.begin(), ans.end());
        
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>846</wp:post_id>
		<wp:post_date><![CDATA[2016-10-06 15:57:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-06 07:57:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-145-binary-tree-postorder-traversal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 146. LRU Cache</title>
		<link>http://xiadong.info/2016/10/leetcode-146-lru-cache/</link>
		<pubDate>Thu, 06 Oct 2016 09:40:04 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=848</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.
<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
<code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
</blockquote>

实现一个LRU数据结构, 就是说在元素容量到达上限时要删除最长时间没有访问的元素. 要注意<code>set</code>和<code>get</code>都属于访问了元素.

主要问题在于如何保存所有访问元素的顺序并且能够高效地进行查找和删除. 我一开始想的方法是使用两个map, 分别保存<code>上一次使用时间=&gt;key</code>和<code>key=&gt;上一次使用时间</code>两个映射. 其中第一个map需要有序而第二个不需要, 所以第二个可以采用unordered_map. 第一个map用于保存每一个key的上一次访问时间并且按照访问时间从远到近排序. 但是这个办法虽然可以AC但是效率不高, 而且并不实用. 因为访问时间的表示范围毕竟是有限的, 实际中的访问次数是完全有可能超过它的取值范围的.

<pre lang='c++'>
class LRUCache{
    unordered_map&lt;int, int&gt; data;
    map&lt;int, int&gt; lastTimeAndKey;
    unordered_map&lt;int, int&gt; keyAndLastTime;
    int capacity, useTime;
public:
    LRUCache(int capacity) {
        this-&gt;capacity = capacity;
        useTime = 0;
    }
    
    int get(int key) {
        if(data.count(key)) {
            int lastUseTime = keyAndLastTime[key];
            keyAndLastTime[key] = useTime;
            lastTimeAndKey.erase(lastUseTime);
            lastTimeAndKey[useTime] = key;
            useTime++;
            return data[key];
        }
        else return -1;
    }
    
    void set(int key, int value) {
        if(data.count(key)){
            int lastUseTime = keyAndLastTime[key];
            keyAndLastTime[key] = useTime;
            lastTimeAndKey.erase(lastUseTime);
            lastTimeAndKey[useTime] = key;
        } 
        else if(data.size() &lt; capacity){
            lastTimeAndKey[useTime] = key;
            keyAndLastTime[key] = useTime;
        }
        else{
            int eraseKey = lastTimeAndKey.begin()-&gt;second;
            keyAndLastTime.erase(eraseKey);
            lastTimeAndKey.erase(lastTimeAndKey.begin());
            data.erase(eraseKey);
            lastTimeAndKey[useTime] = key;
            keyAndLastTime[key] = useTime;
        }
        useTime++;
        data[key] = value;
    }
};
</pre>

所以后来我采用一个双向链表作为队列, 然后使用一个unordered_map来维护<code>key=&gt;链表节点指针(迭代器)</code>的映射, 而链表中保存相应的key值. 当要更新队列时, 就通过key来找到节点, 删除节点并在最后增加节点, 更新key对应的迭代器. 当要删除队列中的第一个元素时, 可以通过头结点保存的key值同时删除data中的数据和<code>key=&gt;链表节点指针(迭代器)</code>中的数据. 这样的话每次<code>set</code>和<code>get</code>的处理时间都是常数的.

<pre lang='c++'>
class LRUCache{
    unordered_map&lt;int, int&gt; data;
    list&lt;int&gt; q;
    unordered_map&lt;int, list&lt;int&gt;::iterator&gt; keyToPointer;
    int capacity;
public:
    LRUCache(int capacity) {
        this-&gt;capacity = capacity;
    }
    
    int get(int key) {
        if(data.count(key)) {
            list&lt;int&gt;::iterator iter = keyToPointer[key];
            q.erase(iter);
            q.push_back(key);
            keyToPointer[key] = --q.end();
            return data[key];
        }
        else return -1;
    }
    
    void set(int key, int value) {
        if(data.count(key)){
            list&lt;int&gt;::iterator iter = keyToPointer[key];
            q.erase(iter);
            q.push_back(key);
            keyToPointer[key] = --q.end();
        } 
        else if(data.size() &lt; capacity){
            q.push_back(key);
            keyToPointer[key] = --q.end();
        }
        else{
            int keyToErase = q.front();
            data.erase(keyToErase);
            keyToPointer.erase(keyToErase);
            q.pop_front();
            q.push_back(key);
            keyToPointer[key] = --q.end();
        }
        data[key] = value;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>848</wp:post_id>
		<wp:post_date><![CDATA[2016-10-06 17:40:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-06 09:40:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-146-lru-cache]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 147. Insertion Sort List</title>
		<link>http://xiadong.info/2016/10/leetcode-147-insertion-sort-list/</link>
		<pubDate>Fri, 07 Oct 2016 07:38:05 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=850</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Sort a linked list using insertion sort.
</blockquote>

使用插入排序对一个链表进行排序. 对于原来链表中的每一个节点搜索在新链表中应该插入的位置.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        return insertion(head);
    }
    
    ListNode* insertion(ListNode* head){
        if(!head) return nullptr;
        ListNode *h = new ListNode(head-&gt;val), *p = head-&gt;next;
        while(p){
            ListNode *tp = h, *prev = nullptr;
            while(tp &amp;&amp; tp-&gt;val &lt; p-&gt;val) {
                prev = tp;
                tp = tp-&gt;next;
            }
            if(prev){
                ListNode *newNode = new ListNode(p-&gt;val);
                newNode-&gt;next = prev-&gt;next;
                prev-&gt;next = newNode;
            }
            else{
                ListNode *newHead = new ListNode(p-&gt;val);
                newHead-&gt;next = h;
                h = newHead;
            }
            
            p = p-&gt;next;
        }
        return h;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>850</wp:post_id>
		<wp:post_date><![CDATA[2016-10-07 15:38:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-07 07:38:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-147-insertion-sort-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 148. Sort List</title>
		<link>http://xiadong.info/2016/10/leetcode-148-sort-list/</link>
		<pubDate>Fri, 07 Oct 2016 07:45:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=853</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.
</blockquote>

不使用额外空间对单向链表进行排序, 要求时间复杂度为O(nlogn). 可以使用归并排序, 使用快慢指针把链表分为两部分, 分别进行递归地归并排序后再合并为一个链表.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head || !head-&gt;next) return head;
        if(head-&gt;next-&gt;next == nullptr){
            if(head-&gt;val &gt; head-&gt;next-&gt;val){
                head-&gt;next-&gt;next = head;
                ListNode *t = head-&gt;next;
                head-&gt;next = nullptr;
                return t;
            }
            else return head;
        }
        ListNode *fast = head, *slow = head;
        while(fast &amp;&amp; fast-&gt;next){
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
        }
        ListNode *right = slow-&gt;next;
        slow-&gt;next = nullptr;
        head = sortList(head);
        right = sortList(right);
        return merge(head, right);
    }
    
    ListNode* merge(ListNode *left, ListNode *right){
        ListNode *head = new ListNode(0), *p1 = left, *p2 = right, *p = head;
        while(p1 &amp;&amp; p2){
            if(p1-&gt;val &lt; p2-&gt;val){
                p-&gt;next = p1;
                p1 = p1-&gt;next;
            }
            else{
                p-&gt;next = p2;
                p2 = p2-&gt;next;
            }
            p = p-&gt;next;
        }
        if(p &amp;&amp; !p1){
            p-&gt;next = p2;
        }
        else if(p &amp;&amp; !p2){
            p-&gt;next = p1;
        }
        return head-&gt;next;
    }
};S
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>853</wp:post_id>
		<wp:post_date><![CDATA[2016-10-07 15:45:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-07 07:45:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-148-sort-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 149. Max Points on a Line</title>
		<link>http://xiadong.info/2016/10/leetcode-149-max-points-on-a-line/</link>
		<pubDate>Sat, 08 Oct 2016 11:17:13 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=855</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given <em>n</em> points on a 2D plane, find the maximum number of points that lie on the same straight line.
</blockquote>

寻找一个平面上最多有多少个点共线. 首先应该复杂度应该是O(n<sup>2</sup>)的, 因为要判断每一个点与其他点的关系(或者说判断是否在之前的点所连成的线上). 对每一个点, 计算与其他点的连线的斜率, 找出出现次数最多的斜率, 它的出现次数就是共线的点的个数(但是这里没有包括改点自己, 再加上重复点的问题, 所以最后要加上该点自己的出现次数). 使用一个hash表来保存斜率的出现次数即可.

还要注意对于连线斜率为无穷大的点来说(横坐标相同), 要单独处理.

<pre lang='c++'>
/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution {
public:
    int maxPoints(vector&lt;Point&gt;&amp; points) {
        if(points.size() &lt; 2) return points.size();
        
        int maxNum = 2;
        for(int i = 0; i &lt; points.size(); i++){
            unordered_map&lt;double, int&gt; slope;
            int num = 1, mmax = 0, infiniteSlope = 0;
            for(int j = 0; j &lt; i; j++){
                if(points[i].x == points[j].x){
                    if(points[i].y == points[j].y){
                        num++;
                    }
                    else{
                        mmax = max(mmax, ++infiniteSlope);
                    }
                }
                else{
                    double k = (double)(points[i].y - points[j].y) / (points[i].x - points[j].x);
                    mmax = max(mmax, ++slope[k]);
                }
            }
            maxNum = max(maxNum, mmax + num);
        }
        return maxNum;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>855</wp:post_id>
		<wp:post_date><![CDATA[2016-10-08 19:17:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-08 11:17:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-149-max-points-on-a-line]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 150. Evaluate Reverse Polish Notation</title>
		<link>http://xiadong.info/2016/10/leetcode-150-evaluate-reverse-polish-notation/</link>
		<pubDate>Sat, 08 Oct 2016 11:25:58 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=857</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Evaluate the value of an arithmetic expression in <a href='http://en.wikipedia.org/wiki/Reverse_Polish_notation'>Reverse Polish Notation</a>.
Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.
Some examples:
<pre lang='undefined'>
  [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9
  [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6
</pre>
</blockquote>

<em>逆波兰表达式</em>的意思就是运算符后缀, 这种方式就是为栈设计的. 当读入数字的时候就将其入栈, 读入运算符的时候就将栈顶的两个元素取出运算后再压入栈.

<pre lang='c++'>
class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        vector&lt;int&gt; nums;
        for(int i = 0; i &lt; tokens.size(); i++){
            string s = tokens[i];
            if(s.size() == 1 &amp;&amp; (s == &quot;+&quot; || s == &quot;-&quot; || s == &quot;*&quot; || s == &quot;/&quot;)){
                int a = nums.back();
                nums.pop_back();
                int b = nums.back();
                nums.pop_back();
                int re;
                switch(s[0]){
                    case &#39;+&#39;:
                        re = a + b;
                        break;
                    case &#39;-&#39;:
                        re = b - a;
                        break;
                    case &#39;*&#39;:
                        re = b * a;
                        break;
                    case &#39;/&#39;:
                        re = b / a;
                        break;
                }
                nums.push_back(re);
            }
            else{
                nums.push_back(stoi(s));
            }
        }
        return nums[0];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>857</wp:post_id>
		<wp:post_date><![CDATA[2016-10-08 19:25:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-08 11:25:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-150-evaluate-reverse-polish-notation]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 415. Add Strings</title>
		<link>http://xiadong.info/2016/10/leetcode-415-add-strings/</link>
		<pubDate>Sun, 09 Oct 2016 08:12:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=859</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two non-negative numbers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.
<strong>Note:</strong>
<ol><li>
The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li>
<li>
Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li>
<li>
Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>
<li>
You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li>
</ol>
</blockquote>

简单的模拟加法.

<pre lang='c++'>
class Solution {
public:
    string addStrings(string num1, string num2) {
        if(num2.length() &gt; num1.length()) swap(num1, num2);
        int maxLen = num1.length(), minLen = num2.length(), inc = 0;
        string ans(maxLen, &#39;0&#39;);
        int i;
        for(i = 0; i &lt; minLen; i++){
            char a = num1[maxLen - i - 1] - &#39;0&#39;, b = num2[minLen - i - 1] - &#39;0&#39;;
            char r = a + b + inc;
            if(r &gt;= 10){
                inc = 1;
            }
            else{
                inc = 0;
            }
            ans[maxLen - i - 1] = r % 10 + &#39;0&#39;;
        }
        if(i &lt; maxLen){
            for(; i &lt; maxLen; i++){
                char r = num1[maxLen - i - 1] - &#39;0&#39; + inc;
                if(r &gt;= 10){
                    inc = 1;
                }
                else{
                    inc = 0;
                }
                ans[maxLen - i - 1] = r % 10 + &#39;0&#39;;
            }
        }
        if(inc){
            ans.insert(ans.begin(), &#39;1&#39;);
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>859</wp:post_id>
		<wp:post_date><![CDATA[2016-10-09 16:12:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-09 08:12:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-415-add-strings]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 416. Partition Equal Subset Sum</title>
		<link>http://xiadong.info/2016/10/leetcode-416-partition-equal-subset-sum/</link>
		<pubDate>Sun, 09 Oct 2016 10:27:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=861</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
<strong>Note:</strong>
Both the array size and each of the array element will not exceed 100.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.
</pre>
</blockquote>

动态规划问题, 比较容易看出如果用<code>dp[i][j]</code>表示前i+1个数字能否找出和为j的子集的话, <code>dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i]]</code>. 但是用二维数组来进行dp的话, 数组的列数是不知道的, 我一开始用hash表来存储行, 但是运行速度很慢, 后来注意到总的元素数目最多只有100个, 每个最多只有100, 而我们要找的目标是和的一半, 也就是最多5000, 完全可以把数组的列数设置为和的一半, 然后从下往上dp.

<pre lang='c++'>
class Solution {
public:
    bool canPartition(vector&lt;int&gt;&amp; nums) {
        int sum = 0;
        for(int i = 0; i &lt; nums.size(); i++){
            sum += nums[i];
        }
        if(sum % 2) return false;
        
        sum /= 2;
        vector&lt;int&gt; dp(sum + 1), tmpDp(sum + 1);
        dp[0] = 1;
        dp[nums[0]] = 1;
        
        for(int i = 1; i &lt; nums.size(); i++){
            tmpDp = dp;
            for(int j = 0; j &lt; dp.size(); j++){
                if(tmpDp[j] == 0) continue;
                int t = j + nums[i];
                if(t == sum) return true;
                if(t &lt; sum) dp[t] = 1;
            }
        }
        return false;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>861</wp:post_id>
		<wp:post_date><![CDATA[2016-10-09 18:27:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-09 10:27:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-416-partition-equal-subset-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 417. Pacific Atlantic Water Flow</title>
		<link>http://xiadong.info/2016/10/leetcode-417-pacific-atlantic-water-flow/</link>
		<pubDate>Mon, 10 Oct 2016 07:57:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=863</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the &quot;Pacific ocean&quot; touches the left and top edges of the matrix and the &quot;Atlantic ocean&quot; touches the right and bottom edges.
Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.
Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.
<strong>Note:</strong>
<ol><li>
The order of returned grid coordinates does not matter.</li>
<li>
Both <em>m</em> and <em>n</em> are less than 150.</li>
</ol>
<strong>Example:</strong>
<pre lang='undefined'>
Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
</pre>
</blockquote>

比较直接的搜索题, 用BFS或者DFS分别找出所有与Pacific连接的位置和与Atlantic连接的位置, 然后求它们的交集.

<pre lang='c++'>
class Solution {
    int col, row;
public:
    vector&lt;pair&lt;int, int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;pair&lt;int, int&gt;&gt; ans;
        if(matrix.empty()) return ans;
        if(matrix[0].empty()) return ans;
        row = matrix.size(), col = matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt; pacificVisited(row, vector&lt;int&gt;(col, 0)), atlanticVisited(row, vector&lt;int&gt;(col, 0));
        unordered_set&lt;long long&gt; pacific, atlantic;
        for(int i = 0; i &lt; col; i++){
            BFS(matrix, 0, i, pacificVisited, pacific);
            BFS(matrix, row - 1, i, atlanticVisited, atlantic);
        }
        for(int i = 0; i &lt; row; i++){
            BFS(matrix, i, 0, pacificVisited, pacific);
            BFS(matrix, i, col - 1, atlanticVisited, atlantic);
        }

        for(auto i : pacific){
            if(atlantic.count(i))
                ans.push_back(pair&lt;int, int&gt;(i &gt;&gt; 32, i &amp; -1));
        }
        return ans;
    }
    
    void BFS(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;visited, unordered_set&lt;long long&gt; &amp;ocean){
        if(visited[x][y]) return;
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push(pair&lt;int, int&gt;(x, y));
        ocean.insert((long long)x &lt;&lt; 32 | (long long)y);
        visited[x][y] = 1;
        while(!q.empty()){
            pair&lt;int, int&gt; p = q.front();
            if(p.first &gt; 0 &amp;&amp; !visited[p.first - 1][p.second] &amp;&amp; matrix[p.first][p.second] &lt;= matrix[p.first - 1][p.second]){
                visited[p.first - 1][p.second] = 1;
                pair&lt;int, int&gt; nextP = pair&lt;int, int&gt;(p.first - 1, p.second);
                ocean.insert((long long)nextP.first &lt;&lt; 32 | (long long)nextP.second);
                q.push(nextP);
            }
            if(p.first &lt; row - 1 &amp;&amp; !visited[p.first + 1][p.second] &amp;&amp; matrix[p.first][p.second] &lt;= matrix[p.first + 1][p.second]){
                visited[p.first + 1][p.second] = 1;
                pair&lt;int, int&gt; nextP = pair&lt;int, int&gt;(p.first + 1, p.second);
                ocean.insert((long long)nextP.first &lt;&lt; 32 | (long long)nextP.second);
                q.push(nextP);
            }
            if(p.second &gt; 0 &amp;&amp; !visited[p.first][p.second - 1] &amp;&amp; matrix[p.first][p.second] &lt;= matrix[p.first][p.second - 1]){
                visited[p.first][p.second - 1] = 1;
                pair&lt;int, int&gt; nextP = pair&lt;int, int&gt;(p.first, p.second - 1);
                ocean.insert((long long)nextP.first &lt;&lt; 32 | (long long)nextP.second);
                q.push(nextP);
            }
            if(p.second &lt; col - 1 &amp;&amp; !visited[p.first][p.second + 1] &amp;&amp; matrix[p.first][p.second] &lt;= matrix[p.first][p.second + 1]){
                visited[p.first][p.second + 1] = 1;
                pair&lt;int, int&gt; nextP = pair&lt;int, int&gt;(p.first, p.second + 1);
                ocean.insert((long long)nextP.first &lt;&lt; 32 | (long long)nextP.second);
                q.push(nextP);
            }
            q.pop();
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>863</wp:post_id>
		<wp:post_date><![CDATA[2016-10-10 15:57:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-10 07:57:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-417-pacific-atlantic-water-flow]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 151. Reverse Words in a String</title>
		<link>http://xiadong.info/2016/10/leetcode-151-reverse-words-in-a-string/</link>
		<pubDate>Mon, 10 Oct 2016 08:09:28 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=865</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an input string, reverse the string word by word.
For example,
Given s = &quot;<code>the sky is blue</code>&quot;,
return &quot;<code>blue is sky the</code>&quot;.
<strong>Clarification:</strong>
<ul><li>
What constitutes a word?
A sequence of non-space characters constitutes a word.</li>
<li>
Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>
How about multiple spaces between two words?
Reduce them to a single space in the reversed string.</li>
</ul>
</blockquote>

翻转一个字符串中的单词, 先翻转整个字符串然后再把每一个单词都翻转一次即可. 但是要考虑输入字符串前后的空格和单词间多余空格.

<pre lang='c++'>
class Solution {
public:
    void reverseWords(string &amp;s) {
        trimString(s);
        reverse(s.begin(), s.end());
        for(int i = 0; i &lt; s.size(); i++){
            int j;
            for(j = i + 1; j &lt; s.size() &amp;&amp; s[j] != &#39; &#39;; j++);
            reverse(s.begin() + i, s.begin() + j);
            if(j == s.size()){
                break;
            }
            else{
                while(j + 1 &lt; s.size() &amp;&amp; s[j + 1] == &#39; &#39;) s.erase(j + 1, 1);
                i = j;
            }
        }
    }
    
    void trimString(string &amp;s){
        while(s.front() == &#39; &#39;) s.erase(s.begin());
        while(s.back() == &#39; &#39;) s.pop_back();
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>865</wp:post_id>
		<wp:post_date><![CDATA[2016-10-10 16:09:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-10 08:09:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-151-reverse-words-in-a-string]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 152. Maximum Product Subarray</title>
		<link>http://xiadong.info/2016/10/leetcode-152-maximum-product-subarray/</link>
		<pubDate>Mon, 10 Oct 2016 08:14:54 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=867</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Find the contiguous subarray within an array (containing at least one number) which has the largest product.
For example, given the array <code>[2,3,-2,4]</code>,
the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.
</blockquote>

DP问题, 主要问题在于数组中可能会出现负数, 所以要在维护最大值的同时维护一个最小值, 因为如果一个元素为负, 那么最小值也有可能变为最大值.

<pre lang='c++'>
class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int maxPrevP = nums[0], minPrevP = nums[0], maxP = nums[0];
        for(int i = 1; i &lt; nums.size(); i++){
            int maxCurP = max(maxPrevP * nums[i], max(nums[i], minPrevP * nums[i]));
            int minCurP = min(maxPrevP * nums[i], min(nums[i], minPrevP * nums[i]));
            if(maxP &lt; maxCurP) maxP = maxCurP;
            maxPrevP = maxCurP, minPrevP = minCurP;
        }
        return maxP;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>867</wp:post_id>
		<wp:post_date><![CDATA[2016-10-10 16:14:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-10 08:14:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-152-maximum-product-subarray]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 153. Find Minimum in Rotated Sorted Array</title>
		<link>http://xiadong.info/2016/10/leetcode-153-find-minimum-in-rotated-sorted-array/</link>
		<pubDate>Tue, 11 Oct 2016 08:30:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=869</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Suppose a sorted array is rotated at some pivot unknown to you beforehand.
(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).
Find the minimum element.
You may assume no duplicate exists in the array.
</blockquote>

这道题虽然使用线性遍历的方法也能过, 但是是可以使用二分搜索的. 

一个经过了循环左移的有序数组相当于被分成了两部分, 我们要找的是这两部分的分界点, 判断一个点是在哪一部分是看它与两端的元素的大小关系, 如果比两端的元素大, 那么它是在左半部分; 如果比两端的元素小, 那么它是在右半部分; 如果它比左端元素小比右边元素大, 那么从左端到右端整体是有序的, 在这种情况下最左端元素就是最小值; 不可能出现比左端元素大而比右端元素小的情况.

<pre lang='c++'>
class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        int left = 0, right = nums.size() - 1, mid = (left + right) / 2;
        while(true){
            if(nums[mid] &lt; nums[left] &amp;&amp; nums[mid] &lt; nums[right]){
                right = mid;
            }
            else if(nums[mid] &gt;= nums[left] &amp;&amp; nums[mid] &gt; nums[right]){
                left = mid + 1;
            }
            else{
                return nums[left];
            }
            mid = (left + right) / 2;
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>869</wp:post_id>
		<wp:post_date><![CDATA[2016-10-11 16:30:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-11 08:30:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-153-find-minimum-in-rotated-sorted-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 154. Find Minimum in Rotated Sorted Array II</title>
		<link>http://xiadong.info/2016/10/leetcode-154-find-minimum-in-rotated-sorted-array-ii/</link>
		<pubDate>Tue, 11 Oct 2016 08:37:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=871</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Suppose a sorted array is rotated at some pivot unknown to you beforehand.
(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).
Find the minimum element.
The array may contain duplicates.
</blockquote>

与上一题类似, 但是有重复元素, 所以要用遍历的方法跳过这些元素.

<pre lang='c++'>
class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        int left = 0, right = nums.size() - 1, mid = (right + left) / 2;
        while(left &lt; right){
            if(nums[mid] &gt; nums[right]) left = mid + 1;
            else if(nums[mid] == nums[right]) right--;
            else right = mid;
            mid = (right + left) / 2;
        }
        return nums[left];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>871</wp:post_id>
		<wp:post_date><![CDATA[2016-10-11 16:37:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-11 08:37:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-154-find-minimum-in-rotated-sorted-array-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 155. Min Stack</title>
		<link>http://xiadong.info/2016/10/leetcode-155-min-stack/</link>
		<pubDate>Tue, 11 Oct 2016 08:44:31 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=873</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
<ul><li>
push(x) -- Push element x onto stack.</li>
<li>
pop() -- Removes the element on top of the stack.</li>
<li>
top() -- Get the top element.</li>
<li>
getMin() -- Retrieve the minimum element in the stack.</li>
</ul>
<strong>Example:</strong>
<pre lang='undefined'>
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; Returns -3.
minStack.pop();
minStack.top();      --&gt; Returns 0.
minStack.getMin();   --&gt; Returns -2.
</pre>
</blockquote>

实现一个栈的同时能在常数时间内取得栈内的最小值. 使用两个栈即可, 一个栈用来保存元素, 另一个栈用来保存对应元素时栈内的最小值.

<pre lang='c++'>
class MinStack {
public:
    vector&lt;int&gt; stack;
    vector&lt;int&gt; min;
    void push(int x) {
        stack.push_back(x);
        if(min.empty() || min.back() &gt; x) min.push_back(x);
        else min.push_back(min.back());
    }

    void pop() {
        stack.pop_back();
        min.pop_back();
    }

    int top() {
        if(stack.empty()) return -1;
        return stack.back();
    }

    int getMin() {
        return min.back();
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>873</wp:post_id>
		<wp:post_date><![CDATA[2016-10-11 16:44:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-11 08:44:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-155-min-stack]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 160. Intersection of Two Linked Lists</title>
		<link>http://xiadong.info/2016/10/leetcode-160-intersection-of-two-linked-lists/</link>
		<pubDate>Wed, 12 Oct 2016 08:29:31 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=876</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
<pre lang='undefined'>
A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
</pre>
begin to intersect at node c1.
<strong>Notes:</strong>
<ul><li>
If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>
The linked lists must retain their original structure after the function returns.</li>
<li>
You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>
Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
</blockquote>

这是一道我遇到过的面试题. 解题方法就是先遍历得到两个链表的长度, 然后再跳过较长的链表的前面几个节点, 直到两个链表剩下的部分长度相等, 再同步移动指针来找到相交的节点.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = 0, lenB = 0;
        ListNode *pa = headA, *pb = headB;
        while(pa){
            lenA++;
            pa = pa-&gt;next;
        }
        while(pb){
            lenB++;
            pb = pb-&gt;next;
        }
        pa = headA, pb = headB;
        if(lenA &gt; lenB){
            for(int i = 0; i &lt; lenA - lenB; i++) pa = pa-&gt;next;
        }
        else if(lenA &lt; lenB){
            for(int i = 0; i &lt; lenB - lenA; i++) pb = pb-&gt;next;
        }
        while(pa &amp;&amp; pb){
            if(pa == pb &amp;&amp; pa != nullptr) return pa;
            pa = pa-&gt;next;
            pb = pb-&gt;next;
        }
        return nullptr;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>876</wp:post_id>
		<wp:post_date><![CDATA[2016-10-12 16:29:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-12 08:29:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-160-intersection-of-two-linked-lists]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 162. Find Peak Element</title>
		<link>http://xiadong.info/2016/10/leetcode-162-find-peak-element/</link>
		<pubDate>Wed, 12 Oct 2016 08:42:12 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=878</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>A peak element is an element that is greater than its neighbors.
Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that <code>num[-1] = num[n] = -∞</code>.
For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.
<strong>Note:</strong>Your solution should be in logarithmic complexity.
</blockquote>

二分搜索，每次比较找到的nums[mid]与邻居的大小来决定向哪边搜索,注意对于边界的处理,下标不能越界.

<pre lang='c++'>
class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 1) return 0;
        if(nums.size() == 2) return nums[0] &gt; nums[1] ? 0 : 1;
        int start = 0, end = nums.size(), mid, len = nums.size();
        while(start &lt; end){
            mid = (start + end) / 2;
            if(mid == 0) return nums[0] &gt; nums[1] ? 0 : 1;
            if(mid == nums.size() - 1) return nums[len - 2] &gt; nums[len - 1] ? len - 2 : len - 1;
            if(nums[mid] &gt; nums[mid - 1] &amp;&amp; nums[mid] &gt; nums[mid + 1]){
                return mid;
            }else if(nums[mid] &gt; nums[mid - 1] &amp;&amp; nums[mid + 1] &gt; nums[mid]){
                start = mid + 1;
            }else{
                end = mid;
            }
        }
        return start;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>878</wp:post_id>
		<wp:post_date><![CDATA[2016-10-12 16:42:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-12 08:42:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-162-find-peak-element]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 164. Maximum Gap</title>
		<link>http://xiadong.info/2016/10/leetcode-164-maximum-gap/</link>
		<pubDate>Wed, 12 Oct 2016 11:07:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=880</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.
Try to solve it in linear time/space.
Return 0 if the array contains less than 2 elements.
You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
</blockquote>

这道题就是一个排序问题, 但是要求O(n)时间复杂度, 可用的办法有桶排序(<a href='https://en.wikipedia.org/wiki/Bucket_sort'>bucket sort</a>)和基数排序(<a href='https://en.wikipedia.org/wiki/Radix_sort'>radix sort</a>), 但是虽然说这两种算法有近似O(n)的复杂度, 但是它们并不一定真的比快排之类的算法快, 因为虽然快排, 堆排的时间复杂度是O(nlogn), 但即使n达到2<sup>32</sup>, logn也只有32而已, 实际中要排序的数据达到这个数量级时我觉得应该考虑外部排序了, 因为很可能数据已经无法完全装入内存了. 而桶排序和基数排序的O(n)算法系数也并不小, 所以这道题直接用快排或者STL的sort函数也是能过的.

更进一步来说, 基于比较的排序算法时间复杂度下界是O(nlogn), 而能到达O(n)复杂度的算法是非比较的排序算法(计数排序, 基数排序, 桶排序).(<a href='http://blog.csdn.net/zouliping123/article/details/8934856' target='_blank' >http://blog.csdn.net/zouliping123/article/details/8934856</a>)

桶排序:

<pre lang='c++'>
class Solution {
public:
    int maximumGap(vector&lt;int&gt; &amp;nums) {
        int length = nums.size();
        if (length &lt; 2) return 0;
        int max_item = nums[0], min_item = nums[0];

        for(int i = 1; i &lt; length; i++){
            max_item = max(max_item, nums[i]);
            min_item = min(min_item, nums[i]);
        }

        int bucket_gap = ( max_item - min_item ) / length &gt;= 1 ? ( max_item - min_item ) / length : 1;
        int bucket_size = ( max_item - min_item ) / bucket_gap + 1;

        vector&lt;vector&lt;int&gt;&gt; bucket(bucket_size);

        for(int i = 0; i &lt; length; i++){
            bucket[(nums[i] - min_item) / bucket_gap].push_back(nums[i]);
        }

        int max_gap = 0;

        for(int i = 0; i &lt; bucket_size; i++){
            sort(bucket[i].begin(), bucket[i].end());
        }
        
        int lastNoneEmptyIndex = -1;
        for(int i = 0; i &lt; bucket.size(); i++){
            if(!bucket[i].empty() &amp;&amp; i != 0 &amp;&amp; lastNoneEmptyIndex != -1){
                max_gap =max(max_gap, bucket[i][0] - bucket[lastNoneEmptyIndex].back());
            }
            
            if(!bucket[i].empty()){
                lastNoneEmptyIndex = i;
                for(int j = 1; j &lt; bucket[i].size() &amp;&amp; max_gap &lt; bucket_gap; j++){
                    max_gap = max(max_gap, bucket[i][j] - bucket[i][j - 1]);
                }
            }
        }

        return max_gap;
    }
};
</pre>

基数排序:

<pre lang='c++'>
class Solution {
public:
    int maximumGap(vector&lt;int&gt; &amp;nums) {
        int length = nums.size();
        if (length &lt; 2) return 0;
        int max_gap = 0;
        vector&lt;int&gt; radix(10, 0);
        vector&lt;int&gt; tmp(length);
        int i = 0, r = 1;
        while(i &lt; 10){
            for(int j = 0; j &lt; 10; j++){
                radix[j] = 0;
            }
            for(auto j : nums){
                radix[(j / r) % 10]++;
            }
            for(int j = 1; j &lt; 10; j++){
                radix[j] += radix[j - 1];
            }
            for(int j = length - 1; j &gt;= 0; j--){
                int k = (nums[j] / r) % 10;
                tmp[--radix[k]] = nums[j];
            }
            i++;
            r *= 10;
            nums = tmp;
        }
        
        for(int i = 0; i &lt; length - 1; i++){
            max_gap = max(max_gap, nums[i + 1] - nums[i]);
        }

        return max_gap;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>880</wp:post_id>
		<wp:post_date><![CDATA[2016-10-12 19:07:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-12 11:07:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-164-maximum-gap]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 165. Compare Version Numbers</title>
		<link>http://xiadong.info/2016/10/leetcode-165-compare-version-numbers/</link>
		<pubDate>Thu, 13 Oct 2016 08:38:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=882</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Compare two version numbers <em>version1</em> and <em>version2</em>.
If <em>version1</em> &gt; <em>version2</em> return 1, if <em>version1</em> &lt; <em>version2</em> return -1, otherwise return 0.
You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.
The <code>.</code> character does not represent a decimal point and is used to separate number sequences.
For instance, <code>2.5</code> is not &quot;two and a half&quot; or &quot;half way to version three&quot;, it is the fifth second-level revision of the second first-level revision.
Here is an example of version numbers ordering:
<pre lang='undefined'>
0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37
</pre>
</blockquote>

使用<code>.</code>把字符串分割为数组, 然后再依次比较大小.

<pre lang='c++'>
class Solution {
public:
    int compareVersion(string version1, string version2) {
        vector&lt;int&gt; v1 = versionVector(version1), v2 = versionVector(version2);
        for(int i = 0; i &lt; v1.size() &amp;&amp; i &lt; v2.size(); i++){
            if(v1[i] &gt; v2[i]) return 1;
            else if(v1[i] &lt; v2[i]) return -1;
        }
        if(v1.size() &gt; v2.size()){
            for(int i = v2.size(); i &lt; v1.size(); i++){
                if(v1[i] != 0) return 1;
            }
        }
        else if(v1.size() &lt; v2.size()){
            for(int i = v1.size(); i &lt; v2.size(); i++){
                if(v2[i] != 0) return -1;
            }
        }
        return 0;
    }
    
    vector&lt;int&gt; versionVector(string &amp;s){
        vector&lt;int&gt; version;
        int pos = 0, next = 0;
        while(next = s.find(&#39;.&#39;, pos)){
            version.push_back(stoi(s.substr(pos, next - pos)));
            if(next == string::npos) break;
            pos = next + 1;
        }
        return version;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>882</wp:post_id>
		<wp:post_date><![CDATA[2016-10-13 16:38:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-13 08:38:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-165-compare-version-numbers]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 166. Fraction to Recurring Decimal</title>
		<link>http://xiadong.info/2016/10/leetcode-166-fraction-to-recurring-decimal/</link>
		<pubDate>Thu, 13 Oct 2016 11:16:55 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=884</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.
If the fractional part is repeating, enclose the repeating part in parentheses.
For example,
<ul><li>
Given numerator = 1, denominator = 2, return &quot;0.5&quot;.</li>
<li>
Given numerator = 2, denominator = 1, return &quot;2&quot;.</li>
<li>
Given numerator = 2, denominator = 3, return &quot;0.(6)&quot;.</li>
</ul>
</blockquote>

模拟手算除法, 难度不大但是非常繁琐.

对于循环小数使用一个hash表来保存出现过的余数的值和它所得的结果在结果字符串中的位置, 当出现重复的余数时就可以确定是循环小数.

还要注意int型的溢出问题.

<pre lang='c++'>
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) return string(&quot;0&quot;);
        bool sign = (numerator ^ denominator) &amp; 0x80000000;
        unordered_map&lt;long long, int&gt; remainders;
        long long lldenominator = denominator;
        long long llnumerator = numerator;
        lldenominator = abs(lldenominator);
        llnumerator = abs(llnumerator);
        string dStr = to_string(lldenominator), nStr = to_string(llnumerator);
        int nLen = nStr.length(), dLen = dStr.length();
        long long tmpn = nStr[0] - &#39;0&#39;;
        int ni = 1;
        
        bool hasDot = false;
        string ans;

        while (true) {
            int a = tmpn / lldenominator;
            if(!(a == 0 &amp;&amp; !hasDot)) ans.push_back(a + &#39;0&#39;);
            else if (a == 0 &amp;&amp; !ans.empty()) ans.push_back(&#39;0&#39;);
            tmpn = tmpn % lldenominator;
            if (!tmpn &amp;&amp; ni == nLen) break;
            tmpn *= 10;
            if (ni == nLen &amp;&amp; !hasDot) {
                if (ans.empty()) ans += &quot;0.&quot;;
                else ans += &quot;.&quot;;
                hasDot = true;
            }

            if (ni &lt; nLen) {
                tmpn += nStr[ni++] - &#39;0&#39;;
            }
            if (!hasDot) continue;
            if (remainders.count(tmpn)) break;
            else remainders[tmpn] = ans.size();
        }
        if (tmpn) {
            int index = remainders[tmpn];
            ans.insert(ans.begin() + index, &#39;(&#39;);
            ans.push_back(&#39;)&#39;);
        }
        if (sign) ans = &quot;-&quot; + ans;
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>884</wp:post_id>
		<wp:post_date><![CDATA[2016-10-13 19:16:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-13 11:16:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-166-fraction-to-recurring-decimal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 423. Reconstruct Original Digits from English</title>
		<link>http://xiadong.info/2016/10/leetcode-423-reconstruct-original-digits-from-english/</link>
		<pubDate>Sun, 16 Oct 2016 08:22:14 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=886</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a <strong>non-empty</strong> string containing an out-of-order English representation of digits <code>0-9</code>, output the digits in ascending order.
<strong>Note:</strong>
<ol><li>
Input contains only lowercase English letters.</li>
<li>
Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as &quot;abc&quot; or &quot;zerone&quot; are not permitted.</li>
<li>
Input length is less than 50,000.</li>
</ol>
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: &quot;owoztneoer&quot;

Output: &quot;012&quot;
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: &quot;fviefuro&quot;

Output: &quot;45&quot;
</pre>
</blockquote>

这道题关键在于找出所有的数字, 至于顺序问题采用排序或者先用数组保存最后再拼接都可以. 

先遍历一次输入字符串, 记录每个字母的出现次数, 然后用贪心法逐个找出每个单词的出现次数, 只要组成这个单词的所有字母的剩余个数都不为0, 那么就可以组成这个单词. 但是如果采用<code>0-9</code>的顺序来依次搜索单词的话, <code>one</code>这个单词中的<code>o</code>, <code>n</code>和<code>e</code>可能都不是<code>one</code>中的, 可能是从其他单词中&quot;拿来的&quot;, 这就会导致结果错误. 所以要以特定的顺序来遍历<code>0-9</code>. 如果一个单词中有&quot;独特的&quot;字母, 也就是只在这个单词中出现的字母, 那么它就不可能从其他的单词中&quot;拿来&quot;组成这个单词的所有字母, <code>zero</code>中的<code>z</code>, <code>two</code>中的<code>w</code>, <code>four</code>中的<code>u</code>, <code>six</code>中的<code>x</code>, <code>eight</code>中的<code>g</code>都是唯一的, 因此要把它们放在前面来搜索, 在剩下的单词中继续寻找&quot;唯一的&quot;字母. 这样就可以得到一个<code>0-9</code>的序列, 比如<code>0246875319</code>, 按照这个顺序来搜索单词就可以得到正确答案.

<pre lang='c++'>
class Solution {
    vector&lt;string&gt; digits = {&quot;zero&quot;, &quot;two&quot;, &quot;four&quot;, &quot;six&quot;, &quot;eight&quot;, &quot;seven&quot;, &quot;five&quot;, &quot;three&quot;, &quot;one&quot;, &quot;nine&quot;};
    string digitStr = &quot;0246875319&quot;;
public:
    string originalDigits(string s) {
        vector&lt;int&gt; letters(26, 0);
        for(auto c : s){
            letters[c - &#39;a&#39;]++;
        }
        vector&lt;string&gt; ansVector(10);
        for(int i = 0; i &lt; digits.size(); i++){
            while(true){
                bool cont = true;
                for(int j = 0 ; j &lt; digits[i].length(); j++){
                    if(letters[digits[i][j] - &#39;a&#39;] == 0){
                        cont = false;
                        break;
                    }
                }
                if(!cont) break;
                for(int j = 0 ; j &lt; digits[i].length(); j++){
                    letters[digits[i][j] - &#39;a&#39;]--;
                }
                ansVector[digitStr[i] - &#39;0&#39;].push_back(digitStr[i]);
            }
        }
        string ans;
        for(auto i : ansVector){
            ans += i;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>886</wp:post_id>
		<wp:post_date><![CDATA[2016-10-16 16:22:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-16 08:22:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-423-reconstruct-original-digits-from-english]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 424. Longest Repeating Character Replacement</title>
		<link>http://xiadong.info/2016/10/leetcode-424-longest-repeating-character-replacement/</link>
		<pubDate>Sun, 16 Oct 2016 09:54:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=888</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most <em>k</em> times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.
<strong>Note:</strong>
Both the string&#39;s length and <em>k</em> will not exceed 104.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input:
s = &quot;ABAB&quot;, k = 2

Output:
4

Explanation:
Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input:
s = &quot;AABABBA&quot;, k = 1

Output:
4

Explanation:
Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.
The substring &quot;BBBB&quot; has the longest repeating letters, which is 4.
</pre>
</blockquote>

这道题我采用双指针的方法. p指向最长连续重复字符的结尾, q指向开头. 首先看一个例子: 字符串<code>&quot;ABBBAAABBAAB&quot;</code>, k=2, 先查找<code>A</code>. 用r记录已经替换了多少个字母.

<pre lang='undefined'>
ABBBAAABBAAB
p=0, q=0, r=0
</pre>

一开始p和q都指向开头, 第一个字符为<code>A</code>, 因此不用替换, 此时长度为1.

<pre lang='undefined'>
ABBBAAABBAAB
p=1, q=0, r=1
</pre>

第二个字符需要替换, r变为1, 此时长度为2.

<pre lang='undefined'>
ABBBAAABBAAB
p=2, q=0, r=2
</pre>

第三个字符也要替换, r变为2, 长度为3.

<pre lang='undefined'>
ABBBAAABBAAB
p=3, q=2, r=2
</pre>

第四个字符仍然需要替换, 但是所有的替换次数已经用完, 因此q要向前移, 直到跳过第一个不是<code>A</code>的字符.

<pre lang='undefined'>
ABBBAAABBAAB
p=4, q=2, r=2
</pre>

第五个字符不需要替换, q不变

<pre lang='undefined'>
ABBBAAABBAAB
p=5, q=2, r=2

ABBBAAABBAAB
p=6, q=2, r=2

ABBBAAABBAAB
p=7, q=3, r=2
</pre>

p=7的时候, 又指向了<code>B</code>, 此时q也指向<code>B</code>, 因此只要q前移一格.

<pre lang='undefined'>
ABBBAAABBAAB
p=8, q=4, r=2

ABBBAAABBAAB
p=9, q=4, r=2

ABBBAAABBAAB
p=10, q=4, r=2

ABBBAAABBAAB
p=11, q=8, r=2
</pre>

最后一个字符不是<code>A</code>, 因此q要前移, 先跳过三个<code>A</code>, 再继续跳过一个<code>B</code>以腾出一个替换次数.

最长连续重复字符的长度为<code>max(p-q+1)</code>, 而因为输入只有26个大写字母, 因此对每一个出现的字母计算一次最长长度就可以得到总的最长长度.

<pre lang='c++'>
class Solution {
public:
    int characterReplacement(string s, int k) {
        int maxLen = 0;
        vector&lt;bool&gt; letters(26, false);
        for(auto c : s){
            letters[c - &#39;A&#39;] = true;
        }
        for(int i = 0; i &lt; 26; i++){
            if(!letters[i]) continue;
            int p, q = 0, r = 0;
            for(p = 0; p &lt; s.length(); p++){
                if(s[p] == i + &#39;A&#39;){
                    maxLen = max(maxLen, p - q + 1);
                }
                else{
                    if(r &lt; k){
                        maxLen = max(maxLen, p - q + 1);
                        r++;
                    }
                    else{
                        while(s[q] == i + &#39;A&#39;) q++;
                        q++;
                        maxLen = max(maxLen, p - q + 1);
                    }
                }
            }
        }
        return maxLen;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>888</wp:post_id>
		<wp:post_date><![CDATA[2016-10-16 17:54:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-16 09:54:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-424-longest-repeating-character-replacement]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 167. Two Sum II - Input array is sorted</title>
		<link>http://xiadong.info/2016/10/leetcode-167-two-sum-ii-input-array-is-sorted/</link>
		<pubDate>Mon, 17 Oct 2016 09:18:19 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=890</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution.
<strong>Input:</strong> numbers={2, 7, 11, 15}, target=9
<strong>Output:</strong> index1=1, index2=2
</blockquote>

输入数据是有序的反而更简单了, 两个指针从两端开始向中间移动就可以了.

<pre lang='c++'>
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int l = 0, r = numbers.size() - 1;
        vector&lt;int&gt; ans(2);
        while(true){
            if(numbers[l] + numbers[r] &gt; target){
                r--;
            }
            else if(numbers[l] + numbers[r] &lt; target){
                l++;
            }
            else{
                ans[0] = l + 1;
                ans[1] = r + 1;
                break;
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>890</wp:post_id>
		<wp:post_date><![CDATA[2016-10-17 17:18:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-17 09:18:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-167-two-sum-ii-input-array-is-sorted]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 168. Excel Sheet Column Title</title>
		<link>http://xiadong.info/2016/10/leetcode-168-excel-sheet-column-title/</link>
		<pubDate>Mon, 17 Oct 2016 09:27:22 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=892</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a positive integer, return its corresponding column title as appear in an Excel sheet.
For example:
<pre lang='undefined'>
    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB 
</pre>
</blockquote>

按照26进制来处理, 不过由于是从1而不是0开始的, 所以要对Z单独处理.

<pre lang='c++'>
class Solution {
public:
    string convertToTitle(int n) {
        string ret;
        while(n &gt; 0){
            if(n % 26 == 0) {
                ret.push_back(&#39;Z&#39;);
                n = n / 26 - 1;
            }
            else {
                ret.push_back((n % 26) + &#39;A&#39; - 1);
                n /= 26;
            }
        }
        reverse(ret.begin(), ret.end());
        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>892</wp:post_id>
		<wp:post_date><![CDATA[2016-10-17 17:27:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-17 09:27:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-168-excel-sheet-column-title]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 169. Majority Element</title>
		<link>http://xiadong.info/2016/10/leetcode-169-majority-element/</link>
		<pubDate>Mon, 17 Oct 2016 10:54:37 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=894</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.
You may assume that the array is non-empty and the majority element always exist in the array.
</blockquote>

这道题方法很多, 排序, 哈希表, 位运算等等都可以.

排序:

<pre lang='c++'>
class Solution {
public:
    int majorityElement(vector&lt;int&gt; &amp;nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
</pre>

位运算:

<pre lang='c++'>
class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; bits(32);
        for(auto j : nums){
            for(int i = 0; i &lt; 32; i++){
                if(j &amp; (1 &lt;&lt; i)) bits[i]++;
            }
        }
        int ans = 0;
        for(int i = 0; i &lt; 32; i++){
            if(bits[i] &gt; n / 2){
                ans |= (1 &lt;&lt; i);
            }
        }
        return ans;
    }
};
</pre>

哈希表:

<pre lang='c++'>
class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int n = nums.size() / 2;
        unordered_map&lt;int, int&gt; m;
        for(auto i : nums){
            if(++m[i] &gt; n) return i;
        }
        
        return 0;
    }
};
</pre>

还有一种O(n)的算法

<pre lang='c++'>
class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int n, cnt = 0;
        for(auto i : nums){
            if(cnt == 0){
                cnt++;
                n = i;
            }
            else if(n == i){
                cnt++;
            }
            else{
                cnt--;
            }
            
            if(cnt &gt; nums.size() / 2) break;
        }
        return n;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>894</wp:post_id>
		<wp:post_date><![CDATA[2016-10-17 18:54:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-17 10:54:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-169-majority-element]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 171. Excel Sheet Column Number</title>
		<link>http://xiadong.info/2016/10/leetcode-171-excel-sheet-column-number/</link>
		<pubDate>Thu, 20 Oct 2016 08:26:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=896</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Related to question <a href='https://leetcode.com/problems/excel-sheet-column-title/'>Excel Sheet Column Title</a>
Given a column title as appear in an Excel sheet, return its corresponding column number.
For example:
<pre lang='undefined'>
    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 
</pre>
</blockquote>

二十六进制的转换.

<pre lang='c++'>
class Solution {
public:
    int titleToNumber(string s) {
        int ans = 0;
        for(int i = 0; i &lt; s.length(); i++){
            ans *= 26;
            ans += s[i] - &#39;A&#39; + 1;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>896</wp:post_id>
		<wp:post_date><![CDATA[2016-10-20 16:26:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-20 08:26:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-171-excel-sheet-column-number]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 172. Factorial Trailing Zeroes</title>
		<link>http://xiadong.info/2016/10/leetcode-172-factorial-trailing-zeroes/</link>
		<pubDate>Thu, 20 Oct 2016 09:01:56 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=898</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an integer <em>n</em>, return the number of trailing zeroes in <em>n</em>!.
<strong>Note: </strong>Your solution should be in logarithmic time complexity.
</blockquote>

统计结果中因子5的个数.

<pre lang='c++'>
class Solution {
public:
    int trailingZeroes(int n) {
        int ret = 0;
        while(n &gt; 0){
            ret += n / 5; // 实际是计算比n小的最大的5的整数倍
            n /= 5; // 实际是计算比n小的最大的5的整数倍除以5
        }
        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>898</wp:post_id>
		<wp:post_date><![CDATA[2016-10-20 17:01:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-20 09:01:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-172-factorial-trailing-zeroes]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 412. Fizz Buzz</title>
		<link>http://xiadong.info/2016/10/leetcode-412-fizz-buzz/</link>
		<pubDate>Sat, 29 Oct 2016 08:24:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=901</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Write a program that outputs the string representation of numbers from 1 to <em>n</em>.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
<strong>Example:</strong>
<pre lang='undefined'>
n = 15,

Return:
[
    &quot;1&quot;,
    &quot;2&quot;,
    &quot;Fizz&quot;,
    &quot;4&quot;,
    &quot;Buzz&quot;,
    &quot;Fizz&quot;,
    &quot;7&quot;,
    &quot;8&quot;,
    &quot;Fizz&quot;,
    &quot;Buzz&quot;,
    &quot;11&quot;,
    &quot;Fizz&quot;,
    &quot;13&quot;,
    &quot;14&quot;,
    &quot;FizzBuzz&quot;
]
</pre>
</blockquote>

直接判断数字是不是3或5的倍数就可以了.

<pre lang='c++'>
class Solution {
public:
    vector&lt;string&gt; fizzBuzz(int n) {
        vector&lt;string&gt; ans;
        for(int i = 1; i &lt;= n; i++){
            string s;
            if(i % 3 &amp;&amp; i % 5){
                s = to_string(i);
            }
            else {
                if(i % 3 == 0){
                    s += &quot;Fizz&quot;;
                }
                if(i % 5 == 0){
                    s += &quot;Buzz&quot;;
                }
            }
            ans.push_back(s);
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>901</wp:post_id>
		<wp:post_date><![CDATA[2016-10-29 16:24:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-29 08:24:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-412-fizz-buzz]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[412-fizz-buzz]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 413. Arithmetic Slices</title>
		<link>http://xiadong.info/2016/10/leetcode-413-arithmetic-slices/</link>
		<pubDate>Sat, 29 Oct 2016 09:13:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=906</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, these are arithmetic sequence:
<pre lang='undefined'>
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
</pre>
The following sequence is not arithmetic.
<pre lang='undefined'>
1, 1, 2, 5, 7
</pre>
A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.
A slice (P, Q) of array A is called arithmetic if the sequence:
A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.
The function should return the number of arithmetic slices in the array A.
<strong>Example:</strong>
<pre lang='undefined'>
A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
</pre>
</blockquote>

这道题我首先用双指针找到所有的尽量长的连续等差数列. 对于每个数列, 假设长度为n, 那么它所包含的所有可能长度的等差数列(长度&gt;=3)有[latex] 1+2+3+\cdots+(n-2)=(n-2)(n-1)/2=(n^2-3n+2)/2[/latex]个.

<pre lang='c++'>
class Solution {
public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) {
        if(A.size() &lt; 3) return 0;
        int p = 0, q = 2;
        int ans = 0;
        while(q &lt; A.size()) {
            if(A[p + 1] - A[p] != A[q] - A[p + 1]) {
                p++, q++;
                continue;
            }
            int diff = A[p + 1] - A[p];
            while(q + 1 &lt; A.size() &amp;&amp; A[q + 1] - A[q] == diff) q++;
            int seqLength = q - p + 1;
            ans += (seqLength * seqLength - 3 * seqLength + 2) / 2;
            p = q;
            q = p + 2;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>906</wp:post_id>
		<wp:post_date><![CDATA[2016-10-29 17:13:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-29 09:13:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-413-arithmetic-slices]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 414. Third Maximum Number</title>
		<link>http://xiadong.info/2016/10/leetcode-414-third-maximum-number/</link>
		<pubDate>Sat, 29 Oct 2016 09:52:23 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=915</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a <strong>non-empty</strong> array of integers, return the <strong>third</strong> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [3, 2, 1]

Output: 1

Explanation: The third maximum is 1.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [1, 2]

Output: 2

Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
</pre>
<strong>Example 3:</strong>
<pre lang='undefined'>
Input: [2, 2, 3, 1]

Output: 1

Explanation: Note that the third maximum here means the third maximum distinct number.
Both numbers with value 2 are both considered as second maximum.
</pre>
</blockquote>

只要求保存前三个最大的数(不重复), 所以可以在遍历过程中维护已经遍历过的元素中最大的三个值. 由于有可能不重复的数值不足三个, 所以还要记录已经保存的最大元素的个数.

<pre lang='c++'>
class Solution {
public:
    int thirdMax(vector&lt;int&gt;&amp; nums) {
        int max1, max2, max3;
        max1 = max2 = max3 = INT_MIN;
        int num = 0;
        for(auto i : nums){
            if((i == max1 &amp;&amp; num &gt; 0) || 
               (i == max2 &amp;&amp; num &gt; 1) || 
               (i == max3 &amp;&amp; num &gt; 2)) 
                continue;
            if(num == 0 || i &gt; max1){
                max3 = max2;
                max2 = max1;
                max1 = i;
            }
            else if(num == 1 || i &gt; max2){
                max3 = max2;
                max2 = i;
            }
            else if(num == 2 || i &gt; max3){
                max3 = i;
            }
            num = min(num + 1, 3);
        }
        if(num == 3) return max3;
        return max1;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>915</wp:post_id>
		<wp:post_date><![CDATA[2016-10-29 17:52:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-29 09:52:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-414-third-maximum-number]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 438. Find All Anagrams in a String</title>
		<link>http://xiadong.info/2016/10/leetcode-438-find-all-anagrams-in-a-string/</link>
		<pubDate>Sun, 30 Oct 2016 11:26:32 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=917</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a string s and a non-empty string p, find all the start indices of p&#39;s anagrams in s.
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
The order of output does not matter.
Example 1:
<pre lang='undefined'>
Input:
s: &quot;cbaebabacd&quot; p: &quot;abc&quot;

Output:
[0, 6]

Explanation:
The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.
The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.
</pre>
Example 2:
<pre lang='undefined'>
Input:
s: &quot;abab&quot; p: &quot;ab&quot;

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.
The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.
The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.
</pre>
</blockquote>

使用哈希表和双指针, 可以在<code>O(n)</code>的时间复杂度内完成.

<pre lang='c++'>
class Solution {
public:
    vector&lt;int&gt; findAnagrams(string s, string p) {
        vector&lt;int&gt; letters(26, 0);
        vector&lt;int&gt; ans;
        if(s.empty() || p.empty() || s.length() &lt; p.length()) return ans;
        for(auto c : p){
            letters[c - &#39;a&#39;]++;
        }
        int i = 0, j;
        vector&lt;int&gt; tmp = letters;
        for(j = 0; j &lt; p.length(); j++){
            tmp[s[j] - &#39;a&#39;]--;
        }
        while(j &lt;= s.length()){
            bool match = true;
            for(auto k : tmp){
                if(k != 0){
                    match = false;
                    break;
                }
            }
            if(match) ans.push_back(i);
            if(j == s.length()) break;
            tmp[s[i] - &#39;a&#39;]++;
            tmp[s[j] - &#39;a&#39;]--;
            i++;
            j++;
        }

        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>917</wp:post_id>
		<wp:post_date><![CDATA[2016-10-30 19:26:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-30 11:26:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-438-find-all-anagrams-in-a-string]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 441. Arranging Coins</title>
		<link>http://xiadong.info/2016/10/leetcode-441-arranging-coins/</link>
		<pubDate>Mon, 31 Oct 2016 08:17:51 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=919</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>You have a total of <em>n</em> coins that you want to form in a staircase shape, where every <em>k</em>-th row must have exactly <em>k</em> coins.

Given <em>n</em>, find the total number of <strong>full</strong> staircase rows that can be formed.

<em>n</em> is a non-negative integer and fits within the range of a 32-bit signed integer.

<strong>Example 1:</strong>
<pre lang="undefined">n = 5

The coins can form the following rows:
¤
¤ ¤
¤ ¤

Because the 3rd row is incomplete, we return 2.

</pre>
<strong>Example 2:</strong>
<pre lang="undefined">n = 8

The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

Because the 4th row is incomplete, we return 3.
</pre>
</blockquote>

<div>等差数列的问题, 前m行共有
[latex display="true"] \frac{m(m+1)}{2} [/latex]
个硬币, 共有n个硬币, 那么应该找出最大的m满足
[latex display="true"] \frac{m(m+1)}{2} \le n \rightarrow m^2+m-2n \le 0 [/latex]
因为m是正整数, 所以
[latex display="true"] m \le \frac{-1+\sqrt{1+8n}}{2}[/latex]</div>

<pre lang="c++">class Solution {
public:
    int arrangeCoins(int n) {
        return (sqrt((long long)n * 8 + 1) - 1.0) / 2;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>919</wp:post_id>
		<wp:post_date><![CDATA[2016-10-31 16:17:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-31 08:17:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-441-arranging-coins]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 173. Binary Search Tree Iterator</title>
		<link>http://xiadong.info/2016/10/leetcode-173-binary-search-tree-iterator/</link>
		<pubDate>Mon, 31 Oct 2016 08:56:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=931</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling <code>next()</code> will return the next smallest number in the BST.
<strong>Note: </strong><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.
</blockquote>

二叉树的非递归中序遍历, 只不过不是放在循环中, 而是通过next来触发每一步的进行.

<pre lang='c++'>
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class BSTIterator {
    TreeNode *BST, *curNode;
    vector&lt;TreeNode*&gt; path;
public:
    BSTIterator(TreeNode *root) {
        BST = root;
        mostLeft(root);
        curNode = nullptr;
    }
    
    TreeNode* mostLeft(TreeNode *root){
        TreeNode *node = root;
        while(node) {
            path.push_back(node);
            node = node-&gt;left;
        }
        return node;
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        if(path.empty() &amp;&amp; !curNode) return false;
        else return true;
    }

    /** @return the next smallest number */
    int next() {
        //curNode = path.back();
        int ans;
        if(!curNode){
            ans = path.back()-&gt;val;
            curNode = path.back()-&gt;right;
            path.pop_back();
        }
        else{
            mostLeft(curNode);
            ans = path.back()-&gt;val;
            curNode = path.back()-&gt;right;
            path.pop_back();
        }
        //cout&lt;&lt;ans&lt;&lt;endl;
        return ans;
    }
};

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout &lt;&lt; i.next();
 */
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>931</wp:post_id>
		<wp:post_date><![CDATA[2016-10-31 16:56:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-10-31 08:56:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-173-binary-search-tree-iterator]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 174. Dungeon Game</title>
		<link>http://xiadong.info/2016/11/leetcode-174-dungeon-game/</link>
		<pubDate>Tue, 01 Nov 2016 10:40:03 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=934</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.

Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0's</em>) or contain magic orbs that increase the knight's health (<em>positive</em> integers).

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.

<strong>Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.</strong>

For example, given the dungeon below, the initial health of the knight must be at least <strong>7</strong> if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.

<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANgAAADXCAYAAAB4dp84AAAWXklEQVR4Xu2dL1xi29vF1y1MkaRFypC0SCJpuUwRwwxBKWIYLD+KEAaKEMQgFjCIhVvQIBZ9AxrEMkxhEokpmJiCBdKxHIrvB0FEBD37cIADLqLsvTl77fXdzx+Ye/95eHh4AF9UgAoMRIF/ngD7559/BvIBXJQKfFQF6rGLgH3U0+e+B64AARu4xPyAj6xAT8BYlj3boj11pi7U5b0Lo9MvXVNEGolGEjXSe+M/yvsETPCkGcG6C0ZdlOnCCPYOcDSSMiMJ3lsTO5wRTPBoCRgBE7EMARNRCwABI2AiliFgImoRsJ5q8eJRdvGwBmMNJnjlNIYTMAKmyjidk2gkZUbSROwJWIQpouAhEjACJmIZAiaiFlMh1mB9+oU1GGswQQuxBntLMEYwQTsxRWSKKGIZAiaiFlNEpoh9+oUpIlNEQQsxRWSKqMoyTIVEZGPqrMwvjGCMYCJctcYSMAKmyjidk2gkZUbSROwJWIRNDsFDJGAETMQyBExELXYR2UXs0y+swViDCVqIXUR2EVVZhqmQiGxMnZX5hRGMEUyEK3YRBf1CwAQFU+XGCZzECMYIpomtaSRlRtJE7AlYhF1EwUMkYARMxDIETEQttunZpu/TL8OtwaQyiqU73GMKs+Z5mIzvPb2EYjaH6pwNS6YaSoUSJKMZFnP7RBmV4i3uaoDB+Al3xQrMtiWYP723trL3dRnB6jre3qE2NQvzvAnvyqhsq0KjdKOLDrRoF25EEUxGOXuEQOAMt62nmcNqNAq/zYReLFRyEWzuA+FUEFZDHuEvHvz+mkQ6aGnOkVHO7MMTuoL07w4SkUWUdjdwMhtFwmvRxHi6MVJTt0oujoDvBH+edJxbxV7UD7tJoxtFIWZ60EUvWowesEoWQUcA+eU9JLbtMNdKyMQ8CN0sIJqOwTbT5VSlAuJuD27d54h/MwFyJ2DPcNXq6+7YH6OWXErB47rBcioBlwZhTA9Gaqkj5RF2evDb2tjvbDWHmMeHq7ko0jEbusmokBfhYSPXRUdajBwwuRiHx5eH7TAB93zjppULETg2f2E5mYbf8vr2rWT9cAQ/IZqOYKnunBeAzaHajFz42oD2+QIv49LjwNHnBM6D1r6j2MiN1H565RyOj7MwuvxYe7w8JOTDdngK6zhNedGUVhgWNRNGrouOtBg5YK8PUEYptQnngRHb6QTWTJ0jysh4HQgZorh+uplbgCVwaL1EIHQFw2oUcb+tDa7GOuULNxwxEw4zESz1WaCM3Eg93C9LFdwVbhALHKC0lkTKr01KrBQ2Pekyai10B1glH4fPcwJpNYFUtyhTD/92D263zpF0mRv1VhOwK+NnTFX/4h7A9OohToNLr1KjRnT8ja+n5/D2ea3ryUitg5SLiDs3cHJX/8sCtpJxuC193iRKyWqO040uOtBiqIBV8pe4KUqtz5y2foN9/unwZZRzRwj4zlD+dxuJ8Bpab71IhS7hcezCsHeNuL1ZWTwBVgMWvkfxP+MxfEclLO+lELG/DIGPdZjzANOHPxHrM4SNykhv6yihXKqiJpVweRTASXEZ0fNI91pWEBylw0ely+vnG70WQwRMRjHuwsbJ39ZnWrfTSDzmgBKKF2H49n9h6useYvVmR6/GV+kCbuf+S0CagN0sNgt6uYiUbwMH+UXsnEfxrX2xchPQ6DXiXTsoSm00qv9E9Fs6vnz2en3r2jiBWYPLRLkqo9Ll7ScclRZDBKyXADKKqQA2DvKwbsWx57a+3fGqZOFdCaC2k0ai3kFsSxHb2/Ry6QI+5z7yCz9wmnC1iny5eIzNjf8wl8ggbO0vddLPTQ1I+TCcngLWT1NtzaIYnJsXsCQyiPS513ECTE9ajBwwuZiCZ+MAfz5/xQ93e2fPANOiHdbO/rJcxLFrA2fWtu+8XrXpH6lD+TIA5+5vzH5P4NjbWLvegVwJ3GMnncATnyLmeUswtetoMq+SQ9jpw9X8Dxxu22CSCriIhXB2t4rEeRBD5Gv0//MHHWkxYsBkFI83sXH0/BXz8wNN4Wsyg/CrNr2MQtyJzezyc/u5K2D1lcrIBJ0I3RixeniK4NIn5MNOeEr/w3lire9fdOgpgtV3KxVS2A8e4OaxwQEYFlaxE/bC/uLXLZrg/OYietBFL1qMGDB1h91oVFzAmkzB2+V7sp6rSvVbPoja9jkifdZf9c/Qg5Fe71WGVK5CMhhhmukvBVZ3OnrSZfRajCVgj1+iRlwI3vtxGlH+K4XypQfOs0Ukk25NvnjVJ2BqsdBuHnXpruWIfouo8mArOUR8JzDtHLaK+jdXkvKIeeKY3tbueyEaSZmRVJ7wxE0bL8B0ID8BI2AiNiRgImrptgYT3MQAhvPiUXbxDPffgw3goAe9JI2kzEiDPodxWZ8RTPCkCBgBE7EMARNRiyliT7V48Si7eJgivgMcjaTMSIL31sQOZwQTPFoCRsBELEPARNRiisgUsU+/MEVkiihoocZwRnZlkZ2AETACpkoBAqaJbLyplRlJE7EnYBHWYIKHSMAImIhlCJiIWqw12OTo0y+swViDCVqITY63BGMEE7QTU0SmiCKWIWAiajFFZIrYp1+YIjJFFLQQU0SmiKosw1RIRDamzsr8wgjGCCbCVWssASNgqozTOYlGUmYkTcSegEXY5BA8RAJGwEQsQ8BE1GIXkV3EPv3CGow1mKCF2EVkF1GVZZgKicjG1FmZXxjBGMFEuGIXUdAvBExQMFVunMBJjGB9RLAJ9AO3RAWGrsDDwwO6RrChPwk/kApMoAIEbAIPlVvSjwI9Aau/wRfb0SLtaPqlu1/Y5GCTQxUbbHL00eRgBHsWj0ZSZiRVlE7gJP5USvBQCRgBE7EMARNRi79F7KkWLx5lFw9rMNZgglcOmz8izR8CRsAImCoFGME0kY2pkDIjaSL2BCzCGkzwEAkYAROxDAETUYtNDjY5+vQLazDWYIIWYpODTQ5VlmEqJCIbU2dlfmEEYwQT4ao1loARMFXG6ZxEIykzkiZiT8AibHIIHiIBI2AiliFgImqxi8guYp9+YQ3GGkzQQuwisouoyjJMhURkY+qszC+MYIxgIlyxiyjoFwImKJgqN07gJEYwRjBNbE0jKTOSJmJPwCLsIgoeIgEjYCKWIWAiarFNzzZ9n35hDcYaTNBCbNOzTa/KMkyFRGRj6qzML4xgjGAiXLFNL+gXAiYomCo3TuAkRrBxj2CyhHJV6tiFAdOmGXwaomH1ZCSpmEfJuACLqUMBuYLi7V/cYxqf58yYGYJAetKlboee2gzRK/WPGpsuopQLwu67Qe2FQMtI/IzAahyeanoxkly6RNC1i6o/jeM1U0uA+t93Pbu4qTb/9Pkr9uLbsHdCqLFketGlvq1e2mi8ZUXLjQlgMkrHm3Aez2I74oK5dSNPYc46jyHy9epGUqSypoNklPMXiPkP8OseWNhuA0wu4cLjxD62kIiuY6GWx5HXhzPTHtJxO54x1PSBHhfTB2BvaKP9lhWtOCaAVZD1ryBQ28N13I4ZRVsbzKBRG6mc8cMR+oXP/y4Dv25gbANMLqWw6TyA+fAakaWGSpWsHyuBe+ykE/g2QMJGrUt9r29pMxg3vL/qeAAmFxF3buDEuIxlYwnFigHmpTW4v3+DZci0jdpIlUIGf2DFovkWwS8+VNsAq6fRX3wl/DhPwtUM83IxDtfGFazJNIKWwRVjo9bl8TJ5Q5v3URjMiPEArJKBdyWE39OLWP1ug7lWwNXRFW4XtnCacGN+cL55pboejPT4UFIO/g7AKhkvVkK1F9GqHtU8zgOYEj8RGWCxqhtdemgzGHzeX1V3gFXyl7gpPncLp63fYDdLKORLgNna6phVcmE4fTewJTIID9A4nRIOy0hddZhvqza7AZb1YiVAwLpdPu+jMJgROgNMRjHuwsbJ39ZurdtpJNq6ZK03yhl4HCFgJ43EIIuLDt2HA5gCHboAJuXDsHtusdWRIjo3rrD4AVLE1lF10WYw+Ly/qs4A6/7AUj4Ct/cPbMkkvM18UC7E4dw8g/Uwg/DS8PqIwwHs/YPrekuXL+Fx7GIqeo2YrVGcli89cOwasHcdh32A9apudGGKqMA8nUMqWQQdAWStW4j6l2GSCrjYD+FM/o7ksReW4fGlk3Z09xoMKCPjdyJ0u4ydiBuWWh7/BfeRs0ZxHrENtPtKwLr7eiwi2GOHKJ/CfvgAv+4aGzEsrGMnvAX785diKsgVn6IbI/VKgyo5xEMBnOQbX8lPWbcQ23PDOsDoVf8c3ejCCCZu6ucZMirlKmoGI0wzQwxbbY+sKyO9IaVUKUPC8HQaF136cZ+auWMTwdRsbhBzaCRlqdAgtB/HNQmY4KkRMAImYhkCJqKW3moNwWcf5HBePMouHv57sHdcSCMpM9IgYR6ntRnBBE+LgBEwEcsQMBG1mCL2VIsXj7KLhykiU0TBK6cxnIARMFXG6ZxEIykzkiZiT8AiTBEFD5GAETARyxAwEbWYCrEG69MvrMFYgwlaiDXYW4IxggnaiSkiU0QRyxAwEbWYIjJF7NMvTBGZIgpaiCkiU0RVlmEqJCIbU2dlfmEEYwQT4ao1loARMFXG6ZxEIykzkiZiT8AibHIIHiIBI2AiliFgImqxi8guYp9+YQ3GGkzQQuwisouoyjJMhURkY+qszC+MYIxgIlyxiyjoFwImKJgqN07gJEYwRjBNbE0jKTOSJmJPwCLsIgoeIgEjYCKWIWAiarFNzzZ9n35hDcYaTNBCbNOzTa/KMkyFRGRj6qzML10jmIjQHEsFqEB3BR4eHkDA6A4qMCAFCNiAhOWyVKCuQE/A6m/wxWJepJinX7r7hV1EdhFVscEmRx9NDkawZ/FoJGVGUkXpBE7iF82Ch0rACJiIZQiYiFr8JUdPtXjxKLt4WIOxBhO8ctj8EWn+EDACRsBUKcAIpolsTIWUGUkTsSdgEdZggodIwAiYiGUImIhabHKwydGnX1iDsQYTtBCbHGxyqLIMUyER2Zg6K/MLIxgjmAhXrbEEjICpMk7nJBpJmZE0EXsCFmGTQ/AQCRgBE7EMARNRi11EdhH79AtrMNZgghZiF5FdRFWWYSokIhtTZ2V+YQRjBBPhil1EQb8QMEHBVLlxAicxgjGCaWJrGkmZkTQRewIWYRdR8BAJGAETsQwBE1GLbXq26fv0C2sw1mCCFmKbnm16VZZhKiQiG1NnZX5hBGMEE+GKbXpBvxAwQcFUuXECJzGCjVkEk4p5lIwLsJg+vXxyuYLi7V/cYxqf58yY6Xh70N4dmZGkMoq3d6hNzcI8b4Kxc6OTrossoVyVOnZtwLRpBr0tIKGYzaE6Z8OSqYZSoYRXK0zPwvy0hlRCNleG2bYEs0a+0mUXUS5dIujaRdWfxvGaqSVq/e+7nl3cVJt/+vwVe/Ft2DshHCBlowCskosj4DvBn6d9za1iL+pv7fsj6CLlgrD7blB7cbbLSPyMwPrqtmkMquQi2NwHwqkgrIYCYo5NnD15p32dhXVEI1uwmSRkghs4mY0i4bW8vsRU+EpngMko5y8Q8x/g1z2wsN0GmFzChceJfWwhEV3HQi2PI68PZ6Y9pON2PGOoQgWBKUMHTMoj7PTgt3UPiR07Zqs5xDw+XM1FkY7ZMPMhdJFROt6E83gW2xFXW3SZwpx1vjsIUgFxtwe37nPEv5kAuQnY3B5Otxvw1Go1SMUL7IfOUFqOIh2xwVhKweO6wXIqAZcGYUxXgJUzfjhCv/D532Xg1w2MbYDJpRQ2nQcwH14jsjTTuKGyfqwE7rGTTqCu4TBeQwesnMPxcRZGlx9rjwcuIR+2w1NYx2nKC/PdR9Clgqx/BYHaHq7jdjRO/+1X3RuO4CdE0xE82uUJMGsCPyPWNigl5Pxf4PuzimQ6CMunMi49Dhx9TuA82D7uvU8cgxqsUsjgD6xYNN8i+MWHahtg9RThi6+EH+fJ1s0iF+NwbVzBmkwjaNEoaX5Hx6ED1vY8slTBXeEGscABSmtJpPwW4CPoIhcRd27gxLiMZWMJxYoB5qU1uL9/g6UrbWVkvA6EDFFc16N8XcNegMllXHgc2Je+P15Y85+A8oUbjpgJh5kIlnqkn0px01UEaz20lIO/A7BKxouVUO1FtKpHNY/zAKbET0R6JeJKlVA4bmSAPZnsrv6gC9hKxuG2GPEhdKlk4F0J4ff0Ila/22CuFXB1dIXbhS2cJtyPULx41dNquwe3W+dIusyNJsgTYFOr2Fozw1D/W62KUv4K//e7CuuPcxw2x8qFCBybv/H19BzeV4srNEpz2PgAlvViJfCBAYOEcqmKmlTC5VEAJ8VlRM8jWPgzWbpU8pe4KT73+qat32A3SyjkS4DZ2uoqV3JhOH03sCUyCHderuVLeBy7MOxdI25vhrgnwKqAwfCIFwzGaZjMFix+Xcf6N0sr9Xy6uKcPfyLWZwgbG8CkfBh2zy22OlJE58YVFj9Iivh0dzZS4xOYD38i/Ck2QbrIKMZd2Dj52woT1u00Em2d5NYb5Qw8jhCwk0aiswAvXcDt3McLQHrWYF0i0hOg0WvEbUoqvt5RbWwAQ3PTU9FrxJqbLl964Ng1YO86jqeLSiyAi48edopYv1icngLWT1NwN9MVuRCDc/MClkQGkdns4209ybpI+Qjc3j+wJZOtlE0uxOHcPIP1MINwZ5SpZOFdCaDWDp8AYHLxGJsb/2GuW3QUtMz4AIYyMn4nQrfL2Im4Yanl8V9wHzlrFOeRZiEruHk1w4cNGCo5hJ0+XM3/wOG2DSapgItYCGd3q0icB2E1fgBdKlkEHQFkrVuI+pcbGuyHcCZ/R/LYC0tnI0Iu4ti1gTNrEumg5WUN9qqL+NoFWnanxwiwx28OEQ8FcJJvfN04Zd1CbM8Na39RXIizoQNWb8wXUtgPHuDmscEBGBZWsRP2wm5uOusD6FLJp7AfPsCvlgbr2Alvwd71uyoZhbgTm9nlVmewd5u+8/jrX4M44Sn9D+eJtb5/0aFPwN6xvFQpQ4IRppk+e6hCaDUGjwKwxifLkMpVSIbe+558XWRUylXU3tCgVac+dpgvYE2m4BX5CkeqZwxB1LbPEemz/urmF/7Y9x3oRgeYittgiFP0p4uEfMSF4L0fpwIlRL2ud54tIpns0v5XoedYRjAV+9Rsiv6MpNnW+lpIl7pUcoj4TmDaOWw1iN7cpJRHzBPH9HbjO0YtXgRMUEVdGklwD4MYTl26q0rABN1GIykzkqCsEzucgAkeLQEjYCKWIWAiao20iyj4oEMezotH2cXDLiK7iKrQJGAETJVxOifRSMqMpInYE7AIU0TBQyRgBEzEMgRMRC3WYD3V4sWj7OJhDcYaTPDKaQwnYARMlXFYgymTjYARMGVOYQRTpRMBI2CqjMMIpkw2AkbAlDmFEUyVTgSMgKkyDiOYMtkIGAFT5hRGMFU6ETACpso4jGDKZCNgBEyZUxjBVOlEwAiYKuMwgimTjYARMGVOYQRTpRMBI2CqjMMIpkw2AkbAlDmFEUyVTgSMgKkyDiOYMtkIGAFT5hRGMFU6ETACpso4jGDKZCNgBEyZUxjBVOlEwAiYKuMwgimTjYD1AZgyiTmKClCBtxR4eHhA1/9kAGWjAlSgfwUIWP8acgUq0FOBF4BRJypABbRX4P8ByPremdZWpuYAAAAASUVORK5CYII=" alt="img" />

<strong>Notes:</strong>
<ul>
    <li>The knight's health has no upper bound.</li>
    <li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li>
</ul>
</blockquote>

使用二分搜索+DP. 单纯的二维DP是不行的, 因为这道题要求从起点到终点的路径中每个格子的值都不能小于1. 有可能出现终点时生命值大于0但是每一条路径实际上都无法抵达.

但是我们可以使用DP来判断一个特定初始生命值的knight能否救到princess. 然后在外层使用二分搜索来找到最小的初始生命值. 虽然可以用<code>0~INT_MAX</code>作为搜索范围, 但是先找出初始生命值为0时每一条路径中出现的最小的生命值可以大大缩小这个范围, 实际上如果初始生命值为0时, 所有的格子中生命值都是大于1的, 可以直接返回1; 否则搜索范围的最大值就是最小生命值的绝对值加1.

<pre lang="c++">class Solution {
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {
        if (dungeon.empty()) return 0;
        if (dungeon[0].empty()) return 0;
        int tmp = minInPath(dungeon);
        if(tmp &gt; 0) return 1;
        int left = 0, right = -tmp + 1, mid = (right + left) / 2;
        while (left &lt; right) {
            int h = canArrive(dungeon, mid);
            if(h == 1){
                break;
            }
            else if (h &lt; 1) {
                left = mid + 1;
            }
            else {
                right = mid;
            }
            mid = (right + left) / 2;
        }
        return mid ? mid : 1;
    }

    int canArrive(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon, int target) {
        int row = dungeon.size(), col = dungeon[0].size();
        vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0));
        dp[0][0] = target + dungeon[0][0];
        for (int i = 1; i &lt; col; i++) {
            if (dp[0][i - 1] &gt; 0) dp[0][i] = dp[0][i - 1] + dungeon[0][i];
        }
        for (int i = 1; i &lt; row; i++) {
            if (dp[i - 1][0] &gt; 0) dp[i][0] = dp[i - 1][0] + dungeon[i][0];
        }
        for (int i = 1; i &lt; row; i++) {
            for (int j = 1; j &lt; col; j++) {
                if(dp[i - 1][j] &gt; 0 || dp[i][j - 1] &gt; 0)
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + dungeon[i][j];
            }
        }
        return dp[row - 1][col - 1];
    }
    
    int minInPath(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon){
        int row = dungeon.size(), col = dungeon[0].size(), minInPath = INT_MAX;
        vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0));
        dp[0][0] = dungeon[0][0];
        minInPath = min(minInPath, dp[0][0]);
        for (int i = 1; i &lt; col; i++) {
            dp[0][i] = dp[0][i - 1] + dungeon[0][i];
            minInPath = min(minInPath, dp[0][i]);
        }
        for (int i = 1; i &lt; row; i++) {
            dp[i][0] = dp[i - 1][0] + dungeon[i][0];
            minInPath = min(minInPath, dp[i][0]);
        }
        for (int i = 1; i &lt; row; i++) {
            for (int j = 1; j &lt; col; j++) {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + dungeon[i][j];
                minInPath = min(minInPath, dp[i][j]);
            }
        }
        return minInPath;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>934</wp:post_id>
		<wp:post_date><![CDATA[2016-11-01 18:40:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-01 10:40:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-174-dungeon-game]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 179. Largest Number</title>
		<link>http://xiadong.info/2016/11/leetcode-179-largest-number/</link>
		<pubDate>Tue, 01 Nov 2016 10:55:20 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=936</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a list of non negative integers, arrange them such that they form the largest number.

For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.

Note: The result may be very large, so you need to return a string instead of an integer.</blockquote>

这是一个排序问题, 只要能判断两个数的先后顺序, 那就可以通过比较排序得到最后的有序序列. 对于两个int数据<code>a</code>, <code>b</code>, 把它们以<code>ab</code>和<code>ba</code>两种形式存储在<code>long long</code>中, 就可以通过直接的比较大小来判断顺序.

<pre lang="c++">class Solution {
public:
    string largestNumber(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end(), [=](int a, int b){
            long long ab = func(a, b), ba = func(b, a);
            return ab &gt; ba;
        });
        string re;
        for(int i = 0; i &lt; nums.size(); i++){
            re += to_string(nums[i]);
        }
        auto iter = re.begin();
        for(; iter != re.end() &amp;&amp; (*iter) == '0'; iter++);
        if(iter == re.end()) return string("0");
        else return string(iter, re.end());
    }
    
    long long func(int a, int b){
        if(b == 0) return a * 10;
        long long re = a;
        int t = b;
        while(t &gt; 0) {
            re *= 10;
            t /= 10;
        }
        return re + b;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>936</wp:post_id>
		<wp:post_date><![CDATA[2016-11-01 18:55:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-01 10:55:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-179-largest-number]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 435. Non-overlapping Intervals</title>
		<link>http://xiadong.info/2016/11/leetcode-435-non-overlapping-intervals/</link>
		<pubDate>Wed, 02 Nov 2016 09:10:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=938</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
<strong>Note:</strong>
<ol><li>
You may assume the interval&#39;s end point is always bigger than its start point.</li>
<li>
Intervals like [1,2] and [2,3] have borders &quot;touching&quot; but they don&#39;t overlap each other.</li>
</ol>
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [ [1,2], [2,3], [3,4], [1,3] ]

Output: 1

Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [ [1,2], [1,2], [1,2] ]

Output: 2

Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
</pre>
<strong>Example 3:</strong>
<pre lang='undefined'>
Input: [ [1,2], [2,3] ]

Output: 0

Explanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.
</pre>
</blockquote>

先对区间按照左端点值, 右端点值的优先级从小到大排序, 然后从前到后依次处理. 对于前后两个区间a和b(它们并不一定相邻)来说, 有两种可能的情况:

<ol><li>
两个区间没有重叠. 这样的话b之后的区间也不可能与a有重叠, 不需要做处理.</li>
<li>
两个区间有重叠. 这又分两种情况: 1. a完全&quot;盖住&quot;了b; 2. a没有完全&quot;盖住&quot;b. 对于前者, 应该移除的是a区间, 因为a比b要&quot;大&quot;, 之后的区间如果与b有重叠则一定与a有重叠, 但是与a有重叠不一定与b有重叠. 对于后者, 应该移除区间b, 因为与a有重叠则必然与b有重叠, 但是与b有重叠不一定与a有重叠.</li>
</ol>

a应该始终保存上一个没有被移除的区间.

<pre lang='c++'>
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    int eraseOverlapIntervals(vector&lt;Interval&gt;&amp; intervals) {
        int ans = 0;
        if(intervals.empty()) return 0;
        sort(intervals.begin(), intervals.end(), [&amp;](Interval &amp;a, Interval &amp;b){
            if(a.start == b.start){
                return a.end &lt; b.end;
            }
            return a.start &lt; b.start;
        });
        int p = 0;
        for(int i = 1; i &lt; intervals.size(); i++){
            if(overlap(intervals[p], intervals[i])){
                if(intervals[i].end &lt; intervals[p].end){
                    p = i;
                }
                ans++;
            }
            else{
                p = i;
            }
        }
        return ans;
    }
    
    bool overlap(Interval &amp;a, Interval &amp;b){
        return !(a.start &gt;= b.end || a.end &lt;= b.start);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>938</wp:post_id>
		<wp:post_date><![CDATA[2016-11-02 17:10:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-02 09:10:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-435-non-overlapping-intervals]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 436. Find Right Interval</title>
		<link>http://xiadong.info/2016/11/leetcode-436-find-right-interval/</link>
		<pubDate>Wed, 02 Nov 2016 09:48:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=940</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.

For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.

<strong>Note:</strong>
<ol>
    <li>You may assume the interval's end point is always bigger than its start point.</li>
    <li>You may assume none of these intervals have the same start point.</li>
</ol>
<strong>Example 1:</strong>
<pre lang="undefined">Input: [ [1,2] ]

Output: [-1]

Explanation: There is only one interval in the collection, so it outputs -1.
</pre>
<strong>Example 2:</strong>
<pre lang="undefined">Input: [ [3,4], [2,3], [1,2] ]

Output: [-1, 0, 1]

Explanation: There is no satisfied "right" interval for [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point;
For [1,2], the interval [2,3] has minimum-"right" start point.
</pre>
<strong>Example 3:</strong>
<pre lang="undefined">Input: [ [1,4], [2,3], [3,4] ]

Output: [-1, 2, -1]

Explanation: There is no satisfied "right" interval for [1,4] and [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point.
</pre>
</blockquote>

使用排序+二分搜索. 要注意记录排序之前每个interval的下标.

<pre lang="c++">/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; findRightInterval(vector&lt;Interval&gt;&amp; intervals) {
        vector&lt;pair&lt;int, int&gt;&gt; maps(intervals.size());
        for(int i = 0; i &lt; intervals.size(); i++){
            maps[i].first = intervals[i].start;
            maps[i].second = i;
        }
        
        sort(maps.begin(), maps.end(), [&amp;](pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b){
            return a.first &lt; b.first;
        });
        
        vector&lt;int&gt; ans(intervals.size());
        for(int i = 0; i &lt; intervals.size(); i++){
            int target = intervals[i].end;
            ans[i] = binSearch(maps, 0, target);
        }
        return ans;
    }
    
    int binSearch(vector&lt;pair&lt;int, int&gt;&gt; &amp;m, int begin, int target){
        int left = begin, right = m.size(), mid = (left + right) / 2;
        while(left &lt; right){
            if(m[mid].first == target){
                return m[mid].second;
            }
            else if(m[mid].first &lt; target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
            mid = (left + right) / 2;
        }
        return -1;
    }
};
</pre>

或者可以使用hash表.

<pre lang="c++">/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; findRightInterval(vector&lt;Interval&gt;&amp; intervals) {
        unordered_map&lt;int, int&gt; maps;
        for(int i = 0; i &lt; intervals.size(); i++){
            maps[intervals[i].start] = i;
        }
        vector&lt;int&gt; ans(intervals.size());
        for(int i = 0; i &lt; intervals.size(); i++){
            ans[i] = maps.count(intervals[i].end) ? maps[intervals[i].end] : -1;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>940</wp:post_id>
		<wp:post_date><![CDATA[2016-11-02 17:48:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-02 09:48:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-436-find-right-interval]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 419. Battleships in a Board</title>
		<link>http://xiadong.info/2016/11/leetcode-419-battleships-in-a-board/</link>
		<pubDate>Fri, 04 Nov 2016 08:06:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=943</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given an 2D board, count how many different battleships are in it. The battleships are represented with <code>&#39;X&#39;</code>s, empty slots are represented with <code>&#39;.&#39;</code>s. You may assume the following rules:
<ul><li>
You receive a valid board, made of only battleships or empty slots.</li>
<li>
Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or<code>Nx1</code> (N rows, 1 column), where N can be of any size.</li>
<li>
At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>
</ul>
<strong>Example:</strong>
<pre lang='undefined'>
X..X
...X
...X
</pre>
In the above board there are 2 battleships.
<strong>Invalid Example:</strong>
<pre lang='undefined'>
...X
XXXX
...X
</pre>
This is an invalid board that you will not receive - as battleships will always have a cell separating between them.
<strong>Follow up:</strong>
Could you do it in <strong>one-pass</strong>, using only <strong>O(1) extra memory</strong> and <strong>without modifying</strong> the value of the board?
</blockquote>

这道题题目中举的invalid的例子是不会作为输入数据的, 所以不需要对它进行判断. 最直接的方法就是遍历数组, 然后<del>找舰娘(雾)/老婆(大雾)</del>在遇到一个X的时候计数器加1, 并把与它相邻接的所有X清除以防止重复计算. 

但是Follow up中是要求不修改原数组的. 对于横向的战舰只要直接跳过就可以了, 因为一般都是按行=&gt;列的方式来遍历. 而对于纵向的战舰, 则要判断它上方是否有X, 如果有的话说明这艘战舰已经计算过了, 不应该重复计算.

<pre lang='c++'>
class Solution {
public:
    int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        int ans = 0;
        int row = board.size();
        if(board.empty()) return ans;
        int col = board[0].size();
        for(int i = 0; i &lt; row; i++){
            for(int j = 0; j &lt; col; j++){
                if(board[i][j] == &#39;X&#39;){
                    if(i &gt; 0 &amp;&amp; board[i - 1][j] == &#39;X&#39;){
                        continue;
                    }
                    ans++;
                    if(j &lt; col - 1 &amp;&amp; board[i][j + 1] == &#39;X&#39;){
                        for(; j &lt; col &amp;&amp; board[i][j] == &#39;X&#39;; j++) board[i][j] = &#39;.&#39;;
                        j--;
                    }
                }
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>943</wp:post_id>
		<wp:post_date><![CDATA[2016-11-04 16:06:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-04 08:06:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-419-battleships-in-a-board]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 187. Repeated DNA Sequences</title>
		<link>http://xiadong.info/2016/11/leetcode-187-repeated-dna-sequences/</link>
		<pubDate>Fri, 04 Nov 2016 09:39:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=945</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: &quot;ACGAATTCCG&quot;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.
Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.
For example,
<pre lang='undefined'>
Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,

Return:
[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].
</pre>
</blockquote>

因为序列长度是固定的十位, 所以如果把A, C, G, T对应到1, 2, 3, 4的数字的话, 十位的字符串可以映射到一个整数. 然后就可以用hash表来记录是否出现过相同的字符串.

<pre lang='c++'>
class Solution {
public:
    vector&lt;string&gt; findRepeatedDnaSequences(string s) {
        vector&lt;string&gt; re;
        if(s.size() &lt;= 10) return re;
        unordered_map&lt;unsigned int, int&gt; tSet;
        for(int i = 0; i &lt;= s.size() - 10; i++){
            string str = s.substr(i, 10);
            unsigned int t = strToInt(str);
            if(tSet.count(t)){
                if(tSet[t] == 1) re.push_back(str);
            }
            tSet[t]++;
        }
        return re;
    }
    
    unsigned int strToInt(string s){
        unsigned int re = 0;
        for(int i = 0; i &lt; 10; i++){
            re *= 5;
            re += charToNum(s[i]);
        }
        return re;
    }
    
    unsigned int charToNum(char c){
        if(c == &#39;A&#39;) return 1;
        else if(c == &#39;C&#39;) return 2;
        else if(c == &#39;G&#39;) return 3;
        else return 4;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>945</wp:post_id>
		<wp:post_date><![CDATA[2016-11-04 17:39:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-04 09:39:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-187-repeated-dna-sequences]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 421. Maximum XOR of Two Numbers in an Array</title>
		<link>http://xiadong.info/2016/11/leetcode-421-maximum-xor-of-two-numbers-in-an-array/</link>
		<pubDate>Sat, 05 Nov 2016 10:05:20 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=947</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a <strong>non-empty</strong> array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &lt; 231.
Find the maximum result of ai XOR aj, where 0 ≤ <em>i</em>, <em>j</em> &lt; <em>n</em>.
Could you do this in O(<em>n</em>) runtime?
<strong>Example:</strong>
<pre lang='undefined'>
Input: [3, 10, 5, 25, 2, 8]

Output: 28

Explanation: The maximum result is 5 ^ 25 = 28.
</pre>
</blockquote>

这道题是使用递归的方法. 先找到出现不同的最高位, 然后按照该位是0还是1分为两类, 接下来处理下一位, 这时可以把数字分为4类, 分别以<code>00</code>, <code>01</code>, <code>10</code>和<code>11</code>开头, 最大的异或值会出现在<code>00</code>与<code>11</code>, <code>01</code>与<code>10</code>两种组合中, 递归地处理接下来的位数.

有可能出现<code>00</code>与<code>11</code>, <code>01</code>与<code>10</code>两种组合中每个组合都至少有一种分类是空的, 这个时候说明该位不可能为1, 只能为0, 可以用循环跳过这些位.

<pre lang='c++'>
class Solution {
public:
    int findMaximumXOR(vector&lt;int&gt;&amp; nums) {
        list&lt;int&gt; one, zero;
        int pos;
        for(pos = 31; pos &gt;= 0; pos--){
            // 找到有不同的最高位
            one.clear();
            zero.clear();
            for(auto i : nums){
                if(i &amp; (1 &lt;&lt; pos)) one.push_back(i);
                else zero.push_back(i);
            }
            if(!one.empty() &amp;&amp; !zero.empty()) break;
        }
        if(one.empty() || zero.empty()) return 0;
        
        return (1 &lt;&lt; pos) + findXORHelper(zero, one, pos - 1);
    }
    
    int findXORHelper(list&lt;int&gt; &amp;zero, list&lt;int&gt; &amp;one, int pos){
        if(pos &lt; 0) return 0;
        list&lt;int&gt; zeroZero, zeroOne, oneZero, oneOne;
        
        for(; pos &gt;= 0; pos--){
            // 跳过只能为0的位
            zeroZero.clear();
            zeroOne.clear();
            oneZero.clear();
            oneOne.clear();
            
            for(auto i : zero){
                if(i &amp; (1 &lt;&lt; pos)) zeroOne.push_back(i);
                else zeroZero.push_back(i);
            }
            for(auto i : one){
                if(i &amp; (1 &lt;&lt; pos)) oneOne.push_back(i);
                else oneZero.push_back(i);
            }
            // 该位可以为1
            if(!((zeroZero.empty() || oneOne.empty()) &amp;&amp; (oneZero.empty() || zeroOne.empty()))) break;
        }
        // 所有位数都处理完毕
        if(pos &lt; 0) return 0;
        
        return (1 &lt;&lt; pos) + max(findXORHelper(zeroZero, oneOne, pos - 1), findXORHelper(oneZero, zeroOne, pos - 1));
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>947</wp:post_id>
		<wp:post_date><![CDATA[2016-11-05 18:05:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-05 10:05:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-421-maximum-xor-of-two-numbers-in-an-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 437. Path Sum III</title>
		<link>http://xiadong.info/2016/11/leetcode-437-path-sum-iii/</link>
		<pubDate>Sat, 05 Nov 2016 10:28:51 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=949</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>You are given a binary tree in which each node contains an integer value.
Find the number of paths that sum to a given value.
The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.
<strong>Example:</strong>
<pre lang='undefined'>
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11
</pre>
</blockquote>

这道题用很直接的遍历方法就可以AC, 所以才会是Easy. 我还想了很久有没有O(n)或者O(nlogn)的办法......

对于每一棵子树, 都计算从根节点开始的路径和有没有等于sum的, 这一步用DFS遍历所有路径. 然后递归地处理左子树和右子树.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int ans = 0;
public:
    int pathSum(TreeNode* root, int sum) {
        if(!root) return 0;
        DFS(root, sum);
        pathSum(root-&gt;left, sum);
        pathSum(root-&gt;right, sum);
        return ans;
    }
    
    void DFS(TreeNode *node, int target){
        if(!node) return;
        target -= node-&gt;val;
        if(0 == target) ans++;
        DFS(node-&gt;left, target);
        DFS(node-&gt;right, target);
        target += node-&gt;val;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>949</wp:post_id>
		<wp:post_date><![CDATA[2016-11-05 18:28:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-05 10:28:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-437-path-sum-iii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 447. Number of Boomerangs</title>
		<link>http://xiadong.info/2016/11/leetcode-447-number-of-boomerangs/</link>
		<pubDate>Mon, 07 Nov 2016 02:29:12 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=951</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given <em>n</em> points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code>and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<strong>the order of the tuple matters</strong>).

Find the number of boomerangs. You may assume that <em>n</em> will be at most <strong>500</strong> and coordinates of points are all in the range <strong>[-10000, 10000]</strong>(inclusive).

<strong>Example:</strong>
<pre lang="undefined">Input:
[[0,0],[1,0],[2,0]]

Output:
2

Explanation:
The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
</pre>
</blockquote>

<del>这道题似乎还没有什么好解法, 现在Runtime1368ms都可以beats 100%的C++提交......</del>
现在已经不是了, 1000多ms的Runtime算是比较慢啦, 但是我暂时还没有时间来搞这道题......

使用双重循环+哈希表. 如果认为unordered_map的查询复杂度是O(1), 总体复杂度是O(n^2).

<pre lang="c++">class Solution {
public:
    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {
        int ans = 0;
        for(int i = 0; i &lt; points.size(); i++){
            unordered_map&lt;long long, int&gt; distance;
            for(int j = 0; j &lt; points.size(); j++){
                if(j == i) continue;
                long long d = getDistance(points[i], points[j]);
                if(distance.count(d)){
                    ans += 2 * distance[d];
                }
                distance[d]++;
            }
        }
        return ans;
    }
    
    long long getDistance(pair&lt;int, int&gt; &amp;p1, pair&lt;int, int&gt; &amp;p2){
        return (long long)(p1.first - p2.first) * (long long)(p1.first - p2.first) 
             + (long long)(p1.second - p2.second) * (long long)(p1.second - p2.second);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>951</wp:post_id>
		<wp:post_date><![CDATA[2016-11-07 10:29:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-07 02:29:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-447-number-of-boomerangs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 452. Minimum Number of Arrows to Burst Balloons</title>
		<link>http://xiadong.info/2016/11/leetcode-452-minimum-number-of-arrows-to-burst-balloons/</link>
		<pubDate>Mon, 07 Nov 2016 03:00:20 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=953</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it&#39;s horizontal, y-coordinates don&#39;t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.
An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.
<strong>Example:</strong>
<pre lang='undefined'>
Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2

Explanation:
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
</pre>
</blockquote>

基本思路是每次尽可能多的刺破气球, 所以一开始从最左边的气球的右边缘发射一支箭, 否则最左边的气球就无法刺破了, 这样也能保证刺破尽可能多的气球. 

但是问题在于如何判断哪个气球在&quot;最左边&quot;, 不能以左边缘来进行判断, 因为有这种情况: <code>(1,10),(2,5)</code>, 第一支箭应该从<code>x=5</code>发出而不是<code>x=10</code>, 所以排序时应该使用每个气球的右边缘来进行排序.

<pre lang='c++'>
class Solution {
public:
    int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {
        if(points.empty()) return 0;
        sort(points.begin(), points.end(), [](pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b){
            return a.second &lt; b.second;
        });
        int ans = 1, arrow = points[0].second;
        for(int i = 1; i &lt; points.size(); i++){
            if(points[i].first &gt; arrow){
                ans++;
                arrow = points[i].second;
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>953</wp:post_id>
		<wp:post_date><![CDATA[2016-11-07 11:00:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-07 03:00:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-452-minimum-number-of-arrows-to-burst-balloons]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 453. Minimum Moves to Equal Array Elements</title>
		<link>http://xiadong.info/2016/11/leetcode-453-minimum-moves-to-equal-array-elements/</link>
		<pubDate>Mon, 07 Nov 2016 04:30:12 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=955</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a <strong>non-empty</strong> integer array of size <em>n</em>, find the minimum number of moves required to make all array elements equal, where a move is incrementing <em>n</em> - 1 elements by 1.
<strong>Example:</strong>
<pre lang='undefined'>
Input:
[1,2,3]

Output:
3

Explanation:
Only three moves are needed (remember each move increments two elements):

[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]
</pre>
</blockquote>

有很多种move的策略, 可以任意选择一种. 我的办法是:

<ol><li>
找到当前的最小值与最大值</li>
<li>
增加除了该最大值以外的其他元素, 直到最小值与最大值相等</li>
<li>
如果没有全部相等则回到第一步, 否则结束</li>
</ol>

这样的话总的move次数应该为每个元素与最小元素之差的和. 

<pre lang='c++'>
class Solution {
public:
    int minMoves(vector&lt;int&gt;&amp; nums) {
        int ans = 0, nMin = INT_MAX;
        for(auto i : nums){
            nMin = min(nMin, i);
        }
        for(auto i : nums){
            ans += (i - nMin);
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>955</wp:post_id>
		<wp:post_date><![CDATA[2016-11-07 12:30:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-07 04:30:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-453-minimum-moves-to-equal-array-elements]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 455. Assign Cookies</title>
		<link>http://xiadong.info/2016/11/leetcode-455-assign-cookies/</link>
		<pubDate>Wed, 16 Nov 2016 09:05:55 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=958</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
<strong>Note:</strong>
You may assume the greed factor is always positive. 
You cannot assign more than one cookie to one child.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
</pre>
</blockquote>

排序之后使用贪心来满足尽量多的孩子.

<pre lang='c++'>
class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int gi = 0, si = 0, ans = 0;
        while(si &lt; s.size() &amp;&amp; gi &lt; g.size()){
            if(g[gi] &lt;= s[si]){
                ans++;
                si++;
                gi++;
            }
            else{
                si++;
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>958</wp:post_id>
		<wp:post_date><![CDATA[2016-11-16 17:05:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-16 09:05:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-455-assign-cookies]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 459. Repeated Substring Pattern</title>
		<link>http://xiadong.info/2016/11/leetcode-459-repeated-substring-pattern/</link>
		<pubDate>Wed, 16 Nov 2016 11:08:27 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=960</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: &quot;abab&quot;

Output: True

Explanation: It&#39;s the substring &quot;ab&quot; twice.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: &quot;aba&quot;

Output: False
</pre>
<strong>Example 3:</strong>
<pre lang='undefined'>
Input: &quot;abcabcabcabc&quot;

Output: True

Explanation: It&#39;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)
</pre>
</blockquote>

这道题用最简单的遍历+回溯就可以AC

<pre lang='c++'>
class Solution {
public:
    bool repeatedSubstringPattern(string str) {
        for(int i = 1; i &lt;= str.length() / 2; i++){
            string sub = str.substr(0, i);
            if(check(str, sub)) return true;
        }
        return false;
    }
    
    bool check(string &amp;str, string &amp;sub){
        if(str.length() % sub.length() != 0) return false;
        for(int i = 0; i &lt; str.length(); i += sub.length()){
            if(!strEqual(str, i, sub)) return false;
        }
        return true;
    }
    
    bool strEqual(string &amp;str, int start, string &amp;sub){
        for(int i = 0; i &lt; sub.length(); i++){
            if(sub[i] != str[start + i]) return false;
        }
        return true;
    }
};
</pre>

Runtime 92ms, 不是好解法, 看Discussion有许多人用KMP, 但是我不太懂KMP(加入学习列表), 而且感觉有点大材小. 所以选择了另一种办法: 主要思路就是把字符串循环左移(右移), 当正好移出了要找的子串的时候, 这个字符串应该是跟原字符串相等的. 我们可以只考虑移动字符串长度因子的长度, 因为其他长度都是不可能相等的. 这个解法的Runtime是29ms.

<pre lang='c++'>
class Solution {
public:
    bool repeatedSubstringPattern(string str) {
        string nextStr = str;
        int len = str.length();
        if(len &lt; 1) return false;
        for(int i = 1; i &lt;= len / 2; i++){
            if(len % i == 0){
                nextStr = leftShift(str, i);
                if(nextStr == str) return true;
            }
        }
        return false;
    }
    
    string leftShift(string &amp;str, int l){
        string ret = str.substr(l);
        ret += str.substr(0, l);
        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>960</wp:post_id>
		<wp:post_date><![CDATA[2016-11-16 19:08:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-16 11:08:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-459-repeated-substring-pattern]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 456. 132 Pattern</title>
		<link>http://xiadong.info/2016/11/leetcode-456-132-pattern/</link>
		<pubDate>Thu, 17 Nov 2016 10:28:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=963</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence a<strong>i</strong>, a<strong>j</strong>, a<strong>k</strong> such that <strong>i</strong> &lt; <strong>j</strong> &lt; <strong>k</strong> and a<strong>i</strong> &lt; a<strong>k</strong> &lt; a<strong>j</strong>. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.
<strong>Note:</strong> n will be less than 15,000.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [1, 2, 3, 4]

Output: False

Explanation: There is no 132 pattern in the sequence.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [3, 1, 4, 2]

Output: True

Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
</pre>
<strong>Example 3:</strong>
<pre lang='undefined'>
Input: [-1, 3, 2, 0]

Output: True

Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
</pre>
</blockquote>

这道题一开始我用了最直接的O(n^2)时间复杂度的解法, 后来仔细想了一下后才想出O(n)复杂度的解法.

主要思路是使用栈, 从后往前遍历nums. 假如我们遍历到了元素[latex]a_k[/latex], 那么在继续往前遍历的过程中, [latex]a_k[/latex]有两种状态: 

<ol><li>
等待找到一个比[latex]a_k[/latex]大的元素[latex]a_j[/latex].</li>
<li>
如果找到了[latex]a_j[/latex], 那么[latex]a_k[/latex]就要等待找到一个比[latex]a_k[/latex]小的元素[latex]a_i[/latex].</li>
</ol>

问题在于[latex]a_j[/latex]与[latex]a_k[/latex]之间会有很多个其他元素, 这些元素一定比[latex]a_k[/latex]小或相等, 因此当出现[latex]a_j[/latex]的时候, [latex]a_{j+1} \cdots a_k[/latex]都会进入第二种状态, 对于[latex]a_k[/latex]之后的元素则仍然处于第一种状态. 可以用一个栈来保存处于第一种状态的元素, 出现[latex]a_j[/latex]时, 就弹出所有小于[latex]a_j[/latex]的元素, 并把这些元素都压入另一个栈中.

仔细想一想, 每次从第一个栈中弹出的元素都一定是有序的, 越接近栈顶越小, 如果按照出栈的顺序压入第二个栈中, 就是越接近栈顶的元素越大, 当我们遍历到另一个元素[latex]a_i[/latex]时, 只要它比第二个栈的栈顶元素小, 我们就可以确定函数返回true. 所以实际上我们并不需要第二个栈, 只要用一个变量来保存第一个栈中最后一个弹出的元素就可以了.

最后, 关于这个算法的复杂度. 首先遍历数组是O(n), 然后每一个数组中的元素都<strong>只有一次</strong>入栈和出栈的机会, 因此总的复杂度是O(n). 因为每个元素只能入栈一次, 所以我们可以一开始就设置栈的最大大小, 手动维护栈顶, 以避免栈大小动态增长过程中的开销.

<pre lang='c++'>
class Solution {
public:
    bool find132pattern(vector&lt;int&gt;&amp; nums) {
        if(nums.size() &lt; 3) return false;
        vector&lt;int&gt; waitGreater(nums.size());
        int maxWaitSmaller = INT_MIN, top = -1;
        for(int i = nums.size() - 1; i &gt;= 0; i--){
            if(top &lt; 0 || nums[i] &lt; waitGreater[top]){
                waitGreater[++top] = nums[i];
            }
            else if(nums[i] &gt; waitGreater[top]){
                while(top &gt;= 0 &amp;&amp; waitGreater[top] &lt; nums[i]){
                    top--;
                }
                maxWaitSmaller = waitGreater[top + 1];
                
                waitGreater[++top] = nums[i];
            }
            
            if(maxWaitSmaller != INT_MIN &amp;&amp; nums[i] &lt; maxWaitSmaller) return true;
        }
        return false;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>963</wp:post_id>
		<wp:post_date><![CDATA[2016-11-17 18:28:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-17 10:28:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-456-132-pattern]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 122. Best Time to Buy and Sell Stock II</title>
		<link>http://xiadong.info/2016/11/leetcode-122-best-time-to-buy-and-sell-stock-ii-2/</link>
		<pubDate>Fri, 18 Nov 2016 12:02:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=972</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.
Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.
<strong>Note:</strong>
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
</blockquote>

买卖股票系列题的第四弹......

这个问题用两个dp. <code>buy[i][k]</code>用来保存在<strong>至多</strong>进行k次交易的情况下, 第i天买入和不买入两种情况下的最大获利. <code>profit[i][k]</code>用来保存在至多进行k次交易的情况下, 卖出和不卖出两种情况下的最大获益. 

<code>buy[i][k]=max(buy[i-1][k], profit[i-1][k-1]-p)</code>

<code>buy[i][k-1]</code>表示第i天不买入的获益, <code>profit[i-1][k-1]-p</code>表示第i天买入的获益.

<code>profit[i][k]=max(profit[i-1][k], buy[i][k]+p)</code>

<code>profit[i-1][k]</code>表示第i天不发生交易的获益, <code>buy[i][k]+p</code>表示第i天发生了交易(买入或卖出)的获益.

另外, 在<code>2*k&gt;prices.size()</code>的时候, 应该就回到了<em>122. Best Time to Buy and Sell Stock II</em>的形式.

<pre lang='c++'>
class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
        if (k &lt;&lt; 1 &gt;= prices.size()) {
            int ans = 0;
            for (int i = 1; i &lt; prices.size(); i++) {
                ans += max(0, prices[i] - prices[i - 1]);
            }
            return ans;
        }
        
        vector&lt;vector&lt;int&gt;&gt; buy(prices.size() + 1, vector&lt;int&gt;(k + 1, INT_MIN)), 
                            profit(prices.size() + 1, vector&lt;int&gt;(k + 1, 0));
        for (int i = 1; i &lt;= prices.size(); i++) {
            int p = prices[i - 1];
            for (int kk = 1; kk &lt;= k; kk++) {
                buy[i][kk] = max(buy[i - 1][kk], profit[i - 1][kk - 1] - p);
                profit[i][kk]=max(profit[i - 1][kk], buy[i][kk] + p);
            }
        }
        return profit[prices.size()][k];
    }
};
</pre>

还可以优化为只使用一维数组.

<pre lang='c++'>
class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
        if (k &lt;&lt; 1 &gt;= prices.size()) {
            int ans = 0;
            for (int i = 1; i &lt; prices.size(); i++) {
                ans += max(0, prices[i] - prices[i - 1]);
            }
            return ans;
        }
        
        vector&lt;int&gt; buy(k + 1, INT_MIN), profit(k + 1, 0);
        for (int p : prices) {
            for (int kk = 1; kk &lt;= k; kk++) {
                buy[kk] = max(buy[kk], profit[kk - 1] - p);
                profit[kk] = max(profit[kk], buy[kk] + p);
            }
        }
        return profit[k];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>972</wp:post_id>
		<wp:post_date><![CDATA[2016-11-18 20:02:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-18 12:02:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-122-best-time-to-buy-and-sell-stock-ii-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 189. Rotate Array</title>
		<link>http://xiadong.info/2016/11/leetcode-189-rotate-array/</link>
		<pubDate>Fri, 18 Nov 2016 12:05:50 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=974</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.
For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>.
</blockquote>

循环右移, 没啥好说的......可以选择一起移动, 也可以选择一个元素一个元素移动; 前者时间复杂度低, 后者空间复杂度低.

<pre lang='c++'>
class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        k = k % nums.size();
        vector&lt;int&gt; tmp(nums.begin(), nums.begin() + (nums.size() - k));
        nums.erase(nums.begin(), nums.begin() + (nums.size() - k));
        for(auto i : tmp){
            nums.push_back(i);
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>974</wp:post_id>
		<wp:post_date><![CDATA[2016-11-18 20:05:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-18 12:05:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-189-rotate-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[leetcode-122-best-time-to-buy-and-sell-stock-ii-3]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 190. Reverse Bits</title>
		<link>http://xiadong.info/2016/11/leetcode-190-reverse-bits/</link>
		<pubDate>Sun, 20 Nov 2016 09:27:41 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=977</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Reverse bits of a given 32 bits unsigned integer.
For example, given input 43261596 (represented in binary as <strong>00000010100101000001111010011100</strong>), return 964176192 (represented in binary as <strong>00111001011110000010100101000000</strong>).
</blockquote>

翻转一个32位整数的每一个位.

<pre lang='c++'>
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        for(int i = 0; i &lt; 16; i++){
            swapIntBit(n, i);
        }
        return n;
    }

    void swapIntBit(uint32_t &amp;n, int i){
        uint32_t b1 = n &amp; (1 &lt;&lt; i);
        uint32_t b2 = n &amp; (((unsigned int)0x80000000) &gt;&gt; i);
        n &amp;= ~(1 &lt;&lt; i);
        n &amp;= ~(((unsigned int)0x80000000) &gt;&gt; i);
        n |= b1 &lt;&lt; (31 - i * 2);
        n |= b2 &gt;&gt; (31 - i * 2);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>977</wp:post_id>
		<wp:post_date><![CDATA[2016-11-20 17:27:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-20 09:27:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-190-reverse-bits]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 191. Number of 1 Bits</title>
		<link>http://xiadong.info/2016/11/leetcode-191-number-of-1-bits/</link>
		<pubDate>Sun, 20 Nov 2016 09:30:03 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=979</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Write a function that takes an unsigned integer and returns the number of ’1&#39; bits it has (also known as the <a href='http://en.wikipedia.org/wiki/Hamming_weight'>Hamming weight</a>).
For example, the 32-bit integer ’11&#39; has binary representation <code>00000000000000000000000000001011</code>, so the function should return 3.
</blockquote>

位运算.

<pre lang='c++'>
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        while(n &gt; 0){
            if(n &amp; 1)
                ret++;
            n = n &gt;&gt; 1;
        }
        
        return ret;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>979</wp:post_id>
		<wp:post_date><![CDATA[2016-11-20 17:30:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-20 09:30:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-191-number-of-1-bits]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 198. House Robber</title>
		<link>http://xiadong.info/2016/11/leetcode-198-house-robber/</link>
		<pubDate>Sun, 20 Nov 2016 09:35:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=981</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述

<blockquote>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.
</blockquote>

简单的动态规划问题. 相邻的房子不能同时入侵, 所以如果前一个房子入侵过了, 当前的房子就不能入侵. 

<code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code>

<pre lang='c++'>
class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 0)
            return 0;
        if(nums.size() == 1)
            return nums[0];
        int dp[nums.size()];
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i &lt; nums.size(); i++){
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.size() - 1];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>981</wp:post_id>
		<wp:post_date><![CDATA[2016-11-20 17:35:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-20 09:35:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-198-house-robber]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 462. Minimum Moves to Equal Array Elements II</title>
		<link>http://xiadong.info/2016/12/leetcode-462-minimum-moves-to-equal-array-elements-ii/</link>
		<pubDate>Sat, 03 Dec 2016 15:30:23 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=984</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a <strong>non-empty</strong> integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.

You may assume the array's length is at most 10,000.

<strong>Example:</strong>
<pre lang="undefined">Input:
[1,2,3]

Output:
2

Explanation:
Only two moves are needed (remember each move increments or decrements one element):

[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]
</pre>
</blockquote>

这道题我的首先思路是先找到最终每个元素所等于的值再计算需要的步数.

先考虑三个数[latex]a_1 \ge a_2 \ge a_3[/latex], 我们要找一个数[latex]n[/latex]使得[latex]|a_1-n|+|a_2-n|+|a_3-n|[/latex]最小. 比较容易想到[latex]n[/latex]应该在区间[latex][a_1,a_3][/latex]之间, 所以我们假设一个新的[latex]n[/latex], 满足[latex]a_1 \ge a_2+n \ge a_3[/latex], [latex]a_2+n[/latex]就是我们要找的值. 这时我们要使[latex][a_1-(a_2+n)] + |n| + [(a_2 + n) - a_3][/latex]最小.
[latex display="true"][a_1-(a_2+n)] + |n| + [(a_2 + n) - a_3] = a_1 - a_3 + |n|[/latex]
发现在[latex]n=0[/latex]的时候才能取到最小值[latex]a_1 - a_3[/latex], 所以最终每个元素应有的值是原来所有元素的值的中位数.

以上是奇数的情况, 那么偶数的时候中位数有两个候选. 我们再假设[latex]a_1 \ge a_2 \ge a_3 \ge a_4[/latex], 当选择[latex]a_2[/latex]作为最后的目标时, 总步数为[latex](a_1 - a_2) + (a_2 - a_3) + (a_2 - a_4) = a_1 - a_3 +a_2 - a_4[/latex], 当选择[latex]a_3[/latex]作为最后目标时, 总步数为[latex](a_1 - a_3) + (a_2 - a_3) + (a_3 - a_4) = a_1 - a_3 + a_2 - a_4[/latex], 两种情况是相同, 因此我们只要随便选一个就可以了.

关于找到中位数, 不需要使用<code>sort</code>对所有数据进行排序, 可以使用<code>nth_element</code>来节省时间.

<pre lang="c++">class Solution {
public:
    int minMoves2(vector&lt;int&gt;&amp; nums) {
        int midIndex = nums.size() / 2;
        nth_element(nums.begin(), nums.begin() + midIndex, nums.end());
        int mid = nums[midIndex];
        int ans = 0;
        for(auto i : nums){
            ans += abs(i - mid);
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>984</wp:post_id>
		<wp:post_date><![CDATA[2016-12-03 23:30:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-03 15:30:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-462-minimum-moves-to-equal-array-elements-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 463. Island Perimeter</title>
		<link>http://xiadong.info/2016/12/leetcode-463-island-perimeter/</link>
		<pubDate>Sat, 03 Dec 2016 15:34:44 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=993</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn&#39;t have &quot;lakes&quot; (water inside that isn&#39;t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.
<strong>Example:</strong>
<pre lang='undefined'>
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Answer: 16
Explanation: The perimeter is the 16 yellow stripes in the image below:
</pre>
<img src='https://leetcode.com/static/images/problemset/island.png' alt='' />
</blockquote>

遍历整个二维数组, 对于每块陆地, 计算该块陆地与&quot;水域&quot;接触的边的数量, 这个数量范围为<code>[0,4]</code>, 岛屿的总周长等于每块陆地与水域接触的边的数量之和.

<pre lang='c++'>
class Solution {
public:
    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        if(grid.empty() || grid[0].empty()) return 0;
        int row = grid.size(), col = grid[0].size();
        
        for(int i = 0; i &lt; row; i++){
            for(int j = 0; j &lt; col; j++){
                if(grid[i][j] == 1)
                    ans += getPerimeter(grid, i, j);
            }
        }
        return ans;
    }
    
    int getPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y){
        int ans = 0;
        int row = grid.size(), col = grid[0].size();
        if(x == 0 || grid[x - 1][y] == 0){
            ans++;
        }
        if(x == row - 1 || grid[x + 1][y] == 0){
            ans++;
        }
        if(y == 0 || grid[x][y - 1] == 0){
            ans++;
        }
        if(y == col - 1 || grid[x][y + 1] == 0){
            ans++;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>993</wp:post_id>
		<wp:post_date><![CDATA[2016-12-03 23:34:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-03 15:34:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-463-island-perimeter]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 199. Binary Tree Right Side View</title>
		<link>http://xiadong.info/2016/12/leetcode-199-binary-tree-right-side-view/</link>
		<pubDate>Sun, 04 Dec 2016 10:54:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=996</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.
For example:
Given the following binary tree,
<pre lang='undefined'>
   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---
</pre>
You should return <code>[1, 3, 4]</code>.
</blockquote>

我用DFS对二叉树进行遍历, 先遍历右节点再遍历左节点. 把每次遍历到的新的一层的第一个节点加入结果中.

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        if(!root) return vector&lt;int&gt;();
        vector&lt;int&gt; ans;
        DFS(root, ans, 1);
        return ans;
    }
    
    void DFS(TreeNode *node, vector&lt;int&gt; &amp;ans, int level){
        if(!node) return;
        if(level &gt; ans.size()){
            ans.push_back(node-&gt;val);
        }
        DFS(node-&gt;right, ans, level + 1);
        DFS(node-&gt;left, ans, level + 1);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>996</wp:post_id>
		<wp:post_date><![CDATA[2016-12-04 18:54:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-04 10:54:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-199-binary-tree-right-side-view]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 200. Number of Islands</title>
		<link>http://xiadong.info/2016/12/leetcode-200-number-of-islands/</link>
		<pubDate>Sun, 04 Dec 2016 11:07:42 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=998</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
<strong>Example 1:</strong>
<pre lang='undefined'>
11110
11010
11000
00000
</pre>
Answer: 1
<strong>Example 2:</strong>
<pre lang='undefined'>
11000
11000
00100
00011
</pre>
Answer: 3
</blockquote>

使用BFS遍历即可.

<pre lang='c++'>
class Solution {
    vector&lt;vector&lt;int&gt;&gt; visited;
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        if(grid.empty()) return 0;
        if(grid[0].empty()) return 0;
        int islandNum = 0;
        visited = vector&lt;vector&lt;int&gt;&gt;(grid.size(), vector&lt;int&gt;(grid[0].size(), false));
        for(int i = 0; i &lt; grid.size(); i++){
            for(int j = 0; j &lt; grid[0].size(); j++){
                if(grid[i][j] == &#39;1&#39; &amp;&amp; !visited[i][j]) {
                    BFS(grid, i, j);
                    ++islandNum;
                }
            }
        }
        return islandNum;
    }
    
    void BFS(vector&lt;vector&lt;char&gt;&gt; &amp;g, int x, int y){
        visited[x][y] = true;
        g[x][y] = &#39;0&#39;;
        queue&lt;pair&lt;int, int&gt;&gt; BFS;
        BFS.push(pair&lt;int, int&gt;(x, y));
        while(!BFS.empty()){
            pair&lt;int, int&gt; pos = BFS.front();
            int curX = pos.first, curY = pos.second;
            if(curX - 1 &gt;= 0 &amp;&amp; g[curX - 1][curY] == &#39;1&#39; &amp;&amp; !visited[curX - 1][curY]){
                BFS.push(pair&lt;int, int&gt;(curX - 1, curY));
                visited[curX - 1][curY] = true;
            }
            if(curX + 1 &lt; g.size() &amp;&amp; g[curX + 1][curY] == &#39;1&#39; &amp;&amp; !visited[curX + 1][curY]){
                BFS.push(pair&lt;int, int&gt;(curX + 1, curY));
                visited[curX + 1][curY] = true;
            }
            if(curY - 1 &gt;= 0 &amp;&amp; g[curX][curY - 1] == &#39;1&#39; &amp;&amp; !visited[curX][curY - 1]){
                BFS.push(pair&lt;int, int&gt;(curX, curY - 1));
                visited[curX][curY - 1] = true;
            }
            if(curY + 1 &lt; g[0].size() &amp;&amp; g[curX][curY + 1] == &#39;1&#39; &amp;&amp; !visited[curX][curY + 1]){
                BFS.push(pair&lt;int, int&gt;(curX, curY + 1));
                visited[curX][curY + 1] = true;
            }
            
            BFS.pop();
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>998</wp:post_id>
		<wp:post_date><![CDATA[2016-12-04 19:07:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-04 11:07:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-200-number-of-islands]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 201. Bitwise AND of Numbers Range</title>
		<link>http://xiadong.info/2016/12/leetcode-201-bitwise-and-of-numbers-range/</link>
		<pubDate>Sun, 04 Dec 2016 11:26:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1000</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.
For example, given the range [5, 7], you should return 4.
</blockquote>

位运算题目. 两个数m与n, 从最高位开始往低位看的话, 前面的许多位是相同的, 从某一位开始变得不同, 而这之后的所有位在结果中必然为0(因为中间肯定出现了0和1). 我们把m和n相减后得到的值就是这个阈值.

<pre lang='c++'>
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int minus = n - m + 1;
        int re = 0;
        for(int i = 0; i &lt; 31; i++){
            int t = 1 &lt;&lt; i;
            if(minus &gt; t){
                re = re &amp; (~t);
            }
            else{
                if((t &amp; m) &amp; (t &amp; n)){
                    re = re | t;
                }
                else{
                    re = re &amp; (~t);
                }
            }
        }
        return re;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1000</wp:post_id>
		<wp:post_date><![CDATA[2016-12-04 19:26:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-04 11:26:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-201-bitwise-and-of-numbers-range]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 467. Unique Substrings in Wraparound String</title>
		<link>http://xiadong.info/2016/12/leetcode-467-unique-substrings-in-wraparound-string/</link>
		<pubDate>Mon, 05 Dec 2016 08:25:58 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1002</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Consider the string <code>s</code> to be the infinite wraparound string of &quot;abcdefghijklmnopqrstuvwxyz&quot;, so <code>s</code> will look like this: &quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;.
Now we have another string <code>p</code>. Your job is to find out how many unique non-empty substrings of <code>p</code> are present in <code>s</code>. In particular, your input is the string <code>p</code> and you need to output the number of different non-empty substrings of <code>p</code> in the string <code>s</code>.
<strong>Note:</strong> <code>p</code> consists of only lowercase English letters and the size of p might be over 10000.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: &quot;a&quot;
Output: 1

Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string s.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: &quot;cac&quot;
Output: 2
Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s.
</pre>
<strong>Example 3:</strong>
<pre lang='undefined'>
Input: &quot;zab&quot;
Output: 6
Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s.
</pre>
</blockquote>

动态规划题目. <code>dp[i]</code>记录以<code>p[i]</code>为结尾的符合要求的子串的长度. 为了防止重复, 用另一个数组<code>tail</code>以字母为索引保存结果中以某个字母结尾的最长的子串的长度. 当<code>p[i]</code>与<code>p[i-1]</code>是连续的时候, <code>p[i]=p[i-1]</code>; 否则<code>p[i]=1</code>. 再检查<code>tail[p[i]-&#39;a&#39;]</code>与<code>dp[i]</code>的大小关系, 若<code>tail[p[i]-&#39;a&#39;]&gt;=dp[i]</code>, 说明<code>p[i]</code>结尾的所有子串都已经在结果中了; 否则更新<code>tail[p[i]-&#39;a&#39;]=dp[i]</code>, 增加结果集中以<code>p[i]</code>这个字母结尾的子串的数量. 最后再对<code>tail</code>数组求和就得到结果. 时间复杂度O(n).

<pre lang='c++'>
class Solution {
public:
    int findSubstringInWraproundString(string p) {
        if(p.empty()) return 0;
        vector&lt;int&gt; dp(p.length(), 0);
        vector&lt;int&gt; tail(26, 0);
        dp[0] = 1;
        tail[p[0] - &#39;a&#39;] = 1;
        for(int i = 1; i &lt; p.length(); i++){
            if((p[i - 1] != &#39;z&#39; &amp;&amp; p[i] == p[i - 1] + 1) || (p[i - 1] == &#39;z&#39; &amp;&amp; p[i] == &#39;a&#39;)){
                dp[i] = dp[i - 1] + 1;
            }
            else{
                dp[i] = 1;
            }
            int index = p[i] - &#39;a&#39;;
            tail[index] = max(tail[index], dp[i]);
        }
        int ans = 0;
        for(auto i : tail){
            ans += i;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1002</wp:post_id>
		<wp:post_date><![CDATA[2016-12-05 16:25:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-05 08:25:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-467-unique-substrings-in-wraparound-string]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 202. Happy Number</title>
		<link>http://xiadong.info/2016/12/leetcode-202-happy-number/</link>
		<pubDate>Tue, 06 Dec 2016 10:17:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1005</guid>
		<description></description>
		<content:encoded><![CDATA[ 题目描述:

<blockquote>Write an algorithm to determine if a number is &quot;happy&quot;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.
<strong>Example: </strong>19 is a happy number
<ul><li>
12 + 92 = 82</li>
<li>
82 + 22 = 68</li>
<li>
62 + 82 = 100</li>
<li>
12 + 02 + 02 = 1</li>
</ul>
</blockquote>

最直观的解法可以使用hash表.

<pre lang='c++'>
class Solution {
public:
    bool isHappy(int n) {
        unordered_set&lt;int&gt; s;
        s.insert(n);
        int t = n;
        while(t != 1){
            long long sum = 0;
            while(t &gt; 0){
                sum += ((t % 10) * (t % 10));
                t /= 10;
            }
            t = sum;
            if(s.count(t)) return false;
            else s.insert(t);
        }
        return true;
    }
};
</pre>

但是仔细想想, 输入数据最多为一个十位数, 每一位数字的平方最多为81, 因此中间过程所产生的数肯定落在<code>[1,810]</code>之间, 我们只要开一个较大的数组来保存某个数是否出现过就可以了.

<pre lang='c++'>
class Solution {
public:
    bool isHappy(int n) {
        vector&lt;int&gt; s(1000, 0);
        int t = n;
        while(t != 1){
            int sum = 0;
            while(t &gt; 0){
                sum += ((t % 10) * (t % 10));
                t /= 10;
            }
            t = sum;
            if(s[t]) return false;
            else s[t] = 1;
        }
        return true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1005</wp:post_id>
		<wp:post_date><![CDATA[2016-12-06 18:17:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-06 10:17:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-202-happy-number]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 203. Remove Linked List Elements</title>
		<link>http://xiadong.info/2016/12/leetcode-203-remove-linked-list-elements/</link>
		<pubDate>Tue, 06 Dec 2016 10:20:03 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1007</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Remove all elements from a linked list of integers that have value <strong>val</strong>.
<strong>Example</strong>
<strong>Given:</strong> 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, <strong>val</strong> = 6
<strong>Return:</strong> 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5
</blockquote>

就是单纯的删除链表节点.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(!head) return head;
        ListNode *p = new ListNode(0), *h = p;
        p-&gt;next = head;
        while(p &amp;&amp; p-&gt;next){
            if(p-&gt;next-&gt;val == val){
                p-&gt;next = p-&gt;next-&gt;next;
            }
            else
                p = p-&gt;next;
        }
        return h-&gt;next;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1007</wp:post_id>
		<wp:post_date><![CDATA[2016-12-06 18:20:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-06 10:20:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-203-remove-linked-list-elements]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 204. Count Primes</title>
		<link>http://xiadong.info/2016/12/leetcode-204-count-primes/</link>
		<pubDate>Tue, 06 Dec 2016 10:46:51 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1009</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote><strong>Description:</strong>
Count the number of prime numbers less than a non-negative number, <strong>n</strong>.
</blockquote>

使用筛法, 从小到大剔除每个遇到的素数的小于n的倍数, 直到[latex]\sqrt n[/latex], 每剔除一个就将素数个数减1. sum一开始减2是为了去掉1和n自身.

<pre lang='c++'>
class Solution {
public:
    int countPrimes(int n) {
        if(n &lt;= 1) return 0;
        vector&lt;int&gt; s(n, 0);
        int sum = n - 2;
        for (int i = 2; i * i &lt; n; i++) {
            if(s[i]) continue;
            for (int j = i; i * j &lt; n; j++) {
                int index = i * j;
                if(!s[index]) {
                    sum--;
                    s[index] = 1;
                }
            }
        }
        return sum;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1009</wp:post_id>
		<wp:post_date><![CDATA[2016-12-06 18:46:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-06 10:46:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-204-count-primes]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 205. Isomorphic Strings</title>
		<link>http://xiadong.info/2016/12/leetcode-205-isomorphic-strings/</link>
		<pubDate>Wed, 07 Dec 2016 09:47:27 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1032</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Given two strings <strong>s</strong> and <strong>t</strong>, determine if they are isomorphic.
Two strings are isomorphic if the characters in <strong>s</strong> can be replaced to get <strong>t</strong>.
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.
For example,
Given <code>&quot;egg&quot;</code>, <code>&quot;add&quot;</code>, return true.
Given <code>&quot;foo&quot;</code>, <code>&quot;bar&quot;</code>, return false.
Given <code>&quot;paper&quot;</code>, <code>&quot;title&quot;</code>, return true.
<strong>Note:</strong>
You may assume both <strong>s</strong> and <strong>t</strong> have the same length.
</blockquote>

依次建立替换的映射, 无法完成转换的条件有两个:

<ol><li>
s中两个不同的字符映射到了同一个字符. 用一个数组来记录每个字符是否被映射过, 出现重复时则返回false.</li>
<li>
s中的两个相同字符映射到不同字符. 每次比较字符的映射是否相同.</li>
</ol>

<pre lang='c++'>
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        vector&lt;int&gt; s2t(128, -1), tCnt(128, 0);
        for(int i = 0; i &lt; s.size(); i++){
            char sc = s[i], tc = t[i];
            if(s2t[sc] == -1){
                if(tCnt[tc] == 1) return false;
                s2t[sc] = tc;
                tCnt[tc] = 1;
            }
            else if(s2t[sc] != tc) return false;
        }
        return true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1032</wp:post_id>
		<wp:post_date><![CDATA[2016-12-07 17:47:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-07 09:47:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-205-isomorphic-strings]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 206. Reverse Linked List</title>
		<link>http://xiadong.info/2016/12/leetcode-206-reverse-linked-list/</link>
		<pubDate>Wed, 07 Dec 2016 09:50:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1035</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Reverse a singly linked list.
</blockquote>

翻转一个单向链表, 就是从前往后依次翻转即可.

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head) return NULL;
        ListNode *p1 = head, *p2 = head-&gt;next, *p = head-&gt;next;
        if(!p1 || !p2) return head;
        while(p2 &amp;&amp; p1){
            ListNode *t = p2-&gt;next;
            p2-&gt;next = p1;
            p1 = p2;
            p2 = t;
        }
        head-&gt;next = NULL;
        return p1;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1035</wp:post_id>
		<wp:post_date><![CDATA[2016-12-07 17:50:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-07 09:50:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-206-reverse-linked-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 468. Validate IP Address</title>
		<link>http://xiadong.info/2016/12/leetcode-468-validate-ip-address/</link>
		<pubDate>Mon, 19 Dec 2016 09:56:17 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1038</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>In this problem, your job to write a function to check whether a input string is a valid IPv4 address or IPv6 address or neither.
<strong>IPv4</strong> addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (&quot;.&quot;), e.g.,<code>172.16.254.1</code>;
Besides, you need to keep in mind that leading zeros in the IPv4 is illegal. For example, the address <code>172.16.254.01</code> is illegal.
<strong>IPv6</strong> addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (&quot;:&quot;). For example, the address <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is a legal one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so <code>2001:db8:85a3:0:0:8A2E:0370:7334</code> is also a valid IPv6 address(Omit leading zeros and using upper cases).
However, we don&#39;t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, <code>2001:0db8:85a3::8A2E:0370:7334</code> is an invalid IPv6 address.
Besides, you need to keep in mind that extra leading zeros in the IPv6 is also illegal. For example, the address <code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is also illegal.
<strong>Note:</strong> You could assume there is no extra space in the test cases and there may some special characters in the input string.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: &quot;172.16.254.1&quot;

Output: &quot;IPv4&quot;

Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;

Output: &quot;IPv6&quot;

Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;.
</pre>
<strong>Example 3:</strong>
<pre lang='undefined'>
Input: &quot;256.256.256.256&quot;

Output: &quot;Neither&quot;

Explanation: This is neither a IPv4 address nor a IPv6 address.
</pre>
</blockquote>

判断合法的IP地址, 比较简单, 注意前导零就行.

<pre lang='c++'>
class Solution {
public:
    string validIPAddress(string IP) {
        if(validIPv4(IP)) return string(&quot;IPv4&quot;);
        else if(validIPv6(IP)) return string(&quot;IPv6&quot;);
        return string(&quot;Neither&quot;);
    }
    
    bool validIPv4(string IP){
        int p = 0, q = 0;
        for(int i = 0; i &lt; 4; i++){
            q = IP.find(&#39;.&#39;, p);
            if(q == string::npos &amp;&amp; i != 3){
                return false;
            }
            else if(i == 3){
                q = IP.length();
            }
            string part = IP.substr(p, q - p);
            if(part.empty() || part.length() &gt; 3) return false;
            for(auto c : part){
                if(!isDigit(c)) return false;
            }
            bool leadingZero = part[0] == &#39;0&#39; ? true : false;
            if(leadingZero &amp;&amp; part.length() &gt; 1) return false;
            int t = stoi(part);
            if(t &gt; 255 || t &lt; 0) return false;
            p = q + 1;
        }
        return true;
    }
    
    bool validIPv6(string IP){
        int p = 0, q = 0;
        for(int i = 0; i &lt; 8; i++){
            q = IP.find(&#39;:&#39;, p);
            if(q == string::npos &amp;&amp; i != 7){
                return false;
            }
            else if(i == 7){
                q = IP.length();
            }
            string part = IP.substr(p, q - p);
            if(part.empty() || part.length() &gt; 4) return false;
            for(auto c : part){
                if(!isHex(c)) return false;
            }
            p = q + 1;
        }
        return true;
    }
    
    bool isDigit(char c){
        return c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;;
    }
    
    bool isHex(char c){
        return isDigit(c) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) || (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1038</wp:post_id>
		<wp:post_date><![CDATA[2016-12-19 17:56:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-19 09:56:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-468-validate-ip-address]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 475. Heaters</title>
		<link>http://xiadong.info/2016/12/leetcode-475-heaters/</link>
		<pubDate>Mon, 19 Dec 2016 09:59:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1040</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述:

<blockquote>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.
Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.
So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.
<strong>Note:</strong>
<ol><li>
Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>
<li>
Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>
<li>
As long as a house is in the heaters&#39; warm radius range, it can be warmed.</li>
<li>
All the heaters follow your radius standard and the warm radius will the same.</li>
</ol>
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [1,2,3],[2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [1,2,3,4],[1,4]
Output: 1
Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
</pre>
</blockquote>

我使用二分搜索, 对每个房子搜索与它最近的heater, 维护一个最长的最短距离.

<pre lang='c++'>
class Solution {
public:
    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) {
        sort(heaters.begin(), heaters.end());
        int ans = 0;
        for(auto i : houses){
            int index = binSearch(heaters, i);
            if(index == heaters.size()) index--;
            int tmp = min(abs(heaters[index] - i), abs(index &lt; heaters.size() - 1 ? heaters[index + 1] - i : INT_MAX));
            tmp = min(tmp, abs(index &gt; 0 ? heaters[index - 1] - i : INT_MAX));
            ans = max(ans, tmp);
        }
        return ans;
    }
    
    int binSearch(vector&lt;int&gt;&amp;heaters, int target){
        int left = 0, right = heaters.size(), mid = (left + right) / 2;
        while(left &lt; right){
            if(heaters[mid] == target) return mid;
            else if(heaters[mid] &gt; target) right = mid;
            else left = mid + 1;
            
            mid = (left + right) / 2;
        }
        return left;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1040</wp:post_id>
		<wp:post_date><![CDATA[2016-12-19 17:59:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-19 09:59:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-475-heaters]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2"><![CDATA[二分搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 461. Hamming Distance</title>
		<link>http://xiadong.info/2016/12/leetcode-461-hamming-distance/</link>
		<pubDate>Tue, 27 Dec 2016 10:02:10 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1042</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>The <a href='https://en.wikipedia.org/wiki/Hamming_distance'>Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.
Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.
<strong>Note:</strong>
0 ≤ <code>x</code>, <code>y</code> &lt; 231.
<strong>Example:</strong>
<pre lang='undefined'>
Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.
</pre>
</blockquote>

把两个数异或之后看结果有多少个1.

<pre lang='c++'>
class Solution {
public:
    int hammingDistance(int x, int y) {
        unsigned int z = x ^ y;
        int ans = 0;
        while(z &gt; 0){
            if(z &amp; 1) ans++;
            z &gt;&gt;= 1;
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1042</wp:post_id>
		<wp:post_date><![CDATA[2016-12-27 18:02:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-27 10:02:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-461-hamming-distance]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 477. Total Hamming Distance</title>
		<link>http://xiadong.info/2016/12/leetcode-477-total-hamming-distance/</link>
		<pubDate>Tue, 27 Dec 2016 10:03:03 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1044</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>The <a href='https://en.wikipedia.org/wiki/Hamming_distance'>Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.
Now your job is to find the total Hamming distance between all pairs of the given numbers.
<strong>Example:</strong>
<pre lang='undefined'>
Input: 4, 14, 2

Output: 6

Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case). So the answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
</pre>
<strong>Note:</strong>
<ol><li>
Elements of the given array are in the range of <code>0</code>to <code>10^9</code></li>
<li>
Length of the array will not exceed <code>10^4</code>.</li>
</ol>
</blockquote>

跟 <em>461. Hamming Distance</em> 这道题类似，不过数量增加了。我们可以对int的每一位分别求HammingDistance再求和。n个二进制位中有i个0和j个1，那么它们两两组合成0与1的种类有i*j种。

<pre lang='c++'>
class Solution {
public:
    int totalHammingDistance(vector&lt;int&gt;&amp; nums) {
        int ans = 0;
        for(int i = 0; i &lt; 32; i++){
            int num[2] = {0, 0};
            for(auto j : nums){
                if(j &amp; (1 &lt;&lt; i))
                    num[1]++;
                else
                    num[0]++;
            }
            ans += (num[0] * num[1]);
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1044</wp:post_id>
		<wp:post_date><![CDATA[2016-12-27 18:03:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-27 10:03:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-477-total-hamming-distance]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>新年，2017</title>
		<link>http://xiadong.info/2016/12/%e6%96%b0%e5%b9%b4%ef%bc%8c2017/</link>
		<pubDate>Sat, 31 Dec 2016 15:31:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1047</guid>
		<description></description>
		<content:encoded><![CDATA[总是觉得时间飞逝却又总是抓不住时间，再有几十分钟就要进入2017年了。回头看这2016年，上半年轻松惬意，下半年紧张了不少。写这种总结文字总是觉得很矫情，权当是碎碎念，反正也没有什么人会看到┑(￣Д ￣)┍。

年初从一月份开始在家呆了近四个月，超长假期+很水的毕设=废人一个。要说干了啥……好像看完了《代码大全》，但是我觉得有点看早了，里面有的点能get到，有的点不明觉厉，总体感觉囫囵吞枣。三月底的时候趁着樱花季去日本转了两周，要说是穿越了国界反而更像是穿越了次元壁呢……大阪-奈良-京都-箱根-东京自由行下来感觉就是……以后还要去啊啊啊啊！！！对于动画厨来说简直逛不够啊！而且一个人旅行真的很舒服。

四月份回成都，五月份毕设结束，六月份本科毕业。四年的时光走到了尽头，相比于四年前的那个高中生成长了很多很多，人生的际遇总是那么不可思议，四年前的我怎么也想象不到毕业时的样子吧。

暑假在家，心血来潮准备从头刷LeetCode，也是为明年的面试做准备。这个大坑到现在我还没有填完T_T。暑假看了《Effective STL》，收获不小。

下半年来广州，只上两门课。CMU的课程真的让我觉得跟国内不同，一学期CSAPP从头讲到尾，配套9个Lab，而且是针对没有CS基础的同学，我至少有点基础，不会太费力，但是对其他专业背景的同学要求真的是很高。要说我觉得课程与国内最大的不同就是课后作业的重视程度，不仅数量大，而且难度也不小。

说到明年，希望我能顺利到达美国，能找到一个工作。这大概就是我的新年愿望了吧。

对了，马上就是我着任提督一周年的日子了，嘛，到时候专门写一篇吧:-)]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1047</wp:post_id>
		<wp:post_date><![CDATA[2016-12-31 23:31:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-31 15:31:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%96%b0%e5%b9%b4%ef%bc%8c2017]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>36</wp:comment_id>
			<wp:comment_author><![CDATA[ian]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[cheesehigh@yahoo.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.25]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-01-01 00:35:26]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-12-31 16:35:26]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[东哥666]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1483202126.8154011;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1483231167.6949589;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>37</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.25]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-01-01 08:42:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-01-01 00:42:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[所以你是怎么找到这来的…]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>36</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1483231355.2542911;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>38</wp:comment_id>
			<wp:comment_author><![CDATA[fanw]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[daniel491@163.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.97]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-01-01 17:42:20]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-01-01 09:42:20]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[东哥新年快乐啊~ 新的一年我还要继续抱紧你的大腿！ 2017你绝对可以找个好工作的！育碧蒙特利尔就不错哈哈哈~]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1483263740.161659;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1483263782.6705141;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>39</wp:comment_id>
			<wp:comment_author><![CDATA[xiadong]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiadong.main@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.9]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-01-01 17:44:21]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-01-01 09:44:21]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[所以你又是怎么找到这的눈_눈]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>38</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1483263861.6025071;s:5:"event";s:9:"check-ham";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>40</wp:comment_id>
			<wp:comment_author><![CDATA[fanw]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[daniel491@163.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-01-02 16:09:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-01-02 08:09:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[哈哈，每天早上起床除了默念三遍东哥最帅之外，还要刷一遍东哥的blog啊~]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>39</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1483344568.9432859;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>41</wp:comment_id>
			<wp:comment_author><![CDATA[Yating Chen]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[865800931@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.facebook.com/app_scoped_user_id/380734178952112/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.33.33]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-02-23 15:12:46]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-02-23 07:12:46]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[东哥迷妹签到~]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1487833966.3898699;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1487864078.6677251;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>LeetCode 207. Course Schedule</title>
		<link>http://xiadong.info/2017/01/leetcode-207-course-schedule/</link>
		<pubDate>Mon, 02 Jan 2017 09:47:08 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1049</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code>
Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?
For example:
<pre lang='undefined'>
2, [[1,0]]
</pre>
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.
<pre lang='undefined'>
2, [[1,0],[0,1]]
</pre>
There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
<strong>Note:</strong>
The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href='https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs'>how a graph is represented</a>.
<strong>Hints:</strong>
<ul><li>
This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>
<li>
<a href='https://class.coursera.org/algo-003/lecture/52'>Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>
<li>
Topological sort could also be done via <a href='http://en.wikipedia.org/wiki/Topological_sorting#Algorithms'>BFS</a>.</li>
</ul>
</blockquote>

Hint中已经说的很明确了，就是判断一个图中有没有环。我用DFS来遍历每个节点，有两个出现环的情况：

<ol><li>
出现了路径中已经出现的节点</li>
<li>
有的节点没有被遍历到过，说明它们没有起始的端点</li>
</ol>

<pre lang='c++'>
class Solution {
public:
    bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        vector&lt;vector&lt;int&gt;&gt; gg(numCourses);
        vector&lt;int&gt; prerequested(numCourses, false), allVisited(numCourses, false);
        for (int i = 0; i &lt; prerequisites.size(); i++) {
            gg[prerequisites[i].first].push_back(prerequisites[i].second);
            prerequested[prerequisites[i].second] = true;
        }
        int prerequestedNum = 0;
        for (int i = 0; i &lt; numCourses; i++) {
            if (!prerequested[i]) {
                vector&lt;int&gt; thisTimeVisited(numCourses, false);
                thisTimeVisited[i] = true;
                allVisited[i] = true;
                if (!DFS(gg, i, allVisited, thisTimeVisited)){
                    return false;
                }
                thisTimeVisited[i] = false;
            }
            else {
                prerequestedNum++;
            }
        }
        if (prerequestedNum == numCourses) {
            //no start node
            return false;
        }
        for (int i = 0; i &lt; numCourses; i++) {
            if (!allVisited[i]) {
                //some nodes cannot be visited
                return false;
            }
        }
        return true;
    }

    bool DFS(vector&lt;vector&lt;int&gt;&gt; &amp;gg, int node, vector&lt;int&gt; &amp;allVisited, vector&lt;int&gt; &amp;thisTimeVisited) {
        vector&lt;int&gt; nextNodes = gg[node];
        for (int i = 0; i &lt; nextNodes.size(); i++) {
            if (thisTimeVisited[nextNodes[i]]) {
                //find cycle
                return false;
            }
            allVisited[nextNodes[i]] = true;
            thisTimeVisited[nextNodes[i]] = true;
            if (!DFS(gg, nextNodes[i], allVisited, thisTimeVisited))
                return false;
            thisTimeVisited[nextNodes[i]] = false;
        }
        return true;
    }
};

</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1049</wp:post_id>
		<wp:post_date><![CDATA[2017-01-02 17:47:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-02 09:47:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-207-course-schedule]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 208. Implement Trie (Prefix Tree)</title>
		<link>http://xiadong.info/2017/01/leetcode-208-implement-trie-prefix-tree/</link>
		<pubDate>Mon, 02 Jan 2017 10:13:06 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1051</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.
<strong>Note:</strong>
You may assume that all inputs are consist of lowercase letters <code>a-z</code>.
</blockquote>

实现前缀树。因为输入只有小写字母，所以直接使用26叉树，使用vector来实现支持任意分支数也可以。

<pre lang='c++'>
class TrieNode {
public:
    char val;
    vector&lt;TrieNode*&gt; children;
    bool wordEnd = false;
    // Initialize your data structure here.
    TrieNode(char v = 0) : val(v){
        children = vector&lt;TrieNode*&gt;(26, nullptr);
    }
};

class Trie {
public:
    Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    void insert(string word) {
        insertToNode(word, root);
    }
    
    void insertToNode(string word, TrieNode* node){
        if(word.empty()){
            node-&gt;wordEnd = true;
            return;
        }
        
        int pos;
        for(pos = 0; pos &lt; word.size(); pos++){
            if(node-&gt;children[word[pos] - &#39;a&#39;] != nullptr){
                node = node-&gt;children[word[pos] - &#39;a&#39;];
            }
            else{
                break;
            }
        }
        
        if(pos == word.size()) {
            node-&gt;wordEnd = true;
            return;
        }

        for(int i = pos; i &lt; word.size(); i++){
            TrieNode *tmp = new TrieNode(word[i]);
            node-&gt;children[word[i] - &#39;a&#39;] = tmp;
            node = tmp;
        }
        node-&gt;wordEnd = true;
    }

    // Returns if the word is in the trie.
    bool search(string word) {
        int pos = 0;
        TrieNode *p = root;
        for(; pos &lt; word.size(); pos++){
            if(p-&gt;children[word[pos] - &#39;a&#39;] != nullptr){
                p = p-&gt;children[word[pos] - &#39;a&#39;];
            }
            else{
                break;
            }
        }
        if(pos == word.size() &amp;&amp; p-&gt;wordEnd) return true;
        else return false;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    bool startsWith(string prefix) {
        int pos = 0;
        TrieNode *p = root;
        for(; pos &lt; prefix.size(); pos++){
            if(p-&gt;children[prefix[pos] - &#39;a&#39;] != nullptr){
                p = p-&gt;children[prefix[pos] - &#39;a&#39;];
            }
            else{
                break;
            }
        }
        if(pos == prefix.size()) return true;
        else return false;
    }

private:
    TrieNode* root;
};

// Your Trie object will be instantiated and called as such:
// Trie trie;
// trie.insert(&quot;somestring&quot;);
// trie.search(&quot;key&quot;);
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1051</wp:post_id>
		<wp:post_date><![CDATA[2017-01-02 18:13:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-02 10:13:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-208-implement-trie-prefix-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%bc%80%e6%a0%91trie"><![CDATA[前缀树(Trie)]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 209. Minimum Size Subarray Sum</title>
		<link>http://xiadong.info/2017/01/leetcode-209-minimum-size-subarray-sum/</link>
		<pubDate>Mon, 02 Jan 2017 10:21:33 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1053</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a subarray of which the sum ≥ <strong>s</strong>. If there isn&#39;t one, return 0 instead.
For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,
the subarray <code>[4,3]</code> has the minimal length under the problem constraint.
</blockquote>

使用双指针。因为都是正数，所以子串的长度越长和越大。先增大右指针直到<code>[left,right]</code>中的元素的和&gt;=s，然后从中依次去掉开头的数，也就是left增大，直到和不再&gt;=s，更新最短长度。然后再次增大右指针进入下一个循环。

<pre lang='c++'>
class Solution {
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return 0;
        int left = 0, minSum = 0, minLen = INT_MAX, curSum = 0;
        for(int i = 0; i &lt; nums.size(); i++){
            if(i - left + 1 &gt; minLen){
                curSum -= nums[left++];
            }
            curSum += nums[i];
            if(curSum &gt;= s){
                for(; left &lt;= i &amp;&amp; curSum &gt;= s; left++){
                    curSum -= nums[left];
                }
                minLen = i - left + 2;
            }
        }
        return minLen == INT_MAX ? 0 : minLen;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1053</wp:post_id>
		<wp:post_date><![CDATA[2017-01-02 18:21:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-02 10:21:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-209-minimum-size-subarray-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>阳光之下依然是罪恶——扯扯《GTA5》</title>
		<link>http://xiadong.info/2017/01/%e9%98%b3%e5%85%89%e4%b9%8b%e4%b8%8b%e4%be%9d%e7%84%b6%e6%98%af%e7%bd%aa%e6%81%b6-%e6%89%af%e6%89%af%e3%80%8agta5%e3%80%8b/</link>
		<pubDate>Sun, 08 Jan 2017 09:46:08 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1055</guid>
		<description></description>
		<content:encoded><![CDATA[GTA5已经是好几年前发售的游戏了，奈何我电脑配置太低，再加上80G的大小让我望而却步。上个月Steam特价94软妹币，没忍住剁了手。54个小时通了主线剧情和大部分的支线，还有在游戏里瞎搞花了一些时间，所以主线剧情所需的时间大概在30~40小时左右。

要说我第一次玩GTA5还是一年半前，用老逼的电脑玩了一丁点。很多年以前……大概是初中的时候玩过《罪恶都市》还是《圣安地列斯》，不过那时什么都不懂，属于真正的瞎玩一通，甚至都没有剧情的概念，现在只记得卡在一个开遥控飞机的任务上再也没有过去过。这次通关GTA5之后想写点东西，就当是这几十个小时人生的总结吧。

<strong>本文涉及剧透！</strong>

<h1 data-breakpage="">背景</h1>

GTA5的故事主要发生在洛圣都，NETA洛杉矶。游戏里的洛圣都真是不折不扣的罪恶都市，到处都散发着荒诞的气息。健忘症的警察、泛滥的枪支毒品、比黑帮还像黑帮的FIB和IAA、发生在电视直播上的爆炸和枪杀、大街上一言不合便拔枪开干……一切都构筑在赤裸裸的金钱、暴力与性的基础上。剧情中出现的人物似乎没有一个有正常的三观，这座城市似乎也不存在秩序，自私、贪婪、恃强凌弱也不像现实中那样遮遮掩掩，从这个角度来说，我觉得GTA中的暴力与罪恶恰恰是对现实中掩饰暴力与罪恶的讽刺。

从玩家，也就是三位主角的角度来看，这座城市的中上层简直是面目可憎。本来是秩序维护者的FIB和IAA都不是什么好东西，IAA为了拨款人为制造恐怖袭击，FIB出场的几个探员个个都不干净。有钱人想尽办法赚钱而毫无底线。同时下层则是黑帮火并，毒品交易，各种坑蒙拐骗。

游戏中的洛圣都绝大部时间都是阳光普照，然而在这阳光下的城市却弥漫着浓浓的罪恶气息。

<h1 data-breakpage="">人物</h1>

GTA5的主角有三人，崔佛、麦克和富兰克林，我还是分开来说说吧。

<strong>崔佛</strong>：老实说我还是挺喜欢这种真性情的人的，但可惜他是个疯子。也许说疯子不太准确，也有的人说他有时候控制不住自己的行为。在崔佛刚出场的时候就开始杀人，在后来的行动中又干出各种杀光别人帮派所有人的事情，麦克也总是说老崔只是喜欢杀人而已。但是如果仅仅这样我也并不讨厌他，因为他都是在你死我活的环境下杀人（除了第一个被打死的强尼），而且老崔莫名的有一些童真（当然更有可能是精神缺陷，他也说自己有童年阴影），比如他的个人载具保险杠那里的一只玩具熊，还有大结局（第三条路那个结局）之后遇到他妈妈痛哭流涕；而且他对朋友重情重义（后来我知道前提是他把你当朋友）。但是当我看到他杀了弗洛伊德（貌似没有死）和他女友黛伯拉的时候我就觉得老崔实在是太危害社会了，当老崔浑身是血的走出公寓以及特写给到窗户上的大量血迹时，我就觉得他们两个实在是遭了无妄之灾，一个被表弟的狐朋狗友把生活搞得一团糟（也有可能本来就一团糟），另一个只不过是想把一个看起来就不正常的人从自己家里赶出去而已结果不知道被装了几个袋子。当时我就知道结局要选择杀老崔还是杀麦克，所以我决定不能留老崔，他就像一个坏掉的定时炸弹一样，可能拿在手里就炸了。但是到最后真的选择的时候还是心软了，毕竟是一起抢过银行，怼过坦克，挨过枪子的交情，而且转念一想，三位主角在大街上碾死的围观群众个个都成百上千（都是我的锅，我不好好开车），老崔那次杀人让我印象深刻只不过是剧情中杀人而已，三位主角手上都沾满鲜血，没有理由单独除掉老崔。

<strong>麦克</strong>：三位主角中我最同情麦克了。从一开始富兰克林潜入麦克的房子然后看到他老婆出轨，儿子废柴，女儿胸大无脑只想出名我就开始同情他了，这情况要是换我早就用人生重来枪了。麦克是最像一个文明人的人，换一句话说他是最虚伪的人。他一直想要的就是稳定的生活，可是当需要钱的时候他首先想到的还是抢劫。其实从GTA5的剧情中我看不出麦克为什么对这个从各方面都是bull shit的家庭有那么强的执念，大概我还是没法理解那种年龄的想法吧。

<strong>富兰克林</strong>：我一直觉得富兰克林是一个推动剧情的人物，最终选择线路的时候也是富兰克林来做决定。他一开始只是个偷车的黑帮小混混，不太能看得出他做事的动机，大概是想做一番大事（THE BIG ONE！），感觉富兰克林这个人物塑造的不是很丰满。在救拉玛，救麦克的行动中可以看出他很重义气。

<h1 data-breakpage="">剧情</h1>

GTA5的剧情总的来说就是抢枪抢，杀杀杀……我在最后的选择中选了“第三条路”，一个HE，这个结局太好了，好的不真实。仿佛不费吹灰之力就干掉了所有的对头，一切的麻烦都烟消云散，基友冰释前嫌重归于好，抢来的黄金足够大家挥霍。然而理智告诉我这实在是不合逻辑，不是说选择既不杀麦克也不杀崔佛不合逻辑，而是选择“第三条路”之后这个“不费吹灰之力就干掉了所有的对头”不合逻辑，感觉与前面的剧情落差太大。我也看了另外两个结局，首先我觉得富兰克林不可能去杀麦克，感觉毫无理由，杀崔佛至少还有拆除定时炸弹目的。我觉得要是在现实中我大概会选杀崔佛，要不然指不定他又会搞什么麻烦，这种随机出现BUG的组件还是尽早清除掉为好。

支线任务我还没有做完，不过我对那两个追星的老年夫妇印象挺深的。病态的追寻名人，搜集名人的生活垃圾等等的Hentai行为甚至不惜进行绑架，没有追星经历的我还真是叹为观止。还有那个拿自己老婆当酬劳的房地产中介……一个大写的服，连老崔都表示佩服。]]></content:encoded>
		<excerpt:encoded><![CDATA[GTA5通关感言]]></excerpt:encoded>
		<wp:post_id>1055</wp:post_id>
		<wp:post_date><![CDATA[2017-01-08 17:46:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-08 09:46:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%98%b3%e5%85%89%e4%b9%8b%e4%b8%8b%e4%be%9d%e7%84%b6%e6%98%af%e7%bd%aa%e6%81%b6-%e6%89%af%e6%89%af%e3%80%8agta5%e3%80%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 448. Find All Numbers Disappeared in an Array</title>
		<link>http://xiadong.info/2017/01/leetcode-448-find-all-numbers-disappeared-in-an-array/</link>
		<pubDate>Mon, 09 Jan 2017 10:25:45 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1058</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given an array of integers where 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear twice and others appear once.
Find all the elements of [1, <em>n</em>] inclusive that do not appear in this array.
Could you do it without extra space and in O(<em>n</em>) runtime? You may assume the returned list does not count as extra space.
<strong>Example:</strong>
<pre lang='undefined'>
Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
</pre>
</blockquote>

寻找没有出现过的数字，因为数组中的元素满足1 ≤ a[i] ≤ <em>n</em>，所以可以利用下标来保存一个数是否出现过，把一个数放到它对应的下标处，然后再找出哪些下标与元素不对应就是没有出现过的数。

<pre lang='c++'>
class Solution {
public:
    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; ans;
        for(int i = 0; i &lt; nums.size(); i++){
            if(nums[nums[i] - 1] != nums[i]){
                swap(nums[nums[i] - 1], nums[i]);
                i--;
            }
        }
        for(int i = 0; i &lt; nums.size(); i++){
            if(nums[i] - 1 != i) ans.push_back(i + 1);
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1058</wp:post_id>
		<wp:post_date><![CDATA[2017-01-09 18:25:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-09 10:25:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-448-find-all-numbers-disappeared-in-an-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 434. Number of Segments in a String</title>
		<link>http://xiadong.info/2017/01/leetcode-434-number-of-segments-in-a-string/</link>
		<pubDate>Mon, 09 Jan 2017 10:28:06 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1060</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.
Please note that the string does not contain any <strong>non-printable</strong> characters.
<strong>Example:</strong>
<pre lang='undefined'>
Input: &quot;Hello, my name is John&quot;
Output: 5
</pre>
</blockquote>

比较简单，注意处理连续的空格和结尾。还有有符号数与无符号数的隐式转换问题。

<pre lang='c++'>
class Solution {
public:
    int countSegments(string s) {
        int prevIndex = -1, ans = 0;
        for(int i = 0; i &lt; s.length(); i++){
            if(s[i] == &#39; &#39;){
                if(prevIndex != i - 1){
                    ans++;
                }
                prevIndex = i;
            }
        }
        if(prevIndex &lt; (int)s.length() - 1) ans++;
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1060</wp:post_id>
		<wp:post_date><![CDATA[2017-01-09 18:28:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-09 10:28:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-434-number-of-segments-in-a-string]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 442. Find All Duplicates in an Array</title>
		<link>http://xiadong.info/2017/01/leetcode-442-find-all-duplicates-in-an-array/</link>
		<pubDate>Mon, 09 Jan 2017 10:45:18 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1062</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given an array of integers, 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.
Find all the elements that appear <strong>twice</strong> in this array.
Could you do it without extra space and in O(<em>n</em>) runtime?
<strong>Example:</strong>
<pre lang='undefined'>
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
</pre>
</blockquote>

跟<a href='http://xiadong.info/2017/01/leetcode-448-find-all-numbers-disappeared-in-an-array/'>LeetCode 448. Find All Numbers Disappeared in an Array</a>类似，只不过这次是寻找出现过两次的数。我用0（输入数据中不会出现）来表示该数已经记录过来防止重复计数。

<pre lang='c++'>
class Solution {
public:
    vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; ans;
        for(int i = 0; i &lt; nums.size(); i++){
            if(nums[nums[i] - 1] == 0 || nums[i] == i + 1){
                continue;
            }
            else if(nums[nums[i] - 1] != nums[i]){
                swap(nums[nums[i] - 1], nums[i]);
                i--;
            }
            else{
                ans.push_back(nums[i]);
                nums[nums[i] - 1] = 0;
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1062</wp:post_id>
		<wp:post_date><![CDATA[2017-01-09 18:45:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-09 10:45:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-442-find-all-duplicates-in-an-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>提督着任一周年</title>
		<link>http://xiadong.info/2017/01/%e6%8f%90%e7%9d%a3%e7%9d%80%e4%bb%bb%e4%b8%80%e5%91%a8%e5%b9%b4/</link>
		<pubDate>Mon, 09 Jan 2017 12:30:30 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1064</guid>
		<description></description>
		<content:encoded><![CDATA[说到几年来ACG中最火爆的​IP，舰娘是不得不提到的。我从什么时候开始想尝试一下《舰队Collection》这个游戏已经不记得了，总之是在我开始玩之前就挺久了，我又有一种类似于「原教旨」主义的强迫症，就是除非有足够充足的理由，否则从多个相似的东西中我会选最早出现的或者最初始的，所以我对于国内的一些模仿的游戏没有什么兴趣。但是DMM封锁非日本IP对于国内玩家是一道高墙，虽然我常年FQ，但是一直用美国的地址，2015年我换了VPS后终于有了日本的IP，但是这个IP又过了好几个月才被DMM认为是日本IP，在加上要抢号所以就一直拖延着没有入坑。一年前放寒假在家也不知道我当时是怎么想的，尝试着登陆了一下发现竟然可以访问，于是直接跳进了这个巨坑。

<img src="http://ww1.sinaimg.cn/large/4c1654ddgw1fbkn27fqu2j20m80dcn9h.jpg" alt="img" />

话说当时还只开放柱岛一个服务器，死鱼岛还没有变成秃子岛。一开始的时候俩眼一抹黑，我也不喜欢在贴吧或一些QQ群里问问题，所以我搜到了萌百的舰C条目，所以基本上是一直看萌百来玩的。

<h1 data-breakpage="">舰娘</h1>

初始舰选的是五月雨，原因嘛因为是种田大法。不过我到现在也无法释怀的黑历史就是沉了初始舰……当时作为一名单打独斗的纯萌新，对于大破进击完全没有概念，根本没有想到会沉船，所以就悲剧了……我一直觉得非常对不起我的初始舰，大概半年前疯传五月雨改二还是江风改二的时候贴吧有一篇帖子，标题大概是「初始舰的不同命运」，看到的时候我就一直在想我的初始舰已经看不到现在欣欣向荣的镇守府了。因为这新米提督时期的阴影，所以我发誓一定不会再发生沉船，而且第二次捞上来的五月雨是镇守府第二艘婚舰，也是等级最高的DD。

一开始的时候我的赌船运气并不好，第一艘战舰是扶桑（第一艘婚舰+镇守府最高等级），像五航战、长门级还有铃熊之类比较稀有的普建船基本就没有赌出来过。但是推图倒是很顺利，大船一路碾压到3-2,当时因为没有经验，不像大多数萌新一样先去1-5泡到80级，所以小船练度基本就是没有，3-2又是不能上大船的图，所以临时去1-5把神通川内时雨poi改二了，之后1-5就变成了核潜艇……那时候才开始看到一些dalao对新人的建议，看到说提督等级80以后练小船非常难，所以一直担心我小船练度上不去，不过后来才知道并不需要担心，5-1批量练小船更舒服，浓密如我练级的时候都不红脸的，靠时间也把小船基本都练了（虽然肝婚有点漫长）。

贴吧总是能看到各种非洲人的大建记录贴，我差点以为我也会非的不行，但是幸好没有。因为远征从来不刷闪，所以我的资源增长只够两三天一发大建的，前前后后建了30次左右吧就毕业了，我还记得第一次赌大凤出了我没有的飞龙……现在想来我的双大武B除了大和都是用手机赌出来的，难道真的有buff？出货顺序武藏，大和，BSM，大凤，BSM和漏尿凤是在同一天晚上连出的，我感觉我能吹好久哈哈^^。

至于活动图捞船运气倒是不错，大多数都能入手，新船还没有拿不到的，最多精污100多把……印象比较深的有春活E7捞亲潮，夏活捞欧根和云龙。

<h1 data-breakpage="">活动</h1>

入坑到现在打了四次活动，死咸咸咸，跟现在的萌新没法比啊(｡ŏ_ŏ)。三次大的下滑就是活动时期……

<img src="http://ww4.sinaimg.cn/large/4c1654ddgw1fbkmef0lwxj21080g240t.jpg" alt="img" />

16冬活死在E1,没有对潜装备潜水姬怎么都砸不死，而且当时对于活动还没有什么概念，打了一两天直接放弃了……结果Zara一直绝版到现在……

<img src="http://ww4.sinaimg.cn/large/4c1654ddgw1fbkmhvdtp8j207a06w3ym.jpg" alt="img" />

春活作为史上最屎的有力竞争者，我现在都不想再去回忆当时是怎么打的，E2的DJ姬，E5的彼岸花姬和E6E7的核弹……即使吃丙也是噩梦。没有火箭弹，没有战车，全靠340硬怼，我只记得斩掉E5的时候我真的是从椅子上蹦了起来……不过E2倒是捞船的福利，连开十几个图鉴。五月下旬那密集的锯齿状的曲线就是每天捞船造成的……

接下来的夏活倒是比较平淡。然后就是MMPヲ改遍地的秋活。本来我觉得我的练度也差不多了，可以试试关底打甲，但是事实却是甲甲乙丙丙……

<img src="http://ww2.sinaimg.cn/large/4c1654ddgw1f9zmknkoaxj204z05i747.jpg" alt="img" />

<h1 data-breakpage="">Fin</h1>

我玩舰C的第二天就充钱氪了两个澡堂，到现在又氪了90个床位+4枚戒指，一年的花销也并不大。但是舰C是个极度需要时间的游戏，练级要时间，捞船要等活动，攒资源要时间，可以说玩的时间越长越厉害（所以dalao永远是dalao）……作为一位修仙玩家，我基本上这一年来天天登录，打演习，练级，远征。幸好舰C不需要太高的注意力，完全可以放在一边偶尔点几下，所以也并不怎么影响干正事。

一年了，每天登录到母港已经是一种习惯，70级以上的船也差不多有100艘了，一年前的新米提督早已今非昔比（但从各方面来说依然还是萌新），玩到现在仍然很有乐趣，真是希望能再玩好多年啊……

闲话说了那么多，该结束了，以后的日子也请各位姑娘们多多指教！よろしくお願いします！

<img src="http://ww4.sinaimg.cn/large/4c1654ddgw1fbkmefpqg3j20nm0e6nga.jpg" alt="img" />]]></content:encoded>
		<excerpt:encoded><![CDATA[玩了一年舰C，只做了一些微小的工作，稍微回忆总结一下……]]></excerpt:encoded>
		<wp:post_id>1064</wp:post_id>
		<wp:post_date><![CDATA[2017-01-09 20:30:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-09 12:30:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%8f%90%e7%9d%a3%e7%9d%80%e4%bb%bb%e4%b8%80%e5%91%a8%e5%b9%b4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acg"><![CDATA[ACG]]></category>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 445. Add Two Numbers II</title>
		<link>http://xiadong.info/2017/01/leetcode-445-add-two-numbers-ii/</link>
		<pubDate>Tue, 10 Jan 2017 09:44:03 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1067</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
<strong>Follow up:</strong>
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.
<strong>Example:</strong>
<pre lang='undefined'>
Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 8 -&gt; 0 -&gt; 7
</pre>
</blockquote>

翻转链表后相加再翻转回来。至于Follow up，关键的问题在于加法要求最低位对齐，而单向链表又不能回溯，所以最直接的办法就是用两个数组或者栈保存每个节点的前一个节点……虽然我觉得这实在是有点多此一举，不过没有想到什么更好的办法。

<pre lang='c++'>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        l1 = reverseList(l1);
        l2 = reverseList(l2);
        ListNode ret(0);
        ListNode *p = &amp;ret, *p1 = l1, *p2 = l2;
        int carry = 0;
        while(p1 || p2 || carry &gt; 0){
            int s;
            if(p1 &amp;&amp; p2){
                s = p1-&gt;val + p2-&gt;val + carry;
                p1 = p1-&gt;next;
                p2 = p2-&gt;next;
            }
            else if(p1){
                s = p1-&gt;val + carry;
                p1 = p1-&gt;next;
            }
            else if(p2){
                s = p2-&gt;val + carry;
                p2 = p2-&gt;next;
            }
            else{
                s = carry;
            }
            p-&gt;next = new ListNode(s % 10);
            carry = s / 10;
            p = p-&gt;next;
        }
        ret.next = reverseList(ret.next);
        return ret.next;
    }
    
    ListNode* reverseList(ListNode *l){
        ListNode *p1, *p2;
        p1 = l; p2 = l-&gt;next;
        while(p2){
            ListNode *tmp = p2-&gt;next;
            p2-&gt;next = p1;
            p1 = p2;
            p2 = tmp;
        }
        l-&gt;next = nullptr;
        return p1;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1067</wp:post_id>
		<wp:post_date><![CDATA[2017-01-10 17:44:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-10 09:44:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-445-add-two-numbers-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 449. Serialize and Deserialize BST</title>
		<link>http://xiadong.info/2017/01/leetcode-449-serialize-and-deserialize-bst/</link>
		<pubDate>Tue, 10 Jan 2017 09:56:26 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1069</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.
<strong>The encoded string should be as compact as possible.</strong>
<strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
</blockquote>

序列化一个二叉搜索树，有两个问题：

<ol><li>
如何序列化一个二叉搜索树的节点</li>
<li>
如何序列化节点里的值</li>
</ol>

因为二叉搜索树本身的有序性，所以按照先序遍历的顺序来保存节点就足够恢复BST的结构了。而对于节点里的值，最简单的方法是变为字符串，可是节点值的长度各不相同，这给区分不同的节点带来了麻烦，所以我用四个字节（char）来保存一个int，实际上就是计算机中的小端法存储。

对于节点的序列化与反序列化使用递归来实现。

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    int decodeInt(string &amp;s, int begin){
        int v = 0;
        for(int i = 0; i &lt; 4; i++){
            int t = s[i + begin];
            v |= ((t &amp; 0xff) &lt;&lt; (i &lt;&lt; 3));
        }
        return v;
    }
    
    string encodeInt(int v){
        string s;
        for(int i = 0; i &lt; 4; i++){
            s.push_back(v &amp; 0xff);
            v &gt;&gt;= 8;
        }
        return s;
    }

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        return encodeDFS(root);
    }
    
    string encodeDFS(TreeNode *node){
        if(!node) return string();
        return encodeInt(node-&gt;val) + encodeDFS(node-&gt;left) + encodeDFS(node-&gt;right);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        //cout&lt;&lt;data&lt;&lt;endl;
        return deserializeHelper(data, 0, data.length());
    }
    
    TreeNode* deserializeHelper(string &amp;data, int left, int right){
        if(left == right) return nullptr;
        int v = decodeInt(data, left);
        //cout&lt;&lt;v&lt;&lt;endl;
        TreeNode *node = new TreeNode(v);
        int mid = right;
        for(int i = left + 4; i &lt; right; i += 4){
            int t = decodeInt(data, i);
            if(t &gt; v) {
                mid = i;
                break;
            }
        }
        node-&gt;left = deserializeHelper(data, left + 4, mid);
        node-&gt;right = deserializeHelper(data, mid, right);
        return node;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec codec;
// codec.deserialize(codec.serialize(root));
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1069</wp:post_id>
		<wp:post_date><![CDATA[2017-01-10 17:56:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-10 09:56:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-449-serialize-and-deserialize-bst]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bst"><![CDATA[BST]]></category>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 481. Magical String</title>
		<link>http://xiadong.info/2017/01/leetcode-481-magical-string/</link>
		<pubDate>Tue, 10 Jan 2017 09:59:37 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1071</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>A magical string <strong>S</strong> consists of only &#39;1&#39; and &#39;2&#39; and obeys the following rules:
The string <strong>S</strong> is magical because concatenating the number of contiguous occurrences of characters &#39;1&#39; and &#39;2&#39; generates the string <strong>S</strong> itself.
The first few elements of string <strong>S</strong> is the following: <strong>S</strong> = &quot;1221121221221121122……&quot;
If we group the consecutive &#39;1&#39;s and &#39;2&#39;s in <strong>S</strong>, it will be:
1 22 11 2 1 22 1 22 11 2 11 22 ......
and the occurrences of &#39;1&#39;s or &#39;2&#39;s in each group are:
1 2  2 1 1 2 1 2 2 1 2 2 ......
You can see that the occurrence sequence above is the <strong>S</strong> itself.
Given an integer N as input, return the number of &#39;1&#39;s in the first N number in the magical string <strong>S</strong>.
<strong>Note:</strong> N will not exceed 100,000.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: 6
Output: 3
Explanation: The first 6 elements of magical string S is &quot;12211&quot; and it contains three 1&#39;s, so return 3.
</pre>
</blockquote>

按照一个序列中的数值往这个序列的末尾增加元素，要求1与2是间隔的，不能超过两个相同的值在一起。按照题目给出的规律生成这个序列就可以了。

<pre lang='c++'>
class Solution {
public:
    int magicalString(int n) {
        if(n == 0) return 0;
        vector&lt;int&gt; s(n + 1);
        s[0] = 1, s[1] = 2, s[2] = 2;
        int index1 = 3, index2 = 2;
        int ans = 1;
        while(index1 &lt; n){
            int t = s[index1 - 1] == 1 ? 2 : 1;
            for(int i = 0; i &lt; s[index2]; i++){
                s[index1 + i] = t;
            }
            if(t == 1){
                ans += s[index2];
            }
            index1 += s[index2];
            index2++;
        }
        if(index1 &gt; n &amp;&amp; s[index1 - 1] == 1) ans--; 
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1071</wp:post_id>
		<wp:post_date><![CDATA[2017-01-10 17:59:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-10 09:59:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-481-magical-string]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 476. Number Complement</title>
		<link>http://xiadong.info/2017/01/leetcode-476-number-complement/</link>
		<pubDate>Fri, 13 Jan 2017 08:17:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1086</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
<strong>Note:</strong>
<ol><li>
The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>
You could assume no leading zero bit in the integer’s binary representation.</li>
</ol>
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
</pre>
</blockquote>

就是简单的按位取反，不过不能把前导零给取反了，所以要先确定最高位所在的位置，取反后将更高位置零。

<pre lang='c++'>
class Solution {
public:
    int findComplement(int num) {
        unsigned int unum = num;
        int sigbit = 0;
        while(unum){
            unum &gt;&gt;= 1;
            sigbit++;
        }
        unum = ~num;
        unum = unum &lt;&lt; (32 - sigbit) &gt;&gt; (32 - sigbit);
        return (int)unum;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1086</wp:post_id>
		<wp:post_date><![CDATA[2017-01-13 16:17:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-13 08:17:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-476-number-complement]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 482. License Key Formatting</title>
		<link>http://xiadong.info/2017/01/leetcode-482-license-key-formatting/</link>
		<pubDate>Fri, 13 Jan 2017 08:26:32 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1089</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.
We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.
So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: S = &quot;2-4A0r7-4k&quot;, K = 4

Output: &quot;24A0-R74K&quot;

Explanation: The string S has been split into two parts, each part has 4 characters.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: S = &quot;2-4A0r7-4k&quot;, K = 3

Output: &quot;24-A0R-74K&quot;

Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.
</pre>
<strong>Note:</strong>
<ol><li>
The length of string S will not exceed 12,000, and K is a positive integer.</li>
<li>
String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>
<li>
String S is non-empty.</li>
</ol>
</blockquote>

题目说了很长，但是意思却很简单。就是把一个输入的字符串从后往前分割为K个一组，第一组可以不足K个。然后用“-”把它们连接起来。

<pre lang='c++'>
class Solution {
public:
    string licenseKeyFormatting(string S, int K) {
        string str;
        for(auto c : S){
            if(c == &#39;-&#39;) continue;
            str.push_back(toupper(c));
        }
        string ans, tmp;
        int i;
        for(i = str.length(); i &gt;= K; i -= K){
            ans = str.substr(i - K, K) + &quot;-&quot; + ans;
        }
        if(i &gt; 0){
            ans = str.substr(0, i) + &quot;-&quot; + ans;
        }
        ans.pop_back(); // Delete &quot;-&quot; in the end of ans.
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1089</wp:post_id>
		<wp:post_date><![CDATA[2017-01-13 16:26:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-13 08:26:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-482-license-key-formatting]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 390. Elimination Game</title>
		<link>http://xiadong.info/2017/01/leetcode-390-elimination-game/</link>
		<pubDate>Fri, 13 Jan 2017 08:47:01 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1091</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>There is a list of sorted integers from 1 to <em>n</em>. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.
Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.
We keep repeating the steps again, alternating left to right and right to left, until a single number remains.
Find the last number that remains starting with a list of length <em>n</em>.
<strong>Example:</strong>
<pre lang='undefined'>
Input:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6

Output:
6
</pre>
</blockquote>

这道题我一开始认为会有一个公式来直接计算出最后一个剩下的数是多少，然后又尝试DP从n-1推出n，都没想出来，最后采用的是递归的方法。对于n来说，当n为偶数时，经过一次处理后剩下<code>n/2</code>个数；当为n奇数时，经过一次处理后剩下<code>(n-1)/2</code>个数，把剩下的数的个数作为下一次处理的输入（假设我们的每次处理返回的是数的下标而不是数的具体值），得到的结果为m，那么我们只要把下标m恢复为本次处理的下标即可。

那么如何回复呢？同样分奇偶进行分类，当n为奇数时，举个例子：

<pre lang='undefined'>
Index: 0 1 2 3 4
Value: 1 2 3 4 5
Index: _ 0 _ 1 _
Value: _ 2 _ 4 _
</pre>

无论处理方向正反得到的结果是一样的。可以看出这么一个映射：

<pre lang='undefined'>
m
0 =&gt; 1
1 =&gt; 3
2 =&gt; 5
...
</pre>

所以<code>m * 2 + 1</code>就是本次处理的结果中下标为m的数在本次处理之前的下标。

当m为奇数时有类似的规律，只不过要分处理正（从头到尾）反（从尾到头）方向来讨论。对于正向来说，仍然是<code>m * 2 + 1</code>，对于反向来说则是<code>m * 2</code>。

递归终止条件显然为<code>n==1</code>时返回0。每次递归时要对处理方向取反。

<pre lang='c++'>
class Solution {
    const int L2R = 1, R2L = -1;
    
public:
    int lastRemaining(int n) {
        return lastRemainingImpl(n, L2R) + 1;
    }
    
    int lastRemainingImpl(int n, int direction){
        if(n == 1){
            return 0;
        }
        
        int t = lastRemainingImpl(n % 2 ? (n - 1) / 2 : n / 2, -direction);
        if(n % 2 || direction == L2R){
            return t * 2 + 1;
        }
        else{
            return t * 2;
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1091</wp:post_id>
		<wp:post_date><![CDATA[2017-01-13 16:47:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-13 08:47:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-390-elimination-game]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 485. Max Consecutive Ones</title>
		<link>http://xiadong.info/2017/01/leetcode-485-max-consecutive-ones/</link>
		<pubDate>Sun, 15 Jan 2017 05:53:04 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1093</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a binary array, find the maximum number of consecutive 1s in this array.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
</pre>
<strong>Note:</strong>
<ul><li>
The input array will only contain <code>0</code> and <code>1</code>.</li>
<li>
The length of input array is a positive integer and will not exceed 10,000</li>
</ul>
</blockquote>

最长的连续1的个数。很简单，方法也很多。一开始在最后加一个0是为了方便结尾的处理。

<pre lang='c++'>
class Solution {
public:
    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {
        nums.push_back(0);
        int maxNum = 0;
        int beginIndex = -1;
        for (int i = 0; i &lt; nums.size(); i++) {
            if(nums[i] == 1 &amp;&amp; beginIndex == -1){
                beginIndex = i;
            }
            else if(nums[i] == 0){
                if(beginIndex != -1){
                    maxNum = max(maxNum, i - beginIndex);
                }
                beginIndex = -1;
            }
        }
        return maxNum;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1093</wp:post_id>
		<wp:post_date><![CDATA[2017-01-15 13:53:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-15 05:53:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-485-max-consecutive-ones]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 487. Max Consecutive Ones II</title>
		<link>http://xiadong.info/2017/01/leetcode-487-max-consecutive-ones-ii/</link>
		<pubDate>Sun, 15 Jan 2017 06:01:19 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1095</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [1,0,1,1,0]
Output: 4
Explanation: Flip the first zero will get the the maximum number of consecutive 1s.
    After flipping, the maximum number of consecutive 1s is 4.
</pre>
<strong>Note:</strong>
<ul><li>
The input array will only contain <code>0</code> and <code>1</code>.</li>
<li>
The length of input array is a positive integer and will not exceed 10,000</li>
</ul>
<strong>Follow up:</strong>
What if the input numbers come in one by one as an <strong>infinite stream</strong>? In other words, you can&#39;t store all numbers coming from the stream as it&#39;s too large to hold in memory. Could you solve it efficiently?
</blockquote>

这道题是上一题的升级版。区别在于可以把最多一个0视为1，再求最长的连续1的个数。

我的解法也延续上一题的思路使用双指针，不过这次增加一个变量来记录跳过了多少个0。需要注意的是<code>...100</code>这种情况，左指针（指向子串开头的位置）不能只简单地跳过所有1之后再加1，而应该继续跳过连续的0，这可能导致左指针超过右指针，所以这时要更新右指针。

<pre lang='c++'>
class Solution {
public:
    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {
       int maxNum = 0;
       int p1 = 0, p2 = 0, zero = 1;
       for(; p2 &lt; nums.size(); p2++){
           if(nums[p2] == 0) zero--;
           if(zero &lt; 0){
               maxNum = max(maxNum, p2 - p1);
               while(p1 &lt; nums.size() &amp;&amp; nums[p1] != 0) p1++;
               while(p1 &lt; nums.size() &amp;&amp; nums[p1] != 1) {
                   p1++;
                   if(zero &lt; 1) zero++;
               }
               if(p2 &lt; p1) p2 = p1;
           }
       }
       maxNum = max(maxNum, (int)nums.size() - p1);
       return maxNum;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1095</wp:post_id>
		<wp:post_date><![CDATA[2017-01-15 14:01:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-15 06:01:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-487-max-consecutive-ones-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 488. Zuma Game</title>
		<link>http://xiadong.info/2017/01/leetcode-488-zuma-game/</link>
		<pubDate>Sun, 15 Jan 2017 06:11:45 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1097</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.
Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.
Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.
<pre lang='undefined'>
Examples:

Input: &quot;WRRBBW&quot;, &quot;RB&quot;
Output: -1
Explanation: WRRBBW -&gt; WRR[R]BBW -&gt; WBBW -&gt; WBB[B]W -&gt; WW

Input: &quot;WWRRBBWW&quot;, &quot;WRBRW&quot;
Output: 2
Explanation: WWRRBBWW -&gt; WWRR[R]BBWW -&gt; WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; empty

Input:&quot;G&quot;, &quot;GGGGG&quot;
Output: 2
Explanation: G -&gt; G[G] -&gt; GG[G] -&gt; empty 

Input: &quot;RBYYBBRRB&quot;, &quot;YRBGB&quot;
Output: 3
Explanation: RBYYBBRRB -&gt; RBYY[Y]BBRRB -&gt; RBBBRRB -&gt; RRRB -&gt; B -&gt; B[B] -&gt; BB[B] -&gt; empty 
</pre>
<strong>Note:</strong>
<ol><li>
You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.</li>
<li>
The number of balls on the table won&#39;t exceed 20, and the string represents these balls is called &quot;board&quot; in the input.</li>
<li>
The number of balls in your hand won&#39;t exceed 5, and the string represents these balls is called &quot;hand&quot; in the input.</li>
<li>
Both input strings will be non-empty and only contain characters &#39;R&#39;,&#39;Y&#39;,&#39;B&#39;,&#39;G&#39;,&#39;W&#39;.</li>
</ol>
</blockquote>

这次Contest中最难的题。Zuma游戏的规则，从<code>hand</code>中抽取ball插入到<code>board</code>中，有大于等于三个相同颜色的ball连着就可以消去，问最少几步可以消去，或者无法消去。

初看这道题我以为是图的连通性和最短路径问题（其实也差不多），然后发现构建图的过程中就已经完成了遍历可以得到结果了。使用回溯法，时间上可能效率不高，但好在方法比较容易想到。

对输入的<code>board</code>尝试消去每一个可能的位置，然后对每一个得到的结果递归地进行处理（DFS）。因为<code>board</code>长度不超过20，所以不会因为解空间太大而超时。

代码是Contest的时候写的，可能比较乱……

<pre lang='c++'>
class Solution {
public:
    int findMinStep(string board, string hand){
        return findMinStepImpl(board, hand);
    }
    
    int findMinStepImpl(string board, string hand) {
        if(board.empty()) return 0;
        int minStep = INT_MAX;
        for(int i = 0; i &lt; board.size() - 1; i++){
            if(board[i] == board[i + 1]){
                if(findBall(board[i], hand) != -1){
                    string tb = board, th = hand;
                    char ball = board[i];
                    removeBall(ball, th);
                    tb.insert(tb.begin() + i, ball);
                    removeThree(tb);
                    int ans = findMinStepImpl(tb, th);
                    if(ans != -1) minStep = min(minStep, ans + 1);
                }
            }
        }
        
        if(minStep != INT_MAX)
            return minStep;
        
        for(int i = 0; i &lt; board.size(); i++){
            if(findBall(board[i], hand) != -1){
                string tb = board, th = hand;
                char ball = board[i];
                removeBall(ball, th);
                tb.insert(tb.begin() + i, ball);
                int ans = findMinStepImpl(tb, th);
                if(ans != -1) minStep = min(minStep, ans + 1);
            }
        }
        if(minStep != INT_MAX)
            return minStep;
        else
            return -1;
    }
    
    int findBall(char ball, string &amp;hand){
        auto iter = find(hand.begin(), hand.end(), ball);
        if(iter == hand.end()) return -1;
        else return iter - hand.begin();
    }
    
    void removeBall(char ball, string &amp;hand){
        auto iter = find(hand.begin(), hand.end(), ball);
        if(iter != hand.end()){
            hand.erase(iter);
        }
    }
    
    void removeThree(string &amp;b){
        if(b.size() &lt; 3) return ;
        for(int i = 1; i &lt; b.size(); i++){
            if(b[i] == b[i - 1]){
                int j;
                for(j = i; j &lt; b.size() &amp;&amp; b[j] == b[i]; j++);
                if(j - i + 1 &gt;= 3) {
                    b.erase(i - 1, j - i + 1);
                    return removeThree(b);
                }
            }
        }
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1097</wp:post_id>
		<wp:post_date><![CDATA[2017-01-15 14:11:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-15 06:11:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-488-zuma-game]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 210. Course Schedule II</title>
		<link>http://xiadong.info/2017/01/leetcode-210-course-schedule-ii/</link>
		<pubDate>Tue, 17 Jan 2017 10:06:41 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1100</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code>
Given the total number of courses and a list of prerequisite <strong>pairs</strong>, return the ordering of courses you should take to finish all courses.
There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.
For example:
<pre lang='undefined'>
2, [[1,0]]
</pre>
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is <code>[0,1]</code>
<pre lang='undefined'>
4, [[1,0],[2,0],[3,1],[3,2]]
</pre>
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is<code>[0,2,1,3]</code>.
<strong>Note:</strong>
The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href='https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs'>how a graph is represented</a>.
</blockquote>

要求返回一个图的拓扑排序结果，在有向图存在环路的时候返回空集。拓扑排序可以用点度和队列结合的办法，也可以用DFS的办法。因为输入数据是邻接表，对边的处理比较慢，所以我用DFS来实现拓扑排序，同时判断是否有环存在。

这个题有个条件就是节点编号是在<code>0</code>-<code>n-1</code>之间的，所以记录一个节点的状态可以用数组，没有查询的开销。

<pre lang='c++'>
class Solution {
    vector&lt;int&gt; visited;
    vector&lt;int&gt; inPath;
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        vector&lt;vector&lt;int&gt;&gt; nextCourses(numCourses), preReq(numCourses);
        for(auto i : prerequisites){
            preReq[i.first].push_back(i.second);
            nextCourses[i.second].push_back(i.first);
        }
        visited = vector&lt;int&gt;(numCourses, 0);
        inPath = vector&lt;int&gt;(numCourses, 0);
        vector&lt;int&gt; ans;
        for(int i = 0; i &lt; numCourses; i++){
            if(!visited[i] &amp;&amp; preReq[i].empty()){
                // Begin node
                vector&lt;int&gt; t, path;
                if(DFS(nextCourses, preReq, i, path, t))
                    ans.insert(ans.end(), t.begin(), t.end());
                else
                    return vector&lt;int&gt;();
            }
        }
        if(ans.size() != numCourses)
            return vector&lt;int&gt;();
        else
            return ans;
    }
    
    bool DFS(vector&lt;vector&lt;int&gt;&gt; &amp;nextCourses, vector&lt;vector&lt;int&gt;&gt; &amp;preReq, int node, vector&lt;int&gt; &amp;path, vector&lt;int&gt; &amp;ans){
        if(inPath[node]) {
            ans.clear();
            return false;
        }
        if(visited[node]) return true;
        for(auto i : preReq[node]){
            if(!visited[i])
                return true;
        }
        
        path.push_back(node);
        ans.push_back(node);
        inPath[node] = visited[node] = 1;
        
        for(auto i : nextCourses[node]){
            if(!DFS(nextCourses, preReq, i, path, ans)) 
                return false;
        }
        path.pop_back();
        inPath[node] = 0;
        return true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1100</wp:post_id>
		<wp:post_date><![CDATA[2017-01-17 18:06:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-17 10:06:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-210-course-schedule-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f"><![CDATA[拓扑排序]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 211. Add and Search Word - Data structure design</title>
		<link>http://xiadong.info/2017/01/leetcode-211-add-and-search-word-data-structure-design/</link>
		<pubDate>Tue, 17 Jan 2017 10:09:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1102</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Design a data structure that supports the following two operations:
<pre lang='undefined'>
void addWord(word)
bool search(word)
</pre>
search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.
For example:
<pre lang='undefined'>
addWord(&quot;bad&quot;)
addWord(&quot;dad&quot;)
addWord(&quot;mad&quot;)
search(&quot;pad&quot;) -&gt; false
search(&quot;bad&quot;) -&gt; true
search(&quot;.ad&quot;) -&gt; true
search(&quot;b..&quot;) -&gt; true
</pre>
<strong>Note:</strong>
You may assume that all words are consist of lowercase letters <code>a-z</code>.
</blockquote>

直接用前缀树来实现。

<pre lang='c++'>
class TrieNode {
public:
    char val;
    vector&lt;TrieNode*&gt; children;
    TrieNode* parent;
    bool wordEnd = false;
    TrieNode(char v = 0, TrieNode *p = nullptr) : val(v), parent(p) {}
};

class Trie {
public:
    TrieNode* root;
    Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    void insert(string word) {
        insertToNode(word, root);
    }

    void insertToNode(string word, TrieNode* node) {
        if (word.empty()) {
            node-&gt;wordEnd = true;
            return;
        }
        for (int i = 0; i &lt; node-&gt;children.size(); i++) {
            if (word[0] == node-&gt;children[i]-&gt;val) {
                return insertToNode(word.substr(1), node-&gt;children[i]);
            }
        }
        TrieNode *p = new TrieNode(word[0], node);
        node-&gt;children.push_back(p);
        for (int i = 1; i &lt; word.size(); i++) {
            TrieNode *tmp = new TrieNode(word[i], p);
            p-&gt;children.push_back(tmp);
            p = tmp;
        }
        p-&gt;wordEnd = true;
    }

    // Returns if the word is in the trie.
    bool search(string word, TrieNode *node = nullptr) {
        int pos = 0;
        TrieNode *p = (node ? node : root);
        if (word.empty()) {
            if (p-&gt;wordEnd)
                return true;
            else
                return false;
        }
        for (; pos &lt; word.size(); pos++) {
            if (word[pos] == &#39;.&#39;) {
                if (p-&gt;children.empty() &amp;&amp; word.size() &gt; 1)
                    return false;
                for (int i = 0; i &lt; p-&gt;children.size(); i++) {
                    if (search(word.substr(pos + 1), p-&gt;children[i]))
                        return true;
                }
                return false;
            }
            else {
                bool flag = false;
                for (int i = 0; i &lt; p-&gt;children.size(); i++) {
                    if (word[pos] == p-&gt;children[i]-&gt;val) {
                        p = p-&gt;children[i];
                        flag = true;
                        break;
                    }
                }
                if (flag == false) {
                    return false;
                }
            }
        }
        if (pos == word.size() &amp;&amp; p-&gt;wordEnd) return true;
        else return false;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    bool startsWith(string prefix) {
        int pos = 0;
        TrieNode *p = root;
        for (; pos &lt; prefix.size(); pos++) {
            bool flag = false;
            for (int i = 0; i &lt; p-&gt;children.size(); i++) {
                if (prefix[pos] == p-&gt;children[i]-&gt;val) {
                    p = p-&gt;children[i];
                    flag = true;
                    break;
                }
            }
            if (flag == false) {
                return false;
            }
        }
        return true;
    }

};

class WordDictionary {
public:
    Trie trie;

    // Adds a word into the data structure.
    void addWord(string word) {
        trie.insert(word);
    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character &#39;.&#39; to represent any one letter.
    bool search(string word) {
        return trie.search(word);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1102</wp:post_id>
		<wp:post_date><![CDATA[2017-01-17 18:09:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-17 10:09:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-211-add-and-search-word-data-structure-design]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%bc%80%e6%a0%91trie"><![CDATA[前缀树(Trie)]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 212. Word Search II</title>
		<link>http://xiadong.info/2017/01/leetcode-212-word-search-ii/</link>
		<pubDate>Thu, 19 Jan 2017 09:42:45 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1105</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
For example,
Given <strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board</strong> =
<pre lang='undefined'>
[
  [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],
  [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],
  [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],
  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]
]
</pre>
Return 
<pre lang='undefined'>
[&quot;eat&quot;,&quot;oath&quot;]
</pre>
.
<strong>Note:</strong>
You may assume that all inputs are consist of lowercase letters <code>a-z</code>.
</blockquote>

用DFS来遍历表格，用前缀树来实现判断一个路径是否在目标字符串中。

<pre lang='c++'>
class TrieNode {
public:
    bool isEnd;
    char val;
    vector&lt;TrieNode*&gt; children;
    TrieNode(char _v): isEnd(false), val(_v) {
        children = vector&lt;TrieNode*&gt;(26, nullptr);
    }
};

class Solution {
    TrieNode* root = new TrieNode(0);
    vector&lt;vector&lt;int&gt;&gt; visited;
    vector&lt;string&gt; ans;
    vector&lt;vector&lt;int&gt;&gt; steps = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    int row, col;
public:
    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) {
        for(auto word : words) {
            insertToTrie(word);
        }
        row = board.size();
        if(row == 0) return ans;
        col = board[0].size();
        if(col == 0) return ans;
        visited = vector&lt;vector&lt;int&gt;&gt;(row, vector&lt;int&gt;(col, 0));
        
        string path;
        for(int i = 0; i &lt; row; i++){
            for(int j = 0; j &lt; col; j++){
                DFS(board, path, i, j, root-&gt;children[board[i][j] - &#39;a&#39;]);
            }
        }
        return ans;
    }
    
    void DFS(vector&lt;vector&lt;char&gt;&gt;&amp; board, string &amp;boardPath, int r, int c, TrieNode *node) {
        if (node == nullptr) return;
        visited[r][c] = 1;
        char val = board[r][c];
        boardPath.push_back(val);
        
        if (node-&gt;isEnd) {
            ans.push_back(boardPath); 
            node-&gt;isEnd = false;
        }
        
        for (int i = 0; i &lt; 4; i++) {
            int tr = r + steps[i][0], tc = c + steps[i][1];
            if (isValidPoint(board, tr, tc)) {
                TrieNode *next = node-&gt;children[board[tr][tc] - &#39;a&#39;];
                DFS(board, boardPath, tr, tc, next);
            }
        }
        boardPath.pop_back();
        visited[r][c] = 0;
    }
    
    bool isValidPoint(vector&lt;vector&lt;char&gt;&gt;&amp; board, int r, int c) {
        if(r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || visited[r][c]) return false;
        else return true;
    }
    
    void insertToTrie(string s) {
        TrieNode *p = root, *prev;
        int i = 0;
        do {
            int next = s[i++] - &#39;a&#39;;
            prev = p;
            p = p-&gt;children[next];
        } while (p &amp;&amp; i &lt; s.length());
        if (i &lt; s.length() || p == nullptr) {
            p = prev;
            for(i--; i &lt; s.length(); i++){
                int next = s[i] - &#39;a&#39;;
                p-&gt;children[next] = new TrieNode(s[i]);
                p = p-&gt;children[next];
            }
        }
        p-&gt;isEnd = true;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1105</wp:post_id>
		<wp:post_date><![CDATA[2017-01-19 17:42:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-19 09:42:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-212-word-search-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%bc%80%e6%a0%91trie"><![CDATA[前缀树(Trie)]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 213. House Robber II</title>
		<link>http://xiadong.info/2017/01/leetcode-213-house-robber-ii/</link>
		<pubDate>Thu, 19 Jan 2017 09:49:01 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1107</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote><strong>Note:</strong> This is an extension of <a href='https://leetcode.com/problems/house-robber/'>House Robber</a>.
After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.
</blockquote>

在<a href='http://xiadong.info/2016/11/leetcode-198-house-robber/'>House Robber</a>的简单DP基础上考虑首尾也是相邻的。我把第一个house是否rob分开来进行了两次DP，然后根据最后一个house有没有被抢来从中选择正确的结果。

<pre lang='c++'>
class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        else if (nums.size() == 1) return nums[0];
        else if (nums.size() == 2) {
            return max(nums[0], nums[1]);
        }
        vector&lt;int&gt; v(nums.size(), 0);
        vector&lt;bool&gt; robbed(nums.size(), false);
        v[0] = nums[0];
        robbed[0] = true;
        v[1] = v[0];
        for (int i = 2; i &lt; nums.size(); i++) {
            if (nums[i] + v[i - 2] &gt; v[i - 1]) {
                v[i] = nums[i] + v[i - 2];
                robbed[i] = true;
                robbed[i - 1] = false;
                robbed[i - 2] = true;
            }
            else {
                v[i] = v[i - 1];
                robbed[i - 1] = true;
                robbed[i - 2] = false;
            }
        }
        bool lastRobbed = robbed.back();
        int firstRobbedMax = v.back(), firstRobbedLastNotMax3 = v[v.size() - 3], firstRobbedLastNotMax2 = v[v.size() - 2];
        v[0] = 0;
        robbed[0] = false;
        v[1] = nums[1];
        robbed[1] = true;
        for (int i = 2; i &lt; nums.size(); i++) {
            if (nums[i] + v[i - 2] &gt; v[i - 1]) {
                v[i] = nums[i] + v[i - 2];
                robbed[i] = true;
            }
            else {
                v[i] = v[i - 1];
            }
        }
        int firstNotRobbedMax = v.back();
        if (firstRobbedMax &gt; firstNotRobbedMax &amp;&amp; !lastRobbed) return firstRobbedMax;
        else return max(firstNotRobbedMax, max(firstRobbedLastNotMax3, firstRobbedLastNotMax2));
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1107</wp:post_id>
		<wp:post_date><![CDATA[2017-01-19 17:49:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-19 09:49:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-213-house-robber-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 214. Shortest Palindrome</title>
		<link>http://xiadong.info/2017/01/leetcode-214-shortest-palindrome/</link>
		<pubDate>Sat, 21 Jan 2017 10:59:57 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1110</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.
For example:
Given <code>&quot;aacecaaa&quot;</code>, return <code>&quot;aaacecaaa&quot;</code>.
Given <code>&quot;abcd&quot;</code>, return <code>&quot;dcbabcd&quot;</code>.
</blockquote>

这道题用直接的双重循环<strong>可能</strong>会超时，但是也不一定，比如我下面的代码就可以AC：

<pre lang='c++'>
class Solution {
public:
    string shortestPalindrome(string s) {
        if(s.empty()) return s;
        int max_r = INT_MIN;
        for (int i = s.length() / 2; i &gt;= 0; i--) {
            if ((max_r = palindromeBeside(s, i)) != -1) {
                break;
            }
        }
        string t = s.substr(max_r);
        reverse(t.begin(), t.end());
        return t + s;
    }
    
    int palindromeBeside(string &amp;s, int axis) {
        int l = axis, r = axis;
        for (; l &gt;= 0 &amp;&amp; r &lt; s.length(); l--, r++) {
            if(s[l] != s[r]) 
                break;
        }
        if (l &lt; 0) {
            return r;
        }
        l = axis - 1, r = axis;
        for (; l &gt;= 0 &amp;&amp; r &lt; s.length(); l--, r++) {
            if(s[l] != s[r]) 
                break;
        }
        if (l &lt; 0) {
            return r;
        }
        return -1;
    }
};
</pre>

但是这肯定不是一道Hard题的解法。这道题的本质在于寻找一个字符串<code>S</code>的最长回文前缀子串<code>k</code>，回文串的一个特征就是翻转之后保持不变，如果我们把<code>S</code>整个翻转之后接到<code>S</code>的后面得到的是以<code>k</code>开头，以<code>k</code>结尾的字符串。可以使用KMP算法中计算字符串自我覆盖情况的算法来进行计算，这个算法有点DP的意思，但是理解起来还是有点困难的，具体介绍可以Google关键字KMP。

<pre lang='c++'>
class Solution {
public:
    string shortestPalindrome(string s) {
        if(s.empty()) return s;
        string ts = s;
        reverse(ts.begin(), ts.end());
        ts = s + &quot;|&quot; + ts;
        vector&lt;int&gt; v(ts.length(), 0);
        for (int i = 1; i &lt; ts.length(); i++) {
            int index = i - 1;
            while (index &gt;= 0 &amp;&amp; ts[v[index]] != ts[i]) {
                index = v[index] - 1;
            }
            if (index &gt;= 0) {
                v[i] = v[index] + 1;
            }
        }
        
        ts = s.substr(v.back());
        reverse(ts.begin(), ts.end());
        return ts + s;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1110</wp:post_id>
		<wp:post_date><![CDATA[2017-01-21 18:59:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-21 10:59:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-214-shortest-palindrome]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 215. Kth Largest Element in an Array</title>
		<link>http://xiadong.info/2017/01/leetcode-215-kth-largest-element-in-an-array/</link>
		<pubDate>Sat, 21 Jan 2017 11:04:40 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1112</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
For example,
Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.
<strong>Note: </strong>
You may assume k is always valid, 1 ≤ k ≤ array&#39;s length.
</blockquote>

堆排序，我直接用STL了……

<pre lang='c++'>
class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater&lt;int&gt;());
        return nums[k - 1];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1112</wp:post_id>
		<wp:post_date><![CDATA[2017-01-21 19:04:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-21 11:04:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-215-kth-largest-element-in-an-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 501. Find Mode in Binary Search Tree</title>
		<link>http://xiadong.info/2017/02/leetcode-501-find-mode-in-binary-search-tree/</link>
		<pubDate>Fri, 03 Feb 2017 10:24:00 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1115</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a binary search tree (BST) with duplicates, find all the <a href='https://en.wikipedia.org/wiki/Mode_(statistics)'>mode(s)</a> (the most frequently occurred element) in the given BST.
Assume a BST is defined as follows:
<ul><li>
The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node&#39;s key.</li>
<li>
The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node&#39;s key.</li>
<li>
Both the left and right subtrees must also be binary search trees.</li>
</ul>
For example:
Given BST <code>[1,null,2,2]</code>,
<pre lang='undefined'>
   1
    \
     2
    /
   2
</pre>
return <code>[2]</code>.
<strong>Note:</strong> If a tree has more than one mode, you can return them in any order.
<strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).
</blockquote>

使用Hash表可以快速解决。

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    vector&lt;int&gt; ans;
    unordered_map&lt;int, int&gt; val;
    int maxOccur = 0;
public:
    vector&lt;int&gt; findMode(TreeNode* root) {
        inOrder(root);
        for (auto i : val) {
            if (i.second == maxOccur) 
                ans.push_back(i.first);
        }
        return ans;
    }
    
    void inOrder(TreeNode *node) {
        if(!node) return ;
        inOrder(node-&gt;left);
        maxOccur = max(maxOccur, ++val[node-&gt;val]);
        inOrder(node-&gt;right);
    }
};
</pre>

在要求不使用额外存储空间的情况下，因为这是一棵BST，所以中序遍历结果是一个有序序列，问题就转化为在一个有序序列中连续出现次数最多的元素有哪些。除了维护结果集以外，还要维护结果集中元素的出现次数，上一个元素的值和当前元素的出现次数。当前元素的出现次数超过结果集中元素的出现次数后就清空结果集，然后增加当前元素。

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    vector&lt;int&gt; ans;
    int lastElem = INT_MAX;
    int lastElemOccurTimes;
    int valInAnsOccurTimes = 0;
public:
    vector&lt;int&gt; findMode(TreeNode* root) {
        inOrder(root);
        return ans;
    }
    
    void inOrder(TreeNode *node) {
        if(!node) return ;
        inOrder(node-&gt;left);
        if (lastElem == node-&gt;val) {
            lastElemOccurTimes++;
        }
        else {
            lastElemOccurTimes = 1;
            lastElem = node-&gt;val;
        }
        
        if (lastElemOccurTimes == valInAnsOccurTimes) {
            ans.push_back(node-&gt;val);
        }
        else if (lastElemOccurTimes &gt; valInAnsOccurTimes) {
            valInAnsOccurTimes = lastElemOccurTimes;
            ans.clear();
            ans.push_back(node-&gt;val);
        }
            
        inOrder(node-&gt;right);
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1115</wp:post_id>
		<wp:post_date><![CDATA[2017-02-03 18:24:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-03 10:24:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-501-find-mode-in-binary-search-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bst"><![CDATA[BST]]></category>
		<category domain="category" nicename="cpp"><![CDATA[C++]]></category>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 495. Teemo Attacking</title>
		<link>http://xiadong.info/2017/02/leetcode-495-teemo-attacking/</link>
		<pubDate>Fri, 03 Feb 2017 10:30:03 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1117</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo&#39;s attacking <strong>ascending</strong> time series towards Ashe and the poisoning time duration per Teemo&#39;s attacking, you need to output the total time that Ashe is in poisoned condition.
You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [1,4], 2
Output: 4
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. 
This poisoned status will last 2 seconds until the end of time point 2. 
And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. 
So you finally need to output 4.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [1,2], 2
Output: 3
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. 
This poisoned status will last 2 seconds until the end of time point 2. 
However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. 
Since the poisoned status won&#39;t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. 
So you finally need to output 3.
</pre>
<strong>Note:</strong>
<ol><li>
You may assume the length of given time series array won&#39;t exceed 10000.</li>
<li>
You may assume the numbers in the Teemo&#39;s attacking time series and his poisoning time duration per attacking are non-negative integers, which won&#39;t exceed 10,000,000.</li>
</ol>
</blockquote>

<em>提莫队长，正在送命！</em>

题目比较简单，就是debuff状态时间不会叠加，每次击中目标后重新开始计时，要求返回总的debuff时间。只要每次判断与上一次攻击后的生效时间是否有重合，有的话就减去重合部分即可。

<pre lang='c++'>
class Solution {
public:
    int findPoisonedDuration(vector&lt;int&gt;&amp; timeSeries, int duration) {
        int ans = 0;
        if (timeSeries.empty()) return ans;
        ans = duration;
        for (int i = 1; i &lt; timeSeries.size(); i++) {
            if (timeSeries[i] &gt;= timeSeries[i - 1] + duration) {
                ans += duration;
            }
            else {
                ans += (timeSeries[i] - timeSeries[i - 1]);
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1117</wp:post_id>
		<wp:post_date><![CDATA[2017-02-03 18:30:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-03 10:30:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-495-teemo-attacking]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cpp"><![CDATA[C++]]></category>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 494. Target Sum</title>
		<link>http://xiadong.info/2017/02/leetcode-494-target-sum/</link>
		<pubDate>Fri, 03 Feb 2017 10:36:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1119</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.
Find out how many ways to assign symbols to make sum of integers equal to target S.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: nums is [1, 1, 1, 1, 1], S is 3. 
Output: 5
Explanation: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
</pre>
<strong>Note:</strong>
<ol><li>
The length of the given array is positive and will not exceed 20.</li>
<li>
The sum of elements in the given array will not exceed 1000.</li>
<li>
Your output answer is guaranteed to be fitted in a 32-bit integer.</li>
</ol>
</blockquote>

暴力的DFS可以AC，但是Runtime不理想.

<pre lang='c++'>
class Solution {
    int ans = 0;
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        DFS(nums, 0, 0, S);
        return ans;
    }
    
    void DFS(vector&lt;int&gt;&amp; nums, int i, int path, int S) {
        if (i == nums.size() - 1) {
            if (path + nums[i] == S) ans++;
            if (path - nums[i] == S) ans++;
            return ;
        }
        DFS(nums, i + 1, path + nums[i], S);
        DFS(nums, i + 1, path - nums[i], S);
    }
};
</pre>

使用DP是比较好的选择。<code>dp[i][j]</code>表示前<code>i+1</code>个元素中和为<code>j</code>的情况数，由于和可能为负，所以为了确保下标非负，所有的<code>j</code>减去所有元素的和<code>sum</code>后才是真正的和。

要注意在初始化时，第一个元素如果为0，那么和0所对应的下标<code>sum</code>应该初始化为2而不是1。

<pre lang='c++'>
class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        int sum = 0;
        for (auto i : nums) sum += i;
        
        int dp[nums.size()][sum * 2 + 1];
        memset(dp, 0, sizeof(dp));
        if (S &gt; sum || S &lt; -sum) return 0;
        dp[0][nums[0] + sum]++;
        dp[0][-nums[0] + sum]++;
        for (int i = 1; i &lt; nums.size(); i++) {
            for (int j = 0; j &lt;= sum * 2; j++) {
                if (dp[i - 1][j]) {
                    int index = j + nums[i];
                    if (index &gt;= 0 &amp;&amp; index &lt;= sum * 2) dp[i][index] += dp[i - 1][j];
                    index = j - nums[i];
                    if (index &gt;= 0 &amp;&amp; index &lt;= sum * 2) dp[i][index] += dp[i - 1][j];
                }
            }
        }
        return dp[nums.size() - 1][S + sum];
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1119</wp:post_id>
		<wp:post_date><![CDATA[2017-02-03 18:36:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-03 10:36:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-494-target-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cpp"><![CDATA[C++]]></category>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 492. Construct the Rectangle</title>
		<link>http://xiadong.info/2017/02/leetcode-492-construct-the-rectangle/</link>
		<pubDate>Sat, 04 Feb 2017 07:25:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1123</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>For a web developer, it is very important to know how to design a web page&#39;s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:
<pre lang='undefined'>
1. The area of the rectangular web page you designed must equal to the given target area.

2. The width W should not be larger than the length L, which means L &gt;= W.

3. The difference between length L and width W should be as small as possible.
</pre>
You need to output the length L and the width W of the web page you designed in sequence.
<strong>Example:</strong>
<pre lang='undefined'>
Input: 4
Output: [2, 2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
</pre>
<strong>Note:</strong>
<ol><li>
The given area won&#39;t exceed 10,000,000 and is a positive integer</li>
<li>
The web page&#39;s width and length you designed must be positive integers.</li>
</ol>
</blockquote>

找到最接近的两个因数，使之乘积等于特定值。从给定的<code>area</code>的平方根向两边搜索。

<pre lang='c++'>
class Solution {
public:
    vector&lt;int&gt; constructRectangle(int area) {
        vector&lt;int&gt; ans(2);
        int t = sqrt(area);
        if (t * t == area) {
            ans[0] = ans[1] = t;
            return ans;
        }
        while (area % t != 0) {
            t--;
        }
        ans[0] = area / t;
        ans[1] = t;
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1123</wp:post_id>
		<wp:post_date><![CDATA[2017-02-04 15:25:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-04 07:25:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-492-construct-the-rectangle]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cpp"><![CDATA[C++]]></category>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 496. Next Greater Element I</title>
		<link>http://xiadong.info/2017/02/leetcode-496-next-greater-element-i/</link>
		<pubDate>Mon, 13 Feb 2017 09:21:06 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1125</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>You are given two arrays <strong>(without duplicates)</strong> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>’s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>&#39;s elements in the corresponding places of <code>nums2</code>.
The Next Greater Number of a number <strong>x</strong> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]
Explanation:
    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
    For number 1 in the first array, the next greater number for it in the second array is 3.
    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: nums1 = [2,4], nums2 = [1,2,3,4].
Output: [3,-1]
Explanation:
    For number 2 in the first array, the next greater number for it in the second array is 3.
    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.
</pre>
<strong>Note:</strong>
<ol><li>
All elements in <code>nums1</code> and <code>nums2</code> are unique.</li>
<li>
The length of both <code>nums1</code> and <code>nums2</code> would not exceed 1000.</li>
</ol>
</blockquote>

使用双重循环即可。先搜索数值，再向后搜索比它大的第一个值。

<pre lang='c++'>
class Solution {
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; ans;
        for (auto toFind : findNums) {
            for (int i = 0; i &lt; nums.size(); i++) {
                if (nums[i] == toFind) {
                    int j;
                    for (j = i + 1; j &lt; nums.size() &amp;&amp; nums[j] &lt;= toFind; j++) ;
                    if (j &lt; nums.size()) ans.push_back(nums[j]);
                    else ans.push_back(-1);
                }
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1125</wp:post_id>
		<wp:post_date><![CDATA[2017-02-13 17:21:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-13 09:21:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-496-next-greater-element-i]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 500. Keyboard Row</title>
		<link>http://xiadong.info/2017/02/leetcode-500-keyboard-row/</link>
		<pubDate>Mon, 13 Feb 2017 09:34:30 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1127</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a List of words, return the words that can be typed using letters of <strong>alphabet</strong> on only one row&#39;s of American keyboard like the image below.
<img src='https://leetcode.com/static/images/problemset/keyboard.png' alt='American keyboard' />
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]
Output: [&quot;Alaska&quot;, &quot;Dad&quot;]
</pre>
<strong>Note:</strong>
<ol><li>
You may use one character in the keyboard more than once.</li>
<li>
You may assume the input string will only contain letters of alphabet.</li>
</ol>
</blockquote>

判断每个字母在键盘上位于哪一行，可以用Hash表来保存每个字母所对应的行，也可以每次都搜索一次，因为数据量都很小所以性能差距很小。

Hash表：

<pre lang='c++'>
class Solution {
    vector&lt;int&gt; keymap = {2,3,3,2,1,2,2,2,1,2,2,2,3,3,1,1,1,1,2,1,1,3,1,3,1,3};
public:
    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) {
        vector&lt;string&gt; ans;
        for (auto str : words) {
            int row = keymap[tolower(str[0]) - &#39;a&#39;], i;
            for (i = 1; i &lt; str.length(); i++) {
                if (keymap[tolower(str[i]) - &#39;a&#39;] != row) break;
            }
            if (i == str.length()) ans.push_back(str);
        }
        return ans;
    }
};
</pre>



搜索：

<pre lang='c++'>
class Solution {
    vector&lt;string&gt; keyboard = {&quot;qwertyuiop&quot;, &quot;asdfghjkl&quot;, &quot;zxcvbnm&quot;};
public:
    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) {
        vector&lt;string&gt; ans;
        for (auto str : words) {
            int row = findRow(str[0]), i;
            for (i = 1; i &lt; str.length(); i++) {
                if (findRow(str[i]) != row) break;
            }
            if (i == str.length()) ans.push_back(str);
        }
        return ans;
    }
    
    int findRow(char c) {
        c = tolower(c);
        for (int i = 0; i &lt; keyboard.size(); i++) {
            if (keyboard[i].find(c) != string::npos) 
                return i;
        }
        return -1;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1127</wp:post_id>
		<wp:post_date><![CDATA[2017-02-13 17:34:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-13 09:34:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-500-keyboard-row]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 504. Base 7</title>
		<link>http://xiadong.info/2017/02/leetcode-504-base-7/</link>
		<pubDate>Mon, 13 Feb 2017 09:37:52 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1129</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given an integer, return its base 7 string representation.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: 100
Output: &quot;202&quot;
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: -7
Output: &quot;-10&quot;
</pre>
<strong>Note:</strong> The input will be in range of [-1e7, 1e7].
</blockquote>

使用除法来进行进制转换。

<pre lang='c++'>
class Solution {
public:
    string convertToBase7(int num) {
        int sign = num &gt;= 0 ? 1 : -1;
        string ans;
        num = abs(num);
        if (num == 0) return string(&quot;0&quot;);
        while (num &gt; 0) {
            ans.insert(ans.begin(), (num % 7) + &#39;0&#39;);
            num /= 7;
        }
        if (sign &gt; 0) return ans;
        else return string(&quot;-&quot;) + ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1129</wp:post_id>
		<wp:post_date><![CDATA[2017-02-13 17:37:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-13 09:37:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-504-base-7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 506. Relative Ranks</title>
		<link>http://xiadong.info/2017/02/leetcode-506-relative-ranks/</link>
		<pubDate>Mon, 13 Feb 2017 09:40:35 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1131</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given scores of <strong>N</strong> athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [5, 4, 3, 2, 1]
Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]
Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. 
For the left two athletes, you just need to output their relative ranks according to their scores.
</pre>
<strong>Note:</strong>
<ol><li>
N is a positive integer and won&#39;t exceed 10,000.</li>
<li>
All the scores of athletes are guaranteed to be unique.</li>
</ol>
</blockquote>

用排序+哈希表来建立得分与排名的对应关系。

<pre lang='c++'>
class Solution {
    vector&lt;string&gt; medals = {&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;};
public:
    vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) {
        vector&lt;string&gt; ans;
        unordered_map&lt;int, int&gt; ranks;
        vector&lt;int&gt; sortNums = nums;
        sort(sortNums.begin(), sortNums.end(), greater&lt;int&gt;());
        for (int i = 0; i &lt; sortNums.size(); i++) {
            ranks[sortNums[i]] = i + 1;
        }
        for (auto i : nums) {
            int rank = ranks[i];
            if (rank &lt;= 3) {
                ans.push_back(medals[rank - 1]);
            }
            else {
                ans.push_back(to_string(rank));
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1131</wp:post_id>
		<wp:post_date><![CDATA[2017-02-13 17:40:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-13 09:40:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-506-relative-ranks]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 498. Diagonal Traverse</title>
		<link>http://xiadong.info/2017/02/leetcode-498-diagonal-traverse/</link>
		<pubDate>Sun, 19 Feb 2017 11:04:23 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1134</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.
<strong>Example:</strong>
<pre lang='undefined'>
Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output:  [1,2,4,7,5,3,6,8,9]
Explanation:

</pre>
<strong>Note:</strong>
<ol><li>
The total number of elements of the given matrix will not exceed 10,000.</li>
</ol>
</blockquote>

这道题就是按照题目要求的顺序遍历这个矩阵就可以了。首先有两个方向，对于每个方向在到达矩阵边缘的时候又有两种处理方式，分情况来处理就可以了。
值得注意的是矩阵的右上角与左下角。他们的处理方式分别与矩阵的右边缘和下边缘相同，要注意安排判断横纵坐标的顺序以免越界。

<pre lang='c++'>
class Solution {
    enum DIRECTION {
        DownLeft = 0,
        UpRight = 1
    };
public:
    vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int row = matrix.size();
        if (row == 0) return vector&lt;int&gt;();
        int col = matrix[0].size();
        if (col == 0) return vector&lt;int&gt;();
        
        vector&lt;int&gt; ans;
        
        DIRECTION direction = UpRight;
        
        int x = 0, y = 0;
        while (x != row - 1 || y != col - 1) {
            ans.push_back(matrix[x][y]);
            if (direction == UpRight) {
                if (y == col - 1) {
                    x++;
                    direction = DownLeft;
                }
                else if (x == 0) {
                    y++;
                    direction = DownLeft;
                }
                else {
                    x--;
                    y++;
                }
            }
            else {
                if (x == row - 1) {
                    y++;
                    direction = UpRight;
                }
                else if (y == 0) {
                    x++;
                    direction = UpRight;
                }
                else {
                    x++;
                    y--;
                }
            }
        }
        ans.push_back(matrix[row - 1][col - 1]);
        
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1134</wp:post_id>
		<wp:post_date><![CDATA[2017-02-19 19:04:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-19 11:04:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-498-diagonal-traverse]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 508. Most Frequent Subtree Sum</title>
		<link>http://xiadong.info/2017/02/leetcode-508-most-frequent-subtree-sum/</link>
		<pubDate>Tue, 21 Feb 2017 10:26:05 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1136</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.
<strong>Examples 1</strong>
Input:
<pre lang='undefined'>
  5
 /  \
2   -3
</pre>
return [2, -3, 4], since all the values happen only once, return all of them in any order.
<strong>Examples 2</strong>
Input:
<pre lang='undefined'>
  5
 /  \
2   -5
</pre>
return [2], since 2 happens twice, however -5 only occur once.
<strong>Note:</strong> You may assume the sum of values in any subtree is in the range of 32-bit signed integer.
</blockquote>

用递归来计算每个节点的subtree sum，然后用哈希表保存每个sum的出现次数。

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    unordered_map&lt;int, int&gt; sumFreq;
    int maxSumFreq = INT_MIN;
public:
    vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) {
        DFS_sum(root);
        vector&lt;int&gt; ans;
        for (auto i : sumFreq) {
            if (i.second == maxSumFreq) 
                ans.push_back(i.first);
        }
        return ans;
    }
    
    int DFS_sum(TreeNode *node) {
        if (node == nullptr) {
            return 0;
        }
        int sum = DFS_sum(node-&gt;left) + DFS_sum(node-&gt;right) + node-&gt;val;
        maxSumFreq = max(maxSumFreq, ++sumFreq[sum]);
        return sum;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1136</wp:post_id>
		<wp:post_date><![CDATA[2017-02-21 18:26:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-21 10:26:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-508-most-frequent-subtree-sum]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 513. Find Bottom Left Tree Value</title>
		<link>http://xiadong.info/2017/02/leetcode-513-find-bottom-left-tree-value/</link>
		<pubDate>Tue, 21 Feb 2017 10:31:21 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1138</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a binary tree, find the leftmost value in the last row of the tree.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input:

    2
   / \
  1   3

Output:
1
</pre>
<strong>Example 2: </strong>
<pre lang='undefined'>
Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
</pre>
<strong>Note:</strong> You may assume the tree (i.e., the given root node) is not <strong>NULL</strong>.
</blockquote>

用DFS/BFS遍历一遍二叉树，要保证左子树比右子树先遍历到，这样没出现一个更深的节点就一定是该深度的最左边的节点。

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        return BFS(root);
    }
    
    int BFS(TreeNode *root) {
        queue&lt;TreeNode*&gt; nodeQueue;
        queue&lt;int&gt;       depthQueue; // Store the corresponding depth
        nodeQueue.push(root);
        depthQueue.push(0);
        
        int maxDepth = -1;
        int leftBottomVal;
        while (!nodeQueue.empty()) {
            TreeNode *node = nodeQueue.front();
            nodeQueue.pop();
            int depth = depthQueue.front();
            depthQueue.pop();
            if (maxDepth &lt; depth) {
                maxDepth = depth;
                leftBottomVal = node-&gt;val;
            }
            if (node-&gt;left) {
                nodeQueue.push(node-&gt;left);
                depthQueue.push(depth + 1);
            }
            if (node-&gt;right) {
                nodeQueue.push(node-&gt;right);
                depthQueue.push(depth + 1);
            }
        }
        return leftBottomVal;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1138</wp:post_id>
		<wp:post_date><![CDATA[2017-02-21 18:31:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-21 10:31:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-513-find-bottom-left-tree-value]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 515. Find Largest Value in Each Tree Row</title>
		<link>http://xiadong.info/2017/02/leetcode-515-find-largest-value-in-each-tree-row/</link>
		<pubDate>Tue, 21 Feb 2017 10:34:36 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1140</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>You need to find the largest value in each row of a binary tree.
<strong>Example:</strong>
<pre lang='undefined'>
Input: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

Output: [1, 3, 9]
</pre>
</blockquote>

我使用BFS来遍历二叉树，这样可以保证一行的节点是连续出现的。对于每一行维护一个当前搜索到的最大值，当遇到下一行时说明这一行已经搜索完了，保存结果。

<pre lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    vector&lt;int&gt; ans;
public:
    vector&lt;int&gt; largestValues(TreeNode* root) {
        if (root == nullptr) return ans;
        BFS(root);
        return ans;
    }
    
    void BFS(TreeNode *root) {
        queue&lt;TreeNode*&gt; nodeQueue;
        queue&lt;int&gt;       depthQueue;
        nodeQueue.push(root);
        depthQueue.push(0);
        
        int maxDepth = 0;
        int maxInDepth = root-&gt;val;
        while (!nodeQueue.empty()) {
            TreeNode *node = nodeQueue.front();
            nodeQueue.pop();
            int depth = depthQueue.front();
            depthQueue.pop();
            if (maxDepth &lt; depth) {
                maxDepth = depth;
                ans.push_back(maxInDepth);
                maxInDepth = node-&gt;val;
            }
            else {
                maxInDepth = max(maxInDepth, node-&gt;val);
            }
            
            if (node-&gt;left) {
                nodeQueue.push(node-&gt;left);
                depthQueue.push(depth + 1);
            }
            if (node-&gt;right) {
                nodeQueue.push(node-&gt;right);
                depthQueue.push(depth + 1);
            }
        }
        ans.push_back(maxInDepth); // Last row
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1140</wp:post_id>
		<wp:post_date><![CDATA[2017-02-21 18:34:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-02-21 10:34:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-515-find-largest-value-in-each-tree-row]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 520. Detect Capital</title>
		<link>http://xiadong.info/2017/03/leetcode-520-detect-capital/</link>
		<pubDate>Wed, 01 Mar 2017 09:47:19 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1142</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a word, you need to judge whether the usage of capitals in it is right or not.
We define the usage of capitals in a word to be right when one of the following cases holds:
<ol><li>
All letters in this word are capitals, like &quot;USA&quot;.</li>
<li>
All letters in this word are not capitals, like &quot;leetcode&quot;.</li>
<li>
Only the first letter in this word is capital if it has more than one letter, like &quot;Google&quot;.</li>
</ol>
Otherwise, we define that this word doesn&#39;t use capitals in a right way.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: &quot;USA&quot;
Output: True
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: &quot;FlaG&quot;
Output: False
</pre>
<strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.
</blockquote>

遍历一遍字符串，记录大写字母的出现次数与首字母是否大写，然后根据题目要求返回结果就可以了。

<pre lang='c++'>
class Solution {
public:
    bool detectCapitalUse(string word) {
        if (word.empty()) return true;
        int capitalNum = 0;
        int firstCapital = isupper(word[0]);
        
        for (auto c : word) {
            if (isupper(c)) capitalNum++;
        }
        
        return (capitalNum == 0 || capitalNum == word.length() || (firstCapital &amp;&amp; capitalNum == 1));
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1142</wp:post_id>
		<wp:post_date><![CDATA[2017-03-01 17:47:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-01 09:47:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-520-detect-capital]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 524. Longest Word in Dictionary through Deleting</title>
		<link>http://xiadong.info/2017/03/leetcode-524-longest-word-in-dictionary-through-deleting/</link>
		<pubDate>Wed, 01 Mar 2017 09:51:05 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1144</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input:
s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]

Output: 
&quot;apple&quot;
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input:
s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]

Output: 
&quot;a&quot;
</pre>
<strong>Note:</strong>
<ol><li>
All the strings in the input will only contain lower-case letters.</li>
<li>
The size of the dictionary won&#39;t exceed 1,000.</li>
<li>
The length of all the strings in the input won&#39;t exceed 1,000.</li>
</ol>
</blockquote>

用双指针来判断一个单词可不可以从另一个单词通过删除字母的来。依次判断，选出最长的。如果有多个最长的，就保留字典序较小的。当遍历到一个单词时，可以进行一定的剪枝。

<pre lang='c++'>
class Solution {
public:
    string findLongestWord(string s, vector&lt;string&gt;&amp; d) {
        string ans;
        for (auto word : d) {
            int wordLen = word.length(), ansLen = ans.length();
            if (wordLen &lt;= s.length() &amp;&amp; wordLen &gt;= ansLen &amp;&amp; match(s, word)) {
                if (wordLen &gt; ansLen) ans = word;
                else if (wordLen == ansLen) {
                    ans = min(ans, word);
                }
            }
        }
        return ans;
    }
    
    bool match(string s, string w) {
        int si = 0, wi = 0;
        while (si &lt; s.length() &amp;&amp; wi &lt; w.length()) {
            if (s[si] == w[wi]) {
                wi++;
                si++;
            }
            else {
                si++;
            }
        }
        return wi == w.length();
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1144</wp:post_id>
		<wp:post_date><![CDATA[2017-03-01 17:51:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-01 09:51:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-524-longest-word-in-dictionary-through-deleting]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8f%8c%e6%8c%87%e9%92%88"><![CDATA[双指针]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 525. Contiguous Array</title>
		<link>http://xiadong.info/2017/03/leetcode-525-contiguous-array/</link>
		<pubDate>Fri, 03 Mar 2017 14:12:57 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1146</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.
<strong>Example 1:</strong>
<pre lang='undefined'>
Input: [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.
</pre>
<strong>Example 2:</strong>
<pre lang='undefined'>
Input: [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
</pre>
<strong>Note:</strong> The length of the given binary array will not exceed 50,000.
</blockquote>

这道题一看上去我想到了贪心orDP的方向，但是可以用哈希表来解决。思考的关键在于连续子数组中含有相同数目的0和1会具有什么样的特征，另外一点要考虑的是数据规模。数据规模达到50000，说明解法是小于O(n^2)的，而通过对数组一次遍历可以得到的结果有从数组开始到某一个下标为止所包含的0和1的个数。

如果一个连续子数组<code>[i:j]</code>中的0和1数目相等，那么子数组<code>[0:i]</code>和<code>[0:j]</code>中的0的个数与1的个数之差是相等的。因此对于每一个差值记录最小的下标，当再次出现这个差值时，两个下标之间的子数组就含有相同的0和1.

<pre lang='c++'>
class Solution {
public:
    int findMaxLength(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; diff;
        int cnt[2] = {0, 0};
        int ans = 0;
        diff[0] = -1;
        for (int i = 0; i &lt; nums.size(); i++) {
            cnt[nums[i]]++;
            int t = cnt[0] - cnt[1];
            if (diff.count(t)) {
                ans = max(ans, i - diff[t]);
            }
            else {
                diff[t] = i;
            }
        }
        return ans;
    }
};
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1146</wp:post_id>
		<wp:post_date><![CDATA[2017-03-03 22:12:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-03 14:12:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-525-contiguous-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 526. Beautiful Arrangement</title>
		<link>http://xiadong.info/2017/03/leetcode-526-beautiful-arrangement/</link>
		<pubDate>Fri, 03 Mar 2017 14:19:59 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1148</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Suppose you have <strong>N</strong> integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these <strong>N</strong> numbers successfully if one of the following is true for the ith position (1 ≤ i ≤ N) in this array:
<ol><li>
The number at the ith position is divisible by <strong>i</strong>.</li>
<li>
<strong>i</strong> is divisible by the number at the ith position.</li>
</ol>
Now given N, how many beautiful arrangements can you construct?
<strong>Example 1:</strong>
<p class='math-block'>$$Input: 2
Output: 2
Explanation: 

The first beautiful arrangement is [1, 2]:

Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).

Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).

The second beautiful arrangement is [2, 1]:

Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).

Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.$$</p>
<strong>Note:</strong>
<ol><li>
<strong>N</strong> is a positive integer and will not exceed 15.</li>
</ol>
</blockquote>

因为数据规模比较小，可以先确定对于每一个位置可以选择数值有哪些，然后再用回溯法穷举。

<pre><code class='language-c++' lang='c++'>
class Solution {
    vector&lt;vector&lt;int&gt;&gt; possibleValue;
    int ans = 0;
public:
    int countArrangement(int N) {
        setPossibleValue(N);
        vector&lt;int&gt; visited(N, 0);
        tryValue(0, visited);
        return ans;
    }
    
    void tryValue (int index, vector&lt;int&gt; &amp;visited) {
        if (index == visited.size()) {
            ans++;
            return;
        }
        for (int i = 0; i &lt; possibleValue[index].size(); i++) {
            if (!visited[possibleValue[index][i]]) {
                visited[possibleValue[index][i]] = 1;
                tryValue(index + 1, visited);
                visited[possibleValue[index][i]] = 0;
            }
        }
    }
    
    void setPossibleValue (int N) {
        for (int i = 1; i &lt;= N; i++) {
            vector&lt;int&gt; val;
            for (int j = 1; j &lt;= N; j++) {
                if (i % j == 0 || j % i == 0) {
                    val.push_back(j - 1);
                }
            }

            possibleValue.push_back(val);
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1148</wp:post_id>
		<wp:post_date><![CDATA[2017-03-03 22:19:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-03 14:19:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-526-beautiful-arrangement]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%ba%af"><![CDATA[回溯]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 529. Minesweeper</title>
		<link>http://xiadong.info/2017/03/leetcode-529-minesweeper/</link>
		<pubDate>Fri, 03 Mar 2017 14:22:28 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1150</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Let&#39;s play the minesweeper game (<a href='https://en.wikipedia.org/wiki/Minesweeper_(video_game)'>Wikipedia</a>, <a href='http://minesweeperonline.com/'>online game</a>)!
You are given a 2D char matrix representing the game board. <strong>&#39;M&#39;</strong> represents an <strong>unrevealed</strong> mine, <strong>&#39;E&#39;</strong> represents an <strong>unrevealed</strong> empty square, <strong>&#39;B&#39;</strong> represents a <strong>revealed</strong> blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, <strong>digit</strong> (&#39;1&#39; to &#39;8&#39;) represents how many mines are adjacent to this <strong>revealed</strong> square, and finally <strong>&#39;X&#39;</strong> represents a <strong>revealed</strong> mine.
Now given the next click position (row and column indices) among all the <strong>unrevealed</strong> squares (&#39;M&#39; or &#39;E&#39;), return the board after revealing this position according to the following rules:
<ol><li>
If a mine (&#39;M&#39;) is revealed, then the game is over - change it to <strong>&#39;X&#39;</strong>.</li>
<li>
If an empty square (&#39;E&#39;) with <strong>no adjacent mines</strong> is revealed, then change it to revealed blank (&#39;B&#39;) and all of its adjacent <strong>unrevealed</strong> squares should be revealed recursively.</li>
<li>
If an empty square (&#39;E&#39;) with <strong>at least one adjacent mine</strong> is revealed, then change it to a digit (&#39;1&#39; to &#39;8&#39;) representing the number of adjacent mines.</li>
<li>
Return the board when no more squares will be revealed.</li>
</ol>
<strong>Example 1:</strong>
<p class='math-block'>$$Input: 

[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]

Click : [3,0]

Output: 

[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]

Explanation:
$$</p>
<strong>Example 2:</strong>
<p class='math-block'>$$Input: 

[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]

Click : [1,2]

Output: 

[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]

Explanation:
$$</p>
<strong>Note:</strong>
<ol><li>
The range of the input matrix&#39;s height and width is [1,50].</li>
<li>
The click position will only be an unrevealed square (&#39;M&#39; or &#39;E&#39;), which also means the input board contains at least one clickable square.</li>
<li>
The input board won&#39;t be a stage when game is over (some mines have been revealed).</li>
<li>
For simplicity, not mentioned rules should be ignored in this problem. For example, you <strong>don&#39;t</strong> need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li>
</ol>
</blockquote>

扫雷游戏，根据题目要求做相应的处理就可以了。

<pre><code class='language-c++' lang='c++'>
class Solution {
    int totalRow, totalCol;
public:
    vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;int&gt;&amp; click) {
        totalRow = board.size();
        totalCol = board[0].size();
        char cur = board[click[0]][click[1]];
        switch (cur) {
            case &#39;M&#39;:
                updateM(board, click[0], click[1]);
                break;
            case &#39;E&#39;:
                updateE(board, click[0], click[1]);
                break;
        }
        return board;
    }
    
    void updateM (vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col) {
        board[row][col] = &#39;X&#39;;
    }
    
    void updateE (vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col) {
        if (row &lt; 0 || col &lt; 0 || row &gt;= totalRow || col &gt;= totalCol || board[row][col] != &#39;E&#39;) return;
        int mine = adjacentMine(board, row, col);
        if (mine) {
            board[row][col] = mine + &#39;0&#39;;
        }
        else {
            board[row][col] = &#39;B&#39;;
            updateE(board, row - 1, col - 1);
            updateE(board, row - 1, col);
            updateE(board, row - 1, col + 1);
            updateE(board, row, col + 1);
            updateE(board, row + 1, col + 1);
            updateE(board, row + 1, col);
            updateE(board, row + 1, col - 1);
            updateE(board, row, col - 1);
        }
    }
    
    int adjacentMine (vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col) {
        int cnt = 0;
        if (row - 1 &gt;= 0 &amp;&amp; col - 1 &gt;= 0 &amp;&amp; board[row - 1][col - 1] == &#39;M&#39;)                cnt++;
        if (row - 1 &gt;= 0 &amp;&amp; board[row - 1][col] == &#39;M&#39;)                                    cnt++;
        if (row - 1 &gt;= 0 &amp;&amp; col + 1 &lt; totalCol &amp;&amp; board[row - 1][col + 1] == &#39;M&#39;)          cnt++;
        if (col + 1 &lt; totalCol &amp;&amp; board[row][col + 1] == &#39;M&#39;)                              cnt++;
        if (row + 1 &lt; totalRow &amp;&amp; col + 1 &lt; totalCol &amp;&amp; board[row + 1][col + 1] == &#39;M&#39;)    cnt++;
        if (row + 1 &lt; totalRow &amp;&amp; board[row + 1][col] == &#39;M&#39;)                              cnt++;
        if (row + 1 &lt; totalRow &amp;&amp; col - 1 &gt;= 0 &amp;&amp; board[row + 1][col - 1] == &#39;M&#39;)          cnt++;
        if (col - 1 &gt;= 0 &amp;&amp; board[row][col - 1] == &#39;M&#39;)                                    cnt++;
        
        return cnt;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1150</wp:post_id>
		<wp:post_date><![CDATA[2017-03-03 22:22:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-03 14:22:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-529-minesweeper]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 530. Minimum Absolute Difference in BST</title>
		<link>http://xiadong.info/2017/03/leetcode-530-minimum-absolute-difference-in-bst/</link>
		<pubDate>Sat, 04 Mar 2017 07:47:35 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1152</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a binary search tree with non-negative values, find the minimum <a href='https://en.wikipedia.org/wiki/Absolute_difference'>absolute difference</a> between values of any two nodes.
<strong>Example:</strong>
<pre>Input:

   1
    \
     3
    /
   2

Output:
1

Explanation:
The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</pre>
<strong>Note:</strong> There are at least two nodes in this BST.
</blockquote>

一个只包含非负元素的二叉搜索树中找到两个元素之间的最小差的绝对值。因为是二叉搜索树所以用中序遍历就可以得到一个有序序列，最小的差值一定是出现在相邻的元素中，只比较相邻元素的差值即可。

<pre><code class='language-c++' lang='c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int ans = INT_MAX;
    int prevVal = -1;
public:
    int getMinimumDifference(TreeNode* root) {
        inOrder(root);
        return ans;
    }
    
    void inOrder (TreeNode *node) {
        if (!node) return ;
        inOrder(node-&gt;left);
        if(prevVal &gt;= 0) ans = min (ans, node-&gt;val - prevVal);
        prevVal = node-&gt;val;
        inOrder(node-&gt;right);
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1152</wp:post_id>
		<wp:post_date><![CDATA[2017-03-04 15:47:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-04 07:47:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-530-minimum-absolute-difference-in-bst]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[530-minimum-absolute-difference-in-bst]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 535. Encode and Decode TinyURL</title>
		<link>http://xiadong.info/2017/03/leetcode-535-encode-and-decode-tinyurl/</link>
		<pubDate>Sat, 04 Mar 2017 07:49:05 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1156</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>.
Design the <code>encode</code> and <code>decode</code> methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.
<strong>Note:</strong> Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.
</blockquote>

短链接的维护，但不限制内部如何生成短链接。就是Hash表的问题，我直接使用的<code>unordered_map</code>容器所提供的Hash函数对原链接进行处理，得到一个数值，然后将该数值转换为62进制字符串（10个数字+大小写字母各26个），该字符串作为短链接的后缀部分。

<pre><code class='language-c++' lang='c++'>
class Solution {
    string tinyUrlPrefix = &quot;http://tinyurl.com/&quot;;
    unordered_map&lt;string, string&gt; urls;
public:

    // Encodes a URL to a shortened URL.
    string encode(string longUrl) {
        auto hashFunc = urls.hash_function();
        size_t key = hashFunc(longUrl);
        string shortUrl = tinyUrlPrefix + convertToSixtyTwoBase(key);
        urls[shortUrl] = longUrl;
        return shortUrl;
    }

    // Decodes a shortened URL to its original URL.
    string decode(string shortUrl) {
        return urls[shortUrl];
    }
    
    string convertToSixtyTwoBase (size_t key) {
        string str;
        while (key &gt; 0) {
            int mod = key % 62;
            if (mod &lt; 10) str.push_back(mod + &#39;0&#39;);
            else if (mod &lt; 36) str.push_back(mod - 10 + &#39;a&#39;);
            else str.push_back(mod - 36 + &#39;A&#39;);
            key /= 62;
        }
        return str;
    }
};

// Your Solution object will be instantiated and called as such:
// Solution solution;
// solution.decode(solution.encode(url));
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1156</wp:post_id>
		<wp:post_date><![CDATA[2017-03-04 15:49:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-04 07:49:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-535-encode-and-decode-tinyurl]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 532. K-diff Pairs in an Array</title>
		<link>http://xiadong.info/2017/03/leetcode-532-k-diff-pairs-in-an-array/</link>
		<pubDate>Fri, 10 Mar 2017 13:04:51 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1161</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given an array of integers and an integer <strong>k</strong>, you need to find the number of <strong>unique</strong> k-diff pairs in the array. Here a <strong>k-diff</strong> pair is defined as an integer pair (i, j), where <strong>i</strong> and <strong>j</strong> are both numbers in the array and their <a href='https://en.wikipedia.org/wiki/Absolute_difference'>absolute difference</a> is <strong>k</strong>.
<strong>Example 1:</strong>
<p class='math-block'><pre>Input: [3, 1, 4, 1, 5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of unique pairs.</pre></p>
<strong>Example 2:</strong>
<p class='math-block'><pre>Input:[1, 2, 3, 4, 5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).</pre></p>
<strong>Example 3:</strong>
<p class='math-block'><pre>Input: [1, 3, 1, 5, 4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).</pre></p>
<strong>Note:</strong>
<ol><li>
The pairs (i, j) and (j, i) count as the same pair.</li>
<li>
The length of the array won&#39;t exceed 10,000.</li>
<li>
All the integers in the given input belong to the range: [-1e7, 1e7].</li>
</ol>
</blockquote>

寻找有多少组差的绝对值等于k的数。先对数组进行排序，然后用双指针从前向后搜索：

<ol><li>
移动右指针，直到左右指针元素之差的绝对值大于等于k；</li>
<li>
再移动左指针，直到左右指针元素之差的绝对值小于k；</li>
<li>
重复1,2步直到右指针到达数组结尾，记录下出现过的k的次数；</li>
</ol>

为了去重要跳过已经出现的元素。

<pre><code class='language-c++' lang='c++'>
class Solution {
public:
    int findPairs(vector&lt;int&gt;&amp; nums, int k) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        int p1 = 0, p2 = 1;
        int len = nums.size();
        if (len &lt; 2) return ans;
        while (p1 &lt; len &amp;&amp; p2 &lt; len) {
            int diff = nums[p2] - nums[p1];
            if (diff == k) {
                ans++;
                do {p1++;} while (p1 &lt; len &amp;&amp; nums[p1 - 1] == nums[p1]);
                do {p2++;} while (p2 &lt; len &amp;&amp; nums[p2 - 1] == nums[p2]);
            }
            else if (diff &lt; k) {
                p2++;
            }
            else {
                p1++;
            }
            if (p1 &gt;= p2) p2 = p1 + 1;
        }
        return ans;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1161</wp:post_id>
		<wp:post_date><![CDATA[2017-03-10 21:04:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-10 13:04:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-532-k-diff-pairs-in-an-array]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 241. Different Ways to Add Parentheses</title>
		<link>http://xiadong.info/2017/03/leetcode-241-different-ways-to-add-parentheses/</link>
		<pubDate>Fri, 10 Mar 2017 13:11:14 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1165</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.
Example 1
Input: <code>&quot;2-1-1&quot;</code>.
<pre><code>
((2-1)-1) = 0
(2-(1-1)) = 2
</code></pre>
Output: <code>[0, 2]</code>
Example 2
Input: <code>&quot;2*3-4*5&quot;</code>
<pre><code>
(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
</code></pre>
Output: <code>[-34, -14, -10, -10, 10]</code>
</blockquote>

一开始我以为这是个排列组合问题，实际上也确实是，但是使用分治+递归可以更容易的解决。使用每个运算符把算式分割成两部分，再对两部分分别递归地处理，直到没有运算符，就直接返回数值。两边的字符串分别返回一个结果数组，根据操作符对数组中的元素两两进行运算，将结果放到结果集中返回给上一层函数。

要注意的是这道题并不用去重。

<pre><code class='language-c++' lang='c++'>
class Solution {
public:
    vector&lt;int&gt; diffWaysToCompute(string input) {
        return diffWaysToComputeImpl(input, 0, input.length());
    }
    
    vector&lt;int&gt; diffWaysToComputeImpl(string &amp;input, int left, int right) {
        vector&lt;int&gt; ans;
        for (int i = left; i &lt; right; i++) {
            if (isOperation(input[i])) {
                auto leftResult = diffWaysToComputeImpl(input, left, i);
                auto rightResult = diffWaysToComputeImpl(input, i + 1, right);
                for (auto j : leftResult) {
                    for (auto k : rightResult) {
                        ans.push_back(operate(j, k, input[i]));
                    }
                }
            }
        }
        if (ans.empty()) {
            ans.push_back(stoi(input.substr(left, right - left)));
        }
        return ans;
    }
    
    int operate (int a, int b, char op) {
        switch(op){
            case &#39;+&#39;:
                return a + b;
            case &#39;-&#39;:
                return a - b;
            case &#39;*&#39;:
                return a * b;
        }
    }
    
    bool isOperation (char c) {
        return (c == &#39;+&#39; || c == &#39;-&#39; || c == &#39;*&#39;);
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1165</wp:post_id>
		<wp:post_date><![CDATA[2017-03-10 21:11:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-10 13:11:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-241-different-ways-to-add-parentheses]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e6%b2%bb"><![CDATA[分治]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 516. Longest Palindromic Subsequence</title>
		<link>http://xiadong.info/2017/03/leetcode-516-longest-palindromic-subsequence/</link>
		<pubDate>Tue, 14 Mar 2017 10:00:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1167</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a string s, find the longest palindromic subsequence&#39;s length in s. You may assume that the maximum length of s is 1000.
<strong>Example 1:</strong>
Input:
<pre><code>
&quot;bbbab&quot;
</code></pre>
Output:
<pre><code>
4
</code></pre>
One possible longest palindromic subsequence is &quot;bbbb&quot;.
<strong>Example 2:</strong>
Input:
<pre><code>
&quot;cbbd&quot;
</code></pre>
Output:
<pre><code>
2
</code></pre>
One possible longest palindromic subsequence is &quot;bb&quot;.
</blockquote>

二维DP。<code>dp[i][j]</code>表示<code>s[i]</code>到<code>s[j]</code>（含两端）的字符串中最长的回文子串。状态转移方程如下：

<ol><li>
<code>i==j</code>，<code>dp[i][j]=1</code></li>
<li>
<code>i==j-1</code>，<code>dp[i][j]=2</code></li>
<li>
<code>dp[i]==dp[j]</code>， <code>dp[i][j]=dp[i+1][j-1]+2</code></li>
<li>
<code>dp[i]!=dp[j]</code>，<code>dp[i][j]=max(dp[i+1][j], dp[i][j-1])</code></li>
</ol>

<pre><code class='language-c++' lang='c++'>
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector&lt;vector&lt;int&gt;&gt; dp(s.length(), vector&lt;int&gt;(s.length(), 0));
        if (s.empty()) return 0;
        int maxLen = 1;
        for (int i = 0; i &lt; s.length(); i++) {
            dp[i][i] = 1;
        }
        for (int i = s.length() - 1; i &gt;= 0; i--) {
            for (int j = i + 1; j &lt; s.length(); j++) {
                if (s[i] == s[j]) {
                    if (i + 1 == j) dp[i][j] = 2;
                    else dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][s.length() - 1];
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1167</wp:post_id>
		<wp:post_date><![CDATA[2017-03-14 18:00:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-14 10:00:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-516-longest-palindromic-subsequence]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 539. Minimum Time Difference</title>
		<link>http://xiadong.info/2017/03/leetcode-539-minimum-time-difference/</link>
		<pubDate>Tue, 14 Mar 2017 10:03:51 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1170</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a list of 24-hour clock time points in &quot;Hour:Minutes&quot; format, find the minimum <strong>minutes</strong> difference between any two time points in the list.
<strong>Example 1:</strong>
<pre><code>
Input: [&quot;23:59&quot;,&quot;00:00&quot;]
Output: 1
</code></pre>
<strong>Note:</strong>
<ol><li>
The number of time points in the given list is at least 2 and won&#39;t exceed 20000.</li>
<li>
The input time is legal and ranges from 00:00 to 23:59.</li>
</ol>
</blockquote>

先进行排序，然后依次计算相邻时间的时间差，这个时间差有两个方向，选择较小的一个。最后要注意还要算最后一个时间与第一个时间的时间差。

<pre><code class='language-c++' lang='c++'>
class Solution {
public:
    int findMinDifference(vector&lt;string&gt;&amp; timePoints) {
        if (timePoints.size() &gt;= 1440) return 0;
        sort(timePoints.begin(), timePoints.end());
        int minDiff = INT_MAX;
        for (int i = 1; i &lt; timePoints.size(); i++) {
            minDiff = min(minDiff, calcDiff(timePoints[i - 1], timePoints[i]));
        }
        minDiff = min(minDiff, calcDiff(timePoints[0], timePoints.back()));
        return minDiff;
    }
    
    int calcDiff (string &amp;a, string &amp;b) {
        int aH = stoi(a.substr(0, 2)), 
            bH = stoi(b.substr(0, 2)),
            aM = stoi(a.substr(3, 2)),
            bM = stoi(b.substr(3, 2));
            
        int diff;
        
        if (bH == aH) {
            return bM - aM;
        }
        else {
            diff = (60 - aM) + bM + (bH - aH - 1) * 60;
        }
        return min(diff, 1440 - diff);
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1170</wp:post_id>
		<wp:post_date><![CDATA[2017-03-14 18:03:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-14 10:03:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-539-minimum-time-difference]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 541. Reverse String II</title>
		<link>http://xiadong.info/2017/03/leetcode-541-reverse-string-ii/</link>
		<pubDate>Tue, 14 Mar 2017 10:07:08 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1172</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：

<blockquote>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.
<strong>Example:</strong>
<pre><code>
Input: s = &quot;abcdefg&quot;, k = 2
Output: &quot;bacdfeg&quot;
</code></pre>
<strong>Restrictions:</strong>The string consists of lower English letters only.Length of the given string and k will in the range [1, 10000]
</blockquote>

按照题目要求翻转字符串即可。

<pre><code class='language-c++' lang='c++'>
class Solution {
public:
    string reverseStr(string s, int k) {
        int k2 = k &lt;&lt; 1;
        int i;
        for (i = 0; i &lt; s.length(); i += k2) {
            if (i + k &lt;= s.length())
                reverseStr(s, i, i + k);
            else
                reverseStr(s, i, s.length());
        }
        return s;
    }
    
    void reverseStr(string &amp;s, int left, int right) {
        for (int i = 0; left + i &lt; right - i - 1; i++) {
            swap(s[left + i], s[right - i - 1]);
        }
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1172</wp:post_id>
		<wp:post_date><![CDATA[2017-03-14 18:07:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-14 10:07:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-541-reverse-string-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>为Docker设置下载代理</title>
		<link>http://xiadong.info/2017/03/%e4%b8%badocker%e8%ae%be%e7%bd%ae%e4%b8%8b%e8%bd%bd%e4%bb%a3%e7%90%86/</link>
		<pubDate>Sat, 18 Mar 2017 10:16:34 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1175</guid>
		<description></description>
		<content:encoded><![CDATA[<p>今天装Docker，在下载image的时候总是链接被重置，用Proxychain也没法代理。通过Google找到<a href='https://stackoverflow.com/questions/23111631/cannot-download-docker-images-behind-a-proxy/28093517#28093517' target='_blank' >https://stackoverflow.com/questions/23111631/cannot-download-docker-images-behind-a-proxy/28093517#28093517</a>，官方文档地址：<a href='https://docs.docker.com/engine/admin/systemd/#http-proxy' target='_blank' >https://docs.docker.com/engine/admin/systemd/#http-proxy</a> 。通过配置文件来指定http代理。</p>
<p>具体步骤如下：</p>
<ol><li>
在<code>/etc/systemd/system</code>目录下创建<code>docker.service.d</code>目录</li>
<li>
在<code>docker.service.d</code>目录中创建文件<code>http-proxy.conf</code>文件</li>
<li>
在配置文件中添加：</li>
</ol>
<pre><code class='language-shell' lang='shell'>
[Service]
Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;
</code></pre>
<ol><li>
可以使用<code>NO_PROXY</code>变量指定不走代理的地址：</li>
</ol>
<pre><code class='language-shell' lang='shell'>
Environment=&quot;NO_PROXY=localhost,127.0.0.0/8,docker-registry.somecorporation.com&quot;
</code></pre>
<ol><li>
运行<code>sudo systemctl daemon-reload</code>更新设置</li>
<li>
使用<code>systemctl show --property=Environment docker</code>来查看设置是否生效</li>
</ol>
<pre><code>
Environment=HTTP_PROXY=http://proxy.example.com:80/
</code></pre>
<ol><li>
重启Docker：<code>sudo systemctl restart docker</code></li>
</ol>
<p>我的系统是Ubuntu 16.04，用ss-qt来科学上网，代理服务器的地址填写ss的地址就可以了。要注意ss应设置为http代理而不是socks5。</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1175</wp:post_id>
		<wp:post_date><![CDATA[2017-03-18 18:16:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-18 10:16:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%badocker%e8%ae%be%e7%bd%ae%e4%b8%8b%e8%bd%bd%e4%bb%a3%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="docker"><![CDATA[Docker]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>在终端中用ASCII字符播放视频</title>
		<link>http://xiadong.info/2017/03/%e5%9c%a8%e7%bb%88%e7%ab%af%e4%b8%ad%e7%94%a8ascii%e5%ad%97%e7%ac%a6%e6%92%ad%e6%94%be%e8%a7%86%e9%a2%91/</link>
		<pubDate>Thu, 23 Mar 2017 12:34:24 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1178</guid>
		<description></description>
		<content:encoded><![CDATA[一直想写一个用ASCII字符组成字符画来播放视频的小程序来玩，今天花了大半天时间总算是写出来了：<a href="https://github.com/xiadong1994/ascii-video-player">https://github.com/xiadong1994/ascii-video-player</a>，采用Python+OpenCV

基本原理很简单，就是使用OpenCV解码视频后把每一帧转换为灰度图像后把像素按照终端的窗口大小分成大约对应一个字符大小的块，计算平均值后选择相近的ASCII字符输出即可。

我在Ubuntu 16.04和Python 3.5下编写的程序，其他环境都没有测试。
<h2>问题记录</h2>
<ol>
 	<li>pip安装的opencv-python不支持gtk桌面，我重新从源码编译了一遍（虽然我的最终程序中并不需要显示新窗口）</li>
 	<li>使用Python提供的<code>ProcessPoolExecutor</code>和<code>ThreadPoolExecutor</code>没有有效的加速计算，甚至比单纯的循环还要慢，我对于Python的并发编程一点都不懂……</li>
 	<li>对于字符的选择处理得有点随意，影响最终的效果</li>
</ol>
<h2>效果</h2>
<table>
<thead>
<tr>
<th>原始</th>
<th>ASCII</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/bad_apple.png" target="_blank"><img style="max-width: 100%;" src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/bad_apple.png" alt="bad_apple.png" /></a></td>
<td><a href="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/bad_apple_ascii.png" target="_blank"><img style="max-width: 100%;" src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/bad_apple_ascii.png" alt="bad_apple_ascii" /></a></td>
</tr>
<tr>
<td><a href="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/hyouka.png" target="_blank"><img style="max-width: 100%;" src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/hyouka.png" alt="" /></a></td>
<td><a href="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/hyouka_ascii.png" target="_blank"><img style="max-width: 100%;" src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/hyouka_ascii.png" alt="" /></a></td>
</tr>
<tr>
<td><a href="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/kobayashi.png" target="_blank"><img style="max-width: 100%;" src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/kobayashi.png" alt="" /></a></td>
<td><a href="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/kobayashi_ascii.png" target="_blank"><img style="max-width: 100%;" src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/kobayashi_ascii.png" alt="" /></a></td>
</tr>
<tr>
<td><a href="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/konosuba.png" target="_blank"><img style="max-width: 100%;" src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/konosuba.png" alt="" /></a></td>
<td><a href="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/konosuba_ascii.png" target="_blank"><img style="max-width: 100%;" src="https://raw.githubusercontent.com/xiadong1994/ascii-video-player/master/samples/konosuba_ascii.png" alt="" /></a></td>
</tr>
</tbody>
</table>
总之欢迎提意见。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1178</wp:post_id>
		<wp:post_date><![CDATA[2017-03-23 20:34:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-23 12:34:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9c%a8%e7%bb%88%e7%ab%af%e4%b8%ad%e7%94%a8ascii%e5%ad%97%e7%ac%a6%e6%92%ad%e6%94%be%e8%a7%86%e9%a2%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="life"><![CDATA[Life]]></category>
		<category domain="category" nicename="opencv"><![CDATA[OpenCV]]></category>
		<category domain="category" nicename="python"><![CDATA[Python]]></category>
		<category domain="category" nicename="%e5%a4%87%e5%bf%98"><![CDATA[备忘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>42</wp:comment_id>
			<wp:comment_author><![CDATA[Fan Wu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[fanwu@a.cmu]]></wp:comment_author_email>
			<wp:comment_author_url>http://wufan.cf</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[198.143.44.129]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-03-24 10:43:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-03-24 02:43:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[很强！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1490323408.7501359;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1490323435.8158901;s:5:"event";s:15:"status-approved";s:4:"user";s:7:"xiadong";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>LeetCode 514. Freedom Trail</title>
		<link>http://xiadong.info/2017/03/leetcode-514-freedom-trail/</link>
		<pubDate>Mon, 27 Mar 2017 10:46:47 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1183</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：
<blockquote>In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door.

Given a string <strong>ring</strong>, which represents the code engraved on the outer ring and another string <strong>key</strong>, which represents the keyword needs to be spelled. You need to find the <strong>minimum</strong> number of steps in order to spell all the characters in the keyword.

Initially, the first character of the <strong>ring</strong> is aligned at 12:00 direction. You need to spell all the characters in the string <strong>key</strong> one by one by rotating the ring clockwise or anticlockwise to make each character of the string <strong>key</strong> aligned at 12:00 direction and then by pressing the center button.

At the stage of rotating the ring to spell the key character <strong>key[i]</strong>:
<ol>
 	<li>You can rotate the <strong>ring</strong> clockwise or anticlockwise <strong>one place</strong>, which counts as 1 step. The final purpose of the rotation is to align one of the string <strong>ring's</strong> characters at the 12:00 direction, where this character must equal to the character <strong>key[i]</strong>.</li>
 	<li>If the character <strong>key[i]</strong> has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.</li>
</ol>
<strong>Example:</strong>

<img src="https://leetcode.com/static/images/problemset/ring.jpg" alt="img" />
<pre><code>
Input: ring = "godding", key = "gd"
Output: 4
Explanation:
 For the first key character 'g', since it is already in place, we just need 1 step to spell this character. 
 For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo".
 Also, we need 1 more step for spelling.
 So the final output is 4.
</code></pre>
<strong>Note:</strong>
<ol>
 	<li>Length of both <strong>ring</strong> and <strong>key</strong> will be in range 1 to 100.</li>
 	<li>There are only lowercase letters in both strings and might be some duplcate characters in both strings.</li>
 	<li>It's guaranteed that string <strong>key</strong> could always be spelled by rotating the string <strong>ring</strong>.</li>
</ol>
</blockquote>
LeetCode做得比较多了就很容易发现一个规律，就是LeetCode所能接受的最大总时间复杂度大约在<code>10^6</code>左右，根据观察输入数据的规模就能大致的知道所用算法的时间复杂度上限是多少。比如输入数据是10000或以上，那么<code>O(n^2)</code>一般就是TLE（除非大量剪枝有可能勉强能过），如果输入数据是1000，那么<code>O(n^2)</code>就是可接受的。这道题的输入数据规模只有100，所以<code>O(n^3)</code>的算法也是可以的，我用的DP就是三次方的复杂度。

设一个二维数组<code>dp</code>，<code>dp[i][j]</code>表示输入<code>key[i]</code>字符时位于12点位置的是<code>ring[j]</code>字符时所使用的总的步数。显然<code>ring[j]</code>和<code>key[i]</code>要相同，否则直接不用考虑。

DP的基本思想是对于<code>key[i]</code>，从<code>key[i - 1]</code>时所有可能的<code>ring</code>结束位置的总步数+从该位置转到<code>ring[j]</code>所需要的步数+按按钮中选出最小值，就是<code>dp[i][j]</code>的值。
<pre><code>
dp[i][j] = min(dp[i - 1][k] + 1 + min(abs(k - j), ringLength - abs(k - j))), 0 &lt;= k &lt; ringLength
</code></pre>
最后再从<code>dp[keyLength - 1]</code>的所有元素中找到最小值，就是所求的结果。
<pre lang="c++"><code>
class Solution {
    vector&lt;vector&lt;int&gt;&gt; ringChar2Index, dp;
public:
    int findRotateSteps(string ring, string key) {
        if (key.empty()) return 0;
        int keyLen = key.length(), ringLen = ring.length();
        
        dp = vector&lt;vector&lt;int&gt;&gt;(keyLen, vector&lt;int&gt;(ringLen, -1));
        
        for (int i = 0; i &lt; ringLen; i++) {
            if (ring[i] == key[0]) {
                dp[0][i] = min(i, ringLen - i) + 1;
            }
        }
        
        for (int i = 1; i &lt; keyLen; i++) {
            for (int j = 0; j &lt; ringLen; j++) {
                if (ring[j] == key[i]) {
                    int step = INT_MAX;
                    for (int k = 0; k &lt; ringLen; k++) {
                        if (dp[i - 1][k] &gt;= 0) {
                            int t = abs(k - j);
                            step = min(step, min(t, ringLen - t) + 1 + dp[i - 1][k]);
                        }
                    }
                    dp[i][j] = step;
                }
            }
        }
        
        int minStep = INT_MAX;
        for (int i = 0; i &lt; ringLen; i++) {
            if (dp[keyLen - 1][i] &gt;= 0) {
                minStep = min(minStep, dp[keyLen - 1][i]);
            }
        }
        
        return minStep;
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1183</wp:post_id>
		<wp:post_date><![CDATA[2017-03-27 18:46:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-27 10:46:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-514-freedom-trail]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_jetpack_dont_email_post_to_subs]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 537. Complex Number Multiplication</title>
		<link>http://xiadong.info/2017/03/leetcode-537-complex-number-multiplication/</link>
		<pubDate>Mon, 27 Mar 2017 10:52:39 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1188</guid>
		<description></description>
		<content:encoded><![CDATA[<p>题目描述：</p>
<blockquote><p>Given two strings representing two <a href='https://en.wikipedia.org/wiki/Complex_number'>complex numbers</a>.</p>
<p>You need to return a string representing their multiplication. Note i2 = -1 according to the definition.</p>
<p><strong>Example 1:</strong></p>
<pre><code>
Input: &quot;1+1i&quot;, &quot;1+1i&quot;
Output: &quot;0+2i&quot;
Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>
Input: &quot;1+-1i&quot;, &quot;1+-1i&quot;
Output: &quot;0+-2i&quot;
Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.
</code></pre>
<p><strong>Note:</strong></p>
<ol><li>
The input strings will not have extra blank.</li>
<li>
The input strings will be given in the form of <strong>a+bi</strong>, where the integer <strong>a</strong> and <strong>b</strong> will both belong to the range of [-100, 100]. And <strong>the output should be also in this form</strong>.</li>
</ol>
</blockquote>
<p>比较简单的题，因为不用考虑非法的输入，所以直接用<code>+</code>把字符串分割，然后分别提取实部和虚部进行运算，把结果再转换为字符串即可。</p>
<pre lang='c++'><code>
class Solution {
public:
    string complexNumberMultiply(string a, string b) {
        auto ap = convert(a), bp = convert(b);
        int ra = ap.first * bp.first + (-1) * ap.second * bp.second;
        int rb = ap.first * bp.second + ap.second * bp.first;
        return to_string(ra) + &quot;+&quot; + to_string(rb) + &quot;i&quot;;
    }
    pair&lt;int, int&gt; convert (string s) {
        int a, b;
        int plusIndex;
        for (int i = 0; i &lt; s.length(); i++) {
            if (s[i] == &#39;+&#39;) {
                a = stoi(s.substr(0, i));
                plusIndex = i;
                break;
            }
        }
        b = stoi(s.substr(plusIndex + 1, s.length() - plusIndex - 2));
        return make_pair(a, b);
    }
};
</code></pre>
<p></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1188</wp:post_id>
		<wp:post_date><![CDATA[2017-03-27 18:52:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-27 10:52:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-537-complex-number-multiplication]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 538. Convert BST to Greater Tree</title>
		<link>http://xiadong.info/2017/03/leetcode-538-convert-bst-to-greater-tree/</link>
		<pubDate>Mon, 27 Mar 2017 10:54:45 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1190</guid>
		<description></description>
		<content:encoded><![CDATA[<p>题目描述：</p>
<blockquote><p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>
<p><strong>Example:</strong></p>
<pre><code>
Input: The root of a Binary Search Tree like this:
              5
            /   \
           2     13

Output: The root of a Greater Tree like this:
             18
            /   \
          20     13
</code></pre>
</blockquote>
<p>转换一颗二叉搜索树，使其每一个节点都变为原来的值+所有比它大的节点的值的和。</p>
<p>这道题只要从大往小遍历BST就可以了，也就是DFS先右后左，记录已经遍历过的节点的值的和，每遍历到一个新节点就把节点值加上这个和。</p>
<pre lang='c++'><code class='language-c++'>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        int sum = 0;
        DFS(root, sum);
        return root;
    }
    
    void DFS(TreeNode *node, int &amp;sum) {
        if (!node) return;
        DFS(node-&gt;right, sum);
        int v = node-&gt;val;
        node-&gt;val += sum;
        sum += v;
        DFS(node-&gt;left, sum);
    }
};
</code></pre>
<p></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1190</wp:post_id>
		<wp:post_date><![CDATA[2017-03-27 18:54:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-27 10:54:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-538-convert-bst-to-greater-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bst"><![CDATA[BST]]></category>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 543. Diameter of Binary Tree</title>
		<link>http://xiadong.info/2017/03/leetcode-543-diameter-of-binary-tree/</link>
		<pubDate>Mon, 27 Mar 2017 10:55:46 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1192</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述：
<blockquote>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.

<strong>Example:</strong>
Given a binary tree
<pre><code>
          1
         / \
        2   3
       / \     
      4   5    
</code></pre>
Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].

<strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</blockquote>
这道题可以采用分治法，对于一颗树来说，任意两个节点之间的最长路径从大的方面来说存在两种情况：
<ul>
 	<li>路径经过根节点，则最长路径为左子数的最大深度与右子树的最大深度之和</li>
 	<li>路径不经过根节点，又有两种情况：
<ul>
 	<li>最长路径为左子树的最长路径</li>
 	<li>最长路径为右子树的最长路径</li>
</ul>
</li>
</ul>
所以就可以通过递归求出根节点的这三个长度取最大值就是整棵树的最长路径。

计算子树的深度可以和计算子树的最长路径结合到一起。
<pre lang="c++"><code class="language-c++">
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int maxDepth = 0;
        return diameterOfBinaryTreeImpl(root, maxDepth);
    }
    
    int diameterOfBinaryTreeImpl(TreeNode* node, int &amp;maxDepth) {
        if (!node) return 0;
        int leftMaxDepth = 0, rightMaxDepth = 0;
        int leftAns = diameterOfBinaryTreeImpl(node-&gt;left, leftMaxDepth);
        int rightAns = diameterOfBinaryTreeImpl(node-&gt;right, rightMaxDepth);
        maxDepth = max(leftMaxDepth, rightMaxDepth) + 1;
        return max(leftMaxDepth + rightMaxDepth, max(leftAns, rightAns));
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1192</wp:post_id>
		<wp:post_date><![CDATA[2017-03-27 18:55:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-03-27 10:55:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-543-diameter-of-binary-tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e6%b2%bb"><![CDATA[分治]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 547. Friend Circles</title>
		<link>http://xiadong.info/2017/04/leetcode-547-friend-circles/</link>
		<pubDate>Sun, 09 Apr 2017 09:15:42 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1196</guid>
		<description></description>
		<content:encoded><![CDATA[<p>题目描述：</p>
<blockquote><p>There are <strong>N</strong> students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a <strong>direct</strong> friend of B, and B is a <strong>direct</strong> friend of C, then A is an <strong>indirect</strong> friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p>
<p>Given a <strong>N*N</strong> matrix <strong>M</strong> representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are <strong>direct</strong> friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p>
<p><strong>Example 1:</strong></p>
<pre><code>
Input: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
Output: 2
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. 
The 2nd student himself is in a friend circle. So return 2.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>
Input: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
Output: 1
Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, 
so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.
</code></pre>
<p><strong>Note:</strong></p>
<ol><li>
N is in range [1,200].</li>
<li>
M[i][i] = 1 for all students.</li>
<li>
If M[i][j] = 1, then M[j][i] = 1.</li>
</ol>
</blockquote>
<p>比较典型的并查集题目，也可以使用广度优先搜索来解决。</p>
<p><em>话说朋友圈就直接翻译成Friend Circle?</em></p>
<p>并查集：</p>
<pre lang='c++'><code class='language-c++' lang='c++'>
class Solution {
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        int num = M.size();
        vector&lt;int&gt; uf(num);
        for (int i = 0; i &lt; num; i++) uf[i] = i;
        for (int i = 0; i &lt; num; i++) {
            for (int j = i + 1; j &lt; num; j++) {
                if (!M[i][j]) continue;
                if (uf[i] == i &amp;&amp; uf[j] == j) {
                    uf[j] = i;
                }
                else if (uf[i] == i) {
                    int h = j;
                    while (uf[h] != h) h = uf[h];
                    uf[i] = h;
                }
                else if (uf[j] == j) {
                    int h = i;
                    while (uf[h] != h) h = uf[h];
                    uf[j] = h;
                }
                else {
                    int h1 = j, h2 = i;
                    while (uf[h1] != h1) h1 = uf[h1];
                    while (uf[h2] != h2) h2 = uf[h2];
                    uf[h2] = h1;
                }
            }
        }
        int circleNum = 0;
        for (int i = 0; i &lt; num; i++) {
            if (uf[i] == i) circleNum++;
        }
        return circleNum;
    }
};
</code></pre>
<p>BFS：每发现一个未标记的人，则通过广度优先搜索找出他所在的朋友圈的所有人并全部标记为访问过，朋友圈数量+1<del>s</del>。</p>
<pre lang='c++'><code class='language-c++'>
class Solution {
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        vector&lt;int&gt; visited(M.size(), 0);
        int friendCircleNum = 0;
        for (int i = 0; i &lt; M.size(); i++) {
            if (!visited[i]) {
                setMatrix(M, visited, i);
                ++friendCircleNum;
            }
        }
        return friendCircleNum;
    }
    
    void setMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; M, vector&lt;int&gt;&amp; visited, int x) {
        queue&lt;int&gt; q;
        q.push(x);
        visited[x] = 1;
        while(!q.empty()) {
            int p = q.front();
            q.pop();
            for (int i = 0; i &lt; M.size(); i++) {
                if (M[p][i] &amp;&amp; !visited[i]) {
                    visited[i] = 1;
                    q.push(i);
                }
            }
        }
    }
};
</code></pre>
<p></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1196</wp:post_id>
		<wp:post_date><![CDATA[2017-04-09 17:15:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-04-09 09:15:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-547-friend-circles]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 554. Brick Wall</title>
		<link>http://xiadong.info/2017/04/leetcode-554-brick-wall/</link>
		<pubDate>Sun, 09 Apr 2017 09:17:29 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1198</guid>
		<description></description>
		<content:encoded><![CDATA[<p>题目描述：</p>
<blockquote><p>There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the <strong>top</strong> to the <strong>bottom</strong> and cross the <strong>least</strong> bricks.</p>
<p>The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.</p>
<p>If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.</p>
<p><strong>You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.</strong></p>
<p><strong>Example:</strong></p>
<pre><code>
Input: 
[[1,2,2,1],
 [3,1,2],
 [1,3,2],
 [2,4],
 [3,1,2],
 [1,3,1,1]]
Output: 2
Explanation: 

</code></pre>
<p><strong>Note:</strong></p>
<ol><li>
The width sum of bricks in different rows are the same and won&#39;t exceed INT_MAX.</li>
<li>
The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won&#39;t exceed 20,000.</li>
</ol>
</blockquote>
<p>虽然行数与每一行的砖块数都可能达到10000，但是总的砖块数最大只有20000，又因为总的砖块间缝隙的数量一定小于砖块总数，所以可以用Hash表来记录每一个出现缝隙的位置一共出现了几次缝隙，出现缝隙次数最多的位置就是穿过砖块数最少的位置。</p>
<pre lang='c++'><code class='language-c++'>
class Solution {
public:
    int leastBricks(vector&lt;vector&lt;int&gt;&gt;&amp; wall) {
        if (wall.empty()) return 0;
        int row = wall.size();
        unordered_map&lt;int, int&gt; occurTimes;
        int width;
        for (int i = 0; i &lt; row; i++) {
            int sum = 0;
            for (auto j : wall[i]) {
                sum += j;
                occurTimes[sum]++;
            }
            width = sum;
        }
        occurTimes[width] = 0;
        int maxOccur = 0;
        for (auto &amp;i : occurTimes) {
            maxOccur = max(maxOccur, i.second);
        }
        return row - maxOccur;
    }
};
</code></pre>
<p></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1198</wp:post_id>
		<wp:post_date><![CDATA[2017-04-09 17:17:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-04-09 09:17:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-554-brick-wall]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c%e8%a1%a8"><![CDATA[哈希表]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LeetCode 557. Reverse Words in a String III</title>
		<link>http://xiadong.info/2017/04/leetcode-557-reverse-words-in-a-string-iii/</link>
		<pubDate>Sun, 09 Apr 2017 09:18:49 +0000</pubDate>
		<dc:creator><![CDATA[xiadong]]></dc:creator>
		<guid isPermaLink="false">http://xiadong.info/?p=1200</guid>
		<description></description>
		<content:encoded><![CDATA[<p>题目描述：</p>
<blockquote><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>
<p><strong>Example 1:</strong></p>
<pre><code>
Input: &quot;Let&#39;s take LeetCode contest&quot;
Output: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;
</code></pre>
<p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p>
</blockquote>
<p><del>这么简单的题真的会出现？</del></p>
<p>由于没有多余的空格，所以用双指针找到下一个空格，翻转当前位置与下一个空格之间的字符，设置左指针为下一个空格的位置+1.</p>
<pre lang='c++'><code class='language-c++'>
class Solution {
public:
    string reverseWords(string s) {
        int p1 = 0;
        while (p1 &lt; s.length()) {
            int p2 = p1;
            while (p2 &lt; s.length() &amp;&amp; s[p2] != &#39; &#39;) p2++;
            reverse(s.begin() + p1, s.begin() + p2);
            p1 = p2 + 1;
        }
        return s;
    }
};
</code></pre>
<p></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1200</wp:post_id>
		<wp:post_date><![CDATA[2017-04-09 17:18:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-04-09 09:18:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[leetcode-557-reverse-words-in-a-string-iii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="category" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="leetcode"><![CDATA[LeetCode]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_at_widget]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
